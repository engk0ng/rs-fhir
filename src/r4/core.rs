/// A list of the base types defined by this version of the FHIR specification -
/// types that are defined, but for which only specializations actually are
/// created. See <http://hl7.org/fhir/abstract-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AbstractTypeCode {}
/// Nested message and enum types in `AbstractTypeCode`.
pub mod abstract_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Type = 1,
        Any = 2,
    }
}
/// Indicates whether the account is available to be used.
/// See <http://hl7.org/fhir/account-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AccountStatusCode {}
/// Nested message and enum types in `AccountStatusCode`.
pub mod account_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
        OnHold = 4,
        Unknown = 5,
    }
}
/// Defines behavior for an action or a group for how many times that item may be
/// repeated. See <http://hl7.org/fhir/action-cardinality-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionCardinalityBehaviorCode {}
/// Nested message and enum types in `ActionCardinalityBehaviorCode`.
pub mod action_cardinality_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Single = 1,
        Multiple = 2,
    }
}
/// Defines the kinds of conditions that can appear on actions.
/// See <http://hl7.org/fhir/action-condition-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionConditionKindCode {}
/// Nested message and enum types in `ActionConditionKindCode`.
pub mod action_condition_kind_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Applicability = 1,
        Start = 2,
        Stop = 3,
    }
}
/// Defines organization behavior of a group.
/// See <http://hl7.org/fhir/action-grouping-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionGroupingBehaviorCode {}
/// Nested message and enum types in `ActionGroupingBehaviorCode`.
pub mod action_grouping_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        VisualGroup = 1,
        LogicalGroup = 2,
        SentenceGroup = 3,
    }
}
/// The type of participant for the action.
/// See <http://hl7.org/fhir/action-participant-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionParticipantTypeCode {}
/// Nested message and enum types in `ActionParticipantTypeCode`.
pub mod action_participant_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Patient = 1,
        Practitioner = 2,
        RelatedPerson = 3,
        Device = 4,
    }
}
/// Defines selection frequency behavior for an action or group.
/// See <http://hl7.org/fhir/action-precheck-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionPrecheckBehaviorCode {}
/// Nested message and enum types in `ActionPrecheckBehaviorCode`.
pub mod action_precheck_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Yes = 1,
        No = 2,
    }
}
/// Defines the types of relationships between actions.
/// See <http://hl7.org/fhir/action-relationship-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionRelationshipTypeCode {}
/// Nested message and enum types in `ActionRelationshipTypeCode`.
pub mod action_relationship_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        BeforeStart = 1,
        Before = 2,
        BeforeEnd = 3,
        ConcurrentWithStart = 4,
        Concurrent = 5,
        ConcurrentWithEnd = 6,
        AfterStart = 7,
        After = 8,
        AfterEnd = 9,
    }
}
/// Defines expectations around whether an action or action group is required.
/// See <http://hl7.org/fhir/action-required-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionRequiredBehaviorCode {}
/// Nested message and enum types in `ActionRequiredBehaviorCode`.
pub mod action_required_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Must = 1,
        Could = 2,
        MustUnlessDocumented = 3,
    }
}
/// Defines selection behavior of a group.
/// See <http://hl7.org/fhir/action-selection-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionSelectionBehaviorCode {}
/// Nested message and enum types in `ActionSelectionBehaviorCode`.
pub mod action_selection_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Any = 1,
        All = 2,
        AllOrNone = 3,
        ExactlyOne = 4,
        AtMostOne = 5,
        OneOrMore = 6,
    }
}
/// The type of an address (physical / postal).
/// See <http://hl7.org/fhir/address-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressTypeCode {}
/// Nested message and enum types in `AddressTypeCode`.
pub mod address_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Postal = 1,
        Physical = 2,
        Both = 3,
    }
}
/// The use of an address.
/// See <http://hl7.org/fhir/address-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressUseCode {}
/// Nested message and enum types in `AddressUseCode`.
pub mod address_use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Home = 1,
        Work = 2,
        Temp = 3,
        Old = 4,
        Billing = 5,
    }
}
/// The gender of a person used for administrative purposes.
/// See <http://hl7.org/fhir/administrative-gender>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdministrativeGenderCode {}
/// Nested message and enum types in `AdministrativeGenderCode`.
pub mod administrative_gender_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Male = 1,
        Female = 2,
        Other = 3,
        Unknown = 4,
    }
}
/// Overall nature of the adverse event, e.g. real or potential.
/// See <http://hl7.org/fhir/adverse-event-actuality>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEventActualityCode {}
/// Nested message and enum types in `AdverseEventActualityCode`.
pub mod adverse_event_actuality_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Actual = 1,
        Potential = 2,
    }
}
/// TODO (and should this be required?).
/// See <http://terminology.hl7.org/CodeSystem/adverse-event-outcome>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEventOutcomeCode {}
/// Nested message and enum types in `AdverseEventOutcomeCode`.
pub mod adverse_event_outcome_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Resolved = 1,
        Recovering = 2,
        Ongoing = 3,
        ResolvedWithSequelae = 4,
        Fatal = 5,
        Unknown = 6,
    }
}
/// The severity of the adverse event itself, in direct relation to the subject.
/// See <http://terminology.hl7.org/CodeSystem/adverse-event-severity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEventSeverityCode {}
/// Nested message and enum types in `AdverseEventSeverityCode`.
pub mod adverse_event_severity_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Mild = 1,
        Moderate = 2,
        Severe = 3,
    }
}
/// How resource references can be aggregated.
/// See <http://hl7.org/fhir/resource-aggregation-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AggregationModeCode {}
/// Nested message and enum types in `AggregationModeCode`.
pub mod aggregation_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Contained = 1,
        Referenced = 2,
        Bundled = 3,
    }
}
/// Category of an identified substance associated with allergies or
/// intolerances. See <http://hl7.org/fhir/allergy-intolerance-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceCategoryCode {}
/// Nested message and enum types in `AllergyIntoleranceCategoryCode`.
pub mod allergy_intolerance_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Food = 1,
        Medication = 2,
        Environment = 3,
        Biologic = 4,
    }
}
/// Preferred value set for AllergyIntolerance Clinical Status.
/// See <http://terminology.hl7.org/CodeSystem/allergyintolerance-clinical>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceClinicalStatusCode {}
/// Nested message and enum types in `AllergyIntoleranceClinicalStatusCode`.
pub mod allergy_intolerance_clinical_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        Resolved = 3,
    }
}
/// Estimate of the potential clinical harm, or seriousness, of a reaction to an
/// identified substance. See <http://hl7.org/fhir/allergy-intolerance-criticality>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceCriticalityCode {}
/// Nested message and enum types in `AllergyIntoleranceCriticalityCode`.
pub mod allergy_intolerance_criticality_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Low = 1,
        High = 2,
        UnableToAssess = 3,
    }
}
/// Clinical assessment of the severity of a reaction event as a whole,
/// potentially considering multiple different manifestations. See
/// <http://hl7.org/fhir/reaction-event-severity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceSeverityCode {}
/// Nested message and enum types in `AllergyIntoleranceSeverityCode`.
pub mod allergy_intolerance_severity_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Mild = 1,
        Moderate = 2,
        Severe = 3,
    }
}
/// The risk of an adverse reaction (allergy or intolerance) for this patient
/// upon exposure to the substance (including pharmaceutical products). See
/// <http://terminology.hl7.org/CodeSystem/allerg-intol-substance-exp-risk>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceSubstanceExposureRiskCode {}
/// Nested message and enum types in `AllergyIntoleranceSubstanceExposureRiskCode`.
pub mod allergy_intolerance_substance_exposure_risk_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        KnownReactionRisk = 1,
        NoKnownReactionRisk = 2,
    }
}
/// Identification of the underlying physiological mechanism for a Reaction Risk.
/// See <http://hl7.org/fhir/allergy-intolerance-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceTypeCode {}
/// Nested message and enum types in `AllergyIntoleranceTypeCode`.
pub mod allergy_intolerance_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Allergy = 1,
        Intolerance = 2,
    }
}
/// Preferred value set for AllergyIntolerance Verification Status.
/// See <http://terminology.hl7.org/CodeSystem/allergyintolerance-verification>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceVerificationStatusCode {}
/// Nested message and enum types in `AllergyIntoleranceVerificationStatusCode`.
pub mod allergy_intolerance_verification_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unconfirmed = 1,
        Confirmed = 2,
        Refuted = 3,
        EnteredInError = 4,
    }
}
/// The free/busy status of an appointment.
/// See <http://hl7.org/fhir/appointmentstatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AppointmentStatusCode {}
/// Nested message and enum types in `AppointmentStatusCode`.
pub mod appointment_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposed = 1,
        Pending = 2,
        Booked = 3,
        Arrived = 4,
        Fulfilled = 5,
        Cancelled = 6,
        Noshow = 7,
        EnteredInError = 8,
        CheckedIn = 9,
        Waitlist = 10,
    }
}
/// The type of direction to use for assertion.
/// See <http://hl7.org/fhir/assert-direction-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AssertionDirectionTypeCode {}
/// Nested message and enum types in `AssertionDirectionTypeCode`.
pub mod assertion_direction_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Response = 1,
        Request = 2,
    }
}
/// The type of operator to use for assertion.
/// See <http://hl7.org/fhir/assert-operator-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AssertionOperatorTypeCode {}
/// Nested message and enum types in `AssertionOperatorTypeCode`.
pub mod assertion_operator_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Equals = 1,
        NotEquals = 2,
        In = 3,
        NotIn = 4,
        GreaterThan = 5,
        LessThan = 6,
        Empty = 7,
        NotEmpty = 8,
        Contains = 9,
        NotContains = 10,
        Eval = 11,
    }
}
/// The type of response code to use for assertion.
/// See <http://hl7.org/fhir/assert-response-code-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AssertionResponseTypesCode {}
/// Nested message and enum types in `AssertionResponseTypesCode`.
pub mod assertion_response_types_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Okay = 1,
        Created = 2,
        NoContent = 3,
        NotModified = 4,
        Bad = 5,
        Forbidden = 6,
        NotFound = 7,
        MethodNotAllowed = 8,
        Conflict = 9,
        Gone = 10,
        PreconditionFailed = 11,
        Unprocessable = 12,
    }
}
/// Indicator for type of action performed during the event that generated the
/// event. See <http://hl7.org/fhir/audit-event-action>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventActionCode {}
/// Nested message and enum types in `AuditEventActionCode`.
pub mod audit_event_action_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        C = 1,
        R = 2,
        U = 3,
        D = 4,
        E = 5,
    }
}
/// The type of network access point of this agent in the audit event.
/// See <http://hl7.org/fhir/network-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventAgentNetworkTypeCode {}
/// Nested message and enum types in `AuditEventAgentNetworkTypeCode`.
pub mod audit_event_agent_network_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        MachineName = 1,
        IpAddress = 2,
        TelephoneNumber = 3,
        EmailAddress = 4,
        Uri = 5,
    }
}
/// Indicates whether the event succeeded or failed.
/// See <http://hl7.org/fhir/audit-event-outcome>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventOutcomeCode {}
/// Nested message and enum types in `AuditEventOutcomeCode`.
pub mod audit_event_outcome_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Success = 1,
        MinorFailure = 2,
        SeriousFailure = 3,
        MajorFailure = 4,
    }
}
/// Whether the cost applies to in-network or out-of-network providers.
/// See <http://terminology.hl7.org/CodeSystem/applicability>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BenefitCostApplicabilityCode {}
/// Nested message and enum types in `BenefitCostApplicabilityCode`.
pub mod benefit_cost_applicability_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        InNetwork = 1,
        OutOfNetwork = 2,
        Other = 3,
    }
}
/// Indication of the degree of conformance expectations associated with a
/// binding. See <http://hl7.org/fhir/binding-strength>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BindingStrengthCode {}
/// Nested message and enum types in `BindingStrengthCode`.
pub mod binding_strength_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Required = 1,
        Extensible = 2,
        Preferred = 3,
        Example = 4,
    }
}
/// Biologically Derived Product Category.
/// See <http://hl7.org/fhir/product-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BiologicallyDerivedProductCategoryCode {}
/// Nested message and enum types in `BiologicallyDerivedProductCategoryCode`.
pub mod biologically_derived_product_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Organ = 1,
        Tissue = 2,
        Fluid = 3,
        Cells = 4,
        BiologicalAgent = 5,
    }
}
/// Biologically Derived Product Status.
/// See <http://hl7.org/fhir/product-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BiologicallyDerivedProductStatusCode {}
/// Nested message and enum types in `BiologicallyDerivedProductStatusCode`.
pub mod biologically_derived_product_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Available = 1,
        Unavailable = 2,
    }
}
/// BiologicallyDerived Product Storage Scale.
/// See <http://hl7.org/fhir/product-storage-scale>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BiologicallyDerivedProductStorageScaleCode {}
/// Nested message and enum types in `BiologicallyDerivedProductStorageScaleCode`.
pub mod biologically_derived_product_storage_scale_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Farenheit = 1,
        Celsius = 2,
        Kelvin = 3,
    }
}
/// Indicates the purpose of a bundle - how it is intended to be used.
/// See <http://hl7.org/fhir/bundle-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BundleTypeCode {}
/// Nested message and enum types in `BundleTypeCode`.
pub mod bundle_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Document = 1,
        Message = 2,
        Transaction = 3,
        TransactionResponse = 4,
        Batch = 5,
        BatchResponse = 6,
        History = 7,
        Searchset = 8,
        Collection = 9,
    }
}
/// The master set of status codes used throughout FHIR. All status codes are
/// mapped to one of these codes. See <http://hl7.org/fhir/resource-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CanonicalStatusCodesForFhirResourcesCode {}
/// Nested message and enum types in `CanonicalStatusCodesForFHIRResourcesCode`.
pub mod canonical_status_codes_for_fhir_resources_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Error = 1,
        Proposed = 2,
        Planned = 3,
        Draft = 4,
        Requested = 5,
        Received = 6,
        Declined = 7,
        Accepted = 8,
        Arrived = 9,
        Active = 10,
        Suspended = 11,
        Failed = 12,
        Replaced = 13,
        Complete = 14,
        Inactive = 15,
        Abandoned = 16,
        Unknown = 17,
        Unconfirmed = 18,
        Confirmed = 19,
        Resolved = 20,
        Refuted = 21,
        Differential = 22,
        Partial = 23,
        BusyUnavailable = 24,
        Free = 25,
        OnTarget = 26,
        AheadOfTarget = 27,
        BehindTarget = 28,
        NotReady = 29,
        TransducDiscon = 30,
        HwDiscon = 31,
    }
}
/// How a capability statement is intended to be used.
/// See <http://hl7.org/fhir/capability-statement-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatementKindCode {}
/// Nested message and enum types in `CapabilityStatementKindCode`.
pub mod capability_statement_kind_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Instance = 1,
        Capability = 2,
        Requirements = 3,
    }
}
/// Codes that reflect the current state of a care plan activity within its
/// overall life cycle. See <http://hl7.org/fhir/care-plan-activity-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CarePlanActivityStatusCode {}
/// Nested message and enum types in `CarePlanActivityStatusCode`.
pub mod care_plan_activity_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotStarted = 1,
        Scheduled = 2,
        InProgress = 3,
        OnHold = 4,
        Completed = 5,
        Cancelled = 6,
        Stopped = 7,
        Unknown = 8,
        EnteredInError = 9,
    }
}
/// Indicates the status of the care team.
/// See <http://hl7.org/fhir/care-team-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CareTeamStatusCode {}
/// Nested message and enum types in `CareTeamStatusCode`.
pub mod care_team_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposed = 1,
        Active = 2,
        Suspended = 3,
        Inactive = 4,
        EnteredInError = 5,
    }
}
/// The type of relations between entries.
/// See <http://hl7.org/fhir/relation-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CatalogEntryRelationTypeCode {}
/// Nested message and enum types in `CatalogEntryRelationTypeCode`.
pub mod catalog_entry_relation_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Triggers = 1,
        IsReplacedBy = 2,
    }
}
/// Codes identifying the lifecycle stage of a ChargeItem.
/// See <http://hl7.org/fhir/chargeitem-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ChargeItemStatusCode {}
/// Nested message and enum types in `ChargeItemStatusCode`.
pub mod charge_item_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Planned = 1,
        Billable = 2,
        NotBillable = 3,
        Aborted = 4,
        Billed = 5,
        EnteredInError = 6,
        Unknown = 7,
    }
}
/// Direction in which lists of possible answers should be displayed.
/// See <http://terminology.hl7.org/CodeSystem/choice-list-orientation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ChoiceListOrientationCode {}
/// Nested message and enum types in `ChoiceListOrientationCode`.
pub mod choice_list_orientation_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Horizontal = 1,
        Vertical = 2,
    }
}
/// This value set includes Claim Processing Outcome codes.
/// See <http://hl7.org/fhir/remittance-outcome>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ClaimProcessingCode {}
/// Nested message and enum types in `ClaimProcessingCode`.
pub mod claim_processing_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Queued = 1,
        Complete = 2,
        Error = 3,
        Partial = 4,
    }
}
/// The degree to which the server supports the code search parameter on
/// ValueSet, if it is supported. See <http://hl7.org/fhir/code-search-support>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSearchSupportCode {}
/// Nested message and enum types in `CodeSearchSupportCode`.
pub mod code_search_support_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Explicit = 1,
        All = 2,
    }
}
/// The extent of the content of the code system (the concepts and codes it
/// defines) are represented in a code system resource. See
/// <http://hl7.org/fhir/codesystem-content-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemContentModeCode {}
/// Nested message and enum types in `CodeSystemContentModeCode`.
pub mod code_system_content_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotPresent = 1,
        Example = 2,
        Fragment = 3,
        Complete = 4,
        Supplement = 5,
    }
}
/// The meaning of the hierarchy of concepts in a code system.
/// See <http://hl7.org/fhir/codesystem-hierarchy-meaning>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemHierarchyMeaningCode {}
/// Nested message and enum types in `CodeSystemHierarchyMeaningCode`.
pub mod code_system_hierarchy_meaning_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        GroupedBy = 1,
        IsA = 2,
        PartOf = 3,
        ClassifiedWith = 4,
    }
}
/// Which type a compartment definition describes.
/// See <http://hl7.org/fhir/compartment-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompartmentTypeCode {}
/// Nested message and enum types in `CompartmentTypeCode`.
pub mod compartment_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Patient = 1,
        Encounter = 2,
        RelatedPerson = 3,
        Practitioner = 4,
        Device = 5,
    }
}
/// The way in which a person authenticated a composition.
/// See <http://hl7.org/fhir/composition-attestation-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompositionAttestationModeCode {}
/// Nested message and enum types in `CompositionAttestationModeCode`.
pub mod composition_attestation_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Personal = 1,
        Professional = 2,
        Legal = 3,
        Official = 4,
    }
}
/// The workflow/clinical status of the composition.
/// See <http://hl7.org/fhir/composition-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompositionStatusCode {}
/// Nested message and enum types in `CompositionStatusCode`.
pub mod composition_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Preliminary = 1,
        Final = 2,
        Amended = 3,
        EnteredInError = 4,
    }
}
/// The degree of equivalence between concepts.
/// See <http://hl7.org/fhir/concept-map-equivalence>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConceptMapEquivalenceCode {}
/// Nested message and enum types in `ConceptMapEquivalenceCode`.
pub mod concept_map_equivalence_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Relatedto = 1,
        Equivalent = 2,
        Equal = 3,
        Wider = 4,
        Subsumes = 5,
        Narrower = 6,
        Specializes = 7,
        Inexact = 8,
        Unmatched = 9,
        Disjoint = 10,
    }
}
/// Defines which action to take if there is no match in the group.
/// See <http://hl7.org/fhir/conceptmap-unmapped-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConceptMapGroupUnmappedModeCode {}
/// Nested message and enum types in `ConceptMapGroupUnmappedModeCode`.
pub mod concept_map_group_unmapped_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Provided = 1,
        Fixed = 2,
        OtherMap = 3,
    }
}
/// Preferred value set for Condition Clinical Status.
/// See <http://terminology.hl7.org/CodeSystem/condition-clinical>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionClinicalStatusCode {}
/// Nested message and enum types in `ConditionClinicalStatusCode`.
pub mod condition_clinical_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Recurrence = 2,
        Relapse = 3,
        Inactive = 4,
        Remission = 5,
        Resolved = 6,
    }
}
/// The verification status to support or decline the clinical status of the
/// condition or diagnosis. See
/// <http://terminology.hl7.org/CodeSystem/condition-ver-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionVerificationStatusCode {}
/// Nested message and enum types in `ConditionVerificationStatusCode`.
pub mod condition_verification_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unconfirmed = 1,
        Provisional = 2,
        Differential = 3,
        Confirmed = 4,
        Refuted = 5,
        EnteredInError = 6,
    }
}
/// A code that indicates how the server supports conditional delete.
/// See <http://hl7.org/fhir/conditional-delete-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionalDeleteStatusCode {}
/// Nested message and enum types in `ConditionalDeleteStatusCode`.
pub mod conditional_delete_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotSupported = 1,
        Single = 2,
        Multiple = 3,
    }
}
/// A code that indicates how the server supports conditional read.
/// See <http://hl7.org/fhir/conditional-read-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionalReadStatusCode {}
/// Nested message and enum types in `ConditionalReadStatusCode`.
pub mod conditional_read_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotSupported = 1,
        ModifiedSince = 2,
        NotMatch = 3,
        FullSupport = 4,
    }
}
/// Indicates the degree of adherence to a specified behavior or capability
/// expected for a system to be deemed conformant with a specification. See
/// <http://terminology.hl7.org/CodeSystem/conformance-expectation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConformanceExpectationCode {}
/// Nested message and enum types in `ConformanceExpectationCode`.
pub mod conformance_expectation_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Shall = 1,
        Should = 2,
        May = 3,
        ShouldNot = 4,
    }
}
/// How a resource reference is interpreted when testing consent restrictions.
/// See <http://hl7.org/fhir/consent-data-meaning>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConsentDataMeaningCode {}
/// Nested message and enum types in `ConsentDataMeaningCode`.
pub mod consent_data_meaning_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Instance = 1,
        Related = 2,
        Dependents = 3,
        Authoredby = 4,
    }
}
/// How a rule statement is applied, such as adding additional consent or
/// removing consent. See <http://hl7.org/fhir/consent-provision-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConsentProvisionTypeCode {}
/// Nested message and enum types in `ConsentProvisionTypeCode`.
pub mod consent_provision_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Deny = 1,
        Permit = 2,
    }
}
/// Indicates the state of the consent.
/// See <http://hl7.org/fhir/consent-state-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConsentStateCode {}
/// Nested message and enum types in `ConsentStateCode`.
pub mod consent_state_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Proposed = 2,
        Active = 3,
        Rejected = 4,
        Inactive = 5,
        EnteredInError = 6,
    }
}
/// SHALL applications comply with this constraint?
/// See <http://hl7.org/fhir/constraint-severity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConstraintSeverityCode {}
/// Nested message and enum types in `ConstraintSeverityCode`.
pub mod constraint_severity_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Error = 1,
        Warning = 2,
    }
}
/// Telecommunications form for contact point.
/// See <http://hl7.org/fhir/contact-point-system>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPointSystemCode {}
/// Nested message and enum types in `ContactPointSystemCode`.
pub mod contact_point_system_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Phone = 1,
        Fax = 2,
        Email = 3,
        Pager = 4,
        Url = 5,
        Sms = 6,
        Other = 7,
    }
}
/// Use of contact point.
/// See <http://hl7.org/fhir/contact-point-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPointUseCode {}
/// Nested message and enum types in `ContactPointUseCode`.
pub mod contact_point_use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Home = 1,
        Work = 2,
        Temp = 3,
        Old = 4,
        Mobile = 5,
    }
}
/// This value set contract specific codes for status.
/// See <http://hl7.org/fhir/contract-publicationstatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContractResourcePublicationStatusCode {}
/// Nested message and enum types in `ContractResourcePublicationStatusCode`.
pub mod contract_resource_publication_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Amended = 1,
        Appended = 2,
        Cancelled = 3,
        Disputed = 4,
        EnteredInError = 5,
        Executable = 6,
        Executed = 7,
        Negotiable = 8,
        Offered = 9,
        Policy = 10,
        Rejected = 11,
        Renewed = 12,
        Revoked = 13,
        Resolved = 14,
        Terminated = 15,
    }
}
/// This value set contract specific codes for status.
/// See <http://hl7.org/fhir/contract-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContractResourceStatusCode {}
/// Nested message and enum types in `ContractResourceStatusCode`.
pub mod contract_resource_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Amended = 1,
        Appended = 2,
        Cancelled = 3,
        Disputed = 4,
        EnteredInError = 5,
        Executable = 6,
        Executed = 7,
        Negotiable = 8,
        Offered = 9,
        Policy = 10,
        Rejected = 11,
        Renewed = 12,
        Revoked = 13,
        Resolved = 14,
        Terminated = 15,
    }
}
/// The type of contributor.
/// See <http://hl7.org/fhir/contributor-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContributorTypeCode {}
/// Nested message and enum types in `ContributorTypeCode`.
pub mod contributor_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Author = 1,
        Editor = 2,
        Reviewer = 3,
        Endorser = 4,
    }
}
/// Used to specify why the normally expected content of the data element is
/// missing. See <http://terminology.hl7.org/CodeSystem/data-absent-reason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DataAbsentReasonCode {}
/// Nested message and enum types in `DataAbsentReasonCode`.
pub mod data_absent_reason_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unknown = 1,
        AskedUnknown = 2,
        TempUnknown = 3,
        NotAsked = 4,
        AskedDeclined = 5,
        Masked = 6,
        NotApplicable = 7,
        Unsupported = 8,
        AsText = 9,
        Error = 10,
        NotANumber = 11,
        NegativeInfinity = 12,
        PositiveInfinity = 13,
        NotPerformed = 14,
        NotPermitted = 15,
    }
}
/// A version specific list of the data types defined by the FHIR specification
/// for use as an element  type (any of the FHIR defined data types). See
/// <http://hl7.org/fhir/data-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DataTypeCode {}
/// Nested message and enum types in `DataTypeCode`.
pub mod data_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Address = 1,
        Age = 2,
        Annotation = 3,
        Attachment = 4,
        BackboneElement = 5,
        CodeableConcept = 6,
        Coding = 7,
        ContactDetail = 8,
        ContactPoint = 9,
        Contributor = 10,
        Count = 11,
        DataRequirement = 12,
        Distance = 13,
        Dosage = 14,
        Duration = 15,
        Element = 16,
        ElementDefinition = 17,
        Expression = 18,
        Extension = 19,
        HumanName = 20,
        Identifier = 21,
        MarketingStatus = 22,
        Meta = 23,
        Money = 24,
        MoneyQuantity = 25,
        Narrative = 26,
        ParameterDefinition = 27,
        Period = 28,
        Population = 29,
        ProdCharacteristic = 30,
        ProductShelfLife = 31,
        Quantity = 32,
        Range = 33,
        Ratio = 34,
        Reference = 35,
        RelatedArtifact = 36,
        SampledData = 37,
        Signature = 38,
        SimpleQuantity = 39,
        SubstanceAmount = 40,
        Timing = 41,
        TriggerDefinition = 42,
        UsageContext = 43,
        Base64Binary = 44,
        Boolean = 45,
        Canonical = 46,
        Code = 47,
        Date = 48,
        DateTime = 49,
        Decimal = 50,
        Id = 51,
        Instant = 52,
        Integer = 53,
        Markdown = 54,
        Oid = 55,
        PositiveInt = 56,
        String = 57,
        Time = 58,
        UnsignedInt = 59,
        Uri = 60,
        Url = 61,
        Uuid = 62,
        Xhtml = 63,
    }
}
/// The days of the week.
/// See <http://hl7.org/fhir/days-of-week>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DaysOfWeekCode {}
/// Nested message and enum types in `DaysOfWeekCode`.
pub mod days_of_week_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Mon = 1,
        Tue = 2,
        Wed = 3,
        Thu = 4,
        Fri = 5,
        Sat = 6,
        Sun = 7,
    }
}
/// Indicates the potential degree of impact of the identified issue on the
/// patient. See <http://hl7.org/fhir/detectedissue-severity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DetectedIssueSeverityCode {}
/// Nested message and enum types in `DetectedIssueSeverityCode`.
pub mod detected_issue_severity_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        High = 1,
        Moderate = 2,
        Low = 3,
    }
}
/// Describes the state of a metric calibration.
/// See <http://hl7.org/fhir/metric-calibration-state>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetricCalibrationStateCode {}
/// Nested message and enum types in `DeviceMetricCalibrationStateCode`.
pub mod device_metric_calibration_state_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotCalibrated = 1,
        CalibrationRequired = 2,
        Calibrated = 3,
        Unspecified = 4,
    }
}
/// Describes the type of a metric calibration.
/// See <http://hl7.org/fhir/metric-calibration-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetricCalibrationTypeCode {}
/// Nested message and enum types in `DeviceMetricCalibrationTypeCode`.
pub mod device_metric_calibration_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unspecified = 1,
        Offset = 2,
        Gain = 3,
        TwoPoint = 4,
    }
}
/// Describes the category of the metric.
/// See <http://hl7.org/fhir/metric-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetricCategoryCode {}
/// Nested message and enum types in `DeviceMetricCategoryCode`.
pub mod device_metric_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Measurement = 1,
        Setting = 2,
        Calculation = 3,
        Unspecified = 4,
    }
}
/// Describes the typical color of representation.
/// See <http://hl7.org/fhir/metric-color>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetricColorCode {}
/// Nested message and enum types in `DeviceMetricColorCode`.
pub mod device_metric_color_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Black = 1,
        Red = 2,
        Green = 3,
        Yellow = 4,
        Blue = 5,
        Magenta = 6,
        Cyan = 7,
        White = 8,
    }
}
/// Describes the operational status of the DeviceMetric.
/// See <http://hl7.org/fhir/metric-operational-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetricOperationalStatusCode {}
/// Nested message and enum types in `DeviceMetricOperationalStatusCode`.
pub mod device_metric_operational_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        On = 1,
        Off = 2,
        Standby = 3,
        EnteredInError = 4,
    }
}
/// The type of name the device is referred by.
/// See <http://hl7.org/fhir/device-nametype>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceNameTypeCode {}
/// Nested message and enum types in `DeviceNameTypeCode`.
pub mod device_name_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        UdiLabelName = 1,
        UserFriendlyName = 2,
        PatientReportedName = 3,
        ManufacturerName = 4,
        ModelName = 5,
        Other = 6,
    }
}
/// A coded concept indicating the current status of the Device Usage.
/// See <http://hl7.org/fhir/device-statement-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceUseStatementStatusCode {}
/// Nested message and enum types in `DeviceUseStatementStatusCode`.
pub mod device_use_statement_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Completed = 2,
        EnteredInError = 3,
        Intended = 4,
        Stopped = 5,
        OnHold = 6,
    }
}
/// The status of the diagnostic report.
/// See <http://hl7.org/fhir/diagnostic-report-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportStatusCode {}
/// Nested message and enum types in `DiagnosticReportStatusCode`.
pub mod diagnostic_report_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Registered = 1,
        Partial = 2,
        Preliminary = 3,
        Final = 4,
        Amended = 5,
        Corrected = 6,
        Appended = 7,
        Cancelled = 8,
        EnteredInError = 9,
        Unknown = 10,
    }
}
/// How an element value is interpreted when discrimination is evaluated.
/// See <http://hl7.org/fhir/discriminator-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiscriminatorTypeCode {}
/// Nested message and enum types in `DiscriminatorTypeCode`.
pub mod discriminator_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Value = 1,
        Exists = 2,
        Pattern = 3,
        Type = 4,
        Profile = 5,
    }
}
/// Whether the application produces or consumes documents.
/// See <http://hl7.org/fhir/document-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DocumentModeCode {}
/// Nested message and enum types in `DocumentModeCode`.
pub mod document_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Producer = 1,
        Consumer = 2,
    }
}
/// The status of the document reference.
/// See <http://hl7.org/fhir/document-reference-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DocumentReferenceStatusCode {}
/// Nested message and enum types in `DocumentReferenceStatusCode`.
pub mod document_reference_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Current = 1,
        Superseded = 2,
        EnteredInError = 3,
    }
}
/// The type of relationship between documents.
/// See <http://hl7.org/fhir/document-relationship-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DocumentRelationshipTypeCode {}
/// Nested message and enum types in `DocumentRelationshipTypeCode`.
pub mod document_relationship_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Replaces = 1,
        Transforms = 2,
        Signs = 3,
        Appends = 4,
    }
}
/// A code specifying the types of information being requested.
/// See <http://hl7.org/fhir/eligibilityrequest-purpose>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EligibilityRequestPurposeCode {}
/// Nested message and enum types in `EligibilityRequestPurposeCode`.
pub mod eligibility_request_purpose_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        AuthRequirements = 1,
        Benefits = 2,
        Discovery = 3,
        Validation = 4,
    }
}
/// A code specifying the types of information being requested.
/// See <http://hl7.org/fhir/eligibilityresponse-purpose>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EligibilityResponsePurposeCode {}
/// Nested message and enum types in `EligibilityResponsePurposeCode`.
pub mod eligibility_response_purpose_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        AuthRequirements = 1,
        Benefits = 2,
        Discovery = 3,
        Validation = 4,
    }
}
/// Controls how multiple enableWhen values are interpreted -  whether all or any
/// must be true. See <http://hl7.org/fhir/questionnaire-enable-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EnableWhenBehaviorCode {}
/// Nested message and enum types in `EnableWhenBehaviorCode`.
pub mod enable_when_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        All = 1,
        Any = 2,
    }
}
/// The status of the location.
/// See <http://hl7.org/fhir/encounter-location-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EncounterLocationStatusCode {}
/// Nested message and enum types in `EncounterLocationStatusCode`.
pub mod encounter_location_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Planned = 1,
        Active = 2,
        Reserved = 3,
        Completed = 4,
    }
}
/// Current state of the encounter.
/// See <http://hl7.org/fhir/encounter-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EncounterStatusCode {}
/// Nested message and enum types in `EncounterStatusCode`.
pub mod encounter_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Planned = 1,
        Arrived = 2,
        Triaged = 3,
        InProgress = 4,
        Onleave = 5,
        Finished = 6,
        Cancelled = 7,
        EnteredInError = 8,
        Unknown = 9,
    }
}
/// The status of the endpoint.
/// See <http://hl7.org/fhir/endpoint-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EndpointStatusCode {}
/// Nested message and enum types in `EndpointStatusCode`.
pub mod endpoint_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Suspended = 2,
        Error = 3,
        Off = 4,
        EnteredInError = 5,
        Test = 6,
    }
}
/// The status of the episode of care.
/// See <http://hl7.org/fhir/episode-of-care-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EpisodeOfCareStatusCode {}
/// Nested message and enum types in `EpisodeOfCareStatusCode`.
pub mod episode_of_care_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Planned = 1,
        Waitlist = 2,
        Active = 3,
        Onhold = 4,
        Finished = 5,
        Cancelled = 6,
        EnteredInError = 7,
    }
}
/// The mode of a message capability statement.
/// See <http://hl7.org/fhir/event-capability-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EventCapabilityModeCode {}
/// Nested message and enum types in `EventCapabilityModeCode`.
pub mod event_capability_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Sender = 1,
        Receiver = 2,
    }
}
/// Codes identifying the lifecycle stage of an event.
/// See <http://hl7.org/fhir/event-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EventStatusCode {}
/// Nested message and enum types in `EventStatusCode`.
pub mod event_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Preparation = 1,
        InProgress = 2,
        NotDone = 3,
        OnHold = 4,
        Stopped = 5,
        Completed = 6,
        EnteredInError = 7,
        Unknown = 8,
    }
}
/// Real world event relating to the schedule.
/// See <http://hl7.org/fhir/event-timing>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EventTimingCode {}
/// Nested message and enum types in `EventTimingCode`.
pub mod event_timing_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Morn = 1,
        MornEarly = 2,
        MornLate = 3,
        Noon = 4,
        Aft = 5,
        AftEarly = 6,
        AftLate = 7,
        Eve = 8,
        EveEarly = 9,
        EveLate = 10,
        Night = 11,
        Phs = 12,
    }
}
/// The possible types of variables for exposures or outcomes (E.g. Dichotomous,
/// Continuous, Descriptive). See <http://hl7.org/fhir/variable-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EvidenceVariableTypeCode {}
/// Nested message and enum types in `EvidenceVariableTypeCode`.
pub mod evidence_variable_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Dichotomous = 1,
        Continuous = 2,
        Descriptive = 3,
    }
}
/// The type of actor - system or human.
/// See <http://hl7.org/fhir/examplescenario-actor-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExampleScenarioActorTypeCode {}
/// Nested message and enum types in `ExampleScenarioActorTypeCode`.
pub mod example_scenario_actor_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Person = 1,
        Entity = 2,
    }
}
/// Declares what the source of a parameter is.
/// See <http://terminology.hl7.org/CodeSystem/expansion-parameter-source>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExpansionParameterSourceCode {}
/// Nested message and enum types in `ExpansionParameterSourceCode`.
pub mod expansion_parameter_source_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Input = 1,
        Server = 2,
        Codesystem = 3,
    }
}
/// Defines how concepts are processed into the expansion when it's for UI
/// presentation. See
/// <http://terminology.hl7.org/CodeSystem/expansion-processing-rule>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExpansionProcessingRuleCode {}
/// Nested message and enum types in `ExpansionProcessingRuleCode`.
pub mod expansion_processing_rule_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        AllCodes = 1,
        Ungrouped = 2,
        GroupsOnly = 3,
    }
}
/// A code specifying the state of the resource instance.
/// See <http://hl7.org/fhir/explanationofbenefit-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExplanationOfBenefitStatusCode {}
/// Nested message and enum types in `ExplanationOfBenefitStatusCode`.
pub mod explanation_of_benefit_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Cancelled = 2,
        Draft = 3,
        EnteredInError = 4,
    }
}
/// Whether the results by exposure is describing the results for the primary
/// exposure of interest (exposure) or the alternative state
/// (exposureAlternative). See <http://hl7.org/fhir/exposure-state>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExposureStateCode {}
/// Nested message and enum types in `ExposureStateCode`.
pub mod exposure_state_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Exposure = 1,
        ExposureAlternative = 2,
    }
}
/// How an extension context is interpreted.
/// See <http://hl7.org/fhir/extension-context-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExtensionContextTypeCode {}
/// Nested message and enum types in `ExtensionContextTypeCode`.
pub mod extension_context_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Fhirpath = 1,
        Element = 2,
        Extension = 3,
    }
}
/// The availability status of the device.
/// See <http://hl7.org/fhir/device-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirDeviceStatusCode {}
/// Nested message and enum types in `FHIRDeviceStatusCode`.
pub mod fhir_device_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
        Unknown = 4,
    }
}
/// The set of interactions defined by the RESTful part of the FHIR
/// specification. See <http://hl7.org/fhir/restful-interaction>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirRestfulInteractionsCode {}
/// Nested message and enum types in `FHIRRestfulInteractionsCode`.
pub mod fhir_restful_interactions_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Read = 1,
        Vread = 2,
        Update = 3,
        Patch = 4,
        Delete = 5,
        History = 6,
        HistoryInstance = 7,
        HistoryType = 8,
        HistorySystem = 9,
        Create = 10,
        Search = 11,
        SearchType = 12,
        SearchSystem = 13,
        Capabilities = 14,
        Transaction = 15,
        Batch = 16,
        Operation = 17,
    }
}
/// A code to indicate if the substance is actively used.
/// See <http://hl7.org/fhir/substance-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirSubstanceStatusCode {}
/// Nested message and enum types in `FHIRSubstanceStatusCode`.
pub mod fhir_substance_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
    }
}
/// All published FHIR Versions.
/// See <http://hl7.org/fhir/FHIR-version>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirVersionCode {}
/// Nested message and enum types in `FHIRVersionCode`.
pub mod fhir_version_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        V001 = 1,
        V005 = 2,
        V006 = 3,
        V011 = 4,
        V0080 = 5,
        V0081 = 6,
        V0082 = 7,
        V040 = 8,
        V050 = 9,
        V100 = 10,
        V101 = 11,
        V102 = 12,
        V110 = 13,
        V140 = 14,
        V160 = 15,
        V180 = 16,
        V300 = 17,
        V301 = 18,
        V330 = 19,
        V350 = 20,
        V400 = 21,
        V401 = 22,
    }
}
/// A code that identifies the status of the family history record.
/// See <http://hl7.org/fhir/history-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyHistoryStatusCode {}
/// Nested message and enum types in `FamilyHistoryStatusCode`.
pub mod family_history_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Partial = 1,
        Completed = 2,
        EnteredInError = 3,
        HealthUnknown = 4,
    }
}
/// The kind of operation to perform as a part of a property based filter.
/// See <http://hl7.org/fhir/filter-operator>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FilterOperatorCode {}
/// Nested message and enum types in `FilterOperatorCode`.
pub mod filter_operator_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Equals = 1,
        IsA = 2,
        DescendentOf = 3,
        IsNotA = 4,
        Regex = 5,
        In = 6,
        NotIn = 7,
        Generalizes = 8,
        Exists = 9,
    }
}
/// This value set includes Status codes.
/// See <http://hl7.org/fhir/fm-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FinancialResourceStatusCode {}
/// Nested message and enum types in `FinancialResourceStatusCode`.
pub mod financial_resource_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Cancelled = 2,
        Draft = 3,
        EnteredInError = 4,
    }
}
/// Indicates whether this flag is active and needs to be displayed to a user, or
/// whether it is no longer needed or was entered in error. See
/// <http://hl7.org/fhir/flag-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FlagStatusCode {}
/// Nested message and enum types in `FlagStatusCode`.
pub mod flag_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
    }
}
/// Codes indicating whether the goal has been accepted by a stakeholder.
/// See <http://terminology.hl7.org/CodeSystem/goal-acceptance-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalAcceptanceStatusCode {}
/// Nested message and enum types in `GoalAcceptanceStatusCode`.
pub mod goal_acceptance_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Agree = 1,
        Disagree = 2,
        Pending = 3,
    }
}
/// Codes that reflect the current state of a goal and whether the goal is still
/// being targeted. See <http://hl7.org/fhir/goal-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalLifecycleStatusCode {}
/// Nested message and enum types in `GoalLifecycleStatusCode`.
pub mod goal_lifecycle_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposed = 1,
        Planned = 2,
        Accepted = 3,
        Active = 4,
        OnHold = 5,
        Completed = 6,
        Cancelled = 7,
        EnteredInError = 8,
        Rejected = 9,
    }
}
/// How a compartment must be linked.
/// See <http://hl7.org/fhir/graph-compartment-rule>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GraphCompartmentRuleCode {}
/// Nested message and enum types in `GraphCompartmentRuleCode`.
pub mod graph_compartment_rule_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Identical = 1,
        Matching = 2,
        Different = 3,
        Custom = 4,
    }
}
/// Defines how a compartment rule is used.
/// See <http://hl7.org/fhir/graph-compartment-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GraphCompartmentUseCode {}
/// Nested message and enum types in `GraphCompartmentUseCode`.
pub mod graph_compartment_use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Condition = 1,
        Requirement = 2,
    }
}
/// Possible group measure aggregates (E.g. Mean, Median).
/// See <http://hl7.org/fhir/group-measure>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GroupMeasureCode {}
/// Nested message and enum types in `GroupMeasureCode`.
pub mod group_measure_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Mean = 1,
        Median = 2,
        MeanOfMean = 3,
        MeanOfMedian = 4,
        MedianOfMean = 5,
        MedianOfMedian = 6,
    }
}
/// Types of resources that are part of group.
/// See <http://hl7.org/fhir/group-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GroupTypeCode {}
/// Nested message and enum types in `GroupTypeCode`.
pub mod group_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Person = 1,
        Animal = 2,
        Practitioner = 3,
        Device = 4,
        Medication = 5,
        Substance = 6,
    }
}
/// The status of a guidance response.
/// See <http://hl7.org/fhir/guidance-response-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GuidanceResponseStatusCode {}
/// Nested message and enum types in `GuidanceResponseStatusCode`.
pub mod guidance_response_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Success = 1,
        DataRequested = 2,
        DataRequired = 3,
        InProgress = 4,
        Failure = 5,
        EnteredInError = 6,
    }
}
/// A code that indicates how the page is generated.
/// See <http://hl7.org/fhir/guide-page-generation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GuidePageGenerationCode {}
/// Nested message and enum types in `GuidePageGenerationCode`.
pub mod guide_page_generation_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Html = 1,
        Markdown = 2,
        Xml = 3,
        Generated = 4,
    }
}
/// Code of parameter that is input to the guide.
/// See <http://hl7.org/fhir/guide-parameter-code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GuideParameterCode {}
/// Nested message and enum types in `GuideParameterCode`.
pub mod guide_parameter_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Apply = 1,
        PathResource = 2,
        PathPages = 3,
        PathTxCache = 4,
        ExpansionParameter = 5,
        RuleBrokenLinks = 6,
        GenerateXml = 7,
        GenerateJson = 8,
        GenerateTurtle = 9,
        HtmlTemplate = 10,
    }
}
/// An HL7 administrative unit that owns artifacts in the FHIR specification.
/// See <http://terminology.hl7.org/CodeSystem/hl7-work-group>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Hl7WorkgroupCode {}
/// Nested message and enum types in `HL7WorkgroupCode`.
pub mod hl7_workgroup_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Cbcc = 1,
        Cds = 2,
        Cqi = 3,
        Cg = 4,
        Dev = 5,
        Ehr = 6,
        Fhir = 7,
        Fm = 8,
        Hsi = 9,
        Ii = 10,
        Inm = 11,
        Its = 12,
        Mnm = 13,
        Oo = 14,
        Pa = 15,
        Pc = 16,
        Pher = 17,
        Phx = 18,
        Brr = 19,
        Sd = 20,
        Sec = 21,
        Us = 22,
        Vocab = 23,
        Aid = 24,
    }
}
/// HTTP verbs (in the HTTP command line). See [HTTP
/// rfc](<https://tools.ietf.org/html/rfc7231>) for details. See
/// <http://hl7.org/fhir/http-verb>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HttpVerbCode {}
/// Nested message and enum types in `HTTPVerbCode`.
pub mod http_verb_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Get = 1,
        Head = 2,
        Post = 3,
        Put = 4,
        Delete = 5,
        Patch = 6,
    }
}
/// A code that represents the preferred display order of the components of a
/// human name. See <http://terminology.hl7.org/CodeSystem/name-assembly-order>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameAssemblyOrderCode {}
/// Nested message and enum types in `HumanNameAssemblyOrderCode`.
pub mod human_name_assembly_order_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Nl1 = 1,
        Nl2 = 2,
        Nl3 = 3,
        Nl4 = 4,
    }
}
/// Identifies the purpose for this identifier, if known .
/// See <http://hl7.org/fhir/identifier-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct IdentifierUseCode {}
/// Nested message and enum types in `IdentifierUseCode`.
pub mod identifier_use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Usual = 1,
        Official = 2,
        Temp = 3,
        Secondary = 4,
        Old = 5,
    }
}
/// The level of confidence that this link represents the same actual person,
/// based on NIST Authentication Levels. See
/// <http://hl7.org/fhir/identity-assuranceLevel>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct IdentityAssuranceLevelCode {}
/// Nested message and enum types in `IdentityAssuranceLevelCode`.
pub mod identity_assurance_level_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Level1 = 1,
        Level2 = 2,
        Level3 = 3,
        Level4 = 4,
    }
}
/// The status of the ImagingStudy.
/// See <http://hl7.org/fhir/imagingstudy-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImagingStudyStatusCode {}
/// Nested message and enum types in `ImagingStudyStatusCode`.
pub mod imaging_study_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Registered = 1,
        Available = 2,
        Cancelled = 3,
        EnteredInError = 4,
        Unknown = 5,
    }
}
/// A set codes that define the functional status of an implanted device.
/// See <http://terminology.hl7.org/CodeSystem/implantStatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImplantStatusCode {}
/// Nested message and enum types in `ImplantStatusCode`.
pub mod implant_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Functional = 1,
        NonFunctional = 2,
        Disabled = 3,
        Unknown = 4,
    }
}
/// Codes indicating the kind of the price component.
/// See <http://hl7.org/fhir/invoice-priceComponentType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct InvoicePriceComponentTypeCode {}
/// Nested message and enum types in `InvoicePriceComponentTypeCode`.
pub mod invoice_price_component_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Base = 1,
        Surcharge = 2,
        Deduction = 3,
        Discount = 4,
        Tax = 5,
        Informational = 6,
    }
}
/// Codes identifying the lifecycle stage of an Invoice.
/// See <http://hl7.org/fhir/invoice-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct InvoiceStatusCode {}
/// Nested message and enum types in `InvoiceStatusCode`.
pub mod invoice_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Issued = 2,
        Balanced = 3,
        Cancelled = 4,
        EnteredInError = 5,
    }
}
/// How the issue affects the success of the action.
/// See <http://hl7.org/fhir/issue-severity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct IssueSeverityCode {}
/// Nested message and enum types in `IssueSeverityCode`.
pub mod issue_severity_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Fatal = 1,
        Error = 2,
        Warning = 3,
        Information = 4,
    }
}
/// A code that describes the type of issue.
/// See <http://hl7.org/fhir/issue-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct IssueTypeCode {}
/// Nested message and enum types in `IssueTypeCode`.
pub mod issue_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Invalid = 1,
        Structure = 2,
        Required = 3,
        Value = 4,
        Invariant = 5,
        Security = 6,
        Login = 7,
        Unknown = 8,
        Expired = 9,
        Forbidden = 10,
        Suppressed = 11,
        Processing = 12,
        NotSupported = 13,
        Duplicate = 14,
        MultipleMatches = 15,
        NotFound = 16,
        Deleted = 17,
        TooLong = 18,
        CodeInvalid = 19,
        Extension = 20,
        TooCostly = 21,
        BusinessRule = 22,
        Conflict = 23,
        Transient = 24,
        LockError = 25,
        NoStore = 26,
        Exception = 27,
        Timeout = 28,
        Incomplete = 29,
        Throttled = 30,
        Informational = 31,
    }
}
/// The type of link between this patient resource and another patient resource.
/// See <http://hl7.org/fhir/link-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LinkTypeCode {}
/// Nested message and enum types in `LinkTypeCode`.
pub mod link_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        ReplacedBy = 1,
        Replaces = 2,
        Refer = 3,
        Seealso = 4,
    }
}
/// Used to distinguish different roles a resource can play within a set of
/// linked resources. See <http://hl7.org/fhir/linkage-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LinkageTypeCode {}
/// Nested message and enum types in `LinkageTypeCode`.
pub mod linkage_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Source = 1,
        Alternate = 2,
        Historical = 3,
    }
}
/// The processing mode that applies to this list.
/// See <http://hl7.org/fhir/list-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ListModeCode {}
/// Nested message and enum types in `ListModeCode`.
pub mod list_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Working = 1,
        Snapshot = 2,
        Changes = 3,
    }
}
/// The current state of the list.
/// See <http://hl7.org/fhir/list-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ListStatusCode {}
/// Nested message and enum types in `ListStatusCode`.
pub mod list_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Current = 1,
        Retired = 2,
        EnteredInError = 3,
    }
}
/// Indicates whether a resource instance represents a specific location or a
/// class of locations. See <http://hl7.org/fhir/location-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LocationModeCode {}
/// Nested message and enum types in `LocationModeCode`.
pub mod location_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Instance = 1,
        Kind = 2,
    }
}
/// Indicates whether the location is still in use.
/// See <http://hl7.org/fhir/location-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LocationStatusCode {}
/// Nested message and enum types in `LocationStatusCode`.
pub mod location_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Suspended = 2,
        Inactive = 3,
    }
}
/// A Master Patient Index (MPI) assessment of whether a candidate patient record
/// is a match or not. See <http://terminology.hl7.org/CodeSystem/match-grade>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MatchGradeCode {}
/// Nested message and enum types in `MatchGradeCode`.
pub mod match_grade_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Certain = 1,
        Probable = 2,
        Possible = 3,
        CertainlyNot = 4,
    }
}
/// Observation values that indicate what change in a measurement value or score
/// is indicative of an improvement in the measured item or scored issue. See
/// <http://terminology.hl7.org/CodeSystem/measure-improvement-notation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureImprovementNotationCode {}
/// Nested message and enum types in `MeasureImprovementNotationCode`.
pub mod measure_improvement_notation_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Increase = 1,
        Decrease = 2,
    }
}
/// The status of the measure report.
/// See <http://hl7.org/fhir/measure-report-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureReportStatusCode {}
/// Nested message and enum types in `MeasureReportStatusCode`.
pub mod measure_report_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Complete = 1,
        Pending = 2,
        Error = 3,
    }
}
/// The type of the measure report.
/// See <http://hl7.org/fhir/measure-report-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureReportTypeCode {}
/// Nested message and enum types in `MeasureReportTypeCode`.
pub mod measure_report_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Individual = 1,
        SubjectList = 2,
        Summary = 3,
        DataCollection = 4,
    }
}
/// MedicationAdministration Status Codes
/// See <http://terminology.hl7.org/CodeSystem/medication-admin-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationAdministrationStatusCode {}
/// Nested message and enum types in `MedicationAdministrationStatusCode`.
pub mod medication_administration_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        InProgress = 1,
        NotDone = 2,
        OnHold = 3,
        Completed = 4,
        EnteredInError = 5,
        Stopped = 6,
        Unknown = 7,
    }
}
/// MedicationDispense Status Codes
/// See <http://terminology.hl7.org/CodeSystem/medicationdispense-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationDispenseStatusCode {}
/// Nested message and enum types in `MedicationDispenseStatusCode`.
pub mod medication_dispense_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Preparation = 1,
        InProgress = 2,
        Cancelled = 3,
        OnHold = 4,
        Completed = 5,
        EnteredInError = 6,
        Stopped = 7,
        Declined = 8,
        Unknown = 9,
    }
}
/// MedicationKnowledge Status Codes
/// See <http://terminology.hl7.org/CodeSystem/medicationknowledge-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationKnowledgeStatusCode {}
/// Nested message and enum types in `MedicationKnowledgeStatusCode`.
pub mod medication_knowledge_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
    }
}
/// MedicationRequest Intent Codes
/// See <http://hl7.org/fhir/CodeSystem/medicationrequest-intent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationRequestIntentCode {}
/// Nested message and enum types in `MedicationRequestIntentCode`.
pub mod medication_request_intent_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposal = 1,
        Plan = 2,
        Order = 3,
        OriginalOrder = 4,
        ReflexOrder = 5,
        FillerOrder = 6,
        InstanceOrder = 7,
        Option = 8,
    }
}
/// Medication Status Codes
/// See <http://hl7.org/fhir/CodeSystem/medication-statement-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationStatementStatusCodes {}
/// Nested message and enum types in `MedicationStatementStatusCodes`.
pub mod medication_statement_status_codes {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Completed = 2,
        EnteredInError = 3,
        Intended = 4,
        Stopped = 5,
        OnHold = 6,
        Unknown = 7,
        NotTaken = 8,
    }
}
/// Medication Status Codes
/// See <http://hl7.org/fhir/CodeSystem/medication-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationStatusCode {}
/// Nested message and enum types in `MedicationStatusCode`.
pub mod medication_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
    }
}
/// MedicationRequest Status Codes
/// See <http://hl7.org/fhir/CodeSystem/medicationrequest-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationrequestStatusCode {}
/// Nested message and enum types in `MedicationrequestStatusCode`.
pub mod medicationrequest_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        OnHold = 2,
        Cancelled = 3,
        Completed = 4,
        EnteredInError = 5,
        Stopped = 6,
        Draft = 7,
        Unknown = 8,
    }
}
/// The impact of the content of a message.
/// See <http://hl7.org/fhir/message-significance-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageSignificanceCategoryCode {}
/// Nested message and enum types in `MessageSignificanceCategoryCode`.
pub mod message_significance_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Consequence = 1,
        Currency = 2,
        Notification = 3,
    }
}
/// HL7-defined table of codes which identify conditions under which
/// acknowledgments are required to be returned in response to a message. See
/// <http://hl7.org/fhir/messageheader-response-request>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageheaderResponseRequestCode {}
/// Nested message and enum types in `MessageheaderResponseRequestCode`.
pub mod messageheader_response_request_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Always = 1,
        OnError = 2,
        Never = 3,
        OnSuccess = 4,
    }
}
/// The use of a human name.
/// See <http://hl7.org/fhir/name-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NameUseCode {}
/// Nested message and enum types in `NameUseCode`.
pub mod name_use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Usual = 1,
        Official = 2,
        Temp = 3,
        Nickname = 4,
        Anonymous = 5,
        Old = 6,
        Maiden = 7,
    }
}
/// Identifies the style of unique identifier used to identify a namespace.
/// See <http://hl7.org/fhir/namingsystem-identifier-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NamingSystemIdentifierTypeCode {}
/// Nested message and enum types in `NamingSystemIdentifierTypeCode`.
pub mod naming_system_identifier_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Oid = 1,
        Uuid = 2,
        Uri = 3,
        Other = 4,
    }
}
/// Identifies the purpose of the naming system.
/// See <http://hl7.org/fhir/namingsystem-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NamingSystemTypeCode {}
/// Nested message and enum types in `NamingSystemTypeCode`.
pub mod naming_system_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Codesystem = 1,
        Identifier = 2,
        Root = 3,
    }
}
/// The status of a resource narrative.
/// See <http://hl7.org/fhir/narrative-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NarrativeStatusCode {}
/// Nested message and enum types in `NarrativeStatusCode`.
pub mod narrative_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Generated = 1,
        Extensions = 2,
        Additional = 3,
        Empty = 4,
    }
}
/// The presentation types of notes.
/// See <http://hl7.org/fhir/note-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NoteTypeCode {}
/// Nested message and enum types in `NoteTypeCode`.
pub mod note_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Display = 1,
        Print = 2,
        Printoper = 3,
    }
}
/// Permitted data type for observation value.
/// See <http://hl7.org/fhir/permitted-data-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationDataTypeCode {}
/// Nested message and enum types in `ObservationDataTypeCode`.
pub mod observation_data_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Quantity = 1,
        CodeableConcept = 2,
        String = 3,
        Boolean = 4,
        Integer = 5,
        Range = 6,
        Ratio = 7,
        SampledData = 8,
        Time = 9,
        DateTime = 10,
        Period = 11,
    }
}
/// Codes identifying the category of observation range.
/// See <http://hl7.org/fhir/observation-range-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationRangeCategoryCode {}
/// Nested message and enum types in `ObservationRangeCategoryCode`.
pub mod observation_range_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Reference = 1,
        Critical = 2,
        Absolute = 3,
    }
}
/// Codes providing the status of an observation.
/// See <http://hl7.org/fhir/observation-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationStatusCode {}
/// Nested message and enum types in `ObservationStatusCode`.
pub mod observation_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Registered = 1,
        Preliminary = 2,
        Final = 3,
        Amended = 4,
        Corrected = 5,
        Cancelled = 6,
        EnteredInError = 7,
        Unknown = 8,
    }
}
/// Whether an operation is a normal operation or a query.
/// See <http://hl7.org/fhir/operation-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationKindCode {}
/// Nested message and enum types in `OperationKindCode`.
pub mod operation_kind_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Operation = 1,
        Query = 2,
    }
}
/// Whether an operation parameter is an input or an output parameter.
/// See <http://hl7.org/fhir/operation-parameter-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationParameterUseCode {}
/// Nested message and enum types in `OperationParameterUseCode`.
pub mod operation_parameter_use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        In = 1,
        Out = 2,
    }
}
/// Type for orientation.
/// See <http://hl7.org/fhir/orientation-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OrientationTypeCode {}
/// Nested message and enum types in `OrientationTypeCode`.
pub mod orientation_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Sense = 1,
        Antisense = 2,
    }
}
/// Is the Participant required to attend the appointment.
/// See <http://hl7.org/fhir/participantrequired>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ParticipantRequiredCode {}
/// Nested message and enum types in `ParticipantRequiredCode`.
pub mod participant_required_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Required = 1,
        Optional = 2,
        InformationOnly = 3,
    }
}
/// The Participation status of an appointment.
/// See <http://hl7.org/fhir/participationstatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ParticipationStatusCode {}
/// Nested message and enum types in `ParticipationStatusCode`.
pub mod participation_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Accepted = 1,
        Declined = 2,
        Tentative = 3,
        NeedsAction = 4,
    }
}
/// How a property is represented when serialized.
/// See <http://hl7.org/fhir/property-representation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PropertyRepresentationCode {}
/// Nested message and enum types in `PropertyRepresentationCode`.
pub mod property_representation_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        XmlAttr = 1,
        XmlText = 2,
        TypeAttr = 3,
        CdaText = 4,
        Xhtml = 5,
    }
}
/// The type of a property value.
/// See <http://hl7.org/fhir/concept-property-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PropertyTypeCode {}
/// Nested message and enum types in `PropertyTypeCode`.
pub mod property_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Code = 1,
        Coding = 2,
        String = 3,
        Integer = 4,
        Boolean = 5,
        DateTime = 6,
        Decimal = 7,
    }
}
/// How an entity was used in an activity.
/// See <http://hl7.org/fhir/provenance-entity-role>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProvenanceEntityRoleCode {}
/// Nested message and enum types in `ProvenanceEntityRoleCode`.
pub mod provenance_entity_role_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Derivation = 1,
        Revision = 2,
        Quotation = 3,
        Source = 4,
        Removal = 5,
    }
}
/// The lifecycle status of an artifact.
/// See <http://hl7.org/fhir/publication-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PublicationStatusCode {}
/// Nested message and enum types in `PublicationStatusCode`.
pub mod publication_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Active = 2,
        Retired = 3,
        Unknown = 4,
    }
}
/// Type for quality report.
/// See <http://hl7.org/fhir/quality-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QualityTypeCode {}
/// Nested message and enum types in `QualityTypeCode`.
pub mod quality_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Indel = 1,
        Snp = 2,
        Unknown = 3,
    }
}
/// How the Quantity should be understood and represented.
/// See <http://hl7.org/fhir/quantity-comparator>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuantityComparatorCode {}
/// Nested message and enum types in `QuantityComparatorCode`.
pub mod quantity_comparator_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        LessThan = 1,
        LessThanOrEqualTo = 2,
        GreaterThanOrEqualTo = 3,
        GreaterThan = 4,
    }
}
/// The criteria by which a question is enabled.
/// See <http://hl7.org/fhir/questionnaire-enable-operator>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireItemOperatorCode {}
/// Nested message and enum types in `QuestionnaireItemOperatorCode`.
pub mod questionnaire_item_operator_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Exists = 1,
        Equals = 2,
        NotEqualTo = 3,
        GreaterThan = 4,
        LessThan = 5,
        GreaterThanOrEqualTo = 6,
        LessThanOrEqualTo = 7,
    }
}
/// Distinguishes groups from questions and display text and indicates data type
/// for questions. See <http://hl7.org/fhir/item-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireItemTypeCode {}
/// Nested message and enum types in `QuestionnaireItemTypeCode`.
pub mod questionnaire_item_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Group = 1,
        Display = 2,
        Question = 3,
        Boolean = 4,
        Decimal = 5,
        Integer = 6,
        Date = 7,
        DateTime = 8,
        Time = 9,
        String = 10,
        Text = 11,
        Url = 12,
        Choice = 13,
        OpenChoice = 14,
        Attachment = 15,
        Reference = 16,
        Quantity = 17,
    }
}
/// Identifies the modes of usage of a questionnaire that should enable a
/// particular questionnaire item. See
/// <http://terminology.hl7.org/CodeSystem/questionnaire-usage-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireItemUsageModeCode {}
/// Nested message and enum types in `QuestionnaireItemUsageModeCode`.
pub mod questionnaire_item_usage_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        CaptureDisplay = 1,
        Capture = 2,
        Display = 3,
        DisplayNonEmpty = 4,
        CaptureDisplayNonEmpty = 5,
    }
}
/// Lifecycle status of the questionnaire response.
/// See <http://hl7.org/fhir/questionnaire-answers-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireResponseStatusCode {}
/// Nested message and enum types in `QuestionnaireResponseStatusCode`.
pub mod questionnaire_response_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        InProgress = 1,
        Completed = 2,
        Amended = 3,
        EnteredInError = 4,
        Stopped = 5,
    }
}
/// A set of flags that defines how references are supported.
/// See <http://hl7.org/fhir/reference-handling-policy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReferenceHandlingPolicyCode {}
/// Nested message and enum types in `ReferenceHandlingPolicyCode`.
pub mod reference_handling_policy_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Literal = 1,
        Logical = 2,
        Resolves = 3,
        Enforced = 4,
        Local = 5,
    }
}
/// Whether a reference needs to be version specific or version independent, or
/// whether either can be used. See <http://hl7.org/fhir/reference-version-rules>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReferenceVersionRulesCode {}
/// Nested message and enum types in `ReferenceVersionRulesCode`.
pub mod reference_version_rules_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Either = 1,
        Independent = 2,
        Specific = 3,
    }
}
/// The type of relationship to the related artifact.
/// See <http://hl7.org/fhir/related-artifact-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RelatedArtifactTypeCode {}
/// Nested message and enum types in `RelatedArtifactTypeCode`.
pub mod related_artifact_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Documentation = 1,
        Justification = 2,
        Citation = 3,
        Predecessor = 4,
        Successor = 5,
        DerivedFrom = 6,
        DependsOn = 7,
        ComposedOf = 8,
    }
}
/// Type for access of external URI.
/// See <http://hl7.org/fhir/repository-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RepositoryTypeCode {}
/// Nested message and enum types in `RepositoryTypeCode`.
pub mod repository_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Directlink = 1,
        Openapi = 2,
        Login = 3,
        Oauth = 4,
        Other = 5,
    }
}
/// Codes indicating the degree of authority/intentionality associated with a
/// request. See <http://hl7.org/fhir/request-intent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RequestIntentCode {}
/// Nested message and enum types in `RequestIntentCode`.
pub mod request_intent_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposal = 1,
        Plan = 2,
        Directive = 3,
        Order = 4,
        OriginalOrder = 5,
        ReflexOrder = 6,
        FillerOrder = 7,
        InstanceOrder = 8,
        Option = 9,
    }
}
/// Identifies the level of importance to be assigned to actioning the request.
/// See <http://hl7.org/fhir/request-priority>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RequestPriorityCode {}
/// Nested message and enum types in `RequestPriorityCode`.
pub mod request_priority_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Routine = 1,
        Urgent = 2,
        Asap = 3,
        Stat = 4,
    }
}
/// A list of all the request resource types defined in this version of the FHIR
/// specification. See <http://hl7.org/fhir/request-resource-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RequestResourceTypeCode {}
/// Nested message and enum types in `RequestResourceTypeCode`.
pub mod request_resource_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Appointment = 1,
        AppointmentResponse = 2,
        CarePlan = 3,
        Claim = 4,
        CommunicationRequest = 5,
        Contract = 6,
        DeviceRequest = 7,
        EnrollmentRequest = 8,
        ImmunizationRecommendation = 9,
        MedicationRequest = 10,
        NutritionOrder = 11,
        ServiceRequest = 12,
        SupplyRequest = 13,
        Task = 14,
        VisionPrescription = 15,
    }
}
/// Codes identifying the lifecycle stage of a request.
/// See <http://hl7.org/fhir/request-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RequestStatusCode {}
/// Nested message and enum types in `RequestStatusCode`.
pub mod request_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Active = 2,
        OnHold = 3,
        Revoked = 4,
        Completed = 5,
        EnteredInError = 6,
        Unknown = 7,
    }
}
/// The possible types of research elements (E.g. Population, Exposure, Outcome).
/// See <http://hl7.org/fhir/research-element-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchElementTypeCode {}
/// Nested message and enum types in `ResearchElementTypeCode`.
pub mod research_element_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Population = 1,
        Exposure = 2,
        Outcome = 3,
    }
}
/// Codes that convey the current status of the research study.
/// See <http://hl7.org/fhir/research-study-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchStudyStatusCode {}
/// Nested message and enum types in `ResearchStudyStatusCode`.
pub mod research_study_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        AdministrativelyCompleted = 2,
        Approved = 3,
        ClosedToAccrual = 4,
        ClosedToAccrualAndIntervention = 5,
        Completed = 6,
        Disapproved = 7,
        InReview = 8,
        TemporarilyClosedToAccrual = 9,
        TemporarilyClosedToAccrualAndIntervention = 10,
        Withdrawn = 11,
    }
}
/// Indicates the progression of a study subject through a study.
/// See <http://hl7.org/fhir/research-subject-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchSubjectStatusCode {}
/// Nested message and enum types in `ResearchSubjectStatusCode`.
pub mod research_subject_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Candidate = 1,
        Eligible = 2,
        FollowUp = 3,
        Ineligible = 4,
        NotRegistered = 5,
        OffStudy = 6,
        OnStudy = 7,
        OnStudyIntervention = 8,
        OnStudyObservation = 9,
        PendingOnStudy = 10,
        PotentialCandidate = 11,
        Screening = 12,
        Withdrawn = 13,
    }
}
/// Provides general guidance around the kind of access Control to Read, Search,
/// Create, Update, or Delete a resource. See
/// <http://terminology.hl7.org/CodeSystem/resource-security-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResourceSecurityCategoryCode {}
/// Nested message and enum types in `ResourceSecurityCategoryCode`.
pub mod resource_security_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Anonymous = 1,
        Business = 2,
        Individual = 3,
        Patient = 4,
        NotClassified = 5,
    }
}
/// One of the resource types defined as part of this version of FHIR.
/// See <http://hl7.org/fhir/resource-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResourceTypeCode {}
/// Nested message and enum types in `ResourceTypeCode`.
pub mod resource_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Account = 1,
        ActivityDefinition = 2,
        AdverseEvent = 3,
        AllergyIntolerance = 4,
        Appointment = 5,
        AppointmentResponse = 6,
        AuditEvent = 7,
        Basic = 8,
        Binary = 9,
        BiologicallyDerivedProduct = 10,
        BodyStructure = 11,
        Bundle = 12,
        CapabilityStatement = 13,
        CarePlan = 14,
        CareTeam = 15,
        CatalogEntry = 16,
        ChargeItem = 17,
        ChargeItemDefinition = 18,
        Claim = 19,
        ClaimResponse = 20,
        ClinicalImpression = 21,
        CodeSystem = 22,
        Communication = 23,
        CommunicationRequest = 24,
        CompartmentDefinition = 25,
        Composition = 26,
        ConceptMap = 27,
        Condition = 28,
        Consent = 29,
        Contract = 30,
        Coverage = 31,
        CoverageEligibilityRequest = 32,
        CoverageEligibilityResponse = 33,
        DetectedIssue = 34,
        Device = 35,
        DeviceDefinition = 36,
        DeviceMetric = 37,
        DeviceRequest = 38,
        DeviceUseStatement = 39,
        DiagnosticReport = 40,
        DocumentManifest = 41,
        DocumentReference = 42,
        DomainResource = 43,
        EffectEvidenceSynthesis = 44,
        Encounter = 45,
        Endpoint = 46,
        EnrollmentRequest = 47,
        EnrollmentResponse = 48,
        EpisodeOfCare = 49,
        EventDefinition = 50,
        Evidence = 51,
        EvidenceVariable = 52,
        ExampleScenario = 53,
        ExplanationOfBenefit = 54,
        FamilyMemberHistory = 55,
        Flag = 56,
        Goal = 57,
        GraphDefinition = 58,
        Group = 59,
        GuidanceResponse = 60,
        HealthcareService = 61,
        ImagingStudy = 62,
        Immunization = 63,
        ImmunizationEvaluation = 64,
        ImmunizationRecommendation = 65,
        ImplementationGuide = 66,
        InsurancePlan = 67,
        Invoice = 68,
        Library = 69,
        Linkage = 70,
        List = 71,
        Location = 72,
        Measure = 73,
        MeasureReport = 74,
        Media = 75,
        Medication = 76,
        MedicationAdministration = 77,
        MedicationDispense = 78,
        MedicationKnowledge = 79,
        MedicationRequest = 80,
        MedicationStatement = 81,
        MedicinalProduct = 82,
        MedicinalProductAuthorization = 83,
        MedicinalProductContraindication = 84,
        MedicinalProductIndication = 85,
        MedicinalProductIngredient = 86,
        MedicinalProductInteraction = 87,
        MedicinalProductManufactured = 88,
        MedicinalProductPackaged = 89,
        MedicinalProductPharmaceutical = 90,
        MedicinalProductUndesirableEffect = 91,
        MessageDefinition = 92,
        MessageHeader = 93,
        MolecularSequence = 94,
        NamingSystem = 95,
        NutritionOrder = 96,
        Observation = 97,
        ObservationDefinition = 98,
        OperationDefinition = 99,
        OperationOutcome = 100,
        Organization = 101,
        OrganizationAffiliation = 102,
        Parameters = 103,
        Patient = 104,
        PaymentNotice = 105,
        PaymentReconciliation = 106,
        Person = 107,
        PlanDefinition = 108,
        Practitioner = 109,
        PractitionerRole = 110,
        Procedure = 111,
        Provenance = 112,
        Questionnaire = 113,
        QuestionnaireResponse = 114,
        RelatedPerson = 115,
        RequestGroup = 116,
        ResearchDefinition = 117,
        ResearchElementDefinition = 118,
        ResearchStudy = 119,
        ResearchSubject = 120,
        Resource = 121,
        RiskAssessment = 122,
        RiskEvidenceSynthesis = 123,
        Schedule = 124,
        SearchParameter = 125,
        ServiceRequest = 126,
        Slot = 127,
        Specimen = 128,
        SpecimenDefinition = 129,
        StructureDefinition = 130,
        StructureMap = 131,
        Subscription = 132,
        Substance = 133,
        SubstanceNucleicAcid = 134,
        SubstancePolymer = 135,
        SubstanceProtein = 136,
        SubstanceReferenceInformation = 137,
        SubstanceSourceMaterial = 138,
        SubstanceSpecification = 139,
        SupplyDelivery = 140,
        SupplyRequest = 141,
        Task = 142,
        TerminologyCapabilities = 143,
        TestReport = 144,
        TestScript = 145,
        Set = 146,
        VerificationResult = 147,
        VisionPrescription = 148,
    }
}
/// How the system supports versioning for a resource.
/// See <http://hl7.org/fhir/versioning-policy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResourceVersionPolicyCode {}
/// Nested message and enum types in `ResourceVersionPolicyCode`.
pub mod resource_version_policy_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NoVersion = 1,
        Versioned = 2,
        VersionedUpdate = 3,
    }
}
/// The kind of response to a message.
/// See <http://hl7.org/fhir/response-code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResponseTypeCode {}
/// Nested message and enum types in `ResponseTypeCode`.
pub mod response_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ok = 1,
        TransientError = 2,
        FatalError = 3,
    }
}
/// The mode of a RESTful capability statement.
/// See <http://hl7.org/fhir/restful-capability-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RestfulCapabilityModeCode {}
/// Nested message and enum types in `RestfulCapabilityModeCode`.
pub mod restful_capability_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Client = 1,
        Server = 2,
    }
}
/// The license that applies to an Implementation Guide (using an SPDX license
/// Identifiers, or 'not-open-source'). The binding is required but new SPDX
/// license Identifiers are allowed to be used (<https://spdx.org/licenses/>). See
/// <http://hl7.org/fhir/spdx-license>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpdxLicenseCode {}
/// Nested message and enum types in `SPDXLicenseCode`.
pub mod spdx_license_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotOpenSource = 1,
        BsdZeroClauseLicense = 2,
        Aal = 3,
        Abstyles = 4,
        Adobe2006 = 5,
        AdobeGlyph = 6,
        Adsl = 7,
        Afl11 = 8,
        Afl12 = 9,
        Afl20 = 10,
        Afl21 = 11,
        Afl30 = 12,
        Afmparse = 13,
        Agpl10Only = 14,
        Agpl10OrLater = 15,
        Agpl30Only = 16,
        Agpl30OrLater = 17,
        Aladdin = 18,
        Amdplpa = 19,
        Aml = 20,
        Ampas = 21,
        AntlrPd = 22,
        Apache10 = 23,
        Apache11 = 24,
        Apache20 = 25,
        Apafml = 26,
        Apl10 = 27,
        Apsl10 = 28,
        Apsl11 = 29,
        Apsl12 = 30,
        Apsl20 = 31,
        Artistic10Cl8 = 32,
        Artistic10Perl = 33,
        Artistic10 = 34,
        Artistic20 = 35,
        Bahyph = 36,
        Barr = 37,
        Beerware = 38,
        BitTorrent10 = 39,
        BitTorrent11 = 40,
        Borceux = 41,
        Bsd1Clause = 42,
        Bsd2ClauseFreeBsd = 43,
        Bsd2ClauseNetBsd = 44,
        Bsd2ClausePatent = 45,
        Bsd2Clause = 46,
        Bsd3ClauseAttribution = 47,
        Bsd3ClauseClear = 48,
        Bsd3ClauseLbnl = 49,
        Bsd3ClauseNoNuclearLicense2014 = 50,
        Bsd3ClauseNoNuclearLicense = 51,
        Bsd3ClauseNoNuclearWarranty = 52,
        Bsd3Clause = 53,
        Bsd4ClauseUc = 54,
        Bsd4Clause = 55,
        BsdProtection = 56,
        BsdSourceCode = 57,
        Bsl10 = 58,
        Bzip2105 = 59,
        Bzip2106 = 60,
        Caldera = 61,
        Catosl11 = 62,
        CcBy10 = 63,
        CcBy20 = 64,
        CcBy25 = 65,
        CcBy30 = 66,
        CcBy40 = 67,
        CcByNc10 = 68,
        CcByNc20 = 69,
        CcByNc25 = 70,
        CcByNc30 = 71,
        CcByNc40 = 72,
        CcByNcNd10 = 73,
        CcByNcNd20 = 74,
        CcByNcNd25 = 75,
        CcByNcNd30 = 76,
        CcByNcNd40 = 77,
        CcByNcSa10 = 78,
        CcByNcSa20 = 79,
        CcByNcSa25 = 80,
        CcByNcSa30 = 81,
        CcByNcSa40 = 82,
        CcByNd10 = 83,
        CcByNd20 = 84,
        CcByNd25 = 85,
        CcByNd30 = 86,
        CcByNd40 = 87,
        CcBySa10 = 88,
        CcBySa20 = 89,
        CcBySa25 = 90,
        CcBySa30 = 91,
        CcBySa40 = 92,
        Cc010 = 93,
        Cddl10 = 94,
        Cddl11 = 95,
        CdlaPermissive10 = 96,
        CdlaSharing10 = 97,
        Cecill10 = 98,
        Cecill11 = 99,
        Cecill20 = 100,
        Cecill21 = 101,
        CecillB = 102,
        CecillC = 103,
        ClArtistic = 104,
        CnriJython = 105,
        CnriPythonGplCompatible = 106,
        CnriPython = 107,
        Condor11 = 108,
        Cpal10 = 109,
        Cpl10 = 110,
        Cpol102 = 111,
        Crossword = 112,
        CrystalStacker = 113,
        CuaOpl10 = 114,
        Cube = 115,
        Curl = 116,
        DFsl10 = 117,
        Diffmark = 118,
        Doc = 119,
        Dotseqn = 120,
        Dsdp = 121,
        Dvipdfm = 122,
        Ecl10 = 123,
        Ecl20 = 124,
        Efl10 = 125,
        Efl20 = 126,
        EGenix = 127,
        Entessa = 128,
        Epl10 = 129,
        Epl20 = 130,
        ErlPl11 = 131,
        EuDatagrid = 132,
        Eupl10 = 133,
        Eupl11 = 134,
        Eupl12 = 135,
        Eurosym = 136,
        Fair = 137,
        Frameworx10 = 138,
        FreeImage = 139,
        Fsfap = 140,
        Fsful = 141,
        Fsfullr = 142,
        Ftl = 143,
        Gfdl11Only = 144,
        Gfdl11OrLater = 145,
        Gfdl12Only = 146,
        Gfdl12OrLater = 147,
        Gfdl13Only = 148,
        Gfdl13OrLater = 149,
        Giftware = 150,
        Gl2ps = 151,
        Glide = 152,
        Glulxe = 153,
        Gnuplot = 154,
        Gpl10Only = 155,
        Gpl10OrLater = 156,
        Gpl20Only = 157,
        Gpl20OrLater = 158,
        Gpl30Only = 159,
        Gpl30OrLater = 160,
        GSoap13b = 161,
        HaskellReport = 162,
        Hpnd = 163,
        IbmPibs = 164,
        Icu = 165,
        Ijg = 166,
        ImageMagick = 167,
        IMatix = 168,
        Imlib2 = 169,
        InfoZip = 170,
        IntelAcpi = 171,
        Intel = 172,
        Interbase10 = 173,
        Ipa = 174,
        Ipl10 = 175,
        Isc = 176,
        JasPer20 = 177,
        Json = 178,
        Lal12 = 179,
        Lal13 = 180,
        Latex2e = 181,
        Leptonica = 182,
        Lgpl20Only = 183,
        Lgpl20OrLater = 184,
        Lgpl21Only = 185,
        Lgpl21OrLater = 186,
        Lgpl30Only = 187,
        Lgpl30OrLater = 188,
        Lgpllr = 189,
        Libpng = 190,
        Libtiff = 191,
        LiLiQP11 = 192,
        LiLiQR11 = 193,
        LiLiQRplus11 = 194,
        LinuxOpenIb = 195,
        Lpl10 = 196,
        Lpl102 = 197,
        Lppl10 = 198,
        Lppl11 = 199,
        Lppl12 = 200,
        Lppl13a = 201,
        Lppl13c = 202,
        MakeIndex = 203,
        MirOs = 204,
        Mit0 = 205,
        MitAdvertising = 206,
        MitCmu = 207,
        MitEnna = 208,
        MitFeh = 209,
        Mit = 210,
        Mitnfa = 211,
        Motosoto = 212,
        Mpich2 = 213,
        Mpl10 = 214,
        Mpl11 = 215,
        Mpl20NoCopyleftException = 216,
        Mpl20 = 217,
        MsPl = 218,
        MsRl = 219,
        Mtll = 220,
        Multics = 221,
        Mup = 222,
        Nasa13 = 223,
        Naumen = 224,
        Nbpl10 = 225,
        Ncsa = 226,
        NetSnmp = 227,
        NetCdf = 228,
        Newsletr = 229,
        Ngpl = 230,
        Nlod10 = 231,
        Nlpl = 232,
        Nokia = 233,
        Nosl = 234,
        Noweb = 235,
        Npl10 = 236,
        Npl11 = 237,
        Nposl30 = 238,
        Nrl = 239,
        Ntp = 240,
        OcctPl = 241,
        Oclc20 = 242,
        ODbL10 = 243,
        Ofl10 = 244,
        Ofl11 = 245,
        Ogtsl = 246,
        Oldap11 = 247,
        Oldap12 = 248,
        Oldap13 = 249,
        Oldap14 = 250,
        Oldap201 = 251,
        Oldap20 = 252,
        Oldap21 = 253,
        Oldap221 = 254,
        Oldap222 = 255,
        Oldap22 = 256,
        Oldap23 = 257,
        Oldap24 = 258,
        Oldap25 = 259,
        Oldap26 = 260,
        Oldap27 = 261,
        Oldap28 = 262,
        Oml = 263,
        OpenSsl = 264,
        Opl10 = 265,
        OsetPl21 = 266,
        Osl10 = 267,
        Osl11 = 268,
        Osl20 = 269,
        Osl21 = 270,
        Osl30 = 271,
        Pddl10 = 272,
        Php30 = 273,
        Php301 = 274,
        Plexus = 275,
        PostgreSql = 276,
        Psfrag = 277,
        Psutils = 278,
        Python20 = 279,
        Qhull = 280,
        Qpl10 = 281,
        Rdisc = 282,
        RHeCos11 = 283,
        Rpl11 = 284,
        Rpl15 = 285,
        Rpsl10 = 286,
        RsaMd = 287,
        Rscpl = 288,
        Ruby = 289,
        SaxPd = 290,
        Saxpath = 291,
        Scea = 292,
        Sendmail = 293,
        SgiB10 = 294,
        SgiB11 = 295,
        SgiB20 = 296,
        SimPl20 = 297,
        Sissl12 = 298,
        Sissl = 299,
        Sleepycat = 300,
        Smlnj = 301,
        Smppl = 302,
        Snia = 303,
        Spencer86 = 304,
        Spencer94 = 305,
        Spencer99 = 306,
        Spl10 = 307,
        SugarCrm113 = 308,
        Swl = 309,
        Tcl = 310,
        TcpWrappers = 311,
        TMate = 312,
        Torque11 = 313,
        Tosl = 314,
        UnicodeDfs2015 = 315,
        UnicodeDfs2016 = 316,
        UnicodeTou = 317,
        Unlicense = 318,
        Upl10 = 319,
        Vim = 320,
        Vostrom = 321,
        Vsl10 = 322,
        W3c19980720 = 323,
        W3c20150513 = 324,
        W3c = 325,
        Watcom10 = 326,
        Wsuipa = 327,
        Wtfpl = 328,
        X11 = 329,
        Xerox = 330,
        XFree8611 = 331,
        Xinetd = 332,
        Xnet = 333,
        Xpp = 334,
        XSkat = 335,
        Ypl10 = 336,
        Ypl11 = 337,
        Zed = 338,
        Zend20 = 339,
        Zimbra13 = 340,
        Zimbra14 = 341,
        ZlibAcknowledgement = 342,
        Zlib = 343,
        Zpl11 = 344,
        Zpl20 = 345,
        Zpl21 = 346,
    }
}
/// What Search Comparator Codes are supported in search.
/// See <http://hl7.org/fhir/search-comparator>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SearchComparatorCode {}
/// Nested message and enum types in `SearchComparatorCode`.
pub mod search_comparator_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Eq = 1,
        Ne = 2,
        Gt = 3,
        Lt = 4,
        Ge = 5,
        Le = 6,
        Sa = 7,
        Eb = 8,
        Ap = 9,
    }
}
/// Why an entry is in the result set - whether it's included as a match or
/// because of an _include requirement, or to convey information or warning
/// information about the search process. See
/// <http://hl7.org/fhir/search-entry-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SearchEntryModeCode {}
/// Nested message and enum types in `SearchEntryModeCode`.
pub mod search_entry_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Match = 1,
        Include = 2,
        Outcome = 3,
    }
}
/// A supported modifier for a search parameter.
/// See <http://hl7.org/fhir/search-modifier-code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SearchModifierCode {}
/// Nested message and enum types in `SearchModifierCode`.
pub mod search_modifier_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Missing = 1,
        Exact = 2,
        Contains = 3,
        Not = 4,
        Text = 5,
        In = 6,
        NotIn = 7,
        Below = 8,
        Above = 9,
        Type = 10,
        Identifier = 11,
        OfType = 12,
    }
}
/// Data types allowed to be used for search parameters.
/// See <http://hl7.org/fhir/search-param-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SearchParamTypeCode {}
/// Nested message and enum types in `SearchParamTypeCode`.
pub mod search_param_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Number = 1,
        Date = 2,
        String = 3,
        Token = 4,
        Reference = 5,
        Composite = 6,
        Quantity = 7,
        Uri = 8,
        Special = 9,
    }
}
/// Type if a sequence -- DNA, RNA, or amino acid sequence.
/// See <http://hl7.org/fhir/sequence-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SequenceTypeCode {}
/// Nested message and enum types in `SequenceTypeCode`.
pub mod sequence_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Aa = 1,
        Dna = 2,
        Rna = 3,
    }
}
/// How slices are interpreted when evaluating an instance.
/// See <http://hl7.org/fhir/resource-slicing-rules>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SlicingRulesCode {}
/// Nested message and enum types in `SlicingRulesCode`.
pub mod slicing_rules_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Closed = 1,
        Open = 2,
        OpenAtEnd = 3,
    }
}
/// The free/busy status of the slot.
/// See <http://hl7.org/fhir/slotstatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SlotStatusCode {}
/// Nested message and enum types in `SlotStatusCode`.
pub mod slot_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Busy = 1,
        Free = 2,
        BusyUnavailable = 3,
        BusyTentative = 4,
        EnteredInError = 5,
    }
}
/// Codes that define what the server is capable of.
/// See <http://terminology.hl7.org/CodeSystem/smart-capabilities>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SmartCapabilitiesCode {}
/// Nested message and enum types in `SmartCapabilitiesCode`.
pub mod smart_capabilities_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        LaunchEhr = 1,
        LaunchStandalone = 2,
        ClientPublic = 3,
        ClientConfidentialSymmetric = 4,
        SsoOpenidConnect = 5,
        ContextPassthroughBanner = 6,
        ContextPassthroughStyle = 7,
        ContextEhrPatient = 8,
        ContextEhrEncounter = 9,
        ContextStandalonePatient = 10,
        ContextStandaloneEncounter = 11,
        PermissionOffline = 12,
        PermissionPatient = 13,
        PermissionUser = 14,
    }
}
/// The possible sort directions, ascending or descending.
/// See <http://hl7.org/fhir/sort-direction>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SortDirectionCode {}
/// Nested message and enum types in `SortDirectionCode`.
pub mod sort_direction_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ascending = 1,
        Descending = 2,
    }
}
/// Degree of preference of a type of conditioned specimen.
/// See <http://hl7.org/fhir/specimen-contained-preference>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecimenContainedPreferenceCode {}
/// Nested message and enum types in `SpecimenContainedPreferenceCode`.
pub mod specimen_contained_preference_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Preferred = 1,
        Alternate = 2,
    }
}
/// Codes providing the status/availability of a specimen.
/// See <http://hl7.org/fhir/specimen-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecimenStatusCode {}
/// Nested message and enum types in `SpecimenStatusCode`.
pub mod specimen_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Available = 1,
        Unavailable = 2,
        Unsatisfactory = 3,
        EnteredInError = 4,
    }
}
/// HL7 Ballot/Standards status of artifact.
/// See <http://terminology.hl7.org/CodeSystem/standards-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StandardsStatusCode {}
/// Nested message and enum types in `StandardsStatusCode`.
pub mod standards_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Normative = 2,
        TrialUse = 3,
        Informative = 4,
        Deprecated = 5,
        External = 6,
    }
}
/// The validation status of the target
/// See <http://hl7.org/fhir/CodeSystem/status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StatusCode {}
/// Nested message and enum types in `StatusCode`.
pub mod status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Attested = 1,
        Validated = 2,
        InProcess = 3,
        ReqRevalid = 4,
        ValFail = 5,
        RevalFail = 6,
    }
}
/// Type for strand.
/// See <http://hl7.org/fhir/strand-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StrandTypeCode {}
/// Nested message and enum types in `StrandTypeCode`.
pub mod strand_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Watson = 1,
        Crick = 2,
    }
}
/// Defines the type of structure that a definition is describing.
/// See <http://hl7.org/fhir/structure-definition-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionKindCode {}
/// Nested message and enum types in `StructureDefinitionKindCode`.
pub mod structure_definition_kind_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        PrimitiveType = 1,
        ComplexType = 2,
        Resource = 3,
        Logical = 4,
    }
}
/// How to interpret the context.
/// See <http://hl7.org/fhir/map-context-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapContextTypeCode {}
/// Nested message and enum types in `StructureMapContextTypeCode`.
pub mod structure_map_context_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Type = 1,
        Variable = 2,
    }
}
/// If this is the default rule set to apply for the source type, or this
/// combination of types. See <http://hl7.org/fhir/map-group-type-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapGroupTypeModeCode {}
/// Nested message and enum types in `StructureMapGroupTypeModeCode`.
pub mod structure_map_group_type_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        None = 1,
        Types = 2,
        TypeAndTypes = 3,
    }
}
/// Mode for this instance of data.
/// See <http://hl7.org/fhir/map-input-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapInputModeCode {}
/// Nested message and enum types in `StructureMapInputModeCode`.
pub mod structure_map_input_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Source = 1,
        Target = 2,
    }
}
/// How the referenced structure is used in this mapping.
/// See <http://hl7.org/fhir/map-model-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapModelModeCode {}
/// Nested message and enum types in `StructureMapModelModeCode`.
pub mod structure_map_model_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Source = 1,
        Queried = 2,
        Target = 3,
        Produced = 4,
    }
}
/// If field is a list, how to manage the source.
/// See <http://hl7.org/fhir/map-source-list-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapSourceListModeCode {}
/// Nested message and enum types in `StructureMapSourceListModeCode`.
pub mod structure_map_source_list_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        First = 1,
        NotFirst = 2,
        Last = 3,
        NotLast = 4,
        OnlyOne = 5,
    }
}
/// If field is a list, how to manage the production.
/// See <http://hl7.org/fhir/map-target-list-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapTargetListModeCode {}
/// Nested message and enum types in `StructureMapTargetListModeCode`.
pub mod structure_map_target_list_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        First = 1,
        Share = 2,
        Last = 3,
        Collate = 4,
    }
}
/// How data is copied/created.
/// See <http://hl7.org/fhir/map-transform>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapTransformCode {}
/// Nested message and enum types in `StructureMapTransformCode`.
pub mod structure_map_transform_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Create = 1,
        Copy = 2,
        Truncate = 3,
        Escape = 4,
        Cast = 5,
        Append = 6,
        Translate = 7,
        Reference = 8,
        DateOp = 9,
        Uuid = 10,
        Pointer = 11,
        Evaluate = 12,
        Cc = 13,
        C = 14,
        Qty = 15,
        Id = 16,
        Cp = 17,
    }
}
/// The type of method used to execute a subscription.
/// See <http://hl7.org/fhir/subscription-channel-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubscriptionChannelTypeCode {}
/// Nested message and enum types in `SubscriptionChannelTypeCode`.
pub mod subscription_channel_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        RestHook = 1,
        Websocket = 2,
        Email = 3,
        Sms = 4,
        Message = 5,
    }
}
/// The status of a subscription.
/// See <http://hl7.org/fhir/subscription-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubscriptionStatusCode {}
/// Nested message and enum types in `SubscriptionStatusCode`.
pub mod subscription_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Requested = 1,
        Active = 2,
        Error = 3,
        Off = 4,
    }
}
/// Status of the supply delivery.
/// See <http://hl7.org/fhir/supplydelivery-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyDeliveryStatusCode {}
/// Nested message and enum types in `SupplyDeliveryStatusCode`.
pub mod supply_delivery_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        InProgress = 1,
        Completed = 2,
        Abandoned = 3,
        EnteredInError = 4,
    }
}
/// This value sets refers to a specific supply item.
/// See <http://terminology.hl7.org/CodeSystem/supply-item-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyItemTypeCode {}
/// Nested message and enum types in `SupplyItemTypeCode`.
pub mod supply_item_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Medication = 1,
        Device = 2,
    }
}
/// Status of the supply request.
/// See <http://hl7.org/fhir/supplyrequest-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyRequestStatusCode {}
/// Nested message and enum types in `SupplyRequestStatusCode`.
pub mod supply_request_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Active = 2,
        Suspended = 3,
        Cancelled = 4,
        Completed = 5,
        EnteredInError = 6,
        Unknown = 7,
    }
}
/// Distinguishes whether the task is a proposal, plan or full order.
/// See <http://hl7.org/fhir/task-intent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TaskIntentCode {}
/// Nested message and enum types in `TaskIntentCode`.
pub mod task_intent_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unknown = 1,
    }
}
/// The current status of the task.
/// See <http://hl7.org/fhir/task-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TaskStatusCode {}
/// Nested message and enum types in `TaskStatusCode`.
pub mod task_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Requested = 2,
        Received = 3,
        Accepted = 4,
        Rejected = 5,
        Ready = 6,
        Cancelled = 7,
        InProgress = 8,
        OnHold = 9,
        Failed = 10,
        Completed = 11,
        EnteredInError = 12,
    }
}
/// Life cycle of the Status Code of a Template Design (Version)
/// See urn:oid:2.16.840.1.113883.3.1937.98.5.8
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TemplateStatusCodeLifeCycleCode {}
/// Nested message and enum types in `TemplateStatusCodeLifeCycleCode`.
pub mod template_status_code_life_cycle_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Pending = 2,
        Active = 3,
        Review = 4,
        Cancelled = 5,
        Rejected = 6,
        Retired = 7,
        Terminated = 8,
    }
}
/// The results of executing an action.
/// See <http://hl7.org/fhir/report-action-result-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestReportActionResultCode {}
/// Nested message and enum types in `TestReportActionResultCode`.
pub mod test_report_action_result_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Pass = 1,
        Skip = 2,
        Fail = 3,
        Warning = 4,
        Error = 5,
    }
}
/// The type of participant.
/// See <http://hl7.org/fhir/report-participant-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestReportParticipantTypeCode {}
/// Nested message and enum types in `TestReportParticipantTypeCode`.
pub mod test_report_participant_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        TestEngine = 1,
        Client = 2,
        Server = 3,
    }
}
/// The reported execution result.
/// See <http://hl7.org/fhir/report-result-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestReportResultCode {}
/// Nested message and enum types in `TestReportResultCode`.
pub mod test_report_result_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Pass = 1,
        Fail = 2,
        Pending = 3,
    }
}
/// The current status of the test report.
/// See <http://hl7.org/fhir/report-status-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestReportStatusCode {}
/// Nested message and enum types in `TestReportStatusCode`.
pub mod test_report_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Completed = 1,
        InProgress = 2,
        Waiting = 3,
        Stopped = 4,
        EnteredInError = 5,
    }
}
/// The allowable request method or HTTP operation codes.
/// See <http://hl7.org/fhir/http-operations>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestScriptRequestMethodCode {}
/// Nested message and enum types in `TestScriptRequestMethodCode`.
pub mod test_script_request_method_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Delete = 1,
        Get = 2,
        Options = 3,
        Patch = 4,
        Post = 5,
        Put = 6,
        Head = 7,
    }
}
/// The type of trigger.
/// See <http://hl7.org/fhir/trigger-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TriggerTypeCode {}
/// Nested message and enum types in `TriggerTypeCode`.
pub mod trigger_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NamedEvent = 1,
        Periodic = 2,
        DataChanged = 3,
        DataAdded = 4,
        DataModified = 5,
        DataRemoved = 6,
        DataAccessed = 7,
        DataAccessEnded = 8,
    }
}
/// How a type relates to its baseDefinition.
/// See <http://hl7.org/fhir/type-derivation-rule>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TypeDerivationRuleCode {}
/// Nested message and enum types in `TypeDerivationRuleCode`.
pub mod type_derivation_rule_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Specialization = 1,
        Constraint = 2,
    }
}
/// Codes to identify how UDI data was entered.
/// See <http://hl7.org/fhir/udi-entry-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UdiEntryTypeCode {}
/// Nested message and enum types in `UDIEntryTypeCode`.
pub mod udi_entry_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Barcode = 1,
        Rfid = 2,
        Manual = 3,
        Card = 4,
        SelfReported = 5,
        Unknown = 6,
    }
}
/// The purpose of the Claim: predetermination, preauthorization, claim.
/// See <http://hl7.org/fhir/claim-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UseCode {}
/// Nested message and enum types in `UseCode`.
pub mod use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Claim = 1,
        Preauthorization = 2,
        Predetermination = 3,
    }
}
/// FHIR Value set/code system definition for HL7 v2 table 0444 ( Name assembly
/// order) See <http://terminology.hl7.org/CodeSystem/v2-0444>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V20444Code {}
/// Nested message and enum types in `V20444Code`.
pub mod v20444_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        F = 1,
        G = 2,
    }
}
///  Codes that provide guidance around the circumstances in which a given
///  address should be used.
/// See <http://terminology.hl7.org/CodeSystem/v3-AddressUse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3AddressUseCode {}
/// Nested message and enum types in `V3AddressUseCode`.
pub mod v3_address_use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        GeneralAddressUse = 1,
        Bad = 2,
        Conf = 3,
        H = 4,
        Hp = 5,
        Hv = 6,
        Old = 7,
        Tmp = 8,
        Wp = 9,
        Dir = 10,
        Pub = 11,
        PostalAddressUse = 12,
        Phys = 13,
        Pst = 14,
        TelecommunicationAddressUse = 15,
        As = 16,
        Ec = 17,
        Mc = 18,
        Pg = 19,
    }
}
///  A set of codes specifying the security classification of acts and roles in
///  accordance with the definition for concept domain "Confidentiality".
/// See <http://terminology.hl7.org/CodeSystem/v3-Confidentiality>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3ConfidentialityCode {}
/// Nested message and enum types in `V3ConfidentialityCode`.
pub mod v3_confidentiality_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Confidentiality = 1,
        L = 2,
        M = 3,
        N = 4,
        R = 5,
        U = 6,
        V = 7,
        ConfidentialityByAccessKind = 8,
        B = 9,
        D = 10,
        I = 11,
        ConfidentialityByInfoType = 12,
        Eth = 13,
        Hiv = 14,
        Psy = 15,
        Sdv = 16,
        ConfidentialityModifiers = 17,
        C = 18,
        S = 19,
        T = 20,
    }
}
///   OpenIssue:
///
/// Needs description
/// See <http://terminology.hl7.org/CodeSystem/v3-EntityNamePartQualifier>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3EntityNamePartQualifierCode {}
/// Nested message and enum types in `V3EntityNamePartQualifierCode`.
pub mod v3_entity_name_part_qualifier_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        OrganizationNamePartQualifier = 1,
        Ac = 2,
        Ad = 3,
        Br = 4,
        Cl = 5,
        In = 6,
        Ls = 7,
        Nb = 8,
        Pr = 9,
        Sp = 10,
        Title = 11,
        Vv = 12,
        PharmaceuticalEntityNamePartQualifiers = 13,
        Con = 14,
        Dev = 15,
        Flav = 16,
        Formul = 17,
        Frm = 18,
        Inv = 19,
        Popul = 20,
        Sci = 21,
        Str = 22,
        Time = 23,
        Tmk = 24,
        Use = 25,
        PersonNamePartQualifier = 26,
        PersonNamePartAffixTypes = 27,
        PersonNamePartChangeQualifier = 28,
        PersonNamePartMiscQualifier = 29,
    }
}
///   Description:
///
/// The qualifier is a set of codes each of which specifies a certain subcategory
/// of the name part in addition to the main name part type. For example, a given
/// name may be flagged as a nickname, a family name may be a pseudonym or a name
/// of public records. See
/// <http://terminology.hl7.org/CodeSystem/v3-EntityNamePartQualifierR2>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3EntityNamePartQualifierR2Code {}
/// Nested message and enum types in `V3EntityNamePartQualifierR2Code`.
pub mod v3_entity_name_part_qualifier_r2_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ad = 1,
        Sp = 2,
        Br = 3,
        Cl = 4,
        In = 5,
        Ls = 6,
        Mid = 7,
        Pfx = 8,
        PharmaceuticalEntityNamePartQualifiers = 9,
        Con = 10,
        Dev = 11,
        Flav = 12,
        Formul = 13,
        Frm = 14,
        Inv = 15,
        Popul = 16,
        Sci = 17,
        Str = 18,
        Time = 19,
        Tmk = 20,
        Use = 21,
        Sfx = 22,
        TitleStyles = 23,
        Ac = 24,
        Hon = 25,
        Nb = 26,
        Pr = 27,
    }
}
/// **** MISSING DEFINITIONS ****
/// See <http://terminology.hl7.org/CodeSystem/v3-EntityNameUse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3EntityNameUseCode {}
/// Nested message and enum types in `V3EntityNameUseCode`.
pub mod v3_entity_name_use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NameRepresentationUse = 1,
        Abc = 2,
        Ide = 3,
        Syl = 4,
        Asgn = 5,
        C = 6,
        I = 7,
        L = 8,
        Or = 9,
        P = 10,
        A = 11,
        R = 12,
        Srch = 13,
        Phon = 14,
        Sndx = 15,
    }
}
///   Description:
///
/// A set of codes advising a system or user which name in a set of names to
/// select for a given purpose. See
/// <http://terminology.hl7.org/CodeSystem/v3-EntityNameUseR2>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3EntityNameUseR2Code {}
/// Nested message and enum types in `V3EntityNameUseR2Code`.
pub mod v3_entity_name_use_r2_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Assumed = 1,
        A = 2,
        Anon = 3,
        I = 4,
        P = 5,
        R = 6,
        C = 7,
        M = 8,
        NameRepresentationUse = 9,
        Abc = 10,
        Ide = 11,
        Syl = 12,
        Old = 13,
        Dn = 14,
        Or = 15,
        Phon = 16,
        Srch = 17,
        T = 18,
    }
}
///  A collection of codes specifying why a valid value is not present.
/// See <http://terminology.hl7.org/CodeSystem/v3-NullFlavor>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3NullFlavorCode {}
/// Nested message and enum types in `V3NullFlavorCode`.
pub mod v3_null_flavor_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ni = 1,
        Inv = 2,
        Der = 3,
        Oth = 4,
        Ninf = 5,
        Pinf = 6,
        Unc = 7,
        Msk = 8,
        Na = 9,
        Unk = 10,
        Asku = 11,
        Nav = 12,
        Nask = 13,
        Navu = 14,
        Qs = 15,
        Trc = 16,
        Np = 17,
    }
}
///  A set of codes specifying the modality by which the Entity playing the Role
///  is participating in the Act.  Examples:
///
/// Physically present, over the telephone, written communication.  Rationale:
///
/// Particularly for author (originator) participants this is used to specify
/// whether the information represented by the act was initially provided
/// verbally, (hand-)written, or electronically.  Open Issue:
///
/// There needs to be a reexamination of the hierarchies as there seems to be
/// some muddling between ELECTRONIC and other concepts that involve electronic
/// communication that are in other hierarchies. See
/// <http://terminology.hl7.org/CodeSystem/v3-ParticipationMode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3ParticipationModeCode {}
/// Nested message and enum types in `V3ParticipationModeCode`.
pub mod v3_participation_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Electronic = 1,
        Physical = 2,
        Remote = 3,
        Verbal = 4,
        Dictate = 5,
        Face = 6,
        Phone = 7,
        Videoconf = 8,
        Written = 9,
        Faxwrit = 10,
        Handwrit = 11,
        Mailwrit = 12,
        Onlinewrit = 13,
        Emailwrit = 14,
        Typewrit = 15,
    }
}
/// **** MISSING DEFINITIONS ****
/// See <http://terminology.hl7.org/CodeSystem/v3-ProbabilityDistributionType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3ProbabilityDistributionTypeCode {}
/// Nested message and enum types in `V3ProbabilityDistributionTypeCode`.
pub mod v3_probability_distribution_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        B = 1,
        E = 2,
        F = 3,
        G = 4,
        Ln = 5,
        N = 6,
        T = 7,
        U = 8,
        X2 = 9,
    }
}
///  A set of codes further specifying the kind of Role; specific classification
///  codes for further qualifying RoleClass codes.
/// See <http://terminology.hl7.org/CodeSystem/v3-RoleCode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3RoleCode {}
/// Nested message and enum types in `V3RoleCode`.
pub mod v3_role_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        AffiliationRoleType = 1,
        AgentRoleType = 2,
        Amender = 3,
        Classifier = 4,
        Consenter = 5,
        Conswit = 6,
        Copart = 7,
        Declassifier = 8,
        Delegatee = 9,
        Delegator = 10,
        Downgrder = 11,
        Drivclassifier = 12,
        Grantee = 13,
        Grantor = 14,
        Intprter = 15,
        Reviewer = 16,
        Validator = 17,
        CoverageSponsorRoleType = 18,
        Fullins = 19,
        Selfins = 20,
        PayorRoleType = 21,
        Enrolbkr = 22,
        Tpa = 23,
        Umo = 24,
        Resprsn = 25,
        Excest = 26,
        Guadltm = 27,
        Guard = 28,
        Powatt = 29,
        Dpowatt = 30,
        Hpowatt = 31,
        Spowatt = 32,
        AssignedRoleType = 33,
        AssignedNonPersonLivingSubjectRoleType = 34,
        Assist = 35,
        Bioth = 36,
        Antibiot = 37,
        Debr = 38,
        Cco = 39,
        See = 40,
        Sniff = 41,
        CertifiedEntityType = 42,
        CitizenRoleType = 43,
        Cas = 44,
        Casm = 45,
        Cn = 46,
        Cnrp = 47,
        Cnrpm = 48,
        Cpca = 49,
        Crp = 50,
        Crpm = 51,
        ContactRoleType = 52,
        AdministrativeContactRoleType = 53,
        Bill = 54,
        Org = 55,
        Payor = 56,
        Econ = 57,
        Nok = 58,
        IdentifiedEntityType = 59,
        LocationIdentifiedEntityRoleCode = 60,
        Achfid = 61,
        Jurid = 62,
        Lochfid = 63,
        LivingSubjectProductionClass = 64,
        Bf = 65,
        Bl = 66,
        Br = 67,
        Co = 68,
        Da = 69,
        Dr = 70,
        Du = 71,
        Fi = 72,
        Ly = 73,
        Mt = 74,
        Mu = 75,
        Pl = 76,
        Rc = 77,
        Sh = 78,
        Vl = 79,
        Wl = 80,
        Wo = 81,
        MedicationGeneralizationRoleType = 82,
        Dc = 83,
        Gd = 84,
        Gdf = 85,
        Gds = 86,
        Gdsf = 87,
        Mgdsf = 88,
        MemberRoleType = 89,
        Trb = 90,
        PersonalRelationshipRoleType = 91,
        Fammemb = 92,
        Child = 93,
        Chldadopt = 94,
        Dauadopt = 95,
        Sonadopt = 96,
        Chldfost = 97,
        Daufost = 98,
        Sonfost = 99,
        Dauc = 100,
        Dau = 101,
        Stpdau = 102,
        Nchild = 103,
        Son = 104,
        Sonc = 105,
        Stpson = 106,
        Stpchld = 107,
        Ext = 108,
        Aunt = 109,
        Maunt = 110,
        Paunt = 111,
        Cousn = 112,
        Mcousn = 113,
        Pcousn = 114,
        Ggrprn = 115,
        Ggrfth = 116,
        Mggrfth = 117,
        Pggrfth = 118,
        Ggrmth = 119,
        Mggrmth = 120,
        Pggrmth = 121,
        Mggrprn = 122,
        Pggrprn = 123,
        Grndchild = 124,
        Grnddau = 125,
        Grndson = 126,
        Grprn = 127,
        Grfth = 128,
        Mgrfth = 129,
        Pgrfth = 130,
        Grmth = 131,
        Mgrmth = 132,
        Pgrmth = 133,
        Mgrprn = 134,
        Pgrprn = 135,
        Inlaw = 136,
        Chldinlaw = 137,
        Dauinlaw = 138,
        Soninlaw = 139,
        Prninlaw = 140,
        Fthinlaw = 141,
        Mthinlaw = 142,
        Sibinlaw = 143,
        Broinlaw = 144,
        Sisinlaw = 145,
        Nieneph = 146,
        Nephew = 147,
        Niece = 148,
        Uncle = 149,
        Muncle = 150,
        Puncle = 151,
        Prn = 152,
        Adoptp = 153,
        Adoptf = 154,
        Adoptm = 155,
        Fth = 156,
        Fthfost = 157,
        Nfth = 158,
        Nfthf = 159,
        Stpfth = 160,
        Mth = 161,
        Gestm = 162,
        Mthfost = 163,
        Nmth = 164,
        Nmthf = 165,
        Stpmth = 166,
        Nprn = 167,
        Prnfost = 168,
        Stpprn = 169,
        Sib = 170,
        Bro = 171,
        Hbro = 172,
        Nbro = 173,
        Twinbro = 174,
        Ftwinbro = 175,
        Itwinbro = 176,
        Stpbro = 177,
        Hsib = 178,
        Hsis = 179,
        Nsib = 180,
        Nsis = 181,
        Twinsis = 182,
        Ftwinsis = 183,
        Itwinsis = 184,
        Twin = 185,
        Ftwin = 186,
        Itwin = 187,
        Sis = 188,
        Stpsis = 189,
        Stpsib = 190,
        Sigothr = 191,
        Dompart = 192,
        Fmrsps = 193,
        Sps = 194,
        Husb = 195,
        Wife = 196,
        Frnd = 197,
        Nbor = 198,
        Oneself = 199,
        Room = 200,
        PolicyOrProgramCoverageRoleType = 201,
        CoverageRoleType = 202,
        Famdep = 203,
        Handic = 204,
        Inj = 205,
        Self_ = 206,
        Spon = 207,
        Stud = 208,
        Fstud = 209,
        Pstud = 210,
        Adopt = 211,
        Gchild = 212,
        Gparnt = 213,
        Nat = 214,
        Niene = 215,
        Parnt = 216,
        Spse = 217,
        Step = 218,
        CoveredPartyRoleType = 219,
        ClaimantCoveredPartyRoleType = 220,
        Crimevic = 221,
        Injwkr = 222,
        DependentCoveredPartyRoleType = 223,
        Cocben = 224,
        Diffabl = 225,
        Ward = 226,
        IndividualInsuredPartyRoleType = 227,
        Retiree = 228,
        ProgramEligiblePartyRoleType = 229,
        Indig = 230,
        Mil = 231,
        Actmil = 232,
        Retmil = 233,
        Vet = 234,
        SubscriberCoveredPartyRoleType = 235,
        ResearchSubjectRoleBasis = 236,
        Erl = 237,
        Scn = 238,
        ServiceDeliveryLocationRoleType = 239,
        DedicatedServiceDeliveryLocationRoleType = 240,
        DedicatedClinicalLocationRoleType = 241,
        Dx = 242,
        Cvdx = 243,
        Cath = 244,
        Echo = 245,
        Gidx = 246,
        Endos = 247,
        Raddx = 248,
        Rado = 249,
        Rneu = 250,
        Hosp = 251,
        Chr = 252,
        Gach = 253,
        Mhsp = 254,
        Psychf = 255,
        Rh = 256,
        Rhat = 257,
        Rhii = 258,
        Rhmad = 259,
        Rhpi = 260,
        Rhpih = 261,
        Rhpims = 262,
        Rhpivs = 263,
        Rhyad = 264,
        Hu = 265,
        Bmtu = 266,
        Ccu = 267,
        Chest = 268,
        Epil = 269,
        Er = 270,
        Etu = 271,
        Hd = 272,
        Hlab = 273,
        Inlab = 274,
        Outlab = 275,
        Hrad = 276,
        Huscs = 277,
        Icu = 278,
        Pedicu = 279,
        Pednicu = 280,
        Inpharm = 281,
        Mbl = 282,
        Nccs = 283,
        Ns = 284,
        Outpharm = 285,
        Pedu = 286,
        Phu = 287,
        Rhu = 288,
        Sleep = 289,
        Nccf = 290,
        Snf = 291,
        Of = 292,
        All = 293,
        Amput = 294,
        Bmtc = 295,
        Breast = 296,
        Canc = 297,
        Capc = 298,
        Card = 299,
        Pedcard = 300,
        Coag = 301,
        Crs = 302,
        Derm = 303,
        Endo = 304,
        Pede = 305,
        Ent = 306,
        Fmc = 307,
        Gi = 308,
        Pedgi = 309,
        Gim = 310,
        Gyn = 311,
        Hem = 312,
        Pedhem = 313,
        Htn = 314,
        Iec = 315,
        Infd = 316,
        Pedid = 317,
        Inv = 318,
        Lymph = 319,
        Mgen = 320,
        Neph = 321,
        Pedneph = 322,
        Neur = 323,
        Ob = 324,
        Oms = 325,
        Oncl = 326,
        Pedho = 327,
        Oph = 328,
        Optc = 329,
        Ortho = 330,
        Hand = 331,
        Paincl = 332,
        Pc = 333,
        Pedc = 334,
        Pedrheum = 335,
        Pod = 336,
        Prev = 337,
        Procto = 338,
        Proff = 339,
        Pros = 340,
        Psi = 341,
        Psy = 342,
        Rheum = 343,
        Spmed = 344,
        Su = 345,
        Pls = 346,
        Uro = 347,
        Tr = 348,
        Travel = 349,
        Wnd = 350,
        Rtf = 351,
        Prc = 352,
        Surf = 353,
        DedicatedNonClinicalLocationRoleType = 354,
        Daddr = 355,
        Mobl = 356,
        Amb = 357,
        Pharm = 358,
        IncidentalServiceDeliveryLocationRoleType = 359,
        Acc = 360,
        Comm = 361,
        Csc = 362,
        Ptres = 363,
        School = 364,
        Upc = 365,
        Work = 366,
        SpecimenRoleType = 367,
        C = 368,
        G = 369,
        L = 370,
        P = 371,
        Q = 372,
        B = 373,
        E = 374,
        F = 375,
        O = 376,
        V = 377,
        R = 378,
        Claim = 379,
        CommunityLaboratory = 380,
        Gt = 381,
        HomeHealth = 382,
        Laboratory = 383,
        Pathologist = 384,
        Ph = 385,
        Phlebotomist = 386,
        Prog = 387,
        Pt = 388,
        Subject = 389,
        ThirdParty = 390,
        Dep = 391,
        Depen = 392,
        Fm = 393,
        Indiv = 394,
        Named = 395,
        Psychcf = 396,
        Subscr = 397,
    }
}
/// **** MISSING DEFINITIONS ****
/// See <http://terminology.hl7.org/CodeSystem/v3-TimingEvent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3TimingEventCode {}
/// Nested message and enum types in `V3TimingEventCode`.
pub mod v3_timing_event_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ac = 1,
        Acd = 2,
        Acm = 3,
        Acv = 4,
        C = 5,
        Cd = 6,
        Cm = 7,
        Cv = 8,
        Hs = 9,
        Ic = 10,
        Icd = 11,
        Icm = 12,
        Icv = 13,
        Pc = 14,
        Pcd = 15,
        Pcm = 16,
        Pcv = 17,
        Wake = 18,
    }
}
/// A coded concept listing the base codes.
/// See <http://hl7.org/fhir/vision-base-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct VisionBaseCode {}
/// Nested message and enum types in `VisionBaseCode`.
pub mod vision_base_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Up = 1,
        Down = 2,
        In = 3,
        Out = 4,
    }
}
/// A coded concept listing the eye codes.
/// See <http://hl7.org/fhir/vision-eye-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct VisionEyesCode {}
/// Nested message and enum types in `VisionEyesCode`.
pub mod vision_eyes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Right = 1,
        Left = 2,
    }
}
/// How a search parameter relates to the set of elements returned by evaluating
/// its xpath query. See <http://hl7.org/fhir/search-xpath-usage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct XPathUsageTypeCode {}
/// Nested message and enum types in `XPathUsageTypeCode`.
pub mod x_path_usage_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Normal = 1,
        Phonetic = 2,
        Nearby = 3,
        Distance = 4,
        Other = 5,
    }
}
/// UCUM units for recording body length measures such as height and head
/// circumference See <http://hl7.org/fhir/ValueSet/ucum-bodylength>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BodyLengthUnitsValueSet {}
/// Nested message and enum types in `BodyLengthUnitsValueSet`.
pub mod body_length_units_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Cm = 1,
        InI = 2,
    }
}
/// UCUM units for recording Body Temperature
/// See <http://hl7.org/fhir/ValueSet/ucum-bodytemp>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BodyTemperatureUnitsValueSet {}
/// Nested message and enum types in `BodyTemperatureUnitsValueSet`.
pub mod body_temperature_units_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Cel = 1,
        DegF = 2,
    }
}
/// UCUM units for recording Body Weight
/// See <http://hl7.org/fhir/ValueSet/ucum-bodyweight>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BodyWeightUnitsValueSet {}
/// Nested message and enum types in `BodyWeightUnitsValueSet`.
pub mod body_weight_units_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Kg = 1,
        LbAv = 2,
        G = 3,
    }
}
/// Resource types defined as part of FHIR that can be represented as in-line
/// definitions of a care plan activity. See
/// <http://hl7.org/fhir/ValueSet/care-plan-activity-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CarePlanActivityKindValueSet {}
/// Nested message and enum types in `CarePlanActivityKindValueSet`.
pub mod care_plan_activity_kind_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Appointment = 1,
        CommunicationRequest = 2,
        DeviceRequest = 3,
        MedicationRequest = 4,
        NutritionOrder = 5,
        Task = 6,
        ServiceRequest = 7,
        VisionPrescription = 8,
    }
}
/// Codes indicating the degree of authority/intentionality associated with a
/// care plan. See <http://hl7.org/fhir/ValueSet/care-plan-intent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CarePlanIntentValueSet {}
/// Nested message and enum types in `CarePlanIntentValueSet`.
pub mod care_plan_intent_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposal = 1,
        Plan = 2,
        Order = 3,
        Option = 4,
    }
}
/// Codes that reflect the current state of a clinical impression within its
/// overall lifecycle. See <http://hl7.org/fhir/ValueSet/clinicalimpression-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ClinicalImpressionStatusValueSet {}
/// Nested message and enum types in `ClinicalImpressionStatusValueSet`.
pub mod clinical_impression_status_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        InProgress = 1,
        Completed = 2,
        EnteredInError = 3,
    }
}
/// A set of codes each of which specifies a certain subcategory of the name part
/// in addition to the main name part type. See
/// <http://hl7.org/fhir/ValueSet/name-part-qualifier>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EntityNamePartQualifierValueSet {}
/// Nested message and enum types in `EntityNamePartQualifierValueSet`.
pub mod entity_name_part_qualifier_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ls = 1,
        Ac = 2,
        Nb = 3,
        Pr = 4,
        Hon = 5,
        Br = 6,
        Ad = 7,
        Sp = 8,
        Mid = 9,
        Cl = 10,
        In = 11,
        Vv = 12,
    }
}
/// Real world event relating to the schedule.
/// See <http://hl7.org/fhir/ValueSet/event-timing>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EventTimingValueSet {}
/// Nested message and enum types in `EventTimingValueSet`.
pub mod event_timing_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Morn = 1,
        MornEarly = 2,
        MornLate = 3,
        Noon = 4,
        Aft = 5,
        AftEarly = 6,
        AftLate = 7,
        Eve = 8,
        EveEarly = 9,
        EveLate = 10,
        Night = 11,
        Phs = 12,
        Hs = 13,
        Wake = 14,
        C = 15,
        Cm = 16,
        Cd = 17,
        Cv = 18,
        Ac = 19,
        Acm = 20,
        Acd = 21,
        Acv = 22,
        Pc = 23,
        Pcm = 24,
        Pcd = 25,
        Pcv = 26,
    }
}
/// A list of all the concrete types defined in this version of the FHIR
/// specification - Abstract Types, Data Types and Resource Types. See
/// <http://hl7.org/fhir/ValueSet/all-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirAllTypesValueSet {}
/// Nested message and enum types in `FHIRAllTypesValueSet`.
pub mod fhir_all_types_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Address = 1,
        Age = 2,
        Annotation = 3,
        Attachment = 4,
        BackboneElement = 5,
        CodeableConcept = 6,
        Coding = 7,
        ContactDetail = 8,
        ContactPoint = 9,
        Contributor = 10,
        Count = 11,
        DataRequirement = 12,
        Distance = 13,
        Dosage = 14,
        Duration = 15,
        Element = 16,
        ElementDefinition = 17,
        Expression = 18,
        Extension = 19,
        HumanName = 20,
        Identifier = 21,
        MarketingStatus = 22,
        Meta = 23,
        Money = 24,
        MoneyQuantity = 25,
        Narrative = 26,
        ParameterDefinition = 27,
        Period = 28,
        Population = 29,
        ProdCharacteristic = 30,
        ProductShelfLife = 31,
        Quantity = 32,
        Range = 33,
        Ratio = 34,
        Reference = 35,
        RelatedArtifact = 36,
        SampledData = 37,
        Signature = 38,
        SimpleQuantity = 39,
        SubstanceAmount = 40,
        Timing = 41,
        TriggerDefinition = 42,
        UsageContext = 43,
        Base64Binary = 44,
        Boolean = 45,
        Canonical = 46,
        Code = 47,
        Date = 48,
        DateTime = 49,
        Decimal = 50,
        Id = 51,
        Instant = 52,
        Integer = 53,
        Markdown = 54,
        Oid = 55,
        PositiveInt = 56,
        String = 57,
        Time = 58,
        UnsignedInt = 59,
        Uri = 60,
        Url = 61,
        Uuid = 62,
        Xhtml = 63,
        Account = 64,
        ActivityDefinition = 65,
        AdverseEvent = 66,
        AllergyIntolerance = 67,
        Appointment = 68,
        AppointmentResponse = 69,
        AuditEvent = 70,
        Basic = 71,
        Binary = 72,
        BiologicallyDerivedProduct = 73,
        BodyStructure = 74,
        Bundle = 75,
        CapabilityStatement = 76,
        CarePlan = 77,
        CareTeam = 78,
        CatalogEntry = 79,
        ChargeItem = 80,
        ChargeItemDefinition = 81,
        Claim = 82,
        ClaimResponse = 83,
        ClinicalImpression = 84,
        CodeSystem = 85,
        Communication = 86,
        CommunicationRequest = 87,
        CompartmentDefinition = 88,
        Composition = 89,
        ConceptMap = 90,
        Condition = 91,
        Consent = 92,
        Contract = 93,
        Coverage = 94,
        CoverageEligibilityRequest = 95,
        CoverageEligibilityResponse = 96,
        DetectedIssue = 97,
        Device = 98,
        DeviceDefinition = 99,
        DeviceMetric = 100,
        DeviceRequest = 101,
        DeviceUseStatement = 102,
        DiagnosticReport = 103,
        DocumentManifest = 104,
        DocumentReference = 105,
        DomainResource = 106,
        EffectEvidenceSynthesis = 107,
        Encounter = 108,
        Endpoint = 109,
        EnrollmentRequest = 110,
        EnrollmentResponse = 111,
        EpisodeOfCare = 112,
        EventDefinition = 113,
        Evidence = 114,
        EvidenceVariable = 115,
        ExampleScenario = 116,
        ExplanationOfBenefit = 117,
        FamilyMemberHistory = 118,
        Flag = 119,
        Goal = 120,
        GraphDefinition = 121,
        Group = 122,
        GuidanceResponse = 123,
        HealthcareService = 124,
        ImagingStudy = 125,
        Immunization = 126,
        ImmunizationEvaluation = 127,
        ImmunizationRecommendation = 128,
        ImplementationGuide = 129,
        InsurancePlan = 130,
        Invoice = 131,
        Library = 132,
        Linkage = 133,
        List = 134,
        Location = 135,
        Measure = 136,
        MeasureReport = 137,
        Media = 138,
        Medication = 139,
        MedicationAdministration = 140,
        MedicationDispense = 141,
        MedicationKnowledge = 142,
        MedicationRequest = 143,
        MedicationStatement = 144,
        MedicinalProduct = 145,
        MedicinalProductAuthorization = 146,
        MedicinalProductContraindication = 147,
        MedicinalProductIndication = 148,
        MedicinalProductIngredient = 149,
        MedicinalProductInteraction = 150,
        MedicinalProductManufactured = 151,
        MedicinalProductPackaged = 152,
        MedicinalProductPharmaceutical = 153,
        MedicinalProductUndesirableEffect = 154,
        MessageDefinition = 155,
        MessageHeader = 156,
        MolecularSequence = 157,
        NamingSystem = 158,
        NutritionOrder = 159,
        Observation = 160,
        ObservationDefinition = 161,
        OperationDefinition = 162,
        OperationOutcome = 163,
        Organization = 164,
        OrganizationAffiliation = 165,
        Parameters = 166,
        Patient = 167,
        PaymentNotice = 168,
        PaymentReconciliation = 169,
        Person = 170,
        PlanDefinition = 171,
        Practitioner = 172,
        PractitionerRole = 173,
        Procedure = 174,
        Provenance = 175,
        Questionnaire = 176,
        QuestionnaireResponse = 177,
        RelatedPerson = 178,
        RequestGroup = 179,
        ResearchDefinition = 180,
        ResearchElementDefinition = 181,
        ResearchStudy = 182,
        ResearchSubject = 183,
        Resource = 184,
        RiskAssessment = 185,
        RiskEvidenceSynthesis = 186,
        Schedule = 187,
        SearchParameter = 188,
        ServiceRequest = 189,
        Slot = 190,
        Specimen = 191,
        SpecimenDefinition = 192,
        StructureDefinition = 193,
        StructureMap = 194,
        Subscription = 195,
        Substance = 196,
        SubstanceNucleicAcid = 197,
        SubstancePolymer = 198,
        SubstanceProtein = 199,
        SubstanceReferenceInformation = 200,
        SubstanceSourceMaterial = 201,
        SubstanceSpecification = 202,
        SupplyDelivery = 203,
        SupplyRequest = 204,
        Task = 205,
        TerminologyCapabilities = 206,
        TestReport = 207,
        TestScript = 208,
        Set = 209,
        VerificationResult = 210,
        VisionPrescription = 211,
        Type = 212,
        Any = 213,
    }
}
/// A list of all the concrete types defined in this version of the FHIR
/// specification - Data Types and Resource Types. See
/// <http://hl7.org/fhir/ValueSet/defined-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirDefinedTypeValueSet {}
/// Nested message and enum types in `FHIRDefinedTypeValueSet`.
pub mod fhir_defined_type_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Address = 1,
        Age = 2,
        Annotation = 3,
        Attachment = 4,
        BackboneElement = 5,
        CodeableConcept = 6,
        Coding = 7,
        ContactDetail = 8,
        ContactPoint = 9,
        Contributor = 10,
        Count = 11,
        DataRequirement = 12,
        Distance = 13,
        Dosage = 14,
        Duration = 15,
        Element = 16,
        ElementDefinition = 17,
        Expression = 18,
        Extension = 19,
        HumanName = 20,
        Identifier = 21,
        MarketingStatus = 22,
        Meta = 23,
        Money = 24,
        MoneyQuantity = 25,
        Narrative = 26,
        ParameterDefinition = 27,
        Period = 28,
        Population = 29,
        ProdCharacteristic = 30,
        ProductShelfLife = 31,
        Quantity = 32,
        Range = 33,
        Ratio = 34,
        Reference = 35,
        RelatedArtifact = 36,
        SampledData = 37,
        Signature = 38,
        SimpleQuantity = 39,
        SubstanceAmount = 40,
        Timing = 41,
        TriggerDefinition = 42,
        UsageContext = 43,
        Base64Binary = 44,
        Boolean = 45,
        Canonical = 46,
        Code = 47,
        Date = 48,
        DateTime = 49,
        Decimal = 50,
        Id = 51,
        Instant = 52,
        Integer = 53,
        Markdown = 54,
        Oid = 55,
        PositiveInt = 56,
        String = 57,
        Time = 58,
        UnsignedInt = 59,
        Uri = 60,
        Url = 61,
        Uuid = 62,
        Xhtml = 63,
        Account = 64,
        ActivityDefinition = 65,
        AdverseEvent = 66,
        AllergyIntolerance = 67,
        Appointment = 68,
        AppointmentResponse = 69,
        AuditEvent = 70,
        Basic = 71,
        Binary = 72,
        BiologicallyDerivedProduct = 73,
        BodyStructure = 74,
        Bundle = 75,
        CapabilityStatement = 76,
        CarePlan = 77,
        CareTeam = 78,
        CatalogEntry = 79,
        ChargeItem = 80,
        ChargeItemDefinition = 81,
        Claim = 82,
        ClaimResponse = 83,
        ClinicalImpression = 84,
        CodeSystem = 85,
        Communication = 86,
        CommunicationRequest = 87,
        CompartmentDefinition = 88,
        Composition = 89,
        ConceptMap = 90,
        Condition = 91,
        Consent = 92,
        Contract = 93,
        Coverage = 94,
        CoverageEligibilityRequest = 95,
        CoverageEligibilityResponse = 96,
        DetectedIssue = 97,
        Device = 98,
        DeviceDefinition = 99,
        DeviceMetric = 100,
        DeviceRequest = 101,
        DeviceUseStatement = 102,
        DiagnosticReport = 103,
        DocumentManifest = 104,
        DocumentReference = 105,
        DomainResource = 106,
        EffectEvidenceSynthesis = 107,
        Encounter = 108,
        Endpoint = 109,
        EnrollmentRequest = 110,
        EnrollmentResponse = 111,
        EpisodeOfCare = 112,
        EventDefinition = 113,
        Evidence = 114,
        EvidenceVariable = 115,
        ExampleScenario = 116,
        ExplanationOfBenefit = 117,
        FamilyMemberHistory = 118,
        Flag = 119,
        Goal = 120,
        GraphDefinition = 121,
        Group = 122,
        GuidanceResponse = 123,
        HealthcareService = 124,
        ImagingStudy = 125,
        Immunization = 126,
        ImmunizationEvaluation = 127,
        ImmunizationRecommendation = 128,
        ImplementationGuide = 129,
        InsurancePlan = 130,
        Invoice = 131,
        Library = 132,
        Linkage = 133,
        List = 134,
        Location = 135,
        Measure = 136,
        MeasureReport = 137,
        Media = 138,
        Medication = 139,
        MedicationAdministration = 140,
        MedicationDispense = 141,
        MedicationKnowledge = 142,
        MedicationRequest = 143,
        MedicationStatement = 144,
        MedicinalProduct = 145,
        MedicinalProductAuthorization = 146,
        MedicinalProductContraindication = 147,
        MedicinalProductIndication = 148,
        MedicinalProductIngredient = 149,
        MedicinalProductInteraction = 150,
        MedicinalProductManufactured = 151,
        MedicinalProductPackaged = 152,
        MedicinalProductPharmaceutical = 153,
        MedicinalProductUndesirableEffect = 154,
        MessageDefinition = 155,
        MessageHeader = 156,
        MolecularSequence = 157,
        NamingSystem = 158,
        NutritionOrder = 159,
        Observation = 160,
        ObservationDefinition = 161,
        OperationDefinition = 162,
        OperationOutcome = 163,
        Organization = 164,
        OrganizationAffiliation = 165,
        Parameters = 166,
        Patient = 167,
        PaymentNotice = 168,
        PaymentReconciliation = 169,
        Person = 170,
        PlanDefinition = 171,
        Practitioner = 172,
        PractitionerRole = 173,
        Procedure = 174,
        Provenance = 175,
        Questionnaire = 176,
        QuestionnaireResponse = 177,
        RelatedPerson = 178,
        RequestGroup = 179,
        ResearchDefinition = 180,
        ResearchElementDefinition = 181,
        ResearchStudy = 182,
        ResearchSubject = 183,
        Resource = 184,
        RiskAssessment = 185,
        RiskEvidenceSynthesis = 186,
        Schedule = 187,
        SearchParameter = 188,
        ServiceRequest = 189,
        Slot = 190,
        Specimen = 191,
        SpecimenDefinition = 192,
        StructureDefinition = 193,
        StructureMap = 194,
        Subscription = 195,
        Substance = 196,
        SubstanceNucleicAcid = 197,
        SubstancePolymer = 198,
        SubstanceProtein = 199,
        SubstanceReferenceInformation = 200,
        SubstanceSourceMaterial = 201,
        SubstanceSpecification = 202,
        SupplyDelivery = 203,
        SupplyRequest = 204,
        Task = 205,
        TerminologyCapabilities = 206,
        TestReport = 207,
        TestScript = 208,
        Set = 209,
        VerificationResult = 210,
        VisionPrescription = 211,
    }
}
/// A code that represents the preferred display order of the components of a
/// human name. See <http://hl7.org/fhir/ValueSet/name-assembly-order>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameAssemblyOrderValueSet {}
/// Nested message and enum types in `HumanNameAssemblyOrderValueSet`.
pub mod human_name_assembly_order_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Nl1 = 1,
        Nl2 = 2,
        Nl3 = 3,
        Nl4 = 4,
        F = 5,
        G = 6,
        Unk = 7,
    }
}
/// The value set to instantiate this attribute should be drawn from a
/// terminologically robust code system that consists of or contains concepts to
/// support describing the current status of the evaluation for vaccine
/// administration event. See
/// <http://hl7.org/fhir/ValueSet/immunization-evaluation-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImmunizationEvaluationStatusCodesValueSet {}
/// Nested message and enum types in `ImmunizationEvaluationStatusCodesValueSet`.
pub mod immunization_evaluation_status_codes_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Completed = 1,
        EnteredInError = 2,
    }
}
/// The value set to instantiate this attribute should be drawn from a
/// terminologically robust code system that consists of or contains concepts to
/// support describing the current status of the administered dose of vaccine.
/// See <http://hl7.org/fhir/ValueSet/immunization-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImmunizationStatusCodesValueSet {}
/// Nested message and enum types in `ImmunizationStatusCodesValueSet`.
pub mod immunization_status_codes_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Completed = 1,
        EnteredInError = 2,
        NotDone = 3,
    }
}
/// LDL Cholesterol codes - measured or calculated
/// See <http://hl7.org/fhir/ValueSet/ldlcholesterol-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LdlCodesValueSet {}
/// Nested message and enum types in `LDLCodesValueSet`.
pub mod ldl_codes_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        LdlCholesterolAssay = 1,
        CholesterolInLdlMassVolumeInSerumOrPlasmaByCalculation = 2,
    }
}
/// A set of codes for each different representation of a name.
/// See <http://hl7.org/fhir/ValueSet/name-v3-representation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NameRepresentationUseValueSet {}
/// Nested message and enum types in `NameRepresentationUseValueSet`.
pub mod name_representation_use_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Abc = 1,
        Ide = 2,
        Syl = 3,
    }
}
/// The value set includes the v3 RoleCode PRN (parent), TWIN (twin) and all of
/// their specializations.  It covers the relationships needed to establish
/// genetic pedigree relationships between family members. See
/// <http://hl7.org/fhir/ValueSet/parent-relationship-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ParentRelationshipCodesValueSet {}
/// Nested message and enum types in `ParentRelationshipCodesValueSet`.
pub mod parent_relationship_codes_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Prn = 1,
        Adoptp = 2,
        Adoptf = 3,
        Adoptm = 4,
        Fth = 5,
        Fthfost = 6,
        Nfth = 7,
        Nfthf = 8,
        Stpfth = 9,
        Mth = 10,
        Gestm = 11,
        Mthfost = 12,
        Nmth = 13,
        Nmthf = 14,
        Stpmth = 15,
        Nprn = 16,
        Prnfost = 17,
        Stpprn = 18,
        Twin = 19,
        Ftwin = 20,
        Itwin = 21,
    }
}
/// Uses of an address not included in Address.use.
/// See <http://hl7.org/fhir/ValueSet/postal-address-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PostalAddressUseValueSet {}
/// Nested message and enum types in `PostalAddressUseValueSet`.
pub mod postal_address_use_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Bad = 1,
        Conf = 2,
        Hp = 3,
        Hv = 4,
        Dir = 5,
        Pub = 6,
        Phys = 7,
        Pst = 8,
    }
}
/// Codes specifying the type of probability distribution.
/// See <http://hl7.org/fhir/ValueSet/probability-distribution-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProbabilityDistributionTypeValueSet {}
/// Nested message and enum types in `ProbabilityDistributionTypeValueSet`.
pub mod probability_distribution_type_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        B = 1,
        E = 2,
        F = 3,
        G = 4,
        Ln = 5,
        N = 6,
        T = 7,
        U = 8,
        X2 = 9,
    }
}
/// Codes describing how the QuestionnaireResponse was populated
/// See <http://hl7.org/fhir/ValueSet/questionnaireresponse-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireResponseModeValueSet {}
/// Nested message and enum types in `QuestionnaireResponseModeValueSet`.
pub mod questionnaire_response_mode_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Electronic = 1,
        Verbal = 2,
        Written = 3,
    }
}
/// The value set includes the v3 RoleCode SIB (sibling) and all of its
/// specializations.  It covers the relationships needed to establish genetic
/// pedigree relationships between family members. See
/// <http://hl7.org/fhir/ValueSet/sibling-relationship-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SiblingRelationshipCodesValueSet {}
/// Nested message and enum types in `SiblingRelationshipCodesValueSet`.
pub mod sibling_relationship_codes_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Sib = 1,
        Bro = 2,
        Hbro = 3,
        Nbro = 4,
        Twinbro = 5,
        Ftwinbro = 6,
        Itwinbro = 7,
        Stpbro = 8,
        Hsib = 9,
        Hsis = 10,
        Nsib = 11,
        Nsis = 12,
        Twinsis = 13,
        Ftwinsis = 14,
        Itwinsis = 15,
        Twin = 16,
        Ftwin = 17,
        Itwin = 18,
        Sis = 19,
        Stpsis = 20,
        Stpsib = 21,
    }
}
/// Operations supported by REST at the system level.
/// See <http://hl7.org/fhir/ValueSet/system-restful-interaction>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SystemRestfulInteractionValueSet {}
/// Nested message and enum types in `SystemRestfulInteractionValueSet`.
pub mod system_restful_interaction_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Transaction = 1,
        Batch = 2,
        SearchSystem = 3,
        HistorySystem = 4,
    }
}
/// Distinguishes whether the task is a proposal, plan or full order.
/// See <http://hl7.org/fhir/ValueSet/task-intent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TaskIntentValueSet {}
/// Nested message and enum types in `TaskIntentValueSet`.
pub mod task_intent_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unknown = 1,
        Proposal = 2,
        Plan = 3,
        Order = 4,
        OriginalOrder = 5,
        ReflexOrder = 6,
        FillerOrder = 7,
        InstanceOrder = 8,
        Option = 9,
    }
}
/// The status indicates the level of maturity of the design and may be used to
/// manage the use of the design. See
/// <http://hl7.org/fhir/ValueSet/template-status-code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TemplateStatusCodeValueSet {}
/// Nested message and enum types in `TemplateStatusCodeValueSet`.
pub mod template_status_code_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Pending = 2,
        Active = 3,
        Review = 4,
        Cancelled = 5,
        Rejected = 6,
        Retired = 7,
        Terminated = 8,
    }
}
/// Operations supported by REST at the type or instance level.
/// See <http://hl7.org/fhir/ValueSet/type-restful-interaction>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TypeRestfulInteractionValueSet {}
/// Nested message and enum types in `TypeRestfulInteractionValueSet`.
pub mod type_restful_interaction_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Read = 1,
        Vread = 2,
        Update = 3,
        Patch = 4,
        Delete = 5,
        HistoryInstance = 6,
        HistoryType = 7,
        Create = 8,
        SearchType = 9,
    }
}
/// A unit of time (units from UCUM).
/// See <http://hl7.org/fhir/ValueSet/units-of-time>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UnitsOfTimeValueSet {}
/// Nested message and enum types in `UnitsOfTimeValueSet`.
pub mod units_of_time_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        S = 1,
        Min = 2,
        H = 3,
        D = 4,
        Wk = 5,
        Mo = 6,
        A = 7,
    }
}
///  Set of codes used to value Act.Confidentiality and Role.Confidentiality
///  attribute in accordance with the definition for concept domain
///  "Confidentiality".
/// See <http://terminology.hl7.org/ValueSet/v3-ConfidentialityClassification>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct V3ConfidentialityClassificationValueSet {}
/// Nested message and enum types in `V3ConfidentialityClassificationValueSet`.
pub mod v3_confidentiality_classification_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        U = 1,
        L = 2,
        M = 3,
        N = 4,
        R = 5,
        V = 6,
    }
}
/// Common UCUM units for recording Vital Signs
/// See <http://hl7.org/fhir/ValueSet/ucum-vitals-common>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct VitalSignsUnitsValueSet {}
/// Nested message and enum types in `VitalSignsUnitsValueSet`.
pub mod vital_signs_units_value_set {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Percent = 1,
        Cm = 2,
        InI = 3,
        Kg = 4,
        G = 5,
        LbAv = 6,
        Cel = 7,
        DegF = 8,
        MmHg = 9,
        PerMin = 10,
        KgM2 = 11,
        M2 = 12,
    }
}
/// Auto-generated from StructureDefinition for base64Binary, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type base64Binary. See
/// <http://hl7.org/fhir/StructureDefinition/base64Binary>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Base64Binary {
    /// Primitive value for base64Binary
    #[prost(bytes = "vec", tag = "1")]
    pub value: prost::alloc::vec::Vec<u8>,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for boolean, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type boolean. See
/// <http://hl7.org/fhir/StructureDefinition/boolean>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Boolean {
    /// Primitive value for boolean
    #[prost(bool, tag = "1")]
    pub value: bool,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for canonical, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type canonical. See
/// <http://hl7.org/fhir/StructureDefinition/canonical>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Canonical {
    /// Primitive value for canonical
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for code, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type code. See
/// <http://hl7.org/fhir/StructureDefinition/code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Code {
    /// Primitive value for code
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for date, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type date. See
/// <http://hl7.org/fhir/StructureDefinition/date>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Date {
    /// Primitive value for date
    #[prost(int64, tag = "1")]
    pub value_us: i64,
    #[prost(string, tag = "2")]
    pub timezone: prost::alloc::string::String,
    #[prost(enumeration = "date::Precision", tag = "3")]
    pub precision: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "4")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "5")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `Date`.
pub mod date {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Precision {
        Unspecified = 0,
        Year = 1,
        Month = 2,
        Day = 3,
    }
}
/// Auto-generated from StructureDefinition for dateTime, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type dateTime. See
/// <http://hl7.org/fhir/StructureDefinition/dateTime>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DateTime {
    /// Primitive value for dateTime
    #[prost(int64, tag = "1")]
    pub value_us: i64,
    #[prost(string, tag = "2")]
    pub timezone: prost::alloc::string::String,
    #[prost(enumeration = "date_time::Precision", tag = "3")]
    pub precision: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "4")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "5")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DateTime`.
pub mod date_time {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Precision {
        Unspecified = 0,
        Year = 1,
        Month = 2,
        Day = 3,
        Second = 4,
        Millisecond = 5,
        Microsecond = 6,
    }
}
/// Auto-generated from StructureDefinition for decimal, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type decimal. See
/// <http://hl7.org/fhir/StructureDefinition/decimal>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Decimal {
    /// Primitive value for decimal
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for id, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type id. See
/// <http://hl7.org/fhir/StructureDefinition/id>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Id {
    /// Primitive value for id
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for instant, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type instant. See
/// <http://hl7.org/fhir/StructureDefinition/instant>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Instant {
    /// Primitive value for instant
    #[prost(int64, tag = "1")]
    pub value_us: i64,
    #[prost(string, tag = "2")]
    pub timezone: prost::alloc::string::String,
    #[prost(enumeration = "instant::Precision", tag = "3")]
    pub precision: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "4")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "5")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `Instant`.
pub mod instant {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Precision {
        Unspecified = 0,
        Second = 1,
        Millisecond = 2,
        Microsecond = 3,
    }
}
/// Auto-generated from StructureDefinition for integer, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type integer. See
/// <http://hl7.org/fhir/StructureDefinition/integer>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Integer {
    /// Primitive value for integer
    #[prost(sint32, tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for markdown, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type markdown. See
/// <http://hl7.org/fhir/StructureDefinition/markdown>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Markdown {
    /// Primitive value for markdown
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for oid, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type oid. See
/// <http://hl7.org/fhir/StructureDefinition/oid>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Oid {
    /// Primitive value for oid
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for positiveInt, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type positiveInt. See
/// <http://hl7.org/fhir/StructureDefinition/positiveInt>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PositiveInt {
    /// Primitive value for positiveInt
    #[prost(uint32, tag = "1")]
    pub value: u32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for string, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type string. See
/// <http://hl7.org/fhir/StructureDefinition/string>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct String {
    /// Primitive value for string
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, boxed, tag = "2")]
    pub id: ::core::option::Option<prost::alloc::boxed::Box<String>>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for time, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type time. See
/// <http://hl7.org/fhir/StructureDefinition/time>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Time {
    /// Primitive value for time
    #[prost(int64, tag = "1")]
    pub value_us: i64,
    #[prost(enumeration = "time::Precision", tag = "2")]
    pub precision: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "3")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "4")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `Time`.
pub mod time {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Precision {
        Unspecified = 0,
        Second = 1,
        Millisecond = 2,
        Microsecond = 3,
    }
}
/// Auto-generated from StructureDefinition for unsignedInt, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type unsignedInt. See
/// <http://hl7.org/fhir/StructureDefinition/unsignedInt>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UnsignedInt {
    /// Primitive value for unsignedInt
    #[prost(uint32, tag = "1")]
    pub value: u32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for uri, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type uri. See
/// <http://hl7.org/fhir/StructureDefinition/uri>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Uri {
    /// Primitive value for uri
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for url, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type url. See
/// <http://hl7.org/fhir/StructureDefinition/url>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Url {
    /// Primitive value for url
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for uuid, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type uuid. See
/// <http://hl7.org/fhir/StructureDefinition/uuid>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Uuid {
    /// Primitive value for uuid
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for xhtml, last updated
/// 2019-11-01T09:29:23.356+11:00. Primitive Type xhtml. See
/// <http://hl7.org/fhir/StructureDefinition/xhtml>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Xhtml {
    /// Actual xhtml
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for Address, last updated
/// 2019-11-01T09:29:23.356+11:00. An address expressed using postal conventions
/// (as opposed to GPS or other location definition formats). See
/// <http://hl7.org/fhir/StructureDefinition/Address>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Address {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub r#use: ::core::option::Option<address::UseCode>,
    #[prost(message, optional, tag = "4")]
    pub r#type: ::core::option::Option<address::TypeCode>,
    /// Text representation of the address
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<String>,
    /// Street name, number, direction & P.O. Box etc.
    #[prost(message, repeated, tag = "6")]
    pub line: prost::alloc::vec::Vec<String>,
    /// Name of city, town etc.
    #[prost(message, optional, tag = "7")]
    pub city: ::core::option::Option<String>,
    /// District name (aka county)
    #[prost(message, optional, tag = "8")]
    pub district: ::core::option::Option<String>,
    /// Sub-unit of country (abbreviations ok)
    #[prost(message, optional, tag = "9")]
    pub state: ::core::option::Option<String>,
    /// Postal code for area
    #[prost(message, optional, tag = "10")]
    pub postal_code: ::core::option::Option<String>,
    /// Country (e.g. can be ISO 3166 2 or 3 letter code)
    #[prost(message, optional, tag = "11")]
    pub country: ::core::option::Option<String>,
    /// Time period when address was/is in use
    #[prost(message, optional, tag = "12")]
    pub period: ::core::option::Option<Period>,
}
/// Nested message and enum types in `Address`.
pub mod address {
    /// home | work | temp | old | billing - purpose of this address
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UseCode {
        #[prost(enumeration = "super::address_use_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// postal | physical | both
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::address_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Age, last updated
/// 2019-11-01T09:29:23.356+11:00. A duration of time during which an organism
/// (or a process) has existed. See <http://hl7.org/fhir/StructureDefinition/Age>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Age {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<age::ComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Nested message and enum types in `Age`.
pub mod age {
    /// < | <= | >= | > - how to understand the value
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ComparatorCode {
        #[prost(enumeration = "super::quantity_comparator_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Annotation, last updated
/// 2019-11-01T09:29:23.356+11:00. Text node with attribution. See
/// <http://hl7.org/fhir/StructureDefinition/Annotation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Annotation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub author: ::core::option::Option<annotation::AuthorX>,
    /// When the annotation was made
    #[prost(message, optional, tag = "4")]
    pub time: ::core::option::Option<DateTime>,
    /// The annotation  - text content (as markdown)
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Markdown>,
}
/// Nested message and enum types in `Annotation`.
pub mod annotation {
    /// Individual responsible for the annotation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AuthorX {
        #[prost(oneof = "author_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<author_x::Choice>,
    }
    /// Nested message and enum types in `AuthorX`.
    pub mod author_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Reference(super::super::Reference),
            #[prost(message, tag = "2")]
            StringValue(super::super::String),
        }
    }
}
/// Auto-generated from StructureDefinition for Attachment, last updated
/// 2019-11-01T09:29:23.356+11:00. Content in a format defined elsewhere. See
/// <http://hl7.org/fhir/StructureDefinition/Attachment>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Attachment {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub content_type: ::core::option::Option<attachment::ContentTypeCode>,
    /// Human language of the content (BCP-47)
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Data inline, base64ed
    #[prost(message, optional, tag = "5")]
    pub data: ::core::option::Option<Base64Binary>,
    /// Uri where the data can be found
    #[prost(message, optional, tag = "6")]
    pub url: ::core::option::Option<Url>,
    /// Number of bytes of content (if url provided)
    #[prost(message, optional, tag = "7")]
    pub size: ::core::option::Option<UnsignedInt>,
    /// Hash of the data (sha-1, base64ed)
    #[prost(message, optional, tag = "8")]
    pub hash: ::core::option::Option<Base64Binary>,
    /// Label to display in place of the data
    #[prost(message, optional, tag = "9")]
    pub title: ::core::option::Option<String>,
    /// Date attachment was first created
    #[prost(message, optional, tag = "10")]
    pub creation: ::core::option::Option<DateTime>,
}
/// Nested message and enum types in `Attachment`.
pub mod attachment {
    /// Mime type of the content, with charset etc.
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ContentTypeCode {
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// This valueset is not enumerable, and so is represented as a string.
        #[prost(string, tag = "4")]
        pub value: prost::alloc::string::String,
    }
}
/// Auto-generated from StructureDefinition for BackboneElement, last updated
/// 2019-11-01T09:29:23.356+11:00. Base for elements defined inside a resource.
/// See <http://hl7.org/fhir/StructureDefinition/BackboneElement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BackboneElement {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored even if unrecognized
    #[prost(message, repeated, tag = "3")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for CodeableConcept, last updated
/// 2019-11-01T09:29:23.356+11:00. Concept - reference to a terminology or just
/// text. See <http://hl7.org/fhir/StructureDefinition/CodeableConcept>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeableConcept {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Code defined by a terminology system
    #[prost(message, repeated, tag = "3")]
    pub coding: prost::alloc::vec::Vec<Coding>,
    /// Plain text representation of the concept
    #[prost(message, optional, tag = "4")]
    pub text: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for Coding, last updated
/// 2019-11-01T09:29:23.356+11:00. A reference to a code defined by a terminology
/// system. See <http://hl7.org/fhir/StructureDefinition/Coding>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Coding {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Identity of the terminology system
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<Uri>,
    /// Version of the system - if relevant
    #[prost(message, optional, tag = "4")]
    pub version: ::core::option::Option<String>,
    /// Symbol in syntax defined by the system
    #[prost(message, optional, tag = "5")]
    pub code: ::core::option::Option<Code>,
    /// Representation defined by the system
    #[prost(message, optional, tag = "6")]
    pub display: ::core::option::Option<String>,
    /// If this coding was chosen directly by the user
    #[prost(message, optional, tag = "7")]
    pub user_selected: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for ContactDetail, last updated
/// 2019-11-01T09:29:23.356+11:00. Contact information. See
/// <http://hl7.org/fhir/StructureDefinition/ContactDetail>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactDetail {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Name of an individual to contact
    #[prost(message, optional, tag = "3")]
    pub name: ::core::option::Option<String>,
    /// Contact details for individual or organization
    #[prost(message, repeated, tag = "4")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
}
/// Auto-generated from StructureDefinition for ContactPoint, last updated
/// 2019-11-01T09:29:23.356+11:00. Details of a Technology mediated contact point
/// (phone, fax, email, etc.). See
/// <http://hl7.org/fhir/StructureDefinition/ContactPoint>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPoint {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<contact_point::SystemCode>,
    /// The actual contact point details
    #[prost(message, optional, tag = "4")]
    pub value: ::core::option::Option<String>,
    #[prost(message, optional, tag = "5")]
    pub r#use: ::core::option::Option<contact_point::UseCode>,
    /// Specify preferred order of use (1 = highest)
    #[prost(message, optional, tag = "6")]
    pub rank: ::core::option::Option<PositiveInt>,
    /// Time period when the contact point was/is in use
    #[prost(message, optional, tag = "7")]
    pub period: ::core::option::Option<Period>,
}
/// Nested message and enum types in `ContactPoint`.
pub mod contact_point {
    /// phone | fax | email | pager | url | sms | other
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SystemCode {
        #[prost(enumeration = "super::contact_point_system_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// home | work | temp | old | mobile - purpose of this contact point
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UseCode {
        #[prost(enumeration = "super::contact_point_use_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Contributor, last updated
/// 2019-11-01T09:29:23.356+11:00. Contributor information. See
/// <http://hl7.org/fhir/StructureDefinition/Contributor>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Contributor {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<contributor::TypeCode>,
    /// Who contributed the content
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<String>,
    /// Contact details of the contributor
    #[prost(message, repeated, tag = "5")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
}
/// Nested message and enum types in `Contributor`.
pub mod contributor {
    /// author | editor | reviewer | endorser
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::contributor_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Count, last updated
/// 2019-11-01T09:29:23.356+11:00. A measured or measurable amount. See
/// <http://hl7.org/fhir/StructureDefinition/Count>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Count {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<count::ComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Nested message and enum types in `Count`.
pub mod count {
    /// < | <= | >= | > - how to understand the value
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ComparatorCode {
        #[prost(enumeration = "super::quantity_comparator_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for DataRequirement, last updated
/// 2019-11-01T09:29:23.356+11:00. Describes a required data item. See
/// <http://hl7.org/fhir/StructureDefinition/DataRequirement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DataRequirement {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<data_requirement::TypeCode>,
    /// The profile of the required data
    #[prost(message, repeated, tag = "4")]
    pub profile: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, optional, tag = "5")]
    pub subject: ::core::option::Option<data_requirement::SubjectX>,
    /// Indicates specific structure elements that are referenced by the knowledge
    /// module
    #[prost(message, repeated, tag = "6")]
    pub must_support: prost::alloc::vec::Vec<String>,
    #[prost(message, repeated, tag = "7")]
    pub code_filter: prost::alloc::vec::Vec<data_requirement::CodeFilter>,
    #[prost(message, repeated, tag = "8")]
    pub date_filter: prost::alloc::vec::Vec<data_requirement::DateFilter>,
    /// Number of results
    #[prost(message, optional, tag = "9")]
    pub limit: ::core::option::Option<PositiveInt>,
    #[prost(message, repeated, tag = "10")]
    pub sort: prost::alloc::vec::Vec<data_requirement::Sort>,
}
/// Nested message and enum types in `DataRequirement`.
pub mod data_requirement {
    /// The type of the required data
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::fhir_all_types_value_set::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SubjectX {
        #[prost(oneof = "subject_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<subject_x::Choice>,
    }
    /// Nested message and enum types in `SubjectX`.
    pub mod subject_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// What codes are expected
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CodeFilter {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// A code-valued attribute to filter on
        #[prost(message, optional, tag = "3")]
        pub path: ::core::option::Option<super::String>,
        /// A coded (token) parameter to search on
        #[prost(message, optional, tag = "4")]
        pub search_param: ::core::option::Option<super::String>,
        /// Valueset for the filter
        #[prost(message, optional, tag = "5")]
        pub value_set: ::core::option::Option<super::Canonical>,
        /// What code is expected
        #[prost(message, repeated, tag = "6")]
        pub code: prost::alloc::vec::Vec<super::Coding>,
    }
    /// What dates/date ranges are expected
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DateFilter {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// A date-valued attribute to filter on
        #[prost(message, optional, tag = "3")]
        pub path: ::core::option::Option<super::String>,
        /// A date valued parameter to search on
        #[prost(message, optional, tag = "4")]
        pub search_param: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<date_filter::ValueX>,
    }
    /// Nested message and enum types in `DateFilter`.
    pub mod date_filter {
        /// The value of the filter, as a Period, DateTime, or Duration value
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(oneof = "value_x::Choice", tags = "1, 2, 3")]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
                #[prost(message, tag = "3")]
                Duration(super::super::super::Duration),
            }
        }
    }
    /// Order of the results
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Sort {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// The name of the attribute to perform the sort
        #[prost(message, optional, tag = "3")]
        pub path: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "4")]
        pub direction: ::core::option::Option<sort::DirectionCode>,
    }
    /// Nested message and enum types in `Sort`.
    pub mod sort {
        /// ascending | descending
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DirectionCode {
            #[prost(enumeration = "super::super::sort_direction_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for Distance, last updated
/// 2019-11-01T09:29:23.356+11:00. A length - a value with a unit that is a
/// physical distance. See <http://hl7.org/fhir/StructureDefinition/Distance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Distance {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<distance::ComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Nested message and enum types in `Distance`.
pub mod distance {
    /// < | <= | >= | > - how to understand the value
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ComparatorCode {
        #[prost(enumeration = "super::quantity_comparator_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Dosage, last updated
/// 2019-11-01T09:29:23.356+11:00. How the medication is/was taken or should be
/// taken. See <http://hl7.org/fhir/StructureDefinition/Dosage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Dosage {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored even if unrecognized
    #[prost(message, repeated, tag = "3")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The order of the dosage instructions
    #[prost(message, optional, tag = "4")]
    pub sequence: ::core::option::Option<Integer>,
    /// Free text dosage instructions e.g. SIG
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<String>,
    /// Supplemental instruction or warnings to the patient - e.g. "with meals",
    /// "may cause drowsiness"
    #[prost(message, repeated, tag = "6")]
    pub additional_instruction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Patient or consumer oriented instructions
    #[prost(message, optional, tag = "7")]
    pub patient_instruction: ::core::option::Option<String>,
    /// When medication should be administered
    #[prost(message, optional, tag = "8")]
    pub timing: ::core::option::Option<Timing>,
    #[prost(message, optional, tag = "9")]
    pub as_needed: ::core::option::Option<dosage::AsNeededX>,
    /// Body site to administer to
    #[prost(message, optional, tag = "10")]
    pub site: ::core::option::Option<CodeableConcept>,
    /// How drug should enter body
    #[prost(message, optional, tag = "11")]
    pub route: ::core::option::Option<CodeableConcept>,
    /// Technique for administering medication
    #[prost(message, optional, tag = "12")]
    pub method: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "13")]
    pub dose_and_rate: prost::alloc::vec::Vec<dosage::DoseAndRate>,
    /// Upper limit on medication per unit of time
    #[prost(message, optional, tag = "14")]
    pub max_dose_per_period: ::core::option::Option<Ratio>,
    /// Upper limit on medication per administration
    #[prost(message, optional, tag = "15")]
    pub max_dose_per_administration: ::core::option::Option<SimpleQuantity>,
    /// Upper limit on medication per lifetime of the patient
    #[prost(message, optional, tag = "16")]
    pub max_dose_per_lifetime: ::core::option::Option<SimpleQuantity>,
}
/// Nested message and enum types in `Dosage`.
pub mod dosage {
    /// Take "as needed" (for x)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AsNeededX {
        #[prost(oneof = "as_needed_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<as_needed_x::Choice>,
    }
    /// Nested message and enum types in `AsNeededX`.
    pub mod as_needed_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// Amount of medication administered
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DoseAndRate {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// The kind of dose or rate specified
        #[prost(message, optional, tag = "3")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "4")]
        pub dose: ::core::option::Option<dose_and_rate::DoseX>,
        #[prost(message, optional, tag = "5")]
        pub rate: ::core::option::Option<dose_and_rate::RateX>,
    }
    /// Nested message and enum types in `DoseAndRate`.
    pub mod dose_and_rate {
        /// Amount of medication per dose
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DoseX {
            #[prost(oneof = "dose_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<dose_x::Choice>,
        }
        /// Nested message and enum types in `DoseX`.
        pub mod dose_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Range(super::super::super::Range),
                #[prost(message, tag = "2")]
                Quantity(super::super::super::SimpleQuantity),
            }
        }
        /// Amount of medication per unit of time
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RateX {
            #[prost(oneof = "rate_x::Choice", tags = "1, 2, 3")]
            pub choice: ::core::option::Option<rate_x::Choice>,
        }
        /// Nested message and enum types in `RateX`.
        pub mod rate_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
                #[prost(message, tag = "3")]
                Quantity(super::super::super::SimpleQuantity),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Duration, last updated
/// 2019-11-01T09:29:23.356+11:00. A length of time. See
/// <http://hl7.org/fhir/StructureDefinition/Duration>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Duration {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<duration::ComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Nested message and enum types in `Duration`.
pub mod duration {
    /// < | <= | >= | > - how to understand the value
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ComparatorCode {
        #[prost(enumeration = "super::quantity_comparator_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for ElementDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. Definition of an element in a resource or
/// extension. See <http://hl7.org/fhir/StructureDefinition/ElementDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinition {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored even if unrecognized
    #[prost(message, repeated, tag = "3")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Path of the element in the hierarchy of elements
    #[prost(message, optional, tag = "4")]
    pub path: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "5")]
    pub representation: prost::alloc::vec::Vec<element_definition::RepresentationCode>,
    /// Name for this particular element (in a set of slices)
    #[prost(message, optional, tag = "6")]
    pub slice_name: ::core::option::Option<String>,
    /// If this slice definition constrains an inherited slice definition (or not)
    #[prost(message, optional, tag = "7")]
    pub slice_is_constraining: ::core::option::Option<Boolean>,
    /// Name for element to display with or prompt for element
    #[prost(message, optional, tag = "8")]
    pub label: ::core::option::Option<String>,
    /// Corresponding codes in terminologies
    #[prost(message, repeated, tag = "9")]
    pub code: prost::alloc::vec::Vec<Coding>,
    #[prost(message, optional, tag = "10")]
    pub slicing: ::core::option::Option<element_definition::Slicing>,
    /// Concise definition for space-constrained presentation
    #[prost(message, optional, tag = "11")]
    pub short: ::core::option::Option<String>,
    /// Full formal definition as narrative text
    #[prost(message, optional, tag = "12")]
    pub definition: ::core::option::Option<Markdown>,
    /// Comments about the use of this element
    #[prost(message, optional, tag = "13")]
    pub comment: ::core::option::Option<Markdown>,
    /// Why this resource has been created
    #[prost(message, optional, tag = "14")]
    pub requirements: ::core::option::Option<Markdown>,
    /// Other names
    #[prost(message, repeated, tag = "15")]
    pub alias: prost::alloc::vec::Vec<String>,
    /// Minimum Cardinality
    #[prost(message, optional, tag = "16")]
    pub min: ::core::option::Option<UnsignedInt>,
    /// Maximum Cardinality (a number or *)
    #[prost(message, optional, tag = "17")]
    pub max: ::core::option::Option<String>,
    #[prost(message, optional, tag = "18")]
    pub base: ::core::option::Option<element_definition::Base>,
    /// Reference to definition of content for the element
    #[prost(message, optional, tag = "19")]
    pub content_reference: ::core::option::Option<Uri>,
    #[prost(message, repeated, tag = "20")]
    pub r#type: prost::alloc::vec::Vec<element_definition::TypeRef>,
    #[prost(message, optional, tag = "21")]
    pub default_value: ::core::option::Option<element_definition::DefaultValueX>,
    /// Implicit meaning when this element is missing
    #[prost(message, optional, tag = "22")]
    pub meaning_when_missing: ::core::option::Option<Markdown>,
    /// What the order of the elements means
    #[prost(message, optional, tag = "23")]
    pub order_meaning: ::core::option::Option<String>,
    #[prost(message, optional, tag = "24")]
    pub fixed: ::core::option::Option<element_definition::FixedX>,
    #[prost(message, optional, tag = "25")]
    pub pattern: ::core::option::Option<element_definition::PatternX>,
    #[prost(message, repeated, tag = "26")]
    pub example: prost::alloc::vec::Vec<element_definition::Example>,
    #[prost(message, optional, tag = "27")]
    pub min_value: ::core::option::Option<element_definition::MinValueX>,
    #[prost(message, optional, tag = "28")]
    pub max_value: ::core::option::Option<element_definition::MaxValueX>,
    /// Max length for strings
    #[prost(message, optional, tag = "29")]
    pub max_length: ::core::option::Option<Integer>,
    /// Reference to invariant about presence
    #[prost(message, repeated, tag = "30")]
    pub condition: prost::alloc::vec::Vec<Id>,
    #[prost(message, repeated, tag = "31")]
    pub constraint: prost::alloc::vec::Vec<element_definition::Constraint>,
    /// If the element must be supported
    #[prost(message, optional, tag = "32")]
    pub must_support: ::core::option::Option<Boolean>,
    /// If this modifies the meaning of other elements
    #[prost(message, optional, tag = "33")]
    pub is_modifier: ::core::option::Option<Boolean>,
    /// Reason that this element is marked as a modifier
    #[prost(message, optional, tag = "34")]
    pub is_modifier_reason: ::core::option::Option<String>,
    /// Include when _summary = true?
    #[prost(message, optional, tag = "35")]
    pub is_summary: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "36")]
    pub binding: ::core::option::Option<element_definition::ElementDefinitionBinding>,
    #[prost(message, repeated, tag = "37")]
    pub mapping: prost::alloc::vec::Vec<element_definition::Mapping>,
}
/// Nested message and enum types in `ElementDefinition`.
pub mod element_definition {
    /// xmlAttr | xmlText | typeAttr | cdaText | xhtml
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RepresentationCode {
        #[prost(enumeration = "super::property_representation_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// This element is sliced - slices follow
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Slicing {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "3")]
        pub discriminator: prost::alloc::vec::Vec<slicing::Discriminator>,
        /// Text description of how slicing works (or not)
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// If elements must be in same order as slices
        #[prost(message, optional, tag = "5")]
        pub ordered: ::core::option::Option<super::Boolean>,
        #[prost(message, optional, tag = "6")]
        pub rules: ::core::option::Option<slicing::RulesCode>,
    }
    /// Nested message and enum types in `Slicing`.
    pub mod slicing {
        /// Element values that are used to distinguish the slices
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Discriminator {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "3")]
            pub r#type: ::core::option::Option<discriminator::TypeCode>,
            /// Path to element value
            #[prost(message, optional, tag = "4")]
            pub path: ::core::option::Option<super::super::String>,
        }
        /// Nested message and enum types in `Discriminator`.
        pub mod discriminator {
            /// value | exists | pattern | type | profile
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct TypeCode {
                #[prost(
                    enumeration = "super::super::super::discriminator_type_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
        /// closed | open | openAtEnd
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RulesCode {
            #[prost(enumeration = "super::super::slicing_rules_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Base definition information for tools
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Base {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Path that identifies the base element
        #[prost(message, optional, tag = "3")]
        pub path: ::core::option::Option<super::String>,
        /// Min cardinality of the base element
        #[prost(message, optional, tag = "4")]
        pub min: ::core::option::Option<super::UnsignedInt>,
        /// Max cardinality of the base element
        #[prost(message, optional, tag = "5")]
        pub max: ::core::option::Option<super::String>,
    }
    /// Data type and Profile for this element
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeRef {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Data type or Resource (reference to definition)
        #[prost(message, optional, tag = "3")]
        pub code: ::core::option::Option<super::Uri>,
        /// Profiles (StructureDefinition or IG) - one must apply
        #[prost(message, repeated, tag = "4")]
        pub profile: prost::alloc::vec::Vec<super::Canonical>,
        /// Profile (StructureDefinition or IG) on the Reference/canonical target -
        /// one must apply
        #[prost(message, repeated, tag = "5")]
        pub target_profile: prost::alloc::vec::Vec<super::Canonical>,
        #[prost(message, repeated, tag = "6")]
        pub aggregation: prost::alloc::vec::Vec<type_ref::AggregationCode>,
        #[prost(message, optional, tag = "7")]
        pub versioning: ::core::option::Option<type_ref::VersioningCode>,
    }
    /// Nested message and enum types in `TypeRef`.
    pub mod type_ref {
        /// contained | referenced | bundled - how aggregated
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AggregationCode {
            #[prost(enumeration = "super::super::aggregation_mode_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// either | independent | specific
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct VersioningCode {
            #[prost(
                enumeration = "super::super::reference_version_rules_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Specified value if missing from instance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DefaultValueX {
        #[prost(
            oneof = "default_value_x::Choice",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50"
        )]
        pub choice: ::core::option::Option<default_value_x::Choice>,
    }
    /// Nested message and enum types in `DefaultValueX`.
    pub mod default_value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Base64Binary(super::super::Base64Binary),
            #[prost(message, tag = "2")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "3")]
            Canonical(super::super::Canonical),
            #[prost(message, tag = "4")]
            Code(super::super::Code),
            #[prost(message, tag = "5")]
            Date(super::super::Date),
            #[prost(message, tag = "6")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "7")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "8")]
            Id(super::super::Id),
            #[prost(message, tag = "9")]
            Instant(super::super::Instant),
            #[prost(message, tag = "10")]
            Integer(super::super::Integer),
            #[prost(message, tag = "11")]
            Markdown(super::super::Markdown),
            #[prost(message, tag = "12")]
            Oid(super::super::Oid),
            #[prost(message, tag = "13")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "14")]
            StringValue(super::super::String),
            #[prost(message, tag = "15")]
            Time(super::super::Time),
            #[prost(message, tag = "16")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "17")]
            Uri(super::super::Uri),
            #[prost(message, tag = "18")]
            Url(super::super::Url),
            #[prost(message, tag = "19")]
            Uuid(super::super::Uuid),
            #[prost(message, tag = "20")]
            Address(super::super::Address),
            #[prost(message, tag = "21")]
            Age(super::super::Age),
            #[prost(message, tag = "22")]
            Annotation(super::super::Annotation),
            #[prost(message, tag = "23")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "24")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "25")]
            Coding(super::super::Coding),
            #[prost(message, tag = "26")]
            ContactPoint(super::super::ContactPoint),
            #[prost(message, tag = "27")]
            Count(super::super::Count),
            #[prost(message, tag = "28")]
            Distance(super::super::Distance),
            #[prost(message, tag = "29")]
            Duration(super::super::Duration),
            #[prost(message, tag = "30")]
            HumanName(super::super::HumanName),
            #[prost(message, tag = "31")]
            Identifier(super::super::Identifier),
            #[prost(message, tag = "32")]
            Money(super::super::Money),
            #[prost(message, tag = "33")]
            Period(super::super::Period),
            #[prost(message, tag = "34")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "35")]
            Range(super::super::Range),
            #[prost(message, tag = "36")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "37")]
            Reference(super::super::Reference),
            #[prost(message, tag = "38")]
            SampledData(super::super::SampledData),
            #[prost(message, tag = "39")]
            Signature(super::super::Signature),
            #[prost(message, tag = "40")]
            Timing(super::super::Timing),
            #[prost(message, tag = "41")]
            ContactDetail(super::super::ContactDetail),
            #[prost(message, tag = "42")]
            Contributor(super::super::Contributor),
            #[prost(message, tag = "43")]
            DataRequirement(super::super::DataRequirement),
            #[prost(message, tag = "44")]
            Expression(super::super::Expression),
            #[prost(message, tag = "45")]
            ParameterDefinition(super::super::ParameterDefinition),
            #[prost(message, tag = "46")]
            RelatedArtifact(super::super::RelatedArtifact),
            #[prost(message, tag = "47")]
            TriggerDefinition(super::super::TriggerDefinition),
            #[prost(message, tag = "48")]
            UsageContext(super::super::UsageContext),
            #[prost(message, tag = "49")]
            Dosage(super::super::Dosage),
            #[prost(message, tag = "50")]
            Meta(super::super::Meta),
        }
    }
    /// Value must be exactly this
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FixedX {
        #[prost(
            oneof = "fixed_x::Choice",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50"
        )]
        pub choice: ::core::option::Option<fixed_x::Choice>,
    }
    /// Nested message and enum types in `FixedX`.
    pub mod fixed_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Base64Binary(super::super::Base64Binary),
            #[prost(message, tag = "2")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "3")]
            Canonical(super::super::Canonical),
            #[prost(message, tag = "4")]
            Code(super::super::Code),
            #[prost(message, tag = "5")]
            Date(super::super::Date),
            #[prost(message, tag = "6")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "7")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "8")]
            Id(super::super::Id),
            #[prost(message, tag = "9")]
            Instant(super::super::Instant),
            #[prost(message, tag = "10")]
            Integer(super::super::Integer),
            #[prost(message, tag = "11")]
            Markdown(super::super::Markdown),
            #[prost(message, tag = "12")]
            Oid(super::super::Oid),
            #[prost(message, tag = "13")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "14")]
            StringValue(super::super::String),
            #[prost(message, tag = "15")]
            Time(super::super::Time),
            #[prost(message, tag = "16")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "17")]
            Uri(super::super::Uri),
            #[prost(message, tag = "18")]
            Url(super::super::Url),
            #[prost(message, tag = "19")]
            Uuid(super::super::Uuid),
            #[prost(message, tag = "20")]
            Address(super::super::Address),
            #[prost(message, tag = "21")]
            Age(super::super::Age),
            #[prost(message, tag = "22")]
            Annotation(super::super::Annotation),
            #[prost(message, tag = "23")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "24")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "25")]
            Coding(super::super::Coding),
            #[prost(message, tag = "26")]
            ContactPoint(super::super::ContactPoint),
            #[prost(message, tag = "27")]
            Count(super::super::Count),
            #[prost(message, tag = "28")]
            Distance(super::super::Distance),
            #[prost(message, tag = "29")]
            Duration(super::super::Duration),
            #[prost(message, tag = "30")]
            HumanName(super::super::HumanName),
            #[prost(message, tag = "31")]
            Identifier(super::super::Identifier),
            #[prost(message, tag = "32")]
            Money(super::super::Money),
            #[prost(message, tag = "33")]
            Period(super::super::Period),
            #[prost(message, tag = "34")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "35")]
            Range(super::super::Range),
            #[prost(message, tag = "36")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "37")]
            Reference(super::super::Reference),
            #[prost(message, tag = "38")]
            SampledData(super::super::SampledData),
            #[prost(message, tag = "39")]
            Signature(super::super::Signature),
            #[prost(message, tag = "40")]
            Timing(super::super::Timing),
            #[prost(message, tag = "41")]
            ContactDetail(super::super::ContactDetail),
            #[prost(message, tag = "42")]
            Contributor(super::super::Contributor),
            #[prost(message, tag = "43")]
            DataRequirement(super::super::DataRequirement),
            #[prost(message, tag = "44")]
            Expression(super::super::Expression),
            #[prost(message, tag = "45")]
            ParameterDefinition(super::super::ParameterDefinition),
            #[prost(message, tag = "46")]
            RelatedArtifact(super::super::RelatedArtifact),
            #[prost(message, tag = "47")]
            TriggerDefinition(super::super::TriggerDefinition),
            #[prost(message, tag = "48")]
            UsageContext(super::super::UsageContext),
            #[prost(message, tag = "49")]
            Dosage(super::super::Dosage),
            #[prost(message, tag = "50")]
            Meta(super::super::Meta),
        }
    }
    /// Value must have at least these property values
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PatternX {
        #[prost(
            oneof = "pattern_x::Choice",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50"
        )]
        pub choice: ::core::option::Option<pattern_x::Choice>,
    }
    /// Nested message and enum types in `PatternX`.
    pub mod pattern_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Base64Binary(super::super::Base64Binary),
            #[prost(message, tag = "2")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "3")]
            Canonical(super::super::Canonical),
            #[prost(message, tag = "4")]
            Code(super::super::Code),
            #[prost(message, tag = "5")]
            Date(super::super::Date),
            #[prost(message, tag = "6")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "7")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "8")]
            Id(super::super::Id),
            #[prost(message, tag = "9")]
            Instant(super::super::Instant),
            #[prost(message, tag = "10")]
            Integer(super::super::Integer),
            #[prost(message, tag = "11")]
            Markdown(super::super::Markdown),
            #[prost(message, tag = "12")]
            Oid(super::super::Oid),
            #[prost(message, tag = "13")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "14")]
            StringValue(super::super::String),
            #[prost(message, tag = "15")]
            Time(super::super::Time),
            #[prost(message, tag = "16")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "17")]
            Uri(super::super::Uri),
            #[prost(message, tag = "18")]
            Url(super::super::Url),
            #[prost(message, tag = "19")]
            Uuid(super::super::Uuid),
            #[prost(message, tag = "20")]
            Address(super::super::Address),
            #[prost(message, tag = "21")]
            Age(super::super::Age),
            #[prost(message, tag = "22")]
            Annotation(super::super::Annotation),
            #[prost(message, tag = "23")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "24")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "25")]
            Coding(super::super::Coding),
            #[prost(message, tag = "26")]
            ContactPoint(super::super::ContactPoint),
            #[prost(message, tag = "27")]
            Count(super::super::Count),
            #[prost(message, tag = "28")]
            Distance(super::super::Distance),
            #[prost(message, tag = "29")]
            Duration(super::super::Duration),
            #[prost(message, tag = "30")]
            HumanName(super::super::HumanName),
            #[prost(message, tag = "31")]
            Identifier(super::super::Identifier),
            #[prost(message, tag = "32")]
            Money(super::super::Money),
            #[prost(message, tag = "33")]
            Period(super::super::Period),
            #[prost(message, tag = "34")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "35")]
            Range(super::super::Range),
            #[prost(message, tag = "36")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "37")]
            Reference(super::super::Reference),
            #[prost(message, tag = "38")]
            SampledData(super::super::SampledData),
            #[prost(message, tag = "39")]
            Signature(super::super::Signature),
            #[prost(message, tag = "40")]
            Timing(super::super::Timing),
            #[prost(message, tag = "41")]
            ContactDetail(super::super::ContactDetail),
            #[prost(message, tag = "42")]
            Contributor(super::super::Contributor),
            #[prost(message, tag = "43")]
            DataRequirement(super::super::DataRequirement),
            #[prost(message, tag = "44")]
            Expression(super::super::Expression),
            #[prost(message, tag = "45")]
            ParameterDefinition(super::super::ParameterDefinition),
            #[prost(message, tag = "46")]
            RelatedArtifact(super::super::RelatedArtifact),
            #[prost(message, tag = "47")]
            TriggerDefinition(super::super::TriggerDefinition),
            #[prost(message, tag = "48")]
            UsageContext(super::super::UsageContext),
            #[prost(message, tag = "49")]
            Dosage(super::super::Dosage),
            #[prost(message, tag = "50")]
            Meta(super::super::Meta),
        }
    }
    /// Example value (as defined for type)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Example {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Describes the purpose of this example
        #[prost(message, optional, tag = "3")]
        pub label: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "4")]
        pub value: ::core::option::Option<example::ValueX>,
    }
    /// Nested message and enum types in `Example`.
    pub mod example {
        /// Value of Example (one of allowed types)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(
                oneof = "value_x::Choice",
                tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50"
            )]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Base64Binary(super::super::super::Base64Binary),
                #[prost(message, tag = "2")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "3")]
                Canonical(super::super::super::Canonical),
                #[prost(message, tag = "4")]
                Code(super::super::super::Code),
                #[prost(message, tag = "5")]
                Date(super::super::super::Date),
                #[prost(message, tag = "6")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "7")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "8")]
                Id(super::super::super::Id),
                #[prost(message, tag = "9")]
                Instant(super::super::super::Instant),
                #[prost(message, tag = "10")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "11")]
                Markdown(super::super::super::Markdown),
                #[prost(message, tag = "12")]
                Oid(super::super::super::Oid),
                #[prost(message, tag = "13")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "14")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "15")]
                Time(super::super::super::Time),
                #[prost(message, tag = "16")]
                UnsignedInt(super::super::super::UnsignedInt),
                #[prost(message, tag = "17")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "18")]
                Url(super::super::super::Url),
                #[prost(message, tag = "19")]
                Uuid(super::super::super::Uuid),
                #[prost(message, tag = "20")]
                Address(super::super::super::Address),
                #[prost(message, tag = "21")]
                Age(super::super::super::Age),
                #[prost(message, tag = "22")]
                Annotation(super::super::super::Annotation),
                #[prost(message, tag = "23")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "24")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "25")]
                Coding(super::super::super::Coding),
                #[prost(message, tag = "26")]
                ContactPoint(super::super::super::ContactPoint),
                #[prost(message, tag = "27")]
                Count(super::super::super::Count),
                #[prost(message, tag = "28")]
                Distance(super::super::super::Distance),
                #[prost(message, tag = "29")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "30")]
                HumanName(super::super::super::HumanName),
                #[prost(message, tag = "31")]
                Identifier(super::super::super::Identifier),
                #[prost(message, tag = "32")]
                Money(super::super::super::Money),
                #[prost(message, tag = "33")]
                Period(super::super::super::Period),
                #[prost(message, tag = "34")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "35")]
                Range(super::super::super::Range),
                #[prost(message, tag = "36")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "37")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "38")]
                SampledData(super::super::super::SampledData),
                #[prost(message, tag = "39")]
                Signature(super::super::super::Signature),
                #[prost(message, tag = "40")]
                Timing(super::super::super::Timing),
                #[prost(message, tag = "41")]
                ContactDetail(super::super::super::ContactDetail),
                #[prost(message, tag = "42")]
                Contributor(super::super::super::Contributor),
                #[prost(message, tag = "43")]
                DataRequirement(super::super::super::DataRequirement),
                #[prost(message, tag = "44")]
                Expression(super::super::super::Expression),
                #[prost(message, tag = "45")]
                ParameterDefinition(super::super::super::ParameterDefinition),
                #[prost(message, tag = "46")]
                RelatedArtifact(super::super::super::RelatedArtifact),
                #[prost(message, tag = "47")]
                TriggerDefinition(super::super::super::TriggerDefinition),
                #[prost(message, tag = "48")]
                UsageContext(super::super::super::UsageContext),
                #[prost(message, tag = "49")]
                Dosage(super::super::super::Dosage),
                #[prost(message, tag = "50")]
                Meta(super::super::super::Meta),
            }
        }
    }
    /// Minimum Allowed Value (for some types)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MinValueX {
        #[prost(oneof = "min_value_x::Choice", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
        pub choice: ::core::option::Option<min_value_x::Choice>,
    }
    /// Nested message and enum types in `MinValueX`.
    pub mod min_value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "3")]
            Instant(super::super::Instant),
            #[prost(message, tag = "4")]
            Time(super::super::Time),
            #[prost(message, tag = "5")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "6")]
            Integer(super::super::Integer),
            #[prost(message, tag = "7")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "8")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "9")]
            Quantity(super::super::Quantity),
        }
    }
    /// Maximum Allowed Value (for some types)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MaxValueX {
        #[prost(oneof = "max_value_x::Choice", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
        pub choice: ::core::option::Option<max_value_x::Choice>,
    }
    /// Nested message and enum types in `MaxValueX`.
    pub mod max_value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "3")]
            Instant(super::super::Instant),
            #[prost(message, tag = "4")]
            Time(super::super::Time),
            #[prost(message, tag = "5")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "6")]
            Integer(super::super::Integer),
            #[prost(message, tag = "7")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "8")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "9")]
            Quantity(super::super::Quantity),
        }
    }
    /// Condition that must evaluate to true
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Constraint {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Target of 'condition' reference above
        #[prost(message, optional, tag = "3")]
        pub key: ::core::option::Option<super::Id>,
        /// Why this constraint is necessary or appropriate
        #[prost(message, optional, tag = "4")]
        pub requirements: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub severity: ::core::option::Option<constraint::SeverityCode>,
        /// Human description of constraint
        #[prost(message, optional, tag = "6")]
        pub human: ::core::option::Option<super::String>,
        /// FHIRPath expression of constraint
        #[prost(message, optional, tag = "7")]
        pub expression: ::core::option::Option<super::String>,
        /// XPath expression of constraint
        #[prost(message, optional, tag = "8")]
        pub xpath: ::core::option::Option<super::String>,
        /// Reference to original source of constraint
        #[prost(message, optional, tag = "9")]
        pub source: ::core::option::Option<super::Canonical>,
    }
    /// Nested message and enum types in `Constraint`.
    pub mod constraint {
        /// error | warning
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SeverityCode {
            #[prost(
                enumeration = "super::super::constraint_severity_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// ValueSet details if this is coded
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ElementDefinitionBinding {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "3")]
        pub strength: ::core::option::Option<element_definition_binding::StrengthCode>,
        /// Human explanation of the value set
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Source of value set
        #[prost(message, optional, tag = "5")]
        pub value_set: ::core::option::Option<super::Canonical>,
    }
    /// Nested message and enum types in `ElementDefinitionBinding`.
    pub mod element_definition_binding {
        /// required | extensible | preferred | example
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct StrengthCode {
            #[prost(enumeration = "super::super::binding_strength_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Map element to another set of definitions
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Mapping {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to mapping declaration
        #[prost(message, optional, tag = "3")]
        pub identity: ::core::option::Option<super::Id>,
        #[prost(message, optional, tag = "4")]
        pub language: ::core::option::Option<mapping::LanguageCode>,
        /// Details of the mapping
        #[prost(message, optional, tag = "5")]
        pub map: ::core::option::Option<super::String>,
        /// Comments about the mapping or its use
        #[prost(message, optional, tag = "6")]
        pub comment: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Mapping`.
    pub mod mapping {
        /// Computable language of mapping
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct LanguageCode {
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// This valueset is not enumerable, and so is represented as a string.
            #[prost(string, tag = "4")]
            pub value: prost::alloc::string::String,
        }
    }
}
/// Auto-generated from StructureDefinition for Expression, last updated
/// 2019-11-01T09:29:23.356+11:00. An expression that can be used to generate a
/// value. See <http://hl7.org/fhir/StructureDefinition/Expression>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Expression {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Natural language description of the condition
    #[prost(message, optional, tag = "3")]
    pub description: ::core::option::Option<String>,
    /// Short name assigned to expression for reuse
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<Id>,
    /// text/cql | text/fhirpath | application/x-fhir-query | etc.
    #[prost(message, optional, tag = "5")]
    pub language: ::core::option::Option<Code>,
    /// Expression in specified language
    #[prost(message, optional, tag = "6")]
    pub expression: ::core::option::Option<String>,
    /// Where the expression is found
    #[prost(message, optional, tag = "7")]
    pub reference: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for HumanName, last updated
/// 2019-11-01T09:29:23.356+11:00. Name of a human - parts and usage. See
/// <http://hl7.org/fhir/StructureDefinition/HumanName>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub r#use: ::core::option::Option<human_name::UseCode>,
    /// Text representation of the full name
    #[prost(message, optional, tag = "4")]
    pub text: ::core::option::Option<String>,
    /// Family name (often called 'Surname')
    #[prost(message, optional, tag = "5")]
    pub family: ::core::option::Option<String>,
    /// Given names (not always 'first'). Includes middle names
    #[prost(message, repeated, tag = "6")]
    pub given: prost::alloc::vec::Vec<String>,
    /// Parts that come before the name
    #[prost(message, repeated, tag = "7")]
    pub prefix: prost::alloc::vec::Vec<String>,
    /// Parts that come after the name
    #[prost(message, repeated, tag = "8")]
    pub suffix: prost::alloc::vec::Vec<String>,
    /// Time period when name was/is in use
    #[prost(message, optional, tag = "9")]
    pub period: ::core::option::Option<Period>,
}
/// Nested message and enum types in `HumanName`.
pub mod human_name {
    /// usual | official | temp | nickname | anonymous | old | maiden
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UseCode {
        #[prost(enumeration = "super::name_use_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Identifier, last updated
/// 2019-11-01T09:29:23.356+11:00. An identifier intended for computation. See
/// <http://hl7.org/fhir/StructureDefinition/Identifier>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Identifier {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub r#use: ::core::option::Option<identifier::UseCode>,
    /// Description of identifier
    #[prost(message, optional, tag = "4")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// The namespace for the identifier value
    #[prost(message, optional, tag = "5")]
    pub system: ::core::option::Option<Uri>,
    /// The value that is unique
    #[prost(message, optional, tag = "6")]
    pub value: ::core::option::Option<String>,
    /// Time period when id is/was valid for use
    #[prost(message, optional, tag = "7")]
    pub period: ::core::option::Option<Period>,
    /// Organization that issued id (may be just text)
    #[prost(message, optional, boxed, tag = "8")]
    pub assigner: ::core::option::Option<prost::alloc::boxed::Box<Reference>>,
}
/// Nested message and enum types in `Identifier`.
pub mod identifier {
    /// usual | official | temp | secondary | old (If known)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UseCode {
        #[prost(enumeration = "super::identifier_use_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for MarketingStatus, last updated
/// 2019-11-01T09:29:23.356+11:00. The marketing status describes the date when a
/// medicinal product is actually put on the market or the date as of which it is
/// no longer available. See
/// <http://hl7.org/fhir/StructureDefinition/MarketingStatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MarketingStatus {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored even if unrecognized
    #[prost(message, repeated, tag = "3")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The country in which the marketing authorisation has been granted shall be
    /// specified It should be specified using the ISO 3166 ‑ 1 alpha-2 code
    /// elements
    #[prost(message, optional, tag = "4")]
    pub country: ::core::option::Option<CodeableConcept>,
    /// Where a Medicines Regulatory Agency has granted a marketing authorisation
    /// for which specific provisions within a jurisdiction apply, the jurisdiction
    /// can be specified using an appropriate controlled terminology The controlled
    /// term and the controlled term identifier shall be specified
    #[prost(message, optional, tag = "5")]
    pub jurisdiction: ::core::option::Option<CodeableConcept>,
    /// This attribute provides information on the status of the marketing of the
    /// medicinal product See ISO/TS 20443 for more information and examples
    #[prost(message, optional, tag = "6")]
    pub status: ::core::option::Option<CodeableConcept>,
    /// The date when the Medicinal Product is placed on the market by the
    /// Marketing Authorisation Holder (or where applicable, the
    /// manufacturer/distributor) in a country and/or jurisdiction shall be
    /// provided A complete date consisting of day, month and year shall be
    /// specified using the ISO 8601 date format NOTE “Placed on the market” refers
    /// to the release of the Medicinal Product into the distribution chain
    #[prost(message, optional, tag = "7")]
    pub date_range: ::core::option::Option<Period>,
    /// The date when the Medicinal Product is placed on the market by the
    /// Marketing Authorisation Holder (or where applicable, the
    /// manufacturer/distributor) in a country and/or jurisdiction shall be
    /// provided A complete date consisting of day, month and year shall be
    /// specified using the ISO 8601 date format NOTE “Placed on the market” refers
    /// to the release of the Medicinal Product into the distribution chain
    #[prost(message, optional, tag = "8")]
    pub restore_date: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for Meta, last updated
/// 2019-11-01T09:29:23.356+11:00. Metadata about a resource. See
/// <http://hl7.org/fhir/StructureDefinition/Meta>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Meta {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Version specific identifier
    #[prost(message, optional, tag = "3")]
    pub version_id: ::core::option::Option<Id>,
    /// When the resource version last changed
    #[prost(message, optional, tag = "4")]
    pub last_updated: ::core::option::Option<Instant>,
    /// Identifies where the resource comes from
    #[prost(message, optional, tag = "5")]
    pub source: ::core::option::Option<Uri>,
    /// Profiles this resource claims to conform to
    #[prost(message, repeated, tag = "6")]
    pub profile: prost::alloc::vec::Vec<Canonical>,
    /// Security Labels applied to this resource
    #[prost(message, repeated, tag = "7")]
    pub security: prost::alloc::vec::Vec<Coding>,
    /// Tags applied to this resource
    #[prost(message, repeated, tag = "8")]
    pub tag: prost::alloc::vec::Vec<Coding>,
}
/// Auto-generated from StructureDefinition for Money, last updated
/// 2019-11-01T09:29:23.356+11:00. An amount of economic utility in some
/// recognized currency. See <http://hl7.org/fhir/StructureDefinition/Money>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Money {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    #[prost(message, optional, tag = "4")]
    pub currency: ::core::option::Option<money::CurrencyCode>,
}
/// Nested message and enum types in `Money`.
pub mod money {
    /// ISO 4217 Currency Code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CurrencyCode {
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// This valueset is not enumerable, and so is represented as a string.
        #[prost(string, tag = "4")]
        pub value: prost::alloc::string::String,
    }
}
/// Auto-generated from StructureDefinition for MoneyQuantity, last updated
/// 2019-11-01T09:29:23.356+11:00. An amount of money. With regard to precision,
/// see [Decimal Precision](datatypes.html#precision). See
/// <http://hl7.org/fhir/StructureDefinition/MoneyQuantity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MoneyQuantity {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<money_quantity::ComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Nested message and enum types in `MoneyQuantity`.
pub mod money_quantity {
    /// < | <= | >= | > - how to understand the value
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ComparatorCode {
        #[prost(enumeration = "super::quantity_comparator_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Narrative, last updated
/// 2019-11-01T09:29:23.356+11:00. Human-readable summary of the resource
/// (essential clinical and business information). See
/// <http://hl7.org/fhir/StructureDefinition/Narrative>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Narrative {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<narrative::StatusCode>,
    /// Limited xhtml content
    #[prost(message, optional, tag = "4")]
    pub div: ::core::option::Option<Xhtml>,
}
/// Nested message and enum types in `Narrative`.
pub mod narrative {
    /// generated | extensions | additional | empty
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::narrative_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for ParameterDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. Definition of a parameter to a module. See
/// <http://hl7.org/fhir/StructureDefinition/ParameterDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ParameterDefinition {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Name used to access the parameter value
    #[prost(message, optional, tag = "3")]
    pub name: ::core::option::Option<Code>,
    #[prost(message, optional, tag = "4")]
    pub r#use: ::core::option::Option<parameter_definition::UseCode>,
    /// Minimum cardinality
    #[prost(message, optional, tag = "5")]
    pub min: ::core::option::Option<Integer>,
    /// Maximum cardinality (a number of *)
    #[prost(message, optional, tag = "6")]
    pub max: ::core::option::Option<String>,
    /// A brief description of the parameter
    #[prost(message, optional, tag = "7")]
    pub documentation: ::core::option::Option<String>,
    #[prost(message, optional, tag = "8")]
    pub r#type: ::core::option::Option<parameter_definition::TypeCode>,
    /// What profile the value is expected to be
    #[prost(message, optional, tag = "9")]
    pub profile: ::core::option::Option<Canonical>,
}
/// Nested message and enum types in `ParameterDefinition`.
pub mod parameter_definition {
    /// in | out
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UseCode {
        #[prost(enumeration = "super::operation_parameter_use_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// What type of value
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::fhir_all_types_value_set::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Period, last updated
/// 2019-11-01T09:29:23.356+11:00. Time range defined by start and end date/time.
/// See <http://hl7.org/fhir/StructureDefinition/Period>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Period {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Starting time with inclusive boundary
    #[prost(message, optional, tag = "3")]
    pub start: ::core::option::Option<DateTime>,
    /// End time with inclusive boundary, if not ongoing
    #[prost(message, optional, tag = "4")]
    pub end: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for Population, last updated
/// 2019-11-01T09:29:23.356+11:00. A definition of a set of people that apply to
/// some clinically related context, for example people contraindicated for a
/// certain medication. See <http://hl7.org/fhir/StructureDefinition/Population>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Population {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored even if unrecognized
    #[prost(message, repeated, tag = "3")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "4")]
    pub age: ::core::option::Option<population::AgeX>,
    /// The gender of the specific population
    #[prost(message, optional, tag = "5")]
    pub gender: ::core::option::Option<CodeableConcept>,
    /// Race of the specific population
    #[prost(message, optional, tag = "6")]
    pub race: ::core::option::Option<CodeableConcept>,
    /// The existing physiological conditions of the specific population to which
    /// this applies
    #[prost(message, optional, tag = "7")]
    pub physiological_condition: ::core::option::Option<CodeableConcept>,
}
/// Nested message and enum types in `Population`.
pub mod population {
    /// The age of the specific population
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AgeX {
        #[prost(oneof = "age_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<age_x::Choice>,
    }
    /// Nested message and enum types in `AgeX`.
    pub mod age_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Range(super::super::Range),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
}
/// Auto-generated from StructureDefinition for ProdCharacteristic, last updated
/// 2019-11-01T09:29:23.356+11:00. The marketing status describes the date when a
/// medicinal product is actually put on the market or the date as of which it is
/// no longer available. See
/// <http://hl7.org/fhir/StructureDefinition/ProdCharacteristic>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProdCharacteristic {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored even if unrecognized
    #[prost(message, repeated, tag = "3")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Where applicable, the height can be specified using a numerical value and
    /// its unit of measurement The unit of measurement shall be specified in
    /// accordance with ISO 11240 and the resulting terminology The symbol and the
    /// symbol identifier shall be used
    #[prost(message, optional, tag = "4")]
    pub height: ::core::option::Option<Quantity>,
    /// Where applicable, the width can be specified using a numerical value and
    /// its unit of measurement The unit of measurement shall be specified in
    /// accordance with ISO 11240 and the resulting terminology The symbol and the
    /// symbol identifier shall be used
    #[prost(message, optional, tag = "5")]
    pub width: ::core::option::Option<Quantity>,
    /// Where applicable, the depth can be specified using a numerical value and
    /// its unit of measurement The unit of measurement shall be specified in
    /// accordance with ISO 11240 and the resulting terminology The symbol and the
    /// symbol identifier shall be used
    #[prost(message, optional, tag = "6")]
    pub depth: ::core::option::Option<Quantity>,
    /// Where applicable, the weight can be specified using a numerical value and
    /// its unit of measurement The unit of measurement shall be specified in
    /// accordance with ISO 11240 and the resulting terminology The symbol and the
    /// symbol identifier shall be used
    #[prost(message, optional, tag = "7")]
    pub weight: ::core::option::Option<Quantity>,
    /// Where applicable, the nominal volume can be specified using a numerical
    /// value and its unit of measurement The unit of measurement shall be
    /// specified in accordance with ISO 11240 and the resulting terminology The
    /// symbol and the symbol identifier shall be used
    #[prost(message, optional, tag = "8")]
    pub nominal_volume: ::core::option::Option<Quantity>,
    /// Where applicable, the external diameter can be specified using a numerical
    /// value and its unit of measurement The unit of measurement shall be
    /// specified in accordance with ISO 11240 and the resulting terminology The
    /// symbol and the symbol identifier shall be used
    #[prost(message, optional, tag = "9")]
    pub external_diameter: ::core::option::Option<Quantity>,
    /// Where applicable, the shape can be specified An appropriate controlled
    /// vocabulary shall be used The term and the term identifier shall be used
    #[prost(message, optional, tag = "10")]
    pub shape: ::core::option::Option<String>,
    /// Where applicable, the color can be specified An appropriate controlled
    /// vocabulary shall be used The term and the term identifier shall be used
    #[prost(message, repeated, tag = "11")]
    pub color: prost::alloc::vec::Vec<String>,
    /// Where applicable, the imprint can be specified as text
    #[prost(message, repeated, tag = "12")]
    pub imprint: prost::alloc::vec::Vec<String>,
    /// Where applicable, the image can be provided The format of the image
    /// attachment shall be specified by regional implementations
    #[prost(message, repeated, tag = "13")]
    pub image: prost::alloc::vec::Vec<Attachment>,
    /// Where applicable, the scoring can be specified An appropriate controlled
    /// vocabulary shall be used The term and the term identifier shall be used
    #[prost(message, optional, tag = "14")]
    pub scoring: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for ProductShelfLife, last updated
/// 2019-11-01T09:29:23.356+11:00. The shelf-life and storage information for a
/// medicinal product item or container can be described using this class. See
/// <http://hl7.org/fhir/StructureDefinition/ProductShelfLife>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProductShelfLife {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored even if unrecognized
    #[prost(message, repeated, tag = "3")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier for the packaged Medicinal Product
    #[prost(message, optional, tag = "4")]
    pub identifier: ::core::option::Option<Identifier>,
    /// This describes the shelf life, taking into account various scenarios such
    /// as shelf life of the packaged Medicinal Product itself, shelf life after
    /// transformation where necessary and shelf life after the first opening of a
    /// bottle, etc. The shelf life type shall be specified using an appropriate
    /// controlled vocabulary The controlled term and the controlled term
    /// identifier shall be specified
    #[prost(message, optional, tag = "5")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// The shelf life time period can be specified using a numerical value for the
    /// period of time and its unit of time measurement The unit of measurement
    /// shall be specified in accordance with ISO 11240 and the resulting
    /// terminology The symbol and the symbol identifier shall be used
    #[prost(message, optional, tag = "6")]
    pub period: ::core::option::Option<Quantity>,
    /// Special precautions for storage, if any, can be specified using an
    /// appropriate controlled vocabulary The controlled term and the controlled
    /// term identifier shall be specified
    #[prost(message, repeated, tag = "7")]
    pub special_precautions_for_storage: prost::alloc::vec::Vec<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for Quantity, last updated
/// 2019-11-01T09:29:23.356+11:00. A measured or measurable amount. See
/// <http://hl7.org/fhir/StructureDefinition/Quantity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Quantity {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<quantity::ComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Nested message and enum types in `Quantity`.
pub mod quantity {
    /// < | <= | >= | > - how to understand the value
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ComparatorCode {
        #[prost(enumeration = "super::quantity_comparator_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Range, last updated
/// 2019-11-01T09:29:23.356+11:00. Set of values bounded by low and high. See
/// <http://hl7.org/fhir/StructureDefinition/Range>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Range {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Low limit
    #[prost(message, optional, tag = "3")]
    pub low: ::core::option::Option<SimpleQuantity>,
    /// High limit
    #[prost(message, optional, tag = "4")]
    pub high: ::core::option::Option<SimpleQuantity>,
}
/// Auto-generated from StructureDefinition for Ratio, last updated
/// 2019-11-01T09:29:23.356+11:00. A ratio of two Quantity values - a numerator
/// and a denominator. See <http://hl7.org/fhir/StructureDefinition/Ratio>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Ratio {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerator value
    #[prost(message, optional, tag = "3")]
    pub numerator: ::core::option::Option<Quantity>,
    /// Denominator value
    #[prost(message, optional, tag = "4")]
    pub denominator: ::core::option::Option<Quantity>,
}
/// Auto-generated from StructureDefinition for RelatedArtifact, last updated
/// 2019-11-01T09:29:23.356+11:00. Related artifacts for a knowledge resource.
/// See <http://hl7.org/fhir/StructureDefinition/RelatedArtifact>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RelatedArtifact {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<related_artifact::TypeCode>,
    /// Short label
    #[prost(message, optional, tag = "4")]
    pub label: ::core::option::Option<String>,
    /// Brief description of the related artifact
    #[prost(message, optional, tag = "5")]
    pub display: ::core::option::Option<String>,
    /// Bibliographic citation for the artifact
    #[prost(message, optional, tag = "6")]
    pub citation: ::core::option::Option<Markdown>,
    /// Where the artifact can be accessed
    #[prost(message, optional, tag = "7")]
    pub url: ::core::option::Option<Url>,
    /// What document is being referenced
    #[prost(message, optional, tag = "8")]
    pub document: ::core::option::Option<Attachment>,
    /// What resource is being referenced
    #[prost(message, optional, tag = "9")]
    pub resource: ::core::option::Option<Canonical>,
}
/// Nested message and enum types in `RelatedArtifact`.
pub mod related_artifact {
    /// documentation | justification | citation | predecessor | successor |
    /// derived-from | depends-on | composed-of
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::related_artifact_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for SampledData, last updated
/// 2019-11-01T09:29:23.356+11:00. A series of measurements taken by a device.
/// See <http://hl7.org/fhir/StructureDefinition/SampledData>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SampledData {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Zero value and units
    #[prost(message, optional, tag = "3")]
    pub origin: ::core::option::Option<SimpleQuantity>,
    /// Number of milliseconds between samples
    #[prost(message, optional, tag = "4")]
    pub period: ::core::option::Option<Decimal>,
    /// Multiply data by this before adding to origin
    #[prost(message, optional, tag = "5")]
    pub factor: ::core::option::Option<Decimal>,
    /// Lower limit of detection
    #[prost(message, optional, tag = "6")]
    pub lower_limit: ::core::option::Option<Decimal>,
    /// Upper limit of detection
    #[prost(message, optional, tag = "7")]
    pub upper_limit: ::core::option::Option<Decimal>,
    /// Number of sample points at each time point
    #[prost(message, optional, tag = "8")]
    pub dimensions: ::core::option::Option<PositiveInt>,
    /// Decimal values with spaces, or "E" | "U" | "L"
    #[prost(message, optional, tag = "9")]
    pub data: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for Signature, last updated
/// 2019-11-01T09:29:23.356+11:00. A Signature - XML DigSig, JWS, Graphical image
/// of signature, etc. See <http://hl7.org/fhir/StructureDefinition/Signature>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Signature {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Indication of the reason the entity signed the object(s)
    #[prost(message, repeated, tag = "3")]
    pub r#type: prost::alloc::vec::Vec<Coding>,
    /// When the signature was created
    #[prost(message, optional, tag = "4")]
    pub when: ::core::option::Option<Instant>,
    /// Who signed
    #[prost(message, optional, tag = "5")]
    pub who: ::core::option::Option<Reference>,
    /// The party represented
    #[prost(message, optional, tag = "6")]
    pub on_behalf_of: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "7")]
    pub target_format: ::core::option::Option<signature::TargetFormatCode>,
    #[prost(message, optional, tag = "8")]
    pub sig_format: ::core::option::Option<signature::SigFormatCode>,
    /// The actual signature content (XML DigSig. JWS, picture, etc.)
    #[prost(message, optional, tag = "9")]
    pub data: ::core::option::Option<Base64Binary>,
}
/// Nested message and enum types in `Signature`.
pub mod signature {
    /// The technical format of the signed resources
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TargetFormatCode {
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// This valueset is not enumerable, and so is represented as a string.
        #[prost(string, tag = "4")]
        pub value: prost::alloc::string::String,
    }
    /// The technical format of the signature
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SigFormatCode {
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// This valueset is not enumerable, and so is represented as a string.
        #[prost(string, tag = "4")]
        pub value: prost::alloc::string::String,
    }
}
/// Auto-generated from StructureDefinition for SimpleQuantity, last updated
/// 2019-11-01T09:29:23.356+11:00. A fixed quantity (no comparator). See
/// <http://hl7.org/fhir/StructureDefinition/SimpleQuantity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SimpleQuantity {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Auto-generated from StructureDefinition for SubstanceAmount, last updated
/// 2019-11-01T09:29:23.356+11:00. Chemical substances are a single substance
/// type whose primary defining element is the molecular structure. Chemical
/// substances shall be defined on the basis of their complete covalent molecular
/// structure; the presence of a salt (counter-ion) and/or solvates (water,
/// alcohols) is also captured. Purity, grade, physical form or particle size are
/// not taken into account in the definition of a chemical substance or in the
/// assignment of a Substance ID. See
/// <http://hl7.org/fhir/StructureDefinition/SubstanceAmount>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubstanceAmount {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored even if unrecognized
    #[prost(message, repeated, tag = "3")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "4")]
    pub amount: ::core::option::Option<substance_amount::AmountX>,
    /// Most elements that require a quantitative value will also have a field
    /// called amount type. Amount type should always be specified because the
    /// actual value of the amount is often dependent on it. EXAMPLE: In capturing
    /// the actual relative amounts of substances or molecular fragments it is
    /// essential to indicate whether the amount refers to a mole ratio or weight
    /// ratio. For any given element an effort should be made to use same the
    /// amount type for all related definitional elements
    #[prost(message, optional, tag = "5")]
    pub amount_type: ::core::option::Option<CodeableConcept>,
    /// A textual comment on a numeric value
    #[prost(message, optional, tag = "6")]
    pub amount_text: ::core::option::Option<String>,
    #[prost(message, optional, tag = "7")]
    pub reference_range: ::core::option::Option<substance_amount::ReferenceRange>,
}
/// Nested message and enum types in `SubstanceAmount`.
pub mod substance_amount {
    /// Used to capture quantitative values for a variety of elements. If only
    /// limits are given, the arithmetic mean would be the average. If only a
    /// single definite value for a given element is given, it would be captured in
    /// this field
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AmountX {
        #[prost(oneof = "amount_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<amount_x::Choice>,
    }
    /// Nested message and enum types in `AmountX`.
    pub mod amount_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "2")]
            Range(super::super::Range),
            #[prost(message, tag = "3")]
            StringValue(super::super::String),
        }
    }
    /// Reference range of possible or expected values
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ReferenceRange {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Lower limit possible or expected
        #[prost(message, optional, tag = "3")]
        pub low_limit: ::core::option::Option<super::Quantity>,
        /// Upper limit possible or expected
        #[prost(message, optional, tag = "4")]
        pub high_limit: ::core::option::Option<super::Quantity>,
    }
}
/// Auto-generated from StructureDefinition for Timing, last updated
/// 2019-11-01T09:29:23.356+11:00. A timing schedule that specifies an event that
/// may occur multiple times. See <http://hl7.org/fhir/StructureDefinition/Timing>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Timing {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored even if unrecognized
    #[prost(message, repeated, tag = "3")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// When the event occurs
    #[prost(message, repeated, tag = "4")]
    pub event: prost::alloc::vec::Vec<DateTime>,
    #[prost(message, optional, tag = "5")]
    pub repeat: ::core::option::Option<timing::Repeat>,
    /// BID | TID | QID | AM | PM | QD | QOD | +
    #[prost(message, optional, tag = "6")]
    pub code: ::core::option::Option<CodeableConcept>,
}
/// Nested message and enum types in `Timing`.
pub mod timing {
    /// When the event is to occur
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Repeat {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "3")]
        pub bounds: ::core::option::Option<repeat::BoundsX>,
        /// Number of times to repeat
        #[prost(message, optional, tag = "4")]
        pub count: ::core::option::Option<super::PositiveInt>,
        /// Maximum number of times to repeat
        #[prost(message, optional, tag = "5")]
        pub count_max: ::core::option::Option<super::PositiveInt>,
        /// How long when it happens
        #[prost(message, optional, tag = "6")]
        pub duration: ::core::option::Option<super::Decimal>,
        /// How long when it happens (Max)
        #[prost(message, optional, tag = "7")]
        pub duration_max: ::core::option::Option<super::Decimal>,
        #[prost(message, optional, tag = "8")]
        pub duration_unit: ::core::option::Option<repeat::DurationUnitCode>,
        /// Event occurs frequency times per period
        #[prost(message, optional, tag = "9")]
        pub frequency: ::core::option::Option<super::PositiveInt>,
        /// Event occurs up to frequencyMax times per period
        #[prost(message, optional, tag = "10")]
        pub frequency_max: ::core::option::Option<super::PositiveInt>,
        /// Event occurs frequency times per period
        #[prost(message, optional, tag = "11")]
        pub period: ::core::option::Option<super::Decimal>,
        /// Upper limit of period (3-4 hours)
        #[prost(message, optional, tag = "12")]
        pub period_max: ::core::option::Option<super::Decimal>,
        #[prost(message, optional, tag = "13")]
        pub period_unit: ::core::option::Option<repeat::PeriodUnitCode>,
        #[prost(message, repeated, tag = "14")]
        pub day_of_week: prost::alloc::vec::Vec<repeat::DayOfWeekCode>,
        /// Time of day for action
        #[prost(message, repeated, tag = "15")]
        pub time_of_day: prost::alloc::vec::Vec<super::Time>,
        #[prost(message, repeated, tag = "16")]
        pub when: prost::alloc::vec::Vec<repeat::WhenCode>,
        /// Minutes from event (before or after)
        #[prost(message, optional, tag = "17")]
        pub offset: ::core::option::Option<super::UnsignedInt>,
    }
    /// Nested message and enum types in `Repeat`.
    pub mod repeat {
        /// Length/Range of lengths, or (Start and/or end) limits
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct BoundsX {
            #[prost(oneof = "bounds_x::Choice", tags = "1, 2, 3")]
            pub choice: ::core::option::Option<bounds_x::Choice>,
        }
        /// Nested message and enum types in `BoundsX`.
        pub mod bounds_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
                #[prost(message, tag = "3")]
                Period(super::super::super::Period),
            }
        }
        /// s | min | h | d | wk | mo | a - unit of time (UCUM)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DurationUnitCode {
            #[prost(
                enumeration = "super::super::units_of_time_value_set::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// s | min | h | d | wk | mo | a - unit of time (UCUM)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PeriodUnitCode {
            #[prost(
                enumeration = "super::super::units_of_time_value_set::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// mon | tue | wed | thu | fri | sat | sun
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DayOfWeekCode {
            #[prost(enumeration = "super::super::days_of_week_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Code for time period of occurrence
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct WhenCode {
            #[prost(enumeration = "super::super::event_timing_value_set::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for TriggerDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. Defines an expected trigger for a module. See
/// <http://hl7.org/fhir/StructureDefinition/TriggerDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TriggerDefinition {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<trigger_definition::TypeCode>,
    /// Name or URI that identifies the event
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<String>,
    #[prost(message, optional, tag = "5")]
    pub timing: ::core::option::Option<trigger_definition::TimingX>,
    /// Triggering data of the event (multiple = 'and')
    #[prost(message, repeated, tag = "6")]
    pub data: prost::alloc::vec::Vec<DataRequirement>,
    /// Whether the event triggers (boolean expression)
    #[prost(message, optional, tag = "7")]
    pub condition: ::core::option::Option<Expression>,
}
/// Nested message and enum types in `TriggerDefinition`.
pub mod trigger_definition {
    /// named-event | periodic | data-changed | data-added | data-modified |
    /// data-removed | data-accessed | data-access-ended
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::trigger_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Timing of the event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TimingX {
        #[prost(oneof = "timing_x::Choice", tags = "1, 2, 3, 4")]
        pub choice: ::core::option::Option<timing_x::Choice>,
    }
    /// Nested message and enum types in `TimingX`.
    pub mod timing_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Timing(super::super::Timing),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
            #[prost(message, tag = "3")]
            Date(super::super::Date),
            #[prost(message, tag = "4")]
            DateTime(super::super::DateTime),
        }
    }
}
/// Auto-generated from StructureDefinition for UsageContext, last updated
/// 2019-11-01T09:29:23.356+11:00. Describes the context of use for a conformance
/// or knowledge resource. See
/// <http://hl7.org/fhir/StructureDefinition/UsageContext>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UsageContext {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Type of context being specified
    #[prost(message, optional, tag = "3")]
    pub code: ::core::option::Option<Coding>,
    #[prost(message, optional, tag = "4")]
    pub value: ::core::option::Option<usage_context::ValueX>,
}
/// Nested message and enum types in `UsageContext`.
pub mod usage_context {
    /// Value that defines the context
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "3")]
            Range(super::super::Range),
            #[prost(message, tag = "4")]
            Reference(super::super::Reference),
        }
    }
}
// End of auto-generated messages.

/// Base for all elements. See <http://hl7.org/fhir/StructureDefinition/Element>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Element {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Optional Extensions Element. See
/// <http://hl7.org/fhir/StructureDefinition/Extension>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Extension {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// identifies the meaning of the extension
    #[prost(message, optional, tag = "2")]
    pub url: ::core::option::Option<Uri>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "4")]
    pub value: ::core::option::Option<extension::ValueX>,
}
/// Nested message and enum types in `Extension`.
pub mod extension {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(
            oneof = "value_x::Choice",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49"
        )]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Base64Binary(super::super::Base64Binary),
            #[prost(message, tag = "2")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "3")]
            Canonical(super::super::Canonical),
            #[prost(message, tag = "4")]
            Code(super::super::Code),
            #[prost(message, tag = "5")]
            Date(super::super::Date),
            #[prost(message, tag = "6")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "7")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "8")]
            Id(super::super::Id),
            #[prost(message, tag = "9")]
            Instant(super::super::Instant),
            #[prost(message, tag = "10")]
            Integer(super::super::Integer),
            #[prost(message, tag = "11")]
            Markdown(super::super::Markdown),
            #[prost(message, tag = "12")]
            Oid(super::super::Oid),
            #[prost(message, tag = "13")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "14")]
            StringValue(super::super::String),
            #[prost(message, tag = "15")]
            Time(super::super::Time),
            #[prost(message, tag = "16")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "17")]
            Uri(super::super::Uri),
            #[prost(message, tag = "18")]
            Url(super::super::Url),
            #[prost(message, tag = "19")]
            Uuid(super::super::Uuid),
            #[prost(message, tag = "20")]
            Address(super::super::Address),
            #[prost(message, tag = "21")]
            Age(super::super::Age),
            #[prost(message, tag = "22")]
            Annotation(super::super::Annotation),
            #[prost(message, tag = "23")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "24")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "25")]
            Coding(super::super::Coding),
            #[prost(message, tag = "26")]
            ContactPoint(super::super::ContactPoint),
            #[prost(message, tag = "27")]
            Count(super::super::Count),
            #[prost(message, tag = "28")]
            Distance(super::super::Distance),
            #[prost(message, tag = "29")]
            Duration(super::super::Duration),
            #[prost(message, tag = "30")]
            HumanName(super::super::HumanName),
            #[prost(message, tag = "31")]
            Identifier(super::super::Identifier),
            #[prost(message, tag = "32")]
            Money(super::super::Money),
            #[prost(message, tag = "33")]
            Period(super::super::Period),
            #[prost(message, tag = "34")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "35")]
            Range(super::super::Range),
            #[prost(message, tag = "36")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "37")]
            Reference(super::super::Reference),
            #[prost(message, tag = "38")]
            SampledData(super::super::SampledData),
            #[prost(message, tag = "39")]
            Signature(super::super::Signature),
            #[prost(message, tag = "40")]
            Timing(super::super::Timing),
            #[prost(message, tag = "41")]
            ContactDetail(super::super::ContactDetail),
            #[prost(message, tag = "42")]
            Contributor(super::super::Contributor),
            #[prost(message, tag = "43")]
            DataRequirement(super::super::DataRequirement),
            #[prost(message, tag = "44")]
            Expression(super::super::Expression),
            #[prost(message, tag = "45")]
            ParameterDefinition(super::super::ParameterDefinition),
            #[prost(message, tag = "46")]
            RelatedArtifact(super::super::RelatedArtifact),
            #[prost(message, tag = "47")]
            TriggerDefinition(super::super::TriggerDefinition),
            #[prost(message, tag = "48")]
            UsageContext(super::super::UsageContext),
            #[prost(message, tag = "49")]
            Dosage(super::super::Dosage),
        }
    }
}
/// Specialization of Coding that drops the system and code fields.
/// Fields that use this message must be annotated with
/// fhir_inlined_coding_system and fhir_inlined_coding_code.
/// TODO: autogenerate this.
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodingWithFixedCode {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Version of the system - if relevant
    #[prost(message, optional, tag = "4")]
    pub version: ::core::option::Option<String>,
    /// Representation defined by the system
    #[prost(message, optional, tag = "6")]
    pub display: ::core::option::Option<String>,
    /// If this coding was chosen directly by the user
    #[prost(message, optional, tag = "7")]
    pub user_selected: ::core::option::Option<Boolean>,
}
/// TODO: autogenerate this.
/// A reference from one resource to another
/// See <https://www.hl7.org/fhir/datatypes.html#Reference>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Reference {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<Uri>,
    /// Logical reference, when literal reference is not known
    #[prost(message, optional, boxed, tag = "155")]
    pub identifier: ::core::option::Option<prost::alloc::boxed::Box<Identifier>>,
    /// Text alternative for the resource
    #[prost(message, optional, tag = "156")]
    pub display: ::core::option::Option<String>,
    /// Literal reference, Relative, internal or absolute URL
    #[prost(
        oneof = "reference::Reference",
        tags = "4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154"
    )]
    pub reference: ::core::option::Option<reference::Reference>,
}
/// Nested message and enum types in `Reference`.
pub mod reference {
    /// Literal reference, Relative, internal or absolute URL
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Oneof)]
    pub enum Reference {
        /// Absolute URIs are untyped.
        #[prost(message, tag = "4")]
        Uri(super::String),
        /// Fragments (internal references) are untyped, and represented here
        /// without the leading '#'.
        #[prost(message, tag = "5")]
        Fragment(super::String),
        /// Typed relative urls are represented here.
        #[prost(message, tag = "6")]
        ResourceId(super::ReferenceId),
        #[prost(message, tag = "7")]
        AccountId(super::ReferenceId),
        #[prost(message, tag = "8")]
        ActivityDefinitionId(super::ReferenceId),
        #[prost(message, tag = "9")]
        AdverseEventId(super::ReferenceId),
        #[prost(message, tag = "10")]
        AllergyIntoleranceId(super::ReferenceId),
        #[prost(message, tag = "11")]
        AppointmentId(super::ReferenceId),
        #[prost(message, tag = "12")]
        AppointmentResponseId(super::ReferenceId),
        #[prost(message, tag = "13")]
        AuditEventId(super::ReferenceId),
        #[prost(message, tag = "14")]
        BasicId(super::ReferenceId),
        #[prost(message, tag = "15")]
        BinaryId(super::ReferenceId),
        #[prost(message, tag = "16")]
        BiologicallyDerivedProductId(super::ReferenceId),
        #[prost(message, tag = "17")]
        BodyStructureId(super::ReferenceId),
        #[prost(message, tag = "18")]
        BundleId(super::ReferenceId),
        #[prost(message, tag = "19")]
        CapabilityStatementId(super::ReferenceId),
        #[prost(message, tag = "20")]
        CarePlanId(super::ReferenceId),
        #[prost(message, tag = "21")]
        CareTeamId(super::ReferenceId),
        #[prost(message, tag = "22")]
        CatalogEntryId(super::ReferenceId),
        #[prost(message, tag = "23")]
        ChargeItemId(super::ReferenceId),
        #[prost(message, tag = "24")]
        ChargeItemDefinitionId(super::ReferenceId),
        #[prost(message, tag = "25")]
        ClaimId(super::ReferenceId),
        #[prost(message, tag = "26")]
        ClaimResponseId(super::ReferenceId),
        #[prost(message, tag = "27")]
        ClinicalImpressionId(super::ReferenceId),
        #[prost(message, tag = "28")]
        CodeSystemId(super::ReferenceId),
        #[prost(message, tag = "29")]
        CommunicationId(super::ReferenceId),
        #[prost(message, tag = "30")]
        CommunicationRequestId(super::ReferenceId),
        #[prost(message, tag = "31")]
        CompartmentDefinitionId(super::ReferenceId),
        #[prost(message, tag = "32")]
        CompositionId(super::ReferenceId),
        #[prost(message, tag = "33")]
        ConceptMapId(super::ReferenceId),
        #[prost(message, tag = "34")]
        ConditionId(super::ReferenceId),
        #[prost(message, tag = "35")]
        ConsentId(super::ReferenceId),
        #[prost(message, tag = "36")]
        ContractId(super::ReferenceId),
        #[prost(message, tag = "37")]
        CoverageId(super::ReferenceId),
        #[prost(message, tag = "38")]
        CoverageEligibilityRequestId(super::ReferenceId),
        #[prost(message, tag = "39")]
        CoverageEligibilityResponseId(super::ReferenceId),
        #[prost(message, tag = "40")]
        DetectedIssueId(super::ReferenceId),
        #[prost(message, tag = "41")]
        DeviceId(super::ReferenceId),
        #[prost(message, tag = "42")]
        DeviceDefinitionId(super::ReferenceId),
        #[prost(message, tag = "43")]
        DeviceMetricId(super::ReferenceId),
        #[prost(message, tag = "44")]
        DeviceRequestId(super::ReferenceId),
        #[prost(message, tag = "45")]
        DeviceUseStatementId(super::ReferenceId),
        #[prost(message, tag = "46")]
        DiagnosticReportId(super::ReferenceId),
        #[prost(message, tag = "47")]
        DocumentManifestId(super::ReferenceId),
        #[prost(message, tag = "48")]
        DocumentReferenceId(super::ReferenceId),
        #[prost(message, tag = "49")]
        DomainResourceId(super::ReferenceId),
        #[prost(message, tag = "50")]
        EffectEvidenceSynthesisId(super::ReferenceId),
        #[prost(message, tag = "51")]
        EncounterId(super::ReferenceId),
        #[prost(message, tag = "52")]
        EndpointId(super::ReferenceId),
        #[prost(message, tag = "53")]
        EnrollmentRequestId(super::ReferenceId),
        #[prost(message, tag = "54")]
        EnrollmentResponseId(super::ReferenceId),
        #[prost(message, tag = "55")]
        EpisodeOfCareId(super::ReferenceId),
        #[prost(message, tag = "56")]
        EventDefinitionId(super::ReferenceId),
        #[prost(message, tag = "57")]
        EvidenceId(super::ReferenceId),
        #[prost(message, tag = "58")]
        EvidenceVariableId(super::ReferenceId),
        #[prost(message, tag = "59")]
        ExampleScenarioId(super::ReferenceId),
        #[prost(message, tag = "60")]
        ExplanationOfBenefitId(super::ReferenceId),
        #[prost(message, tag = "61")]
        FamilyMemberHistoryId(super::ReferenceId),
        #[prost(message, tag = "62")]
        FlagId(super::ReferenceId),
        #[prost(message, tag = "63")]
        GoalId(super::ReferenceId),
        #[prost(message, tag = "64")]
        GraphDefinitionId(super::ReferenceId),
        #[prost(message, tag = "65")]
        GroupId(super::ReferenceId),
        #[prost(message, tag = "66")]
        GuidanceResponseId(super::ReferenceId),
        #[prost(message, tag = "67")]
        HealthcareServiceId(super::ReferenceId),
        #[prost(message, tag = "68")]
        ImagingStudyId(super::ReferenceId),
        #[prost(message, tag = "69")]
        ImmunizationId(super::ReferenceId),
        #[prost(message, tag = "70")]
        ImmunizationEvaluationId(super::ReferenceId),
        #[prost(message, tag = "71")]
        ImmunizationRecommendationId(super::ReferenceId),
        #[prost(message, tag = "72")]
        ImplementationGuideId(super::ReferenceId),
        #[prost(message, tag = "73")]
        InsurancePlanId(super::ReferenceId),
        #[prost(message, tag = "74")]
        InvoiceId(super::ReferenceId),
        #[prost(message, tag = "75")]
        LibraryId(super::ReferenceId),
        #[prost(message, tag = "76")]
        LinkageId(super::ReferenceId),
        #[prost(message, tag = "77")]
        ListId(super::ReferenceId),
        #[prost(message, tag = "78")]
        LocationId(super::ReferenceId),
        #[prost(message, tag = "79")]
        MeasureId(super::ReferenceId),
        #[prost(message, tag = "80")]
        MeasureReportId(super::ReferenceId),
        #[prost(message, tag = "81")]
        MediaId(super::ReferenceId),
        #[prost(message, tag = "82")]
        MedicationId(super::ReferenceId),
        #[prost(message, tag = "83")]
        MedicationAdministrationId(super::ReferenceId),
        #[prost(message, tag = "84")]
        MedicationDispenseId(super::ReferenceId),
        #[prost(message, tag = "85")]
        MedicationKnowledgeId(super::ReferenceId),
        #[prost(message, tag = "86")]
        MedicationRequestId(super::ReferenceId),
        #[prost(message, tag = "87")]
        MedicationStatementId(super::ReferenceId),
        #[prost(message, tag = "88")]
        MedicinalProductId(super::ReferenceId),
        #[prost(message, tag = "89")]
        MedicinalProductAuthorizationId(super::ReferenceId),
        #[prost(message, tag = "90")]
        MedicinalProductContraindicationId(super::ReferenceId),
        #[prost(message, tag = "91")]
        MedicinalProductIndicationId(super::ReferenceId),
        #[prost(message, tag = "92")]
        MedicinalProductIngredientId(super::ReferenceId),
        #[prost(message, tag = "93")]
        MedicinalProductInteractionId(super::ReferenceId),
        #[prost(message, tag = "94")]
        MedicinalProductManufacturedId(super::ReferenceId),
        #[prost(message, tag = "95")]
        MedicinalProductPackagedId(super::ReferenceId),
        #[prost(message, tag = "96")]
        MedicinalProductPharmaceuticalId(super::ReferenceId),
        #[prost(message, tag = "97")]
        MedicinalProductUndesirableEffectId(super::ReferenceId),
        #[prost(message, tag = "98")]
        MessageDefinitionId(super::ReferenceId),
        #[prost(message, tag = "99")]
        MessageHeaderId(super::ReferenceId),
        #[prost(message, tag = "100")]
        MolecularSequenceId(super::ReferenceId),
        #[prost(message, tag = "101")]
        NamingSystemId(super::ReferenceId),
        #[prost(message, tag = "102")]
        NutritionOrderId(super::ReferenceId),
        #[prost(message, tag = "103")]
        ObservationId(super::ReferenceId),
        #[prost(message, tag = "104")]
        ObservationDefinitionId(super::ReferenceId),
        #[prost(message, tag = "105")]
        OperationDefinitionId(super::ReferenceId),
        #[prost(message, tag = "106")]
        OperationOutcomeId(super::ReferenceId),
        #[prost(message, tag = "107")]
        OrganizationId(super::ReferenceId),
        #[prost(message, tag = "108")]
        OrganizationAffiliationId(super::ReferenceId),
        #[prost(message, tag = "109")]
        ParametersId(super::ReferenceId),
        #[prost(message, tag = "110")]
        PatientId(super::ReferenceId),
        #[prost(message, tag = "111")]
        PaymentNoticeId(super::ReferenceId),
        #[prost(message, tag = "112")]
        PaymentReconciliationId(super::ReferenceId),
        #[prost(message, tag = "113")]
        PersonId(super::ReferenceId),
        #[prost(message, tag = "114")]
        PlanDefinitionId(super::ReferenceId),
        #[prost(message, tag = "115")]
        PractitionerId(super::ReferenceId),
        #[prost(message, tag = "116")]
        PractitionerRoleId(super::ReferenceId),
        #[prost(message, tag = "117")]
        ProcedureId(super::ReferenceId),
        #[prost(message, tag = "118")]
        ProvenanceId(super::ReferenceId),
        #[prost(message, tag = "119")]
        QuestionnaireId(super::ReferenceId),
        #[prost(message, tag = "120")]
        QuestionnaireResponseId(super::ReferenceId),
        #[prost(message, tag = "121")]
        RelatedPersonId(super::ReferenceId),
        #[prost(message, tag = "122")]
        RequestGroupId(super::ReferenceId),
        #[prost(message, tag = "123")]
        ResearchDefinitionId(super::ReferenceId),
        #[prost(message, tag = "124")]
        ResearchElementDefinitionId(super::ReferenceId),
        #[prost(message, tag = "125")]
        ResearchStudyId(super::ReferenceId),
        #[prost(message, tag = "126")]
        ResearchSubjectId(super::ReferenceId),
        #[prost(message, tag = "127")]
        RiskAssessmentId(super::ReferenceId),
        #[prost(message, tag = "128")]
        RiskEvidenceSynthesisId(super::ReferenceId),
        #[prost(message, tag = "129")]
        ScheduleId(super::ReferenceId),
        #[prost(message, tag = "130")]
        SearchParameterId(super::ReferenceId),
        #[prost(message, tag = "131")]
        ServiceRequestId(super::ReferenceId),
        #[prost(message, tag = "132")]
        SlotId(super::ReferenceId),
        #[prost(message, tag = "133")]
        SpecimenId(super::ReferenceId),
        #[prost(message, tag = "134")]
        SpecimenDefinitionId(super::ReferenceId),
        #[prost(message, tag = "135")]
        StructureDefinitionId(super::ReferenceId),
        #[prost(message, tag = "136")]
        StructureMapId(super::ReferenceId),
        #[prost(message, tag = "137")]
        SubscriptionId(super::ReferenceId),
        #[prost(message, tag = "138")]
        SubstanceId(super::ReferenceId),
        #[prost(message, tag = "139")]
        SubstanceNucleicAcidId(super::ReferenceId),
        #[prost(message, tag = "140")]
        SubstancePolymerId(super::ReferenceId),
        #[prost(message, tag = "141")]
        SubstanceProteinId(super::ReferenceId),
        #[prost(message, tag = "142")]
        SubstanceReferenceInformationId(super::ReferenceId),
        #[prost(message, tag = "143")]
        SubstanceSourceMaterialId(super::ReferenceId),
        #[prost(message, tag = "144")]
        SubstanceSpecificationId(super::ReferenceId),
        #[prost(message, tag = "145")]
        SupplyDeliveryId(super::ReferenceId),
        #[prost(message, tag = "146")]
        SupplyRequestId(super::ReferenceId),
        #[prost(message, tag = "147")]
        TaskId(super::ReferenceId),
        #[prost(message, tag = "148")]
        TerminologyCapabilitiesId(super::ReferenceId),
        #[prost(message, tag = "149")]
        TestReportId(super::ReferenceId),
        #[prost(message, tag = "150")]
        TestScriptId(super::ReferenceId),
        #[prost(message, tag = "151")]
        ValueSetId(super::ReferenceId),
        #[prost(message, tag = "152")]
        VerificationResultId(super::ReferenceId),
        #[prost(message, tag = "153")]
        VisionPrescriptionId(super::ReferenceId),
        #[prost(message, tag = "154")]
        MetadataResourceId(super::ReferenceId),
    }
}
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReferenceId {
    /// Primitive value for id
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// History version, if present.
    #[prost(message, optional, tag = "2")]
    pub history: ::core::option::Option<Id>,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "3")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "4")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for Account, last updated
/// 2019-11-01T09:29:23.356+11:00. Tracks balance, charges, for patient or cost
/// center. See <http://hl7.org/fhir/StructureDefinition/Account>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Account {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Account number
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<account::StatusCode>,
    /// E.g. patient, expense, depreciation
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Human-readable label
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// The entity that caused the expenses
    #[prost(message, repeated, tag = "14")]
    pub subject: prost::alloc::vec::Vec<Reference>,
    /// Transaction window
    #[prost(message, optional, tag = "15")]
    pub service_period: ::core::option::Option<Period>,
    #[prost(message, repeated, tag = "16")]
    pub coverage: prost::alloc::vec::Vec<account::Coverage>,
    /// Entity managing the Account
    #[prost(message, optional, tag = "17")]
    pub owner: ::core::option::Option<Reference>,
    /// Explanation of purpose/use
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "19")]
    pub guarantor: prost::alloc::vec::Vec<account::Guarantor>,
    /// Reference to a parent Account
    #[prost(message, optional, tag = "20")]
    pub part_of: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    /// active | inactive | entered-in-error | on-hold | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::account_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// The party(s) that are responsible for covering the payment of this account,
    /// and what order should they be applied to the account
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Coverage {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The party(s), such as insurances, that may contribute to the payment of
        /// this account
        #[prost(message, optional, tag = "4")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// The priority of the coverage in the context of this account
        #[prost(message, optional, tag = "5")]
        pub priority: ::core::option::Option<super::PositiveInt>,
    }
    /// The parties ultimately responsible for balancing the Account
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Guarantor {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Responsible entity
        #[prost(message, optional, tag = "4")]
        pub party: ::core::option::Option<super::Reference>,
        /// Credit or other hold applied
        #[prost(message, optional, tag = "5")]
        pub on_hold: ::core::option::Option<super::Boolean>,
        /// Guarantee account during
        #[prost(message, optional, tag = "6")]
        pub period: ::core::option::Option<super::Period>,
    }
}
/// Auto-generated from StructureDefinition for ActivityDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. The definition of a specific activity to be
/// taken, independent of any particular patient or context. See
/// <http://hl7.org/fhir/StructureDefinition/ActivityDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActivityDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this activity definition, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the activity definition
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the activity definition
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this activity definition (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this activity definition (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Subordinate title of the activity definition
    #[prost(message, optional, tag = "15")]
    pub subtitle: ::core::option::Option<String>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<activity_definition::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "17")]
    pub experimental: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "18")]
    pub subject: ::core::option::Option<activity_definition::SubjectX>,
    /// Date last changed
    #[prost(message, optional, tag = "19")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "20")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "21")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the activity definition
    #[prost(message, optional, tag = "22")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "23")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for activity definition (if applicable)
    #[prost(message, repeated, tag = "24")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this activity definition is defined
    #[prost(message, optional, tag = "25")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the activity definition
    #[prost(message, optional, tag = "26")]
    pub usage: ::core::option::Option<String>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "27")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the activity definition was approved by publisher
    #[prost(message, optional, tag = "28")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the activity definition was last reviewed
    #[prost(message, optional, tag = "29")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the activity definition is expected to be used
    #[prost(message, optional, tag = "30")]
    pub effective_period: ::core::option::Option<Period>,
    /// E.g. Education, Treatment, Assessment, etc.
    #[prost(message, repeated, tag = "31")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "32")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "33")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "34")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "35")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "36")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Logic used by the activity definition
    #[prost(message, repeated, tag = "37")]
    pub library: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, optional, tag = "38")]
    pub kind: ::core::option::Option<activity_definition::KindCode>,
    /// What profile the resource needs to conform to
    #[prost(message, optional, tag = "39")]
    pub profile: ::core::option::Option<Canonical>,
    /// Detail type of activity
    #[prost(message, optional, tag = "40")]
    pub code: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "41")]
    pub intent: ::core::option::Option<activity_definition::IntentCode>,
    #[prost(message, optional, tag = "42")]
    pub priority: ::core::option::Option<activity_definition::PriorityCode>,
    /// True if the activity should not be performed
    #[prost(message, optional, tag = "43")]
    pub do_not_perform: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "44")]
    pub timing: ::core::option::Option<activity_definition::TimingX>,
    /// Where it should happen
    #[prost(message, optional, tag = "45")]
    pub location: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "46")]
    pub participant: prost::alloc::vec::Vec<activity_definition::Participant>,
    #[prost(message, optional, tag = "47")]
    pub product: ::core::option::Option<activity_definition::ProductX>,
    /// How much is administered/consumed/supplied
    #[prost(message, optional, tag = "48")]
    pub quantity: ::core::option::Option<SimpleQuantity>,
    /// Detailed dosage instructions
    #[prost(message, repeated, tag = "49")]
    pub dosage: prost::alloc::vec::Vec<Dosage>,
    /// What part of body to perform on
    #[prost(message, repeated, tag = "50")]
    pub body_site: prost::alloc::vec::Vec<CodeableConcept>,
    /// What specimens are required to perform this action
    #[prost(message, repeated, tag = "51")]
    pub specimen_requirement: prost::alloc::vec::Vec<Reference>,
    /// What observations are required to perform this action
    #[prost(message, repeated, tag = "52")]
    pub observation_requirement: prost::alloc::vec::Vec<Reference>,
    /// What observations must be produced by this action
    #[prost(message, repeated, tag = "53")]
    pub observation_result_requirement: prost::alloc::vec::Vec<Reference>,
    /// Transform to apply the template
    #[prost(message, optional, tag = "54")]
    pub transform: ::core::option::Option<Canonical>,
    #[prost(message, repeated, tag = "55")]
    pub dynamic_value: prost::alloc::vec::Vec<activity_definition::DynamicValue>,
}
/// Nested message and enum types in `ActivityDefinition`.
pub mod activity_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Type of individual the activity definition is intended for
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SubjectX {
        #[prost(oneof = "subject_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<subject_x::Choice>,
    }
    /// Nested message and enum types in `SubjectX`.
    pub mod subject_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Kind of resource
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct KindCode {
        #[prost(enumeration = "super::request_resource_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// proposal | plan | directive | order | original-order | reflex-order |
    /// filler-order | instance-order | option
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct IntentCode {
        #[prost(enumeration = "super::request_intent_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// routine | urgent | asap | stat
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PriorityCode {
        #[prost(enumeration = "super::request_priority_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// When activity is to occur
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TimingX {
        #[prost(oneof = "timing_x::Choice", tags = "1, 2, 3, 4, 5, 6")]
        pub choice: ::core::option::Option<timing_x::Choice>,
    }
    /// Nested message and enum types in `TimingX`.
    pub mod timing_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Timing(super::super::Timing),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "3")]
            Age(super::super::Age),
            #[prost(message, tag = "4")]
            Period(super::super::Period),
            #[prost(message, tag = "5")]
            Range(super::super::Range),
            #[prost(message, tag = "6")]
            Duration(super::super::Duration),
        }
    }
    /// Who should participate in the action
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<participant::TypeCode>,
        /// E.g. Nurse, Surgeon, Parent, etc.
        #[prost(message, optional, tag = "5")]
        pub role: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Participant`.
    pub mod participant {
        /// patient | practitioner | related-person | device
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(
                enumeration = "super::super::action_participant_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// What's administered/supplied
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ProductX {
        #[prost(oneof = "product_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<product_x::Choice>,
    }
    /// Nested message and enum types in `ProductX`.
    pub mod product_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Reference(super::super::Reference),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// Dynamic aspects of the definition
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DynamicValue {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The path to the element to be set dynamically
        #[prost(message, optional, tag = "4")]
        pub path: ::core::option::Option<super::String>,
        /// An expression that provides the dynamic value for the customization
        #[prost(message, optional, tag = "5")]
        pub expression: ::core::option::Option<super::Expression>,
    }
}
/// Auto-generated from StructureDefinition for AdverseEvent, last updated
/// 2019-11-01T09:29:23.356+11:00. Medical care, research study or other
/// healthcare event causing physical injury. See
/// <http://hl7.org/fhir/StructureDefinition/AdverseEvent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEvent {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier for the event
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub actuality: ::core::option::Option<adverse_event::ActualityCode>,
    /// product-problem | product-quality | product-use-error | wrong-dose |
    /// incorrect-prescribing-information | wrong-technique |
    /// wrong-route-of-administration | wrong-rate | wrong-duration | wrong-time |
    /// expired-drug | medical-device-use-error | problem-different-manufacturer |
    /// unsafe-physical-environment
    #[prost(message, repeated, tag = "12")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Type of the event itself in relation to the subject
    #[prost(message, optional, tag = "13")]
    pub event: ::core::option::Option<CodeableConcept>,
    /// Subject impacted by event
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter created as part of
    #[prost(message, optional, tag = "15")]
    pub encounter: ::core::option::Option<Reference>,
    /// When the event occurred
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// When the event was detected
    #[prost(message, optional, tag = "17")]
    pub detected: ::core::option::Option<DateTime>,
    /// When the event was recorded
    #[prost(message, optional, tag = "18")]
    pub recorded_date: ::core::option::Option<DateTime>,
    /// Effect on the subject due to this event
    #[prost(message, repeated, tag = "19")]
    pub resulting_condition: prost::alloc::vec::Vec<Reference>,
    /// Location where adverse event occurred
    #[prost(message, optional, tag = "20")]
    pub location: ::core::option::Option<Reference>,
    /// Seriousness of the event
    #[prost(message, optional, tag = "21")]
    pub seriousness: ::core::option::Option<CodeableConcept>,
    /// mild | moderate | severe
    #[prost(message, optional, tag = "22")]
    pub severity: ::core::option::Option<CodeableConcept>,
    /// resolved | recovering | ongoing | resolvedWithSequelae | fatal | unknown
    #[prost(message, optional, tag = "23")]
    pub outcome: ::core::option::Option<CodeableConcept>,
    /// Who recorded the adverse event
    #[prost(message, optional, tag = "24")]
    pub recorder: ::core::option::Option<Reference>,
    /// Who  was involved in the adverse event or the potential adverse event
    #[prost(message, repeated, tag = "25")]
    pub contributor: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "26")]
    pub suspect_entity: prost::alloc::vec::Vec<adverse_event::SuspectEntity>,
    /// AdverseEvent.subjectMedicalHistory
    #[prost(message, repeated, tag = "27")]
    pub subject_medical_history: prost::alloc::vec::Vec<Reference>,
    /// AdverseEvent.referenceDocument
    #[prost(message, repeated, tag = "28")]
    pub reference_document: prost::alloc::vec::Vec<Reference>,
    /// AdverseEvent.study
    #[prost(message, repeated, tag = "29")]
    pub study: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `AdverseEvent`.
pub mod adverse_event {
    /// actual | potential
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ActualityCode {
        #[prost(enumeration = "super::adverse_event_actuality_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// The suspected agent causing the adverse event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SuspectEntity {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Refers to the specific entity that caused the adverse event
        #[prost(message, optional, tag = "4")]
        pub instance: ::core::option::Option<super::Reference>,
        #[prost(message, repeated, tag = "5")]
        pub causality: prost::alloc::vec::Vec<suspect_entity::Causality>,
    }
    /// Nested message and enum types in `SuspectEntity`.
    pub mod suspect_entity {
        /// Information on the possible cause of the event
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Causality {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Assessment of if the entity caused the event
            #[prost(message, optional, tag = "4")]
            pub assessment: ::core::option::Option<super::super::CodeableConcept>,
            /// AdverseEvent.suspectEntity.causalityProductRelatedness
            #[prost(message, optional, tag = "5")]
            pub product_relatedness: ::core::option::Option<super::super::String>,
            /// AdverseEvent.suspectEntity.causalityAuthor
            #[prost(message, optional, tag = "6")]
            pub author: ::core::option::Option<super::super::Reference>,
            /// ProbabilityScale | Bayesian | Checklist
            #[prost(message, optional, tag = "7")]
            pub method: ::core::option::Option<super::super::CodeableConcept>,
        }
    }
}
/// Auto-generated from StructureDefinition for AllergyIntolerance, last updated
/// 2019-11-01T09:29:23.356+11:00. Allergy or Intolerance (generally: Risk of
/// adverse reaction to a substance). See
/// <http://hl7.org/fhir/StructureDefinition/AllergyIntolerance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntolerance {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External ids for this item
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | inactive | resolved
    #[prost(message, optional, tag = "11")]
    pub clinical_status: ::core::option::Option<CodeableConcept>,
    /// unconfirmed | confirmed | refuted | entered-in-error
    #[prost(message, optional, tag = "12")]
    pub verification_status: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "13")]
    pub r#type: ::core::option::Option<allergy_intolerance::TypeCode>,
    #[prost(message, repeated, tag = "14")]
    pub category: prost::alloc::vec::Vec<allergy_intolerance::CategoryCode>,
    #[prost(message, optional, tag = "15")]
    pub criticality: ::core::option::Option<allergy_intolerance::CriticalityCode>,
    /// Code that identifies the allergy or intolerance
    #[prost(message, optional, tag = "16")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who the sensitivity is for
    #[prost(message, optional, tag = "17")]
    pub patient: ::core::option::Option<Reference>,
    /// Encounter when the allergy or intolerance was asserted
    #[prost(message, optional, tag = "18")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "19")]
    pub onset: ::core::option::Option<allergy_intolerance::OnsetX>,
    /// Date first version of the resource instance was recorded
    #[prost(message, optional, tag = "20")]
    pub recorded_date: ::core::option::Option<DateTime>,
    /// Who recorded the sensitivity
    #[prost(message, optional, tag = "21")]
    pub recorder: ::core::option::Option<Reference>,
    /// Source of the information about the allergy
    #[prost(message, optional, tag = "22")]
    pub asserter: ::core::option::Option<Reference>,
    /// Date(/time) of last known occurrence of a reaction
    #[prost(message, optional, tag = "23")]
    pub last_occurrence: ::core::option::Option<DateTime>,
    /// Additional text not captured in other fields
    #[prost(message, repeated, tag = "24")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "25")]
    pub reaction: prost::alloc::vec::Vec<allergy_intolerance::Reaction>,
}
/// Nested message and enum types in `AllergyIntolerance`.
pub mod allergy_intolerance {
    /// allergy | intolerance - Underlying mechanism (if known)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::allergy_intolerance_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// food | medication | environment | biologic
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CategoryCode {
        #[prost(
            enumeration = "super::allergy_intolerance_category_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// low | high | unable-to-assess
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CriticalityCode {
        #[prost(
            enumeration = "super::allergy_intolerance_criticality_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// When allergy or intolerance was identified
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OnsetX {
        #[prost(oneof = "onset_x::Choice", tags = "1, 2, 3, 4, 5")]
        pub choice: ::core::option::Option<onset_x::Choice>,
    }
    /// Nested message and enum types in `OnsetX`.
    pub mod onset_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Age(super::super::Age),
            #[prost(message, tag = "3")]
            Period(super::super::Period),
            #[prost(message, tag = "4")]
            Range(super::super::Range),
            #[prost(message, tag = "5")]
            StringValue(super::super::String),
        }
    }
    /// Adverse Reaction Events linked to exposure to substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Reaction {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Specific substance or pharmaceutical product considered to be responsible
        /// for event
        #[prost(message, optional, tag = "4")]
        pub substance: ::core::option::Option<super::CodeableConcept>,
        /// Clinical symptoms/signs associated with the Event
        #[prost(message, repeated, tag = "5")]
        pub manifestation: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Description of the event as a whole
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        /// Date(/time) when manifestations showed
        #[prost(message, optional, tag = "7")]
        pub onset: ::core::option::Option<super::DateTime>,
        #[prost(message, optional, tag = "8")]
        pub severity: ::core::option::Option<reaction::SeverityCode>,
        /// How the subject was exposed to the substance
        #[prost(message, optional, tag = "9")]
        pub exposure_route: ::core::option::Option<super::CodeableConcept>,
        /// Text about event not captured in other fields
        #[prost(message, repeated, tag = "10")]
        pub note: prost::alloc::vec::Vec<super::Annotation>,
    }
    /// Nested message and enum types in `Reaction`.
    pub mod reaction {
        /// mild | moderate | severe (of event as a whole)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SeverityCode {
            #[prost(
                enumeration = "super::super::allergy_intolerance_severity_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for Appointment, last updated
/// 2019-11-01T09:29:23.356+11:00. A booking of a healthcare event among
/// patient(s), practitioner(s), related person(s) and/or device(s) for a
/// specific date/time. This may result in one or more Encounter(s). See
/// <http://hl7.org/fhir/StructureDefinition/Appointment>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Appointment {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this item
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<appointment::StatusCode>,
    /// The coded reason for the appointment being cancelled
    #[prost(message, optional, tag = "12")]
    pub cancelation_reason: ::core::option::Option<CodeableConcept>,
    /// A broad categorization of the service that is to be performed during this
    /// appointment
    #[prost(message, repeated, tag = "13")]
    pub service_category: prost::alloc::vec::Vec<CodeableConcept>,
    /// The specific service that is to be performed during this appointment
    #[prost(message, repeated, tag = "14")]
    pub service_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// The specialty of a practitioner that would be required to perform the
    /// service requested in this appointment
    #[prost(message, repeated, tag = "15")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// The style of appointment or patient that has been booked in the slot (not
    /// service type)
    #[prost(message, optional, tag = "16")]
    pub appointment_type: ::core::option::Option<CodeableConcept>,
    /// Coded reason this appointment is scheduled
    #[prost(message, repeated, tag = "17")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Reason the appointment is to take place (resource)
    #[prost(message, repeated, tag = "18")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Used to make informed decisions if needing to re-prioritize
    #[prost(message, optional, tag = "19")]
    pub priority: ::core::option::Option<UnsignedInt>,
    /// Shown on a subject line in a meeting request, or appointment list
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<String>,
    /// Additional information to support the appointment
    #[prost(message, repeated, tag = "21")]
    pub supporting_information: prost::alloc::vec::Vec<Reference>,
    /// When appointment is to take place
    #[prost(message, optional, tag = "22")]
    pub start: ::core::option::Option<Instant>,
    /// When appointment is to conclude
    #[prost(message, optional, tag = "23")]
    pub end: ::core::option::Option<Instant>,
    /// Can be less than start/end (e.g. estimate)
    #[prost(message, optional, tag = "24")]
    pub minutes_duration: ::core::option::Option<PositiveInt>,
    /// The slots that this appointment is filling
    #[prost(message, repeated, tag = "25")]
    pub slot: prost::alloc::vec::Vec<Reference>,
    /// The date that this appointment was initially created
    #[prost(message, optional, tag = "26")]
    pub created: ::core::option::Option<DateTime>,
    /// Additional comments
    #[prost(message, optional, tag = "27")]
    pub comment: ::core::option::Option<String>,
    /// Detailed information and instructions for the patient
    #[prost(message, optional, tag = "28")]
    pub patient_instruction: ::core::option::Option<String>,
    /// The service request this appointment is allocated to assess
    #[prost(message, repeated, tag = "29")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "30")]
    pub participant: prost::alloc::vec::Vec<appointment::Participant>,
    /// Potential date/time interval(s) requested to allocate the appointment
    /// within
    #[prost(message, repeated, tag = "31")]
    pub requested_period: prost::alloc::vec::Vec<Period>,
}
/// Nested message and enum types in `Appointment`.
pub mod appointment {
    /// proposed | pending | booked | arrived | fulfilled | cancelled | noshow |
    /// entered-in-error | checked-in | waitlist
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::appointment_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Participants involved in appointment
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Role of participant in the appointment
        #[prost(message, repeated, tag = "4")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Person, Location/HealthcareService or Device
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "6")]
        pub required: ::core::option::Option<participant::RequiredCode>,
        #[prost(message, optional, tag = "7")]
        pub status: ::core::option::Option<participant::StatusCode>,
        /// Participation period of the actor
        #[prost(message, optional, tag = "8")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// Nested message and enum types in `Participant`.
    pub mod participant {
        /// required | optional | information-only
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RequiredCode {
            #[prost(
                enumeration = "super::super::participant_required_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// accepted | declined | tentative | needs-action
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct StatusCode {
            #[prost(
                enumeration = "super::super::participation_status_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for AppointmentResponse, last updated
/// 2019-11-01T09:29:23.356+11:00. A reply to an appointment request for a
/// patient and/or practitioner(s), such as a confirmation or rejection. See
/// <http://hl7.org/fhir/StructureDefinition/AppointmentResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AppointmentResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this item
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Appointment this response relates to
    #[prost(message, optional, tag = "11")]
    pub appointment: ::core::option::Option<Reference>,
    /// Time from appointment, or requested new start time
    #[prost(message, optional, tag = "12")]
    pub start: ::core::option::Option<Instant>,
    /// Time from appointment, or requested new end time
    #[prost(message, optional, tag = "13")]
    pub end: ::core::option::Option<Instant>,
    /// Role of participant in the appointment
    #[prost(message, repeated, tag = "14")]
    pub participant_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Person, Location, HealthcareService, or Device
    #[prost(message, optional, tag = "15")]
    pub actor: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "16")]
    pub participant_status: ::core::option::Option<appointment_response::ParticipantStatusCode>,
    /// Additional comments
    #[prost(message, optional, tag = "17")]
    pub comment: ::core::option::Option<String>,
}
/// Nested message and enum types in `AppointmentResponse`.
pub mod appointment_response {
    /// accepted | declined | tentative | needs-action
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ParticipantStatusCode {
        #[prost(enumeration = "super::participation_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for AuditEvent, last updated
/// 2019-11-01T09:29:23.356+11:00. Event record kept for security purposes. See
/// <http://hl7.org/fhir/StructureDefinition/AuditEvent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEvent {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Type/identifier of event
    #[prost(message, optional, tag = "10")]
    pub r#type: ::core::option::Option<Coding>,
    /// More specific type/id for the event
    #[prost(message, repeated, tag = "11")]
    pub subtype: prost::alloc::vec::Vec<Coding>,
    #[prost(message, optional, tag = "12")]
    pub action: ::core::option::Option<audit_event::ActionCode>,
    /// When the activity occurred
    #[prost(message, optional, tag = "13")]
    pub period: ::core::option::Option<Period>,
    /// Time when the event was recorded
    #[prost(message, optional, tag = "14")]
    pub recorded: ::core::option::Option<Instant>,
    #[prost(message, optional, tag = "15")]
    pub outcome: ::core::option::Option<audit_event::OutcomeCode>,
    /// Description of the event outcome
    #[prost(message, optional, tag = "16")]
    pub outcome_desc: ::core::option::Option<String>,
    /// The purposeOfUse of the event
    #[prost(message, repeated, tag = "17")]
    pub purpose_of_event: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "18")]
    pub agent: prost::alloc::vec::Vec<audit_event::Agent>,
    #[prost(message, optional, tag = "19")]
    pub source: ::core::option::Option<audit_event::Source>,
    #[prost(message, repeated, tag = "20")]
    pub entity: prost::alloc::vec::Vec<audit_event::Entity>,
}
/// Nested message and enum types in `AuditEvent`.
pub mod audit_event {
    /// Type of action performed during the event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ActionCode {
        #[prost(enumeration = "super::audit_event_action_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Whether the event succeeded or failed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OutcomeCode {
        #[prost(enumeration = "super::audit_event_outcome_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Actor involved in the event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Agent {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// How agent participated
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Agent role in the event
        #[prost(message, repeated, tag = "5")]
        pub role: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Identifier of who
        #[prost(message, optional, tag = "6")]
        pub who: ::core::option::Option<super::Reference>,
        /// Alternative User identity
        #[prost(message, optional, tag = "7")]
        pub alt_id: ::core::option::Option<super::String>,
        /// Human friendly name for the agent
        #[prost(message, optional, tag = "8")]
        pub name: ::core::option::Option<super::String>,
        /// Whether user is initiator
        #[prost(message, optional, tag = "9")]
        pub requestor: ::core::option::Option<super::Boolean>,
        /// Where
        #[prost(message, optional, tag = "10")]
        pub location: ::core::option::Option<super::Reference>,
        /// Policy that authorized event
        #[prost(message, repeated, tag = "11")]
        pub policy: prost::alloc::vec::Vec<super::Uri>,
        /// Type of media
        #[prost(message, optional, tag = "12")]
        pub media: ::core::option::Option<super::Coding>,
        #[prost(message, optional, tag = "13")]
        pub network: ::core::option::Option<agent::Network>,
        /// Reason given for this user
        #[prost(message, repeated, tag = "14")]
        pub purpose_of_use: prost::alloc::vec::Vec<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Agent`.
    pub mod agent {
        /// Logical network location for application activity
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Network {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Identifier for the network access point of the user device
            #[prost(message, optional, tag = "4")]
            pub address: ::core::option::Option<super::super::String>,
            #[prost(message, optional, tag = "5")]
            pub r#type: ::core::option::Option<network::TypeCode>,
        }
        /// Nested message and enum types in `Network`.
        pub mod network {
            /// The type of network access point
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct TypeCode {
                #[prost(
                    enumeration = "super::super::super::audit_event_agent_network_type_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
    }
    /// Audit Event Reporter
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Source {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Logical source location within the enterprise
        #[prost(message, optional, tag = "4")]
        pub site: ::core::option::Option<super::String>,
        /// The identity of source detecting the event
        #[prost(message, optional, tag = "5")]
        pub observer: ::core::option::Option<super::Reference>,
        /// The type of source where event originated
        #[prost(message, repeated, tag = "6")]
        pub r#type: prost::alloc::vec::Vec<super::Coding>,
    }
    /// Data or objects used
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Entity {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Specific instance of resource
        #[prost(message, optional, tag = "4")]
        pub what: ::core::option::Option<super::Reference>,
        /// Type of entity involved
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::Coding>,
        /// What role the entity played
        #[prost(message, optional, tag = "6")]
        pub role: ::core::option::Option<super::Coding>,
        /// Life-cycle stage for the entity
        #[prost(message, optional, tag = "7")]
        pub lifecycle: ::core::option::Option<super::Coding>,
        /// Security labels on the entity
        #[prost(message, repeated, tag = "8")]
        pub security_label: prost::alloc::vec::Vec<super::Coding>,
        /// Descriptor for entity
        #[prost(message, optional, tag = "9")]
        pub name: ::core::option::Option<super::String>,
        /// Descriptive text
        #[prost(message, optional, tag = "10")]
        pub description: ::core::option::Option<super::String>,
        /// Query parameters
        #[prost(message, optional, tag = "11")]
        pub query: ::core::option::Option<super::Base64Binary>,
        #[prost(message, repeated, tag = "12")]
        pub detail: prost::alloc::vec::Vec<entity::Detail>,
    }
    /// Nested message and enum types in `Entity`.
    pub mod entity {
        /// Additional Information about the entity
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Detail {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Name of the property
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::String>,
            #[prost(message, optional, tag = "5")]
            pub value: ::core::option::Option<detail::ValueX>,
        }
        /// Nested message and enum types in `Detail`.
        pub mod detail {
            /// Property value
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ValueX {
                #[prost(oneof = "value_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<value_x::Choice>,
            }
            /// Nested message and enum types in `ValueX`.
            pub mod value_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "2")]
                    Base64Binary(super::super::super::super::Base64Binary),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Basic, last updated
/// 2019-11-01T09:29:23.356+11:00. Resource for non-supported content. See
/// <http://hl7.org/fhir/StructureDefinition/Basic>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Basic {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Kind of Resource
    #[prost(message, optional, tag = "11")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Identifies the focus of this resource
    #[prost(message, optional, tag = "12")]
    pub subject: ::core::option::Option<Reference>,
    /// When created
    #[prost(message, optional, tag = "13")]
    pub created: ::core::option::Option<Date>,
    /// Who created
    #[prost(message, optional, tag = "14")]
    pub author: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Binary, last updated
/// 2019-11-01T09:29:23.356+11:00. Pure binary content defined by a format other
/// than FHIR. See <http://hl7.org/fhir/StructureDefinition/Binary>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Binary {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    #[prost(message, optional, tag = "5")]
    pub content_type: ::core::option::Option<binary::ContentTypeCode>,
    /// Identifies another resource to use as proxy when enforcing access control
    #[prost(message, optional, tag = "6")]
    pub security_context: ::core::option::Option<Reference>,
    /// The actual content
    #[prost(message, optional, tag = "7")]
    pub data: ::core::option::Option<Base64Binary>,
}
/// Nested message and enum types in `Binary`.
pub mod binary {
    /// MimeType of the binary content
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ContentTypeCode {
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// This valueset is not enumerable, and so is represented as a string.
        #[prost(string, tag = "4")]
        pub value: prost::alloc::string::String,
    }
}
/// Auto-generated from StructureDefinition for BiologicallyDerivedProduct, last
/// updated 2019-11-01T09:29:23.356+11:00. A material substance originating from
/// a biological entity. See
/// <http://hl7.org/fhir/StructureDefinition/BiologicallyDerivedProduct>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BiologicallyDerivedProduct {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External ids for this item
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub product_category: ::core::option::Option<biologically_derived_product::ProductCategoryCode>,
    /// What this biologically derived product is
    #[prost(message, optional, tag = "12")]
    pub product_code: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<biologically_derived_product::StatusCode>,
    /// Procedure request
    #[prost(message, repeated, tag = "14")]
    pub request: prost::alloc::vec::Vec<Reference>,
    /// The amount of this biologically derived product
    #[prost(message, optional, tag = "15")]
    pub quantity: ::core::option::Option<Integer>,
    /// BiologicallyDerivedProduct parent
    #[prost(message, repeated, tag = "16")]
    pub parent: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "17")]
    pub collection: ::core::option::Option<biologically_derived_product::Collection>,
    #[prost(message, repeated, tag = "18")]
    pub processing: prost::alloc::vec::Vec<biologically_derived_product::Processing>,
    #[prost(message, optional, tag = "19")]
    pub manipulation: ::core::option::Option<biologically_derived_product::Manipulation>,
    #[prost(message, repeated, tag = "20")]
    pub storage: prost::alloc::vec::Vec<biologically_derived_product::Storage>,
}
/// Nested message and enum types in `BiologicallyDerivedProduct`.
pub mod biologically_derived_product {
    /// organ | tissue | fluid | cells | biologicalAgent
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ProductCategoryCode {
        #[prost(
            enumeration = "super::biologically_derived_product_category_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// available | unavailable
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::biologically_derived_product_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// How this product was collected
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Collection {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Individual performing collection
        #[prost(message, optional, tag = "4")]
        pub collector: ::core::option::Option<super::Reference>,
        /// Who is product from
        #[prost(message, optional, tag = "5")]
        pub source: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "6")]
        pub collected: ::core::option::Option<collection::CollectedX>,
    }
    /// Nested message and enum types in `Collection`.
    pub mod collection {
        /// Time of product collection
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CollectedX {
            #[prost(oneof = "collected_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<collected_x::Choice>,
        }
        /// Nested message and enum types in `CollectedX`.
        pub mod collected_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
    }
    /// Any processing of the product during collection
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Processing {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Description of of processing
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Procesing code
        #[prost(message, optional, tag = "5")]
        pub procedure: ::core::option::Option<super::CodeableConcept>,
        /// Substance added during processing
        #[prost(message, optional, tag = "6")]
        pub additive: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "7")]
        pub time: ::core::option::Option<processing::TimeX>,
    }
    /// Nested message and enum types in `Processing`.
    pub mod processing {
        /// Time of processing
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimeX {
            #[prost(oneof = "time_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<time_x::Choice>,
        }
        /// Nested message and enum types in `TimeX`.
        pub mod time_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
    }
    /// Any manipulation of product post-collection
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Manipulation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Description of manipulation
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub time: ::core::option::Option<manipulation::TimeX>,
    }
    /// Nested message and enum types in `Manipulation`.
    pub mod manipulation {
        /// Time of manipulation
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimeX {
            #[prost(oneof = "time_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<time_x::Choice>,
        }
        /// Nested message and enum types in `TimeX`.
        pub mod time_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
    }
    /// Product storage
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Storage {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Description of storage
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Storage temperature
        #[prost(message, optional, tag = "5")]
        pub temperature: ::core::option::Option<super::Decimal>,
        #[prost(message, optional, tag = "6")]
        pub scale: ::core::option::Option<storage::ScaleCode>,
        /// Storage timeperiod
        #[prost(message, optional, tag = "7")]
        pub duration: ::core::option::Option<super::Period>,
    }
    /// Nested message and enum types in `Storage`.
    pub mod storage {
        /// farenheit | celsius | kelvin
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ScaleCode {
            #[prost(
                enumeration = "super::super::biologically_derived_product_storage_scale_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for BodyStructure, last updated
/// 2019-11-01T09:29:23.356+11:00. Specific and identified anatomical structure.
/// See <http://hl7.org/fhir/StructureDefinition/BodyStructure>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BodyStructure {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Bodystructure identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this record is in active use
    #[prost(message, optional, tag = "11")]
    pub active: ::core::option::Option<Boolean>,
    /// Kind of Structure
    #[prost(message, optional, tag = "12")]
    pub morphology: ::core::option::Option<CodeableConcept>,
    /// Body site
    #[prost(message, optional, tag = "13")]
    pub location: ::core::option::Option<CodeableConcept>,
    /// Body site modifier
    #[prost(message, repeated, tag = "14")]
    pub location_qualifier: prost::alloc::vec::Vec<CodeableConcept>,
    /// Text description
    #[prost(message, optional, tag = "15")]
    pub description: ::core::option::Option<String>,
    /// Attached images
    #[prost(message, repeated, tag = "16")]
    pub image: prost::alloc::vec::Vec<Attachment>,
    /// Who this is about
    #[prost(message, optional, tag = "17")]
    pub patient: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for CapabilityStatement, last updated
/// 2019-11-01T09:29:23.356+11:00. A statement of system capabilities. See
/// <http://hl7.org/fhir/StructureDefinition/CapabilityStatement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatement {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this capability statement, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the capability statement
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this capability statement (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this capability statement (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<capability_statement::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the capability statement
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for capability statement (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this capability statement is defined
    #[prost(message, optional, tag = "22")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "23")]
    pub copyright: ::core::option::Option<Markdown>,
    #[prost(message, optional, tag = "24")]
    pub kind: ::core::option::Option<capability_statement::KindCode>,
    /// Canonical URL of another capability statement this implements
    #[prost(message, repeated, tag = "25")]
    pub instantiates: prost::alloc::vec::Vec<Canonical>,
    /// Canonical URL of another capability statement this adds to
    #[prost(message, repeated, tag = "26")]
    pub imports: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, optional, tag = "27")]
    pub software: ::core::option::Option<capability_statement::Software>,
    #[prost(message, optional, tag = "28")]
    pub implementation: ::core::option::Option<capability_statement::Implementation>,
    #[prost(message, optional, tag = "29")]
    pub fhir_version: ::core::option::Option<capability_statement::FhirVersionCode>,
    #[prost(message, repeated, tag = "30")]
    pub format: prost::alloc::vec::Vec<capability_statement::FormatCode>,
    #[prost(message, repeated, tag = "31")]
    pub patch_format: prost::alloc::vec::Vec<capability_statement::PatchFormatCode>,
    /// Implementation guides supported
    #[prost(message, repeated, tag = "32")]
    pub implementation_guide: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, repeated, tag = "33")]
    pub rest: prost::alloc::vec::Vec<capability_statement::Rest>,
    #[prost(message, repeated, tag = "34")]
    pub messaging: prost::alloc::vec::Vec<capability_statement::Messaging>,
    #[prost(message, repeated, tag = "35")]
    pub document: prost::alloc::vec::Vec<capability_statement::Document>,
}
/// Nested message and enum types in `CapabilityStatement`.
pub mod capability_statement {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// instance | capability | requirements
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct KindCode {
        #[prost(
            enumeration = "super::capability_statement_kind_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Software that is covered by this capability statement
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Software {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// A name the software is known by
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Version covered by this statement
        #[prost(message, optional, tag = "5")]
        pub version: ::core::option::Option<super::String>,
        /// Date this version was released
        #[prost(message, optional, tag = "6")]
        pub release_date: ::core::option::Option<super::DateTime>,
    }
    /// If this describes a specific instance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Implementation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Describes this specific instance
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Base URL for the installation
        #[prost(message, optional, tag = "5")]
        pub url: ::core::option::Option<super::Url>,
        /// Organization that manages the data
        #[prost(message, optional, tag = "6")]
        pub custodian: ::core::option::Option<super::Reference>,
    }
    /// FHIR Version the system supports
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FhirVersionCode {
        #[prost(enumeration = "super::fhir_version_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// formats supported (xml | json | ttl | mime type)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FormatCode {
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// This valueset is not enumerable, and so is represented as a string.
        #[prost(string, tag = "4")]
        pub value: prost::alloc::string::String,
    }
    /// Patch formats supported
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PatchFormatCode {
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// This valueset is not enumerable, and so is represented as a string.
        #[prost(string, tag = "4")]
        pub value: prost::alloc::string::String,
    }
    /// If the endpoint is a RESTful one
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Rest {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub mode: ::core::option::Option<rest::ModeCode>,
        /// General description of implementation
        #[prost(message, optional, tag = "5")]
        pub documentation: ::core::option::Option<super::Markdown>,
        #[prost(message, optional, tag = "6")]
        pub security: ::core::option::Option<rest::Security>,
        #[prost(message, repeated, tag = "7")]
        pub resource: prost::alloc::vec::Vec<rest::Resource>,
        #[prost(message, repeated, tag = "8")]
        pub interaction: prost::alloc::vec::Vec<rest::SystemInteraction>,
        /// Search parameters for searching all resources
        #[prost(message, repeated, tag = "9")]
        pub search_param: prost::alloc::vec::Vec<rest::resource::SearchParam>,
        /// Definition of a system level operation
        #[prost(message, repeated, tag = "10")]
        pub operation: prost::alloc::vec::Vec<rest::resource::Operation>,
        /// Compartments served/used by system
        #[prost(message, repeated, tag = "11")]
        pub compartment: prost::alloc::vec::Vec<super::Canonical>,
    }
    /// Nested message and enum types in `Rest`.
    pub mod rest {
        /// client | server
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ModeCode {
            #[prost(
                enumeration = "super::super::restful_capability_mode_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Information about security of implementation
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Security {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Adds CORS Headers (<http://enable-cors.org/>)
            #[prost(message, optional, tag = "4")]
            pub cors: ::core::option::Option<super::super::Boolean>,
            /// OAuth | SMART-on-FHIR | NTLM | Basic | Kerberos | Certificates
            #[prost(message, repeated, tag = "5")]
            pub service: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// General description of how security works
            #[prost(message, optional, tag = "6")]
            pub description: ::core::option::Option<super::super::Markdown>,
        }
        /// Resource served on the REST interface
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Resource {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<resource::TypeCode>,
            /// Base System profile for all uses of resource
            #[prost(message, optional, tag = "5")]
            pub profile: ::core::option::Option<super::super::Canonical>,
            /// Profiles for use cases supported
            #[prost(message, repeated, tag = "6")]
            pub supported_profile: prost::alloc::vec::Vec<super::super::Canonical>,
            /// Additional information about the use of the resource type
            #[prost(message, optional, tag = "7")]
            pub documentation: ::core::option::Option<super::super::Markdown>,
            #[prost(message, repeated, tag = "8")]
            pub interaction: prost::alloc::vec::Vec<resource::ResourceInteraction>,
            #[prost(message, optional, tag = "9")]
            pub versioning: ::core::option::Option<resource::VersioningCode>,
            /// Whether vRead can return past versions
            #[prost(message, optional, tag = "10")]
            pub read_history: ::core::option::Option<super::super::Boolean>,
            /// If update can commit to a new identity
            #[prost(message, optional, tag = "11")]
            pub update_create: ::core::option::Option<super::super::Boolean>,
            /// If allows/uses conditional create
            #[prost(message, optional, tag = "12")]
            pub conditional_create: ::core::option::Option<super::super::Boolean>,
            #[prost(message, optional, tag = "13")]
            pub conditional_read: ::core::option::Option<resource::ConditionalReadCode>,
            /// If allows/uses conditional update
            #[prost(message, optional, tag = "14")]
            pub conditional_update: ::core::option::Option<super::super::Boolean>,
            #[prost(message, optional, tag = "15")]
            pub conditional_delete: ::core::option::Option<resource::ConditionalDeleteCode>,
            #[prost(message, repeated, tag = "16")]
            pub reference_policy: prost::alloc::vec::Vec<resource::ReferencePolicyCode>,
            /// _include values supported by the server
            #[prost(message, repeated, tag = "17")]
            pub search_include: prost::alloc::vec::Vec<super::super::String>,
            /// _revinclude values supported by the server
            #[prost(message, repeated, tag = "18")]
            pub search_rev_include: prost::alloc::vec::Vec<super::super::String>,
            #[prost(message, repeated, tag = "19")]
            pub search_param: prost::alloc::vec::Vec<resource::SearchParam>,
            #[prost(message, repeated, tag = "20")]
            pub operation: prost::alloc::vec::Vec<resource::Operation>,
        }
        /// Nested message and enum types in `Resource`.
        pub mod resource {
            /// A resource type that is supported
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct TypeCode {
                #[prost(
                    enumeration = "super::super::super::resource_type_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// What operations are supported?
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ResourceInteraction {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                #[prost(message, optional, tag = "4")]
                pub code: ::core::option::Option<resource_interaction::CodeType>,
                /// Anything special about operation behavior
                #[prost(message, optional, tag = "5")]
                pub documentation: ::core::option::Option<super::super::super::Markdown>,
            }
            /// Nested message and enum types in `ResourceInteraction`.
            pub mod resource_interaction {
                /// read | vread | update | patch | delete | history-instance |
                /// history-type | create | search-type
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct CodeType {
                    #[prost(
                        enumeration = "super::super::super::super::type_restful_interaction_value_set::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
            }
            /// no-version | versioned | versioned-update
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct VersioningCode {
                #[prost(
                    enumeration = "super::super::super::resource_version_policy_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// not-supported | modified-since | not-match | full-support
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ConditionalReadCode {
                #[prost(
                    enumeration = "super::super::super::conditional_read_status_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// not-supported | single | multiple - how conditional delete is supported
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ConditionalDeleteCode {
                #[prost(
                    enumeration = "super::super::super::conditional_delete_status_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// literal | logical | resolves | enforced | local
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ReferencePolicyCode {
                #[prost(
                    enumeration = "super::super::super::reference_handling_policy_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// Search parameters supported by implementation
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct SearchParam {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Name of search parameter
                #[prost(message, optional, tag = "4")]
                pub name: ::core::option::Option<super::super::super::String>,
                /// Source of definition for parameter
                #[prost(message, optional, tag = "5")]
                pub definition: ::core::option::Option<super::super::super::Canonical>,
                #[prost(message, optional, tag = "6")]
                pub r#type: ::core::option::Option<search_param::TypeCode>,
                /// Server-specific usage
                #[prost(message, optional, tag = "7")]
                pub documentation: ::core::option::Option<super::super::super::Markdown>,
            }
            /// Nested message and enum types in `SearchParam`.
            pub mod search_param {
                /// number | date | string | token | reference | composite | quantity |
                /// uri | special
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct TypeCode {
                    #[prost(
                        enumeration = "super::super::super::super::search_param_type_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
            }
            /// Definition of a resource operation
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Operation {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Name by which the operation/query is invoked
                #[prost(message, optional, tag = "4")]
                pub name: ::core::option::Option<super::super::super::String>,
                /// The defined operation/query
                #[prost(message, optional, tag = "5")]
                pub definition: ::core::option::Option<super::super::super::Canonical>,
                /// Specific details about operation behavior
                #[prost(message, optional, tag = "6")]
                pub documentation: ::core::option::Option<super::super::super::Markdown>,
            }
        }
        /// What operations are supported?
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SystemInteraction {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<system_interaction::CodeType>,
            /// Anything special about operation behavior
            #[prost(message, optional, tag = "5")]
            pub documentation: ::core::option::Option<super::super::Markdown>,
        }
        /// Nested message and enum types in `SystemInteraction`.
        pub mod system_interaction {
            /// transaction | batch | search-system | history-system
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct CodeType {
                #[prost(
                    enumeration = "super::super::super::system_restful_interaction_value_set::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
    }
    /// If messaging is supported
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Messaging {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub endpoint: prost::alloc::vec::Vec<messaging::Endpoint>,
        /// Reliable Message Cache Length (min)
        #[prost(message, optional, tag = "5")]
        pub reliable_cache: ::core::option::Option<super::UnsignedInt>,
        /// Messaging interface behavior details
        #[prost(message, optional, tag = "6")]
        pub documentation: ::core::option::Option<super::Markdown>,
        #[prost(message, repeated, tag = "7")]
        pub supported_message: prost::alloc::vec::Vec<messaging::SupportedMessage>,
    }
    /// Nested message and enum types in `Messaging`.
    pub mod messaging {
        /// Where messages should be sent
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Endpoint {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// http | ftp | mllp +
            #[prost(message, optional, tag = "4")]
            pub protocol: ::core::option::Option<super::super::Coding>,
            /// Network address or identifier of the end-point
            #[prost(message, optional, tag = "5")]
            pub address: ::core::option::Option<super::super::Url>,
        }
        /// Messages supported by this system
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SupportedMessage {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub mode: ::core::option::Option<supported_message::ModeCode>,
            /// Message supported by this system
            #[prost(message, optional, tag = "5")]
            pub definition: ::core::option::Option<super::super::Canonical>,
        }
        /// Nested message and enum types in `SupportedMessage`.
        pub mod supported_message {
            /// sender | receiver
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ModeCode {
                #[prost(
                    enumeration = "super::super::super::event_capability_mode_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
    }
    /// Document definition
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Document {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub mode: ::core::option::Option<document::ModeCode>,
        /// Description of document support
        #[prost(message, optional, tag = "5")]
        pub documentation: ::core::option::Option<super::Markdown>,
        /// Constraint on the resources used in the document
        #[prost(message, optional, tag = "6")]
        pub profile: ::core::option::Option<super::Canonical>,
    }
    /// Nested message and enum types in `Document`.
    pub mod document {
        /// producer | consumer
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ModeCode {
            #[prost(enumeration = "super::super::document_mode_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for CarePlan, last updated
/// 2019-11-01T09:29:23.356+11:00. Healthcare plan for patient or group. See
/// <http://hl7.org/fhir/StructureDefinition/CarePlan>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CarePlan {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this plan
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates FHIR protocol or definition
    #[prost(message, repeated, tag = "11")]
    pub instantiates_canonical: prost::alloc::vec::Vec<Canonical>,
    /// Instantiates external protocol or definition
    #[prost(message, repeated, tag = "12")]
    pub instantiates_uri: prost::alloc::vec::Vec<Uri>,
    /// Fulfills CarePlan
    #[prost(message, repeated, tag = "13")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// CarePlan replaced by this CarePlan
    #[prost(message, repeated, tag = "14")]
    pub replaces: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced CarePlan
    #[prost(message, repeated, tag = "15")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<care_plan::StatusCode>,
    #[prost(message, optional, tag = "17")]
    pub intent: ::core::option::Option<care_plan::IntentCode>,
    /// Type of plan
    #[prost(message, repeated, tag = "18")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Human-friendly name for the care plan
    #[prost(message, optional, tag = "19")]
    pub title: ::core::option::Option<String>,
    /// Summary of nature of plan
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<String>,
    /// Who the care plan is for
    #[prost(message, optional, tag = "21")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter created as part of
    #[prost(message, optional, tag = "22")]
    pub encounter: ::core::option::Option<Reference>,
    /// Time period plan covers
    #[prost(message, optional, tag = "23")]
    pub period: ::core::option::Option<Period>,
    /// Date record was first recorded
    #[prost(message, optional, tag = "24")]
    pub created: ::core::option::Option<DateTime>,
    /// Who is the designated responsible party
    #[prost(message, optional, tag = "25")]
    pub author: ::core::option::Option<Reference>,
    /// Who provided the content of the care plan
    #[prost(message, repeated, tag = "26")]
    pub contributor: prost::alloc::vec::Vec<Reference>,
    /// Who's involved in plan?
    #[prost(message, repeated, tag = "27")]
    pub care_team: prost::alloc::vec::Vec<Reference>,
    /// Health issues this plan addresses
    #[prost(message, repeated, tag = "28")]
    pub addresses: prost::alloc::vec::Vec<Reference>,
    /// Information considered as part of plan
    #[prost(message, repeated, tag = "29")]
    pub supporting_info: prost::alloc::vec::Vec<Reference>,
    /// Desired outcome of plan
    #[prost(message, repeated, tag = "30")]
    pub goal: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "31")]
    pub activity: prost::alloc::vec::Vec<care_plan::Activity>,
    /// Comments about the plan
    #[prost(message, repeated, tag = "32")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `CarePlan`.
pub mod care_plan {
    /// draft | active | on-hold | revoked | completed | entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::request_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// proposal | plan | order | option
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct IntentCode {
        #[prost(enumeration = "super::care_plan_intent_value_set::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Action to occur as part of plan
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Activity {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Results of the activity
        #[prost(message, repeated, tag = "4")]
        pub outcome_codeable_concept: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Appointment, Encounter, Procedure, etc.
        #[prost(message, repeated, tag = "5")]
        pub outcome_reference: prost::alloc::vec::Vec<super::Reference>,
        /// Comments about the activity status/progress
        #[prost(message, repeated, tag = "6")]
        pub progress: prost::alloc::vec::Vec<super::Annotation>,
        /// Activity details defined in specific resource
        #[prost(message, optional, tag = "7")]
        pub reference: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "8")]
        pub detail: ::core::option::Option<activity::Detail>,
    }
    /// Nested message and enum types in `Activity`.
    pub mod activity {
        /// In-line definition of activity
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Detail {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub kind: ::core::option::Option<detail::KindCode>,
            /// Instantiates FHIR protocol or definition
            #[prost(message, repeated, tag = "5")]
            pub instantiates_canonical: prost::alloc::vec::Vec<super::super::Canonical>,
            /// Instantiates external protocol or definition
            #[prost(message, repeated, tag = "6")]
            pub instantiates_uri: prost::alloc::vec::Vec<super::super::Uri>,
            /// Detail type of activity
            #[prost(message, optional, tag = "7")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// Why activity should be done or why activity was prohibited
            #[prost(message, repeated, tag = "8")]
            pub reason_code: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Why activity is needed
            #[prost(message, repeated, tag = "9")]
            pub reason_reference: prost::alloc::vec::Vec<super::super::Reference>,
            /// Goals this activity relates to
            #[prost(message, repeated, tag = "10")]
            pub goal: prost::alloc::vec::Vec<super::super::Reference>,
            #[prost(message, optional, tag = "11")]
            pub status: ::core::option::Option<detail::StatusCode>,
            /// Reason for current status
            #[prost(message, optional, tag = "12")]
            pub status_reason: ::core::option::Option<super::super::CodeableConcept>,
            /// If true, activity is prohibiting action
            #[prost(message, optional, tag = "13")]
            pub do_not_perform: ::core::option::Option<super::super::Boolean>,
            #[prost(message, optional, tag = "14")]
            pub scheduled: ::core::option::Option<detail::ScheduledX>,
            /// Where it should happen
            #[prost(message, optional, tag = "15")]
            pub location: ::core::option::Option<super::super::Reference>,
            /// Who will be responsible?
            #[prost(message, repeated, tag = "16")]
            pub performer: prost::alloc::vec::Vec<super::super::Reference>,
            #[prost(message, optional, tag = "17")]
            pub product: ::core::option::Option<detail::ProductX>,
            /// How to consume/day?
            #[prost(message, optional, tag = "18")]
            pub daily_amount: ::core::option::Option<super::super::SimpleQuantity>,
            /// How much to administer/supply/consume
            #[prost(message, optional, tag = "19")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// Extra info describing activity to perform
            #[prost(message, optional, tag = "20")]
            pub description: ::core::option::Option<super::super::String>,
        }
        /// Nested message and enum types in `Detail`.
        pub mod detail {
            /// Appointment | CommunicationRequest | DeviceRequest | MedicationRequest
            /// | NutritionOrder | Task | ServiceRequest | VisionPrescription
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct KindCode {
                #[prost(
                    enumeration = "super::super::super::care_plan_activity_kind_value_set::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// not-started | scheduled | in-progress | on-hold | completed | cancelled
            /// | stopped | unknown | entered-in-error
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct StatusCode {
                #[prost(
                    enumeration = "super::super::super::care_plan_activity_status_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// When activity is to occur
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ScheduledX {
                #[prost(oneof = "scheduled_x::Choice", tags = "1, 2, 3")]
                pub choice: ::core::option::Option<scheduled_x::Choice>,
            }
            /// Nested message and enum types in `ScheduledX`.
            pub mod scheduled_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Timing(super::super::super::super::Timing),
                    #[prost(message, tag = "2")]
                    Period(super::super::super::super::Period),
                    #[prost(message, tag = "3")]
                    StringValue(super::super::super::super::String),
                }
            }
            /// What is to be administered/supplied
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ProductX {
                #[prost(oneof = "product_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<product_x::Choice>,
            }
            /// Nested message and enum types in `ProductX`.
            pub mod product_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    CodeableConcept(super::super::super::super::CodeableConcept),
                    #[prost(message, tag = "2")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for CareTeam, last updated
/// 2019-11-01T09:29:23.356+11:00. Planned participants in the coordination and
/// delivery of care for a patient or group. See
/// <http://hl7.org/fhir/StructureDefinition/CareTeam>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CareTeam {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this team
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<care_team::StatusCode>,
    /// Type of team
    #[prost(message, repeated, tag = "12")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Name of the team, such as crisis assessment team
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Who care team is for
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter created as part of
    #[prost(message, optional, tag = "15")]
    pub encounter: ::core::option::Option<Reference>,
    /// Time period team covers
    #[prost(message, optional, tag = "16")]
    pub period: ::core::option::Option<Period>,
    #[prost(message, repeated, tag = "17")]
    pub participant: prost::alloc::vec::Vec<care_team::Participant>,
    /// Why the care team exists
    #[prost(message, repeated, tag = "18")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why the care team exists
    #[prost(message, repeated, tag = "19")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Organization responsible for the care team
    #[prost(message, repeated, tag = "20")]
    pub managing_organization: prost::alloc::vec::Vec<Reference>,
    /// A contact detail for the care team (that applies to all members)
    #[prost(message, repeated, tag = "21")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// Comments made about the CareTeam
    #[prost(message, repeated, tag = "22")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `CareTeam`.
pub mod care_team {
    /// proposed | active | suspended | inactive | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::care_team_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Members of the team
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of involvement
        #[prost(message, repeated, tag = "4")]
        pub role: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Who is involved
        #[prost(message, optional, tag = "5")]
        pub member: ::core::option::Option<super::Reference>,
        /// Organization of the practitioner
        #[prost(message, optional, tag = "6")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
        /// Time period of participant
        #[prost(message, optional, tag = "7")]
        pub period: ::core::option::Option<super::Period>,
    }
}
/// Auto-generated from StructureDefinition for CatalogEntry, last updated
/// 2019-11-01T09:29:23.356+11:00. An entry in a catalog. See
/// <http://hl7.org/fhir/StructureDefinition/CatalogEntry>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CatalogEntry {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier of the catalog item
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// The type of item - medication, device, service, protocol or other
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Whether the entry represents an orderable item
    #[prost(message, optional, tag = "12")]
    pub orderable: ::core::option::Option<Boolean>,
    /// The item that is being defined
    #[prost(message, optional, tag = "13")]
    pub referenced_item: ::core::option::Option<Reference>,
    /// Any additional identifier(s) for the catalog item, in the same granularity
    /// or concept
    #[prost(message, repeated, tag = "14")]
    pub additional_identifier: prost::alloc::vec::Vec<Identifier>,
    /// Classification (category or class) of the item entry
    #[prost(message, repeated, tag = "15")]
    pub classification: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<catalog_entry::StatusCode>,
    /// The time period in which this catalog entry is expected to be active
    #[prost(message, optional, tag = "17")]
    pub validity_period: ::core::option::Option<Period>,
    /// The date until which this catalog entry is expected to be active
    #[prost(message, optional, tag = "18")]
    pub valid_to: ::core::option::Option<DateTime>,
    /// When was this catalog last updated
    #[prost(message, optional, tag = "19")]
    pub last_updated: ::core::option::Option<DateTime>,
    /// Additional characteristics of the catalog entry
    #[prost(message, repeated, tag = "20")]
    pub additional_characteristic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Additional classification of the catalog entry
    #[prost(message, repeated, tag = "21")]
    pub additional_classification: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "22")]
    pub related_entry: prost::alloc::vec::Vec<catalog_entry::RelatedEntry>,
}
/// Nested message and enum types in `CatalogEntry`.
pub mod catalog_entry {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// An item that this catalog entry is related to
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelatedEntry {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub relationtype: ::core::option::Option<related_entry::RelationtypeCode>,
        /// The reference to the related item
        #[prost(message, optional, tag = "5")]
        pub item: ::core::option::Option<super::Reference>,
    }
    /// Nested message and enum types in `RelatedEntry`.
    pub mod related_entry {
        /// triggers | is-replaced-by
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RelationtypeCode {
            #[prost(
                enumeration = "super::super::catalog_entry_relation_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for ChargeItem, last updated
/// 2019-11-01T09:29:23.356+11:00. Item containing charge code(s) associated with
/// the provision of healthcare provider products. See
/// <http://hl7.org/fhir/StructureDefinition/ChargeItem>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ChargeItem {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for item
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Defining information about the code of this charge item
    #[prost(message, repeated, tag = "11")]
    pub definition_uri: prost::alloc::vec::Vec<Uri>,
    /// Resource defining the code of this ChargeItem
    #[prost(message, repeated, tag = "12")]
    pub definition_canonical: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<charge_item::StatusCode>,
    /// Part of referenced ChargeItem
    #[prost(message, repeated, tag = "14")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// A code that identifies the charge, like a billing code
    #[prost(message, optional, tag = "15")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Individual service was done for/to
    #[prost(message, optional, tag = "16")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter / Episode associated with event
    #[prost(message, optional, tag = "17")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "18")]
    pub occurrence: ::core::option::Option<charge_item::OccurrenceX>,
    #[prost(message, repeated, tag = "19")]
    pub performer: prost::alloc::vec::Vec<charge_item::Performer>,
    /// Organization providing the charged service
    #[prost(message, optional, tag = "20")]
    pub performing_organization: ::core::option::Option<Reference>,
    /// Organization requesting the charged service
    #[prost(message, optional, tag = "21")]
    pub requesting_organization: ::core::option::Option<Reference>,
    /// Organization that has ownership of the (potential, future) revenue
    #[prost(message, optional, tag = "22")]
    pub cost_center: ::core::option::Option<Reference>,
    /// Quantity of which the charge item has been serviced
    #[prost(message, optional, tag = "23")]
    pub quantity: ::core::option::Option<Quantity>,
    /// Anatomical location, if relevant
    #[prost(message, repeated, tag = "24")]
    pub bodysite: prost::alloc::vec::Vec<CodeableConcept>,
    /// Factor overriding the associated rules
    #[prost(message, optional, tag = "25")]
    pub factor_override: ::core::option::Option<Decimal>,
    /// Price overriding the associated rules
    #[prost(message, optional, tag = "26")]
    pub price_override: ::core::option::Option<Money>,
    /// Reason for overriding the list price/factor
    #[prost(message, optional, tag = "27")]
    pub override_reason: ::core::option::Option<String>,
    /// Individual who was entering
    #[prost(message, optional, tag = "28")]
    pub enterer: ::core::option::Option<Reference>,
    /// Date the charge item was entered
    #[prost(message, optional, tag = "29")]
    pub entered_date: ::core::option::Option<DateTime>,
    /// Why was the charged  service rendered?
    #[prost(message, repeated, tag = "30")]
    pub reason: prost::alloc::vec::Vec<CodeableConcept>,
    /// Which rendered service is being charged?
    #[prost(message, repeated, tag = "31")]
    pub service: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "32")]
    pub product: ::core::option::Option<charge_item::ProductX>,
    /// Account to place this charge
    #[prost(message, repeated, tag = "33")]
    pub account: prost::alloc::vec::Vec<Reference>,
    /// Comments made about the ChargeItem
    #[prost(message, repeated, tag = "34")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Further information supporting this charge
    #[prost(message, repeated, tag = "35")]
    pub supporting_information: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `ChargeItem`.
pub mod charge_item {
    /// planned | billable | not-billable | aborted | billed | entered-in-error |
    /// unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::charge_item_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// When the charged service was applied
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OccurrenceX {
        #[prost(oneof = "occurrence_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<occurrence_x::Choice>,
    }
    /// Nested message and enum types in `OccurrenceX`.
    pub mod occurrence_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
        }
    }
    /// Who performed charged service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Performer {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// What type of performance was done
        #[prost(message, optional, tag = "4")]
        pub function: ::core::option::Option<super::CodeableConcept>,
        /// Individual who was performing
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
    }
    /// Product charged
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ProductX {
        #[prost(oneof = "product_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<product_x::Choice>,
    }
    /// Nested message and enum types in `ProductX`.
    pub mod product_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Reference(super::super::Reference),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
}
/// Auto-generated from StructureDefinition for ChargeItemDefinition, last
/// updated 2019-11-01T09:29:23.356+11:00. Definition of properties and rules
/// about how the price and the applicability of a ChargeItem can be determined.
/// See <http://hl7.org/fhir/StructureDefinition/ChargeItemDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ChargeItemDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this charge item definition, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the charge item definition
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the charge item definition
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this charge item definition (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// Underlying externally-defined charge item definition
    #[prost(message, repeated, tag = "14")]
    pub derived_from_uri: prost::alloc::vec::Vec<Uri>,
    /// A larger definition of which this particular definition is a component or
    /// step
    #[prost(message, repeated, tag = "15")]
    pub part_of: prost::alloc::vec::Vec<Canonical>,
    /// Completed or terminated request(s) whose function is taken by this new
    /// request
    #[prost(message, repeated, tag = "16")]
    pub replaces: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, optional, tag = "17")]
    pub status: ::core::option::Option<charge_item_definition::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "18")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "19")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "20")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "21")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the charge item definition
    #[prost(message, optional, tag = "22")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "23")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for charge item definition (if applicable)
    #[prost(message, repeated, tag = "24")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "25")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the charge item definition was approved by publisher
    #[prost(message, optional, tag = "26")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the charge item definition was last reviewed
    #[prost(message, optional, tag = "27")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the charge item definition is expected to be used
    #[prost(message, optional, tag = "28")]
    pub effective_period: ::core::option::Option<Period>,
    /// Billing codes or product types this definition applies to
    #[prost(message, optional, tag = "29")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Instances this definition applies to
    #[prost(message, repeated, tag = "30")]
    pub instance: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "31")]
    pub applicability: prost::alloc::vec::Vec<charge_item_definition::Applicability>,
    #[prost(message, repeated, tag = "32")]
    pub property_group: prost::alloc::vec::Vec<charge_item_definition::PropertyGroup>,
}
/// Nested message and enum types in `ChargeItemDefinition`.
pub mod charge_item_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Whether or not the billing code is applicable
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Applicability {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Natural language description of the condition
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Language of the expression
        #[prost(message, optional, tag = "5")]
        pub language: ::core::option::Option<super::String>,
        /// Boolean-valued expression
        #[prost(message, optional, tag = "6")]
        pub expression: ::core::option::Option<super::String>,
    }
    /// Group of properties which are applicable under the same conditions
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PropertyGroup {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Conditions under which the priceComponent is applicable
        #[prost(message, repeated, tag = "4")]
        pub applicability: prost::alloc::vec::Vec<Applicability>,
        #[prost(message, repeated, tag = "5")]
        pub price_component: prost::alloc::vec::Vec<property_group::PriceComponent>,
    }
    /// Nested message and enum types in `PropertyGroup`.
    pub mod property_group {
        /// Components of total line item price
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PriceComponent {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<price_component::TypeCode>,
            /// Code identifying the specific component
            #[prost(message, optional, tag = "5")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// Factor used for calculating this component
            #[prost(message, optional, tag = "6")]
            pub factor: ::core::option::Option<super::super::Decimal>,
            /// Monetary amount associated with this component
            #[prost(message, optional, tag = "7")]
            pub amount: ::core::option::Option<super::super::Money>,
        }
        /// Nested message and enum types in `PriceComponent`.
        pub mod price_component {
            /// base | surcharge | deduction | discount | tax | informational
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct TypeCode {
                #[prost(
                    enumeration = "super::super::super::invoice_price_component_type_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Claim, last updated
/// 2019-11-01T09:29:23.356+11:00. Claim, Pre-determination or Pre-authorization.
/// See <http://hl7.org/fhir/StructureDefinition/Claim>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Claim {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for claim
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<claim::StatusCode>,
    /// Category or discipline
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// More granular claim type
    #[prost(message, optional, tag = "13")]
    pub sub_type: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "14")]
    pub r#use: ::core::option::Option<claim::UseCode>,
    /// The recipient of the products and services
    #[prost(message, optional, tag = "15")]
    pub patient: ::core::option::Option<Reference>,
    /// Relevant time frame for the claim
    #[prost(message, optional, tag = "16")]
    pub billable_period: ::core::option::Option<Period>,
    /// Resource creation date
    #[prost(message, optional, tag = "17")]
    pub created: ::core::option::Option<DateTime>,
    /// Author of the claim
    #[prost(message, optional, tag = "18")]
    pub enterer: ::core::option::Option<Reference>,
    /// Target
    #[prost(message, optional, tag = "19")]
    pub insurer: ::core::option::Option<Reference>,
    /// Party responsible for the claim
    #[prost(message, optional, tag = "20")]
    pub provider: ::core::option::Option<Reference>,
    /// Desired processing ugency
    #[prost(message, optional, tag = "21")]
    pub priority: ::core::option::Option<CodeableConcept>,
    /// For whom to reserve funds
    #[prost(message, optional, tag = "22")]
    pub funds_reserve: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "23")]
    pub related: prost::alloc::vec::Vec<claim::RelatedClaim>,
    /// Prescription authorizing services and products
    #[prost(message, optional, tag = "24")]
    pub prescription: ::core::option::Option<Reference>,
    /// Original prescription if superseded by fulfiller
    #[prost(message, optional, tag = "25")]
    pub original_prescription: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "26")]
    pub payee: ::core::option::Option<claim::Payee>,
    /// Treatment referral
    #[prost(message, optional, tag = "27")]
    pub referral: ::core::option::Option<Reference>,
    /// Servicing facility
    #[prost(message, optional, tag = "28")]
    pub facility: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "29")]
    pub care_team: prost::alloc::vec::Vec<claim::CareTeam>,
    #[prost(message, repeated, tag = "30")]
    pub supporting_info: prost::alloc::vec::Vec<claim::SupportingInformation>,
    #[prost(message, repeated, tag = "31")]
    pub diagnosis: prost::alloc::vec::Vec<claim::Diagnosis>,
    #[prost(message, repeated, tag = "32")]
    pub procedure: prost::alloc::vec::Vec<claim::Procedure>,
    #[prost(message, repeated, tag = "33")]
    pub insurance: prost::alloc::vec::Vec<claim::Insurance>,
    #[prost(message, optional, tag = "34")]
    pub accident: ::core::option::Option<claim::Accident>,
    #[prost(message, repeated, tag = "35")]
    pub item: prost::alloc::vec::Vec<claim::Item>,
    /// Total claim cost
    #[prost(message, optional, tag = "36")]
    pub total: ::core::option::Option<Money>,
}
/// Nested message and enum types in `Claim`.
pub mod claim {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::financial_resource_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// claim | preauthorization | predetermination
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UseCode {
        #[prost(enumeration = "super::use_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Prior or corollary claims
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelatedClaim {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to the related claim
        #[prost(message, optional, tag = "4")]
        pub claim: ::core::option::Option<super::Reference>,
        /// How the reference claim is related
        #[prost(message, optional, tag = "5")]
        pub relationship: ::core::option::Option<super::CodeableConcept>,
        /// File or case reference
        #[prost(message, optional, tag = "6")]
        pub reference: ::core::option::Option<super::Identifier>,
    }
    /// Recipient of benefits payable
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payee {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Category of recipient
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Recipient reference
        #[prost(message, optional, tag = "5")]
        pub party: ::core::option::Option<super::Reference>,
    }
    /// Members of the care team
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CareTeam {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Order of care team
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Practitioner or organization
        #[prost(message, optional, tag = "5")]
        pub provider: ::core::option::Option<super::Reference>,
        /// Indicator of the lead practitioner
        #[prost(message, optional, tag = "6")]
        pub responsible: ::core::option::Option<super::Boolean>,
        /// Function within the team
        #[prost(message, optional, tag = "7")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Practitioner credential or specialization
        #[prost(message, optional, tag = "8")]
        pub qualification: ::core::option::Option<super::CodeableConcept>,
    }
    /// Supporting information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SupportingInformation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Information instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Classification of the supplied information
        #[prost(message, optional, tag = "5")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Type of information
        #[prost(message, optional, tag = "6")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "7")]
        pub timing: ::core::option::Option<supporting_information::TimingX>,
        #[prost(message, optional, tag = "8")]
        pub value: ::core::option::Option<supporting_information::ValueX>,
        /// Explanation for the information
        #[prost(message, optional, tag = "9")]
        pub reason: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `SupportingInformation`.
    pub mod supporting_information {
        /// When it occurred
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimingX {
            #[prost(oneof = "timing_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<timing_x::Choice>,
        }
        /// Nested message and enum types in `TimingX`.
        pub mod timing_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Data to be provided
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5")]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "2")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "3")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "4")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "5")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Pertinent diagnosis information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Diagnosis {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Diagnosis instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        #[prost(message, optional, tag = "5")]
        pub diagnosis: ::core::option::Option<diagnosis::DiagnosisX>,
        /// Timing or nature of the diagnosis
        #[prost(message, repeated, tag = "6")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Present on admission
        #[prost(message, optional, tag = "7")]
        pub on_admission: ::core::option::Option<super::CodeableConcept>,
        /// Package billing code
        #[prost(message, optional, tag = "8")]
        pub package_code: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Diagnosis`.
    pub mod diagnosis {
        /// Nature of illness or problem
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DiagnosisX {
            #[prost(oneof = "diagnosis_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<diagnosis_x::Choice>,
        }
        /// Nested message and enum types in `DiagnosisX`.
        pub mod diagnosis_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Clinical procedures performed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Procedure {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Procedure instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Category of Procedure
        #[prost(message, repeated, tag = "5")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// When the procedure was performed
        #[prost(message, optional, tag = "6")]
        pub date: ::core::option::Option<super::DateTime>,
        #[prost(message, optional, tag = "7")]
        pub procedure: ::core::option::Option<procedure::ProcedureX>,
        /// Unique device identifier
        #[prost(message, repeated, tag = "8")]
        pub udi: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Nested message and enum types in `Procedure`.
    pub mod procedure {
        /// Specific clinical procedure
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ProcedureX {
            #[prost(oneof = "procedure_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<procedure_x::Choice>,
        }
        /// Nested message and enum types in `ProcedureX`.
        pub mod procedure_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Patient insurance information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Insurance {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Insurance instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Coverage to be used for adjudication
        #[prost(message, optional, tag = "5")]
        pub focal: ::core::option::Option<super::Boolean>,
        /// Pre-assigned Claim number
        #[prost(message, optional, tag = "6")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Insurance information
        #[prost(message, optional, tag = "7")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// Additional provider contract number
        #[prost(message, optional, tag = "8")]
        pub business_arrangement: ::core::option::Option<super::String>,
        /// Prior authorization reference number
        #[prost(message, repeated, tag = "9")]
        pub pre_auth_ref: prost::alloc::vec::Vec<super::String>,
        /// Adjudication results
        #[prost(message, optional, tag = "10")]
        pub claim_response: ::core::option::Option<super::Reference>,
    }
    /// Details of the event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Accident {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// When the incident occurred
        #[prost(message, optional, tag = "4")]
        pub date: ::core::option::Option<super::Date>,
        /// The nature of the accident
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "6")]
        pub location: ::core::option::Option<accident::LocationX>,
    }
    /// Nested message and enum types in `Accident`.
    pub mod accident {
        /// Where the event occurred
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct LocationX {
            #[prost(oneof = "location_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<location_x::Choice>,
        }
        /// Nested message and enum types in `LocationX`.
        pub mod location_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Address(super::super::super::Address),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Product or service provided
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Item instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Applicable careTeam members
        #[prost(message, repeated, tag = "5")]
        pub care_team_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable diagnoses
        #[prost(message, repeated, tag = "6")]
        pub diagnosis_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable procedures
        #[prost(message, repeated, tag = "7")]
        pub procedure_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable exception and supporting information
        #[prost(message, repeated, tag = "8")]
        pub information_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Revenue or cost center code
        #[prost(message, optional, tag = "9")]
        pub revenue: ::core::option::Option<super::CodeableConcept>,
        /// Benefit classification
        #[prost(message, optional, tag = "10")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Billing, service, product, or drug code
        #[prost(message, optional, tag = "11")]
        pub product_or_service: ::core::option::Option<super::CodeableConcept>,
        /// Product or service billing modifiers
        #[prost(message, repeated, tag = "12")]
        pub modifier: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Program the product or service is provided under
        #[prost(message, repeated, tag = "13")]
        pub program_code: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, optional, tag = "14")]
        pub serviced: ::core::option::Option<item::ServicedX>,
        #[prost(message, optional, tag = "15")]
        pub location: ::core::option::Option<item::LocationX>,
        /// Count of products or services
        #[prost(message, optional, tag = "16")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Fee, charge or cost per item
        #[prost(message, optional, tag = "17")]
        pub unit_price: ::core::option::Option<super::Money>,
        /// Price scaling factor
        #[prost(message, optional, tag = "18")]
        pub factor: ::core::option::Option<super::Decimal>,
        /// Total item cost
        #[prost(message, optional, tag = "19")]
        pub net: ::core::option::Option<super::Money>,
        /// Unique device identifier
        #[prost(message, repeated, tag = "20")]
        pub udi: prost::alloc::vec::Vec<super::Reference>,
        /// Anatomical location
        #[prost(message, optional, tag = "21")]
        pub body_site: ::core::option::Option<super::CodeableConcept>,
        /// Anatomical sub-location
        #[prost(message, repeated, tag = "22")]
        pub sub_site: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Encounters related to this billed item
        #[prost(message, repeated, tag = "23")]
        pub encounter: prost::alloc::vec::Vec<super::Reference>,
        #[prost(message, repeated, tag = "24")]
        pub detail: prost::alloc::vec::Vec<item::Detail>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// Date or dates of service or product delivery
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ServicedX {
            #[prost(oneof = "serviced_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<serviced_x::Choice>,
        }
        /// Nested message and enum types in `ServicedX`.
        pub mod serviced_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Place of service or where product was supplied
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct LocationX {
            #[prost(oneof = "location_x::Choice", tags = "1, 2, 3")]
            pub choice: ::core::option::Option<location_x::Choice>,
        }
        /// Nested message and enum types in `LocationX`.
        pub mod location_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Address(super::super::super::Address),
                #[prost(message, tag = "3")]
                Reference(super::super::super::Reference),
            }
        }
        /// Product or service provided
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Detail {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Item instance identifier
            #[prost(message, optional, tag = "4")]
            pub sequence: ::core::option::Option<super::super::PositiveInt>,
            /// Revenue or cost center code
            #[prost(message, optional, tag = "5")]
            pub revenue: ::core::option::Option<super::super::CodeableConcept>,
            /// Benefit classification
            #[prost(message, optional, tag = "6")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Billing, service, product, or drug code
            #[prost(message, optional, tag = "7")]
            pub product_or_service: ::core::option::Option<super::super::CodeableConcept>,
            /// Service/Product billing modifiers
            #[prost(message, repeated, tag = "8")]
            pub modifier: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Program the product or service is provided under
            #[prost(message, repeated, tag = "9")]
            pub program_code: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Count of products or services
            #[prost(message, optional, tag = "10")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// Fee, charge or cost per item
            #[prost(message, optional, tag = "11")]
            pub unit_price: ::core::option::Option<super::super::Money>,
            /// Price scaling factor
            #[prost(message, optional, tag = "12")]
            pub factor: ::core::option::Option<super::super::Decimal>,
            /// Total item cost
            #[prost(message, optional, tag = "13")]
            pub net: ::core::option::Option<super::super::Money>,
            /// Unique device identifier
            #[prost(message, repeated, tag = "14")]
            pub udi: prost::alloc::vec::Vec<super::super::Reference>,
            #[prost(message, repeated, tag = "15")]
            pub sub_detail: prost::alloc::vec::Vec<detail::SubDetail>,
        }
        /// Nested message and enum types in `Detail`.
        pub mod detail {
            /// Product or service provided
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct SubDetail {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Item instance identifier
                #[prost(message, optional, tag = "4")]
                pub sequence: ::core::option::Option<super::super::super::PositiveInt>,
                /// Revenue or cost center code
                #[prost(message, optional, tag = "5")]
                pub revenue: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Benefit classification
                #[prost(message, optional, tag = "6")]
                pub category: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Billing, service, product, or drug code
                #[prost(message, optional, tag = "7")]
                pub product_or_service:
                    ::core::option::Option<super::super::super::CodeableConcept>,
                /// Service/Product billing modifiers
                #[prost(message, repeated, tag = "8")]
                pub modifier: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Program the product or service is provided under
                #[prost(message, repeated, tag = "9")]
                pub program_code: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Count of products or services
                #[prost(message, optional, tag = "10")]
                pub quantity: ::core::option::Option<super::super::super::SimpleQuantity>,
                /// Fee, charge or cost per item
                #[prost(message, optional, tag = "11")]
                pub unit_price: ::core::option::Option<super::super::super::Money>,
                /// Price scaling factor
                #[prost(message, optional, tag = "12")]
                pub factor: ::core::option::Option<super::super::super::Decimal>,
                /// Total item cost
                #[prost(message, optional, tag = "13")]
                pub net: ::core::option::Option<super::super::super::Money>,
                /// Unique device identifier
                #[prost(message, repeated, tag = "14")]
                pub udi: prost::alloc::vec::Vec<super::super::super::Reference>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for ClaimResponse, last updated
/// 2019-11-01T09:29:23.356+11:00. Response to a claim predetermination or
/// preauthorization. See <http://hl7.org/fhir/StructureDefinition/ClaimResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ClaimResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for a claim response
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<claim_response::StatusCode>,
    /// More granular claim type
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// More granular claim type
    #[prost(message, optional, tag = "13")]
    pub sub_type: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "14")]
    pub r#use: ::core::option::Option<claim_response::UseCode>,
    /// The recipient of the products and services
    #[prost(message, optional, tag = "15")]
    pub patient: ::core::option::Option<Reference>,
    /// Response creation date
    #[prost(message, optional, tag = "16")]
    pub created: ::core::option::Option<DateTime>,
    /// Party responsible for reimbursement
    #[prost(message, optional, tag = "17")]
    pub insurer: ::core::option::Option<Reference>,
    /// Party responsible for the claim
    #[prost(message, optional, tag = "18")]
    pub requestor: ::core::option::Option<Reference>,
    /// Id of resource triggering adjudication
    #[prost(message, optional, tag = "19")]
    pub request: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "20")]
    pub outcome: ::core::option::Option<claim_response::OutcomeCode>,
    /// Disposition Message
    #[prost(message, optional, tag = "21")]
    pub disposition: ::core::option::Option<String>,
    /// Preauthorization reference
    #[prost(message, optional, tag = "22")]
    pub pre_auth_ref: ::core::option::Option<String>,
    /// Preauthorization reference effective period
    #[prost(message, optional, tag = "23")]
    pub pre_auth_period: ::core::option::Option<Period>,
    /// Party to be paid any benefits payable
    #[prost(message, optional, tag = "24")]
    pub payee_type: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "25")]
    pub item: prost::alloc::vec::Vec<claim_response::Item>,
    #[prost(message, repeated, tag = "26")]
    pub add_item: prost::alloc::vec::Vec<claim_response::AddedItem>,
    /// Header-level adjudication
    #[prost(message, repeated, tag = "27")]
    pub adjudication: prost::alloc::vec::Vec<claim_response::item::Adjudication>,
    #[prost(message, repeated, tag = "28")]
    pub total: prost::alloc::vec::Vec<claim_response::Total>,
    #[prost(message, optional, tag = "29")]
    pub payment: ::core::option::Option<claim_response::Payment>,
    /// Funds reserved status
    #[prost(message, optional, tag = "30")]
    pub funds_reserve: ::core::option::Option<CodeableConcept>,
    /// Printed form identifier
    #[prost(message, optional, tag = "31")]
    pub form_code: ::core::option::Option<CodeableConcept>,
    /// Printed reference or actual form
    #[prost(message, optional, tag = "32")]
    pub form: ::core::option::Option<Attachment>,
    #[prost(message, repeated, tag = "33")]
    pub process_note: prost::alloc::vec::Vec<claim_response::Note>,
    /// Request for additional information
    #[prost(message, repeated, tag = "34")]
    pub communication_request: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "35")]
    pub insurance: prost::alloc::vec::Vec<claim_response::Insurance>,
    #[prost(message, repeated, tag = "36")]
    pub error: prost::alloc::vec::Vec<claim_response::Error>,
}
/// Nested message and enum types in `ClaimResponse`.
pub mod claim_response {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::financial_resource_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// claim | preauthorization | predetermination
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UseCode {
        #[prost(enumeration = "super::use_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// queued | complete | error | partial
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OutcomeCode {
        #[prost(enumeration = "super::claim_processing_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Adjudication for claim line items
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Claim item instance identifier
        #[prost(message, optional, tag = "4")]
        pub item_sequence: ::core::option::Option<super::PositiveInt>,
        /// Applicable note numbers
        #[prost(message, repeated, tag = "5")]
        pub note_number: prost::alloc::vec::Vec<super::PositiveInt>,
        #[prost(message, repeated, tag = "6")]
        pub adjudication: prost::alloc::vec::Vec<item::Adjudication>,
        #[prost(message, repeated, tag = "7")]
        pub detail: prost::alloc::vec::Vec<item::ItemDetail>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// Adjudication details
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Adjudication {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of adjudication information
            #[prost(message, optional, tag = "4")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Explanation of adjudication outcome
            #[prost(message, optional, tag = "5")]
            pub reason: ::core::option::Option<super::super::CodeableConcept>,
            /// Monetary amount
            #[prost(message, optional, tag = "6")]
            pub amount: ::core::option::Option<super::super::Money>,
            /// Non-monetary value
            #[prost(message, optional, tag = "7")]
            pub value: ::core::option::Option<super::super::Decimal>,
        }
        /// Adjudication for claim details
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ItemDetail {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Claim detail instance identifier
            #[prost(message, optional, tag = "4")]
            pub detail_sequence: ::core::option::Option<super::super::PositiveInt>,
            /// Applicable note numbers
            #[prost(message, repeated, tag = "5")]
            pub note_number: prost::alloc::vec::Vec<super::super::PositiveInt>,
            /// Detail level adjudication details
            #[prost(message, repeated, tag = "6")]
            pub adjudication: prost::alloc::vec::Vec<Adjudication>,
            #[prost(message, repeated, tag = "7")]
            pub sub_detail: prost::alloc::vec::Vec<item_detail::SubDetail>,
        }
        /// Nested message and enum types in `ItemDetail`.
        pub mod item_detail {
            /// Adjudication for claim sub-details
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct SubDetail {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Claim sub-detail instance identifier
                #[prost(message, optional, tag = "4")]
                pub sub_detail_sequence: ::core::option::Option<super::super::super::PositiveInt>,
                /// Applicable note numbers
                #[prost(message, repeated, tag = "5")]
                pub note_number: prost::alloc::vec::Vec<super::super::super::PositiveInt>,
                /// Subdetail level adjudication details
                #[prost(message, repeated, tag = "6")]
                pub adjudication: prost::alloc::vec::Vec<super::Adjudication>,
            }
        }
    }
    /// Insurer added line items
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AddedItem {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Item sequence number
        #[prost(message, repeated, tag = "4")]
        pub item_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Detail sequence number
        #[prost(message, repeated, tag = "5")]
        pub detail_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Subdetail sequence number
        #[prost(message, repeated, tag = "6")]
        pub subdetail_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Authorized providers
        #[prost(message, repeated, tag = "7")]
        pub provider: prost::alloc::vec::Vec<super::Reference>,
        /// Billing, service, product, or drug code
        #[prost(message, optional, tag = "8")]
        pub product_or_service: ::core::option::Option<super::CodeableConcept>,
        /// Service/Product billing modifiers
        #[prost(message, repeated, tag = "9")]
        pub modifier: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Program the product or service is provided under
        #[prost(message, repeated, tag = "10")]
        pub program_code: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, optional, tag = "11")]
        pub serviced: ::core::option::Option<added_item::ServicedX>,
        #[prost(message, optional, tag = "12")]
        pub location: ::core::option::Option<added_item::LocationX>,
        /// Count of products or services
        #[prost(message, optional, tag = "13")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Fee, charge or cost per item
        #[prost(message, optional, tag = "14")]
        pub unit_price: ::core::option::Option<super::Money>,
        /// Price scaling factor
        #[prost(message, optional, tag = "15")]
        pub factor: ::core::option::Option<super::Decimal>,
        /// Total item cost
        #[prost(message, optional, tag = "16")]
        pub net: ::core::option::Option<super::Money>,
        /// Anatomical location
        #[prost(message, optional, tag = "17")]
        pub body_site: ::core::option::Option<super::CodeableConcept>,
        /// Anatomical sub-location
        #[prost(message, repeated, tag = "18")]
        pub sub_site: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Applicable note numbers
        #[prost(message, repeated, tag = "19")]
        pub note_number: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Added items adjudication
        #[prost(message, repeated, tag = "20")]
        pub adjudication: prost::alloc::vec::Vec<item::Adjudication>,
        #[prost(message, repeated, tag = "21")]
        pub detail: prost::alloc::vec::Vec<added_item::AddedItemDetail>,
    }
    /// Nested message and enum types in `AddedItem`.
    pub mod added_item {
        /// Date or dates of service or product delivery
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ServicedX {
            #[prost(oneof = "serviced_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<serviced_x::Choice>,
        }
        /// Nested message and enum types in `ServicedX`.
        pub mod serviced_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Place of service or where product was supplied
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct LocationX {
            #[prost(oneof = "location_x::Choice", tags = "1, 2, 3")]
            pub choice: ::core::option::Option<location_x::Choice>,
        }
        /// Nested message and enum types in `LocationX`.
        pub mod location_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Address(super::super::super::Address),
                #[prost(message, tag = "3")]
                Reference(super::super::super::Reference),
            }
        }
        /// Insurer added line details
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AddedItemDetail {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Billing, service, product, or drug code
            #[prost(message, optional, tag = "4")]
            pub product_or_service: ::core::option::Option<super::super::CodeableConcept>,
            /// Service/Product billing modifiers
            #[prost(message, repeated, tag = "5")]
            pub modifier: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Count of products or services
            #[prost(message, optional, tag = "6")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// Fee, charge or cost per item
            #[prost(message, optional, tag = "7")]
            pub unit_price: ::core::option::Option<super::super::Money>,
            /// Price scaling factor
            #[prost(message, optional, tag = "8")]
            pub factor: ::core::option::Option<super::super::Decimal>,
            /// Total item cost
            #[prost(message, optional, tag = "9")]
            pub net: ::core::option::Option<super::super::Money>,
            /// Applicable note numbers
            #[prost(message, repeated, tag = "10")]
            pub note_number: prost::alloc::vec::Vec<super::super::PositiveInt>,
            /// Added items detail adjudication
            #[prost(message, repeated, tag = "11")]
            pub adjudication: prost::alloc::vec::Vec<super::item::Adjudication>,
            #[prost(message, repeated, tag = "12")]
            pub sub_detail: prost::alloc::vec::Vec<added_item_detail::AddedItemSubDetail>,
        }
        /// Nested message and enum types in `AddedItemDetail`.
        pub mod added_item_detail {
            /// Insurer added line items
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct AddedItemSubDetail {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Billing, service, product, or drug code
                #[prost(message, optional, tag = "4")]
                pub product_or_service:
                    ::core::option::Option<super::super::super::CodeableConcept>,
                /// Service/Product billing modifiers
                #[prost(message, repeated, tag = "5")]
                pub modifier: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Count of products or services
                #[prost(message, optional, tag = "6")]
                pub quantity: ::core::option::Option<super::super::super::SimpleQuantity>,
                /// Fee, charge or cost per item
                #[prost(message, optional, tag = "7")]
                pub unit_price: ::core::option::Option<super::super::super::Money>,
                /// Price scaling factor
                #[prost(message, optional, tag = "8")]
                pub factor: ::core::option::Option<super::super::super::Decimal>,
                /// Total item cost
                #[prost(message, optional, tag = "9")]
                pub net: ::core::option::Option<super::super::super::Money>,
                /// Applicable note numbers
                #[prost(message, repeated, tag = "10")]
                pub note_number: prost::alloc::vec::Vec<super::super::super::PositiveInt>,
                /// Added items detail adjudication
                #[prost(message, repeated, tag = "11")]
                pub adjudication: prost::alloc::vec::Vec<super::super::item::Adjudication>,
            }
        }
    }
    /// Adjudication totals
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Total {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of adjudication information
        #[prost(message, optional, tag = "4")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Financial total for the category
        #[prost(message, optional, tag = "5")]
        pub amount: ::core::option::Option<super::Money>,
    }
    /// Payment Details
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payment {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Partial or complete payment
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Payment adjustment for non-claim issues
        #[prost(message, optional, tag = "5")]
        pub adjustment: ::core::option::Option<super::Money>,
        /// Explanation for the adjustment
        #[prost(message, optional, tag = "6")]
        pub adjustment_reason: ::core::option::Option<super::CodeableConcept>,
        /// Expected date of payment
        #[prost(message, optional, tag = "7")]
        pub date: ::core::option::Option<super::Date>,
        /// Payable amount after adjustment
        #[prost(message, optional, tag = "8")]
        pub amount: ::core::option::Option<super::Money>,
        /// Business identifier for the payment
        #[prost(message, optional, tag = "9")]
        pub identifier: ::core::option::Option<super::Identifier>,
    }
    /// Note concerning adjudication
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Note {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Note instance identifier
        #[prost(message, optional, tag = "4")]
        pub number: ::core::option::Option<super::PositiveInt>,
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<note::TypeCode>,
        /// Note explanatory text
        #[prost(message, optional, tag = "6")]
        pub text: ::core::option::Option<super::String>,
        /// Language of the text
        #[prost(message, optional, tag = "7")]
        pub language: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Note`.
    pub mod note {
        /// display | print | printoper
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::note_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Patient insurance information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Insurance {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Insurance instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Coverage to be used for adjudication
        #[prost(message, optional, tag = "5")]
        pub focal: ::core::option::Option<super::Boolean>,
        /// Insurance information
        #[prost(message, optional, tag = "6")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// Additional provider contract number
        #[prost(message, optional, tag = "7")]
        pub business_arrangement: ::core::option::Option<super::String>,
        /// Adjudication results
        #[prost(message, optional, tag = "8")]
        pub claim_response: ::core::option::Option<super::Reference>,
    }
    /// Processing errors
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Error {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Item sequence number
        #[prost(message, optional, tag = "4")]
        pub item_sequence: ::core::option::Option<super::PositiveInt>,
        /// Detail sequence number
        #[prost(message, optional, tag = "5")]
        pub detail_sequence: ::core::option::Option<super::PositiveInt>,
        /// Subdetail sequence number
        #[prost(message, optional, tag = "6")]
        pub sub_detail_sequence: ::core::option::Option<super::PositiveInt>,
        /// Error code detailing processing issues
        #[prost(message, optional, tag = "7")]
        pub code: ::core::option::Option<super::CodeableConcept>,
    }
}
/// Auto-generated from StructureDefinition for ClinicalImpression, last updated
/// 2019-11-01T09:29:23.356+11:00. A clinical assessment performed when planning
/// treatments and management strategies for a patient. See
/// <http://hl7.org/fhir/StructureDefinition/ClinicalImpression>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ClinicalImpression {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<clinical_impression::StatusCode>,
    /// Reason for current status
    #[prost(message, optional, tag = "12")]
    pub status_reason: ::core::option::Option<CodeableConcept>,
    /// Kind of assessment performed
    #[prost(message, optional, tag = "13")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Why/how the assessment was performed
    #[prost(message, optional, tag = "14")]
    pub description: ::core::option::Option<String>,
    /// Patient or group assessed
    #[prost(message, optional, tag = "15")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter created as part of
    #[prost(message, optional, tag = "16")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "17")]
    pub effective: ::core::option::Option<clinical_impression::EffectiveX>,
    /// When the assessment was documented
    #[prost(message, optional, tag = "18")]
    pub date: ::core::option::Option<DateTime>,
    /// The clinician performing the assessment
    #[prost(message, optional, tag = "19")]
    pub assessor: ::core::option::Option<Reference>,
    /// Reference to last assessment
    #[prost(message, optional, tag = "20")]
    pub previous: ::core::option::Option<Reference>,
    /// Relevant impressions of patient state
    #[prost(message, repeated, tag = "21")]
    pub problem: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "22")]
    pub investigation: prost::alloc::vec::Vec<clinical_impression::Investigation>,
    /// Clinical Protocol followed
    #[prost(message, repeated, tag = "23")]
    pub protocol: prost::alloc::vec::Vec<Uri>,
    /// Summary of the assessment
    #[prost(message, optional, tag = "24")]
    pub summary: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "25")]
    pub finding: prost::alloc::vec::Vec<clinical_impression::Finding>,
    /// Estimate of likely outcome
    #[prost(message, repeated, tag = "26")]
    pub prognosis_codeable_concept: prost::alloc::vec::Vec<CodeableConcept>,
    /// RiskAssessment expressing likely outcome
    #[prost(message, repeated, tag = "27")]
    pub prognosis_reference: prost::alloc::vec::Vec<Reference>,
    /// Information supporting the clinical impression
    #[prost(message, repeated, tag = "28")]
    pub supporting_info: prost::alloc::vec::Vec<Reference>,
    /// Comments made about the ClinicalImpression
    #[prost(message, repeated, tag = "29")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `ClinicalImpression`.
pub mod clinical_impression {
    /// in-progress | completed | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::clinical_impression_status_value_set::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Time of assessment
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EffectiveX {
        #[prost(oneof = "effective_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<effective_x::Choice>,
    }
    /// Nested message and enum types in `EffectiveX`.
    pub mod effective_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// One or more sets of investigations (signs, symptoms, etc.)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Investigation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// A name/code for the set
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Record of a specific investigation
        #[prost(message, repeated, tag = "5")]
        pub item: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Possible or likely findings and diagnoses
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Finding {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// What was found
        #[prost(message, optional, tag = "4")]
        pub item_codeable_concept: ::core::option::Option<super::CodeableConcept>,
        /// What was found
        #[prost(message, optional, tag = "5")]
        pub item_reference: ::core::option::Option<super::Reference>,
        /// Which investigations support finding
        #[prost(message, optional, tag = "6")]
        pub basis: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for CodeSystem, last updated
/// 2019-11-01T09:29:23.356+11:00. Declares the existence of and describes a code
/// system or code system supplement. See
/// <http://hl7.org/fhir/StructureDefinition/CodeSystem>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystem {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this code system, represented as a URI (globally
    /// unique) (Coding.system)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the code system (business identifier)
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the code system (Coding.version)
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this code system (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this code system (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<code_system::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "16")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "18")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "19")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the code system
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "21")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for code system (if applicable)
    #[prost(message, repeated, tag = "22")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this code system is defined
    #[prost(message, optional, tag = "23")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "24")]
    pub copyright: ::core::option::Option<Markdown>,
    /// If code comparison is case sensitive
    #[prost(message, optional, tag = "25")]
    pub case_sensitive: ::core::option::Option<Boolean>,
    /// Canonical reference to the value set with entire code system
    #[prost(message, optional, tag = "26")]
    pub value_set: ::core::option::Option<Canonical>,
    #[prost(message, optional, tag = "27")]
    pub hierarchy_meaning: ::core::option::Option<code_system::HierarchyMeaningCode>,
    /// If code system defines a compositional grammar
    #[prost(message, optional, tag = "28")]
    pub compositional: ::core::option::Option<Boolean>,
    /// If definitions are not stable
    #[prost(message, optional, tag = "29")]
    pub version_needed: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "30")]
    pub content: ::core::option::Option<code_system::ContentCode>,
    /// Canonical URL of Code System this adds designations and properties to
    #[prost(message, optional, tag = "31")]
    pub supplements: ::core::option::Option<Canonical>,
    /// Total concepts in the code system
    #[prost(message, optional, tag = "32")]
    pub count: ::core::option::Option<UnsignedInt>,
    #[prost(message, repeated, tag = "33")]
    pub filter: prost::alloc::vec::Vec<code_system::Filter>,
    #[prost(message, repeated, tag = "34")]
    pub property: prost::alloc::vec::Vec<code_system::Property>,
    #[prost(message, repeated, tag = "35")]
    pub concept: prost::alloc::vec::Vec<code_system::ConceptDefinition>,
}
/// Nested message and enum types in `CodeSystem`.
pub mod code_system {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// grouped-by | is-a | part-of | classified-with
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct HierarchyMeaningCode {
        #[prost(
            enumeration = "super::code_system_hierarchy_meaning_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// not-present | example | fragment | complete | supplement
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ContentCode {
        #[prost(enumeration = "super::code_system_content_mode_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Filter that can be used in a value set
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Filter {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Code that identifies the filter
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::Code>,
        /// How or why the filter is used
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "6")]
        pub operator: prost::alloc::vec::Vec<filter::OperatorCode>,
        /// What to use for the value
        #[prost(message, optional, tag = "7")]
        pub value: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Filter`.
    pub mod filter {
        /// = | is-a | descendent-of | is-not-a | regex | in | not-in | generalizes |
        /// exists
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct OperatorCode {
            #[prost(enumeration = "super::super::filter_operator_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Additional information supplied about each concept
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Property {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifies the property on the concepts, and when referred to in
        /// operations
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::Code>,
        /// Formal identifier for the property
        #[prost(message, optional, tag = "5")]
        pub uri: ::core::option::Option<super::Uri>,
        /// Why the property is defined, and/or what it conveys
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "7")]
        pub r#type: ::core::option::Option<property::TypeCode>,
    }
    /// Nested message and enum types in `Property`.
    pub mod property {
        /// code | Coding | string | integer | boolean | dateTime | decimal
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::property_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Concepts in the code system
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ConceptDefinition {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Code that identifies concept
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::Code>,
        /// Text to display to the user
        #[prost(message, optional, tag = "5")]
        pub display: ::core::option::Option<super::String>,
        /// Formal definition
        #[prost(message, optional, tag = "6")]
        pub definition: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "7")]
        pub designation: prost::alloc::vec::Vec<concept_definition::Designation>,
        #[prost(message, repeated, tag = "8")]
        pub property: prost::alloc::vec::Vec<concept_definition::ConceptProperty>,
        /// Child Concepts (is-a/contains/categorizes)
        #[prost(message, repeated, tag = "9")]
        pub concept: prost::alloc::vec::Vec<ConceptDefinition>,
    }
    /// Nested message and enum types in `ConceptDefinition`.
    pub mod concept_definition {
        /// Additional representations for the concept
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Designation {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Human language of the designation
            #[prost(message, optional, tag = "4")]
            pub language: ::core::option::Option<super::super::Code>,
            /// Details how this designation would be used
            #[prost(message, optional, tag = "5")]
            pub r#use: ::core::option::Option<super::super::Coding>,
            /// The text value for this designation
            #[prost(message, optional, tag = "6")]
            pub value: ::core::option::Option<super::super::String>,
        }
        /// Property value for the concept
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ConceptProperty {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Reference to CodeSystem.property.code
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::Code>,
            #[prost(message, optional, tag = "5")]
            pub value: ::core::option::Option<concept_property::ValueX>,
        }
        /// Nested message and enum types in `ConceptProperty`.
        pub mod concept_property {
            /// Value of the property for this concept
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ValueX {
                #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5, 6, 7")]
                pub choice: ::core::option::Option<value_x::Choice>,
            }
            /// Nested message and enum types in `ValueX`.
            pub mod value_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Code(super::super::super::super::Code),
                    #[prost(message, tag = "2")]
                    Coding(super::super::super::super::Coding),
                    #[prost(message, tag = "3")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "4")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "5")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "6")]
                    DateTime(super::super::super::super::DateTime),
                    #[prost(message, tag = "7")]
                    Decimal(super::super::super::super::Decimal),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Communication, last updated
/// 2019-11-01T09:29:23.356+11:00. A record of information transmitted from a
/// sender to a receiver. See
/// <http://hl7.org/fhir/StructureDefinition/Communication>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Communication {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates FHIR protocol or definition
    #[prost(message, repeated, tag = "11")]
    pub instantiates_canonical: prost::alloc::vec::Vec<Canonical>,
    /// Instantiates external protocol or definition
    #[prost(message, repeated, tag = "12")]
    pub instantiates_uri: prost::alloc::vec::Vec<Uri>,
    /// Request fulfilled by this communication
    #[prost(message, repeated, tag = "13")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of this action
    #[prost(message, repeated, tag = "14")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// Reply to
    #[prost(message, repeated, tag = "15")]
    pub in_response_to: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<communication::StatusCode>,
    /// Reason for current status
    #[prost(message, optional, tag = "17")]
    pub status_reason: ::core::option::Option<CodeableConcept>,
    /// Message category
    #[prost(message, repeated, tag = "18")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, optional, tag = "19")]
    pub priority: ::core::option::Option<communication::PriorityCode>,
    /// A channel of communication
    #[prost(message, repeated, tag = "20")]
    pub medium: prost::alloc::vec::Vec<CodeableConcept>,
    /// Focus of message
    #[prost(message, optional, tag = "21")]
    pub subject: ::core::option::Option<Reference>,
    /// Description of the purpose/content
    #[prost(message, optional, tag = "22")]
    pub topic: ::core::option::Option<CodeableConcept>,
    /// Resources that pertain to this communication
    #[prost(message, repeated, tag = "23")]
    pub about: prost::alloc::vec::Vec<Reference>,
    /// Encounter created as part of
    #[prost(message, optional, tag = "24")]
    pub encounter: ::core::option::Option<Reference>,
    /// When sent
    #[prost(message, optional, tag = "25")]
    pub sent: ::core::option::Option<DateTime>,
    /// When received
    #[prost(message, optional, tag = "26")]
    pub received: ::core::option::Option<DateTime>,
    /// Message recipient
    #[prost(message, repeated, tag = "27")]
    pub recipient: prost::alloc::vec::Vec<Reference>,
    /// Message sender
    #[prost(message, optional, tag = "28")]
    pub sender: ::core::option::Option<Reference>,
    /// Indication for message
    #[prost(message, repeated, tag = "29")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why was communication done?
    #[prost(message, repeated, tag = "30")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "31")]
    pub payload: prost::alloc::vec::Vec<communication::Payload>,
    /// Comments made about the communication
    #[prost(message, repeated, tag = "32")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `Communication`.
pub mod communication {
    /// preparation | in-progress | not-done | on-hold | stopped | completed |
    /// entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::event_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// routine | urgent | asap | stat
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PriorityCode {
        #[prost(enumeration = "super::request_priority_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Message payload
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payload {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub content: ::core::option::Option<payload::ContentX>,
    }
    /// Nested message and enum types in `Payload`.
    pub mod payload {
        /// Message part content
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ContentX {
            #[prost(oneof = "content_x::Choice", tags = "1, 2, 3")]
            pub choice: ::core::option::Option<content_x::Choice>,
        }
        /// Nested message and enum types in `ContentX`.
        pub mod content_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "2")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "3")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for CommunicationRequest, last
/// updated 2019-11-01T09:29:23.356+11:00. A request for information to be sent
/// to a receiver. See
/// <http://hl7.org/fhir/StructureDefinition/CommunicationRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CommunicationRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Fulfills plan or proposal
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Request(s) replaced by this request
    #[prost(message, repeated, tag = "12")]
    pub replaces: prost::alloc::vec::Vec<Reference>,
    /// Composite request this is part of
    #[prost(message, optional, tag = "13")]
    pub group_identifier: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<communication_request::StatusCode>,
    /// Reason for current status
    #[prost(message, optional, tag = "15")]
    pub status_reason: ::core::option::Option<CodeableConcept>,
    /// Message category
    #[prost(message, repeated, tag = "16")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, optional, tag = "17")]
    pub priority: ::core::option::Option<communication_request::PriorityCode>,
    /// True if request is prohibiting action
    #[prost(message, optional, tag = "18")]
    pub do_not_perform: ::core::option::Option<Boolean>,
    /// A channel of communication
    #[prost(message, repeated, tag = "19")]
    pub medium: prost::alloc::vec::Vec<CodeableConcept>,
    /// Focus of message
    #[prost(message, optional, tag = "20")]
    pub subject: ::core::option::Option<Reference>,
    /// Resources that pertain to this communication request
    #[prost(message, repeated, tag = "21")]
    pub about: prost::alloc::vec::Vec<Reference>,
    /// Encounter created as part of
    #[prost(message, optional, tag = "22")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "23")]
    pub payload: prost::alloc::vec::Vec<communication_request::Payload>,
    #[prost(message, optional, tag = "24")]
    pub occurrence: ::core::option::Option<communication_request::OccurrenceX>,
    /// When request transitioned to being actionable
    #[prost(message, optional, tag = "25")]
    pub authored_on: ::core::option::Option<DateTime>,
    /// Who/what is requesting service
    #[prost(message, optional, tag = "26")]
    pub requester: ::core::option::Option<Reference>,
    /// Message recipient
    #[prost(message, repeated, tag = "27")]
    pub recipient: prost::alloc::vec::Vec<Reference>,
    /// Message sender
    #[prost(message, optional, tag = "28")]
    pub sender: ::core::option::Option<Reference>,
    /// Why is communication needed?
    #[prost(message, repeated, tag = "29")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why is communication needed?
    #[prost(message, repeated, tag = "30")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Comments made about communication request
    #[prost(message, repeated, tag = "31")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `CommunicationRequest`.
pub mod communication_request {
    /// draft | active | on-hold | revoked | completed | entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::request_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// routine | urgent | asap | stat
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PriorityCode {
        #[prost(enumeration = "super::request_priority_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Message payload
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payload {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub content: ::core::option::Option<payload::ContentX>,
    }
    /// Nested message and enum types in `Payload`.
    pub mod payload {
        /// Message part content
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ContentX {
            #[prost(oneof = "content_x::Choice", tags = "1, 2, 3")]
            pub choice: ::core::option::Option<content_x::Choice>,
        }
        /// Nested message and enum types in `ContentX`.
        pub mod content_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "2")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "3")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// When scheduled
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OccurrenceX {
        #[prost(oneof = "occurrence_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<occurrence_x::Choice>,
    }
    /// Nested message and enum types in `OccurrenceX`.
    pub mod occurrence_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
}
/// Auto-generated from StructureDefinition for CompartmentDefinition, last
/// updated 2019-11-01T09:29:23.356+11:00. Compartment Definition for a resource.
/// See <http://hl7.org/fhir/StructureDefinition/CompartmentDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompartmentDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this compartment definition, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the compartment definition
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this compartment definition (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<compartment_definition::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "14")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "15")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "16")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "17")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the compartment definition
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "19")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Why this compartment definition is defined
    #[prost(message, optional, tag = "20")]
    pub purpose: ::core::option::Option<Markdown>,
    #[prost(message, optional, tag = "21")]
    pub code: ::core::option::Option<compartment_definition::CodeType>,
    /// Whether the search syntax is supported
    #[prost(message, optional, tag = "22")]
    pub search: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "23")]
    pub resource: prost::alloc::vec::Vec<compartment_definition::Resource>,
}
/// Nested message and enum types in `CompartmentDefinition`.
pub mod compartment_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Patient | Encounter | RelatedPerson | Practitioner | Device
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CodeType {
        #[prost(enumeration = "super::compartment_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// How a resource is related to the compartment
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Resource {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<resource::CodeType>,
        /// Search Parameter Name, or chained parameters
        #[prost(message, repeated, tag = "5")]
        pub param: prost::alloc::vec::Vec<super::String>,
        /// Additional documentation about the resource and compartment
        #[prost(message, optional, tag = "6")]
        pub documentation: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Resource`.
    pub mod resource {
        /// Name of resource type
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CodeType {
            #[prost(enumeration = "super::super::resource_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for Composition, last updated
/// 2019-11-01T09:29:23.356+11:00. A set of resources composed into a single
/// coherent clinical statement with clinical attestation. See
/// <http://hl7.org/fhir/StructureDefinition/Composition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Composition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Version-independent identifier for the Composition
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<composition::StatusCode>,
    /// Kind of composition (LOINC if possible)
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Categorization of Composition
    #[prost(message, repeated, tag = "13")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who and/or what the composition is about
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Context of the Composition
    #[prost(message, optional, tag = "15")]
    pub encounter: ::core::option::Option<Reference>,
    /// Composition editing time
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Who and/or what authored the composition
    #[prost(message, repeated, tag = "17")]
    pub author: prost::alloc::vec::Vec<Reference>,
    /// Human Readable name/title
    #[prost(message, optional, tag = "18")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "19")]
    pub confidentiality: ::core::option::Option<composition::ConfidentialityCode>,
    #[prost(message, repeated, tag = "20")]
    pub attester: prost::alloc::vec::Vec<composition::Attester>,
    /// Organization which maintains the composition
    #[prost(message, optional, tag = "21")]
    pub custodian: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "22")]
    pub relates_to: prost::alloc::vec::Vec<composition::RelatesTo>,
    #[prost(message, repeated, tag = "23")]
    pub event: prost::alloc::vec::Vec<composition::Event>,
    #[prost(message, repeated, tag = "24")]
    pub section: prost::alloc::vec::Vec<composition::Section>,
}
/// Nested message and enum types in `Composition`.
pub mod composition {
    /// preliminary | final | amended | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::composition_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// As defined by affinity domain
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ConfidentialityCode {
        #[prost(
            enumeration = "super::v3_confidentiality_classification_value_set::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Attests to accuracy of composition
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Attester {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub mode: ::core::option::Option<attester::ModeCode>,
        /// When the composition was attested
        #[prost(message, optional, tag = "5")]
        pub time: ::core::option::Option<super::DateTime>,
        /// Who attested the composition
        #[prost(message, optional, tag = "6")]
        pub party: ::core::option::Option<super::Reference>,
    }
    /// Nested message and enum types in `Attester`.
    pub mod attester {
        /// personal | professional | legal | official
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ModeCode {
            #[prost(
                enumeration = "super::super::composition_attestation_mode_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Relationships to other compositions/documents
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelatesTo {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<relates_to::CodeType>,
        #[prost(message, optional, tag = "5")]
        pub target: ::core::option::Option<relates_to::TargetX>,
    }
    /// Nested message and enum types in `RelatesTo`.
    pub mod relates_to {
        /// replaces | transforms | signs | appends
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CodeType {
            #[prost(
                enumeration = "super::super::document_relationship_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Target of the relationship
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TargetX {
            #[prost(oneof = "target_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<target_x::Choice>,
        }
        /// Nested message and enum types in `TargetX`.
        pub mod target_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Identifier(super::super::super::Identifier),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// The clinical service(s) being documented
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Event {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Code(s) that apply to the event being documented
        #[prost(message, repeated, tag = "4")]
        pub code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// The period covered by the documentation
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
        /// The event(s) being documented
        #[prost(message, repeated, tag = "6")]
        pub detail: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Composition is broken into sections
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Section {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Label for section (e.g. for ToC)
        #[prost(message, optional, tag = "4")]
        pub title: ::core::option::Option<super::String>,
        /// Classification of section (recommended)
        #[prost(message, optional, tag = "5")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Who and/or what authored the section
        #[prost(message, repeated, tag = "6")]
        pub author: prost::alloc::vec::Vec<super::Reference>,
        /// Who/what the section is about, when it is not about the subject of
        /// composition
        #[prost(message, optional, tag = "7")]
        pub focus: ::core::option::Option<super::Reference>,
        /// Text summary of the section, for human interpretation
        #[prost(message, optional, tag = "8")]
        pub text: ::core::option::Option<super::Narrative>,
        #[prost(message, optional, tag = "9")]
        pub mode: ::core::option::Option<section::ModeCode>,
        /// Order of section entries
        #[prost(message, optional, tag = "10")]
        pub ordered_by: ::core::option::Option<super::CodeableConcept>,
        /// A reference to data that supports this section
        #[prost(message, repeated, tag = "11")]
        pub entry: prost::alloc::vec::Vec<super::Reference>,
        /// Why the section is empty
        #[prost(message, optional, tag = "12")]
        pub empty_reason: ::core::option::Option<super::CodeableConcept>,
        /// Nested Section
        #[prost(message, repeated, tag = "13")]
        pub section: prost::alloc::vec::Vec<Section>,
    }
    /// Nested message and enum types in `Section`.
    pub mod section {
        /// working | snapshot | changes
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ModeCode {
            #[prost(enumeration = "super::super::list_mode_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for ConceptMap, last updated
/// 2019-11-01T09:29:23.356+11:00. A map from one set of concepts to one or more
/// other concepts. See <http://hl7.org/fhir/StructureDefinition/ConceptMap>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConceptMap {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this concept map, represented as a URI (globally
    /// unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the concept map
    #[prost(message, optional, tag = "11")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Business version of the concept map
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this concept map (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this concept map (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<concept_map::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "16")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "18")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "19")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the concept map
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "21")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for concept map (if applicable)
    #[prost(message, repeated, tag = "22")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this concept map is defined
    #[prost(message, optional, tag = "23")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "24")]
    pub copyright: ::core::option::Option<Markdown>,
    #[prost(message, optional, tag = "25")]
    pub source: ::core::option::Option<concept_map::SourceX>,
    #[prost(message, optional, tag = "26")]
    pub target: ::core::option::Option<concept_map::TargetX>,
    #[prost(message, repeated, tag = "27")]
    pub group: prost::alloc::vec::Vec<concept_map::Group>,
}
/// Nested message and enum types in `ConceptMap`.
pub mod concept_map {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// The source value set that contains the concepts that are being mapped
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SourceX {
        #[prost(oneof = "source_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<source_x::Choice>,
    }
    /// Nested message and enum types in `SourceX`.
    pub mod source_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Canonical(super::super::Canonical),
        }
    }
    /// The target value set which provides context for the mappings
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TargetX {
        #[prost(oneof = "target_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<target_x::Choice>,
    }
    /// Nested message and enum types in `TargetX`.
    pub mod target_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Canonical(super::super::Canonical),
        }
    }
    /// Same source and target systems
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Group {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Source system where concepts to be mapped are defined
        #[prost(message, optional, tag = "4")]
        pub source: ::core::option::Option<super::Uri>,
        /// Specific version of the  code system
        #[prost(message, optional, tag = "5")]
        pub source_version: ::core::option::Option<super::String>,
        /// Target system that the concepts are to be mapped to
        #[prost(message, optional, tag = "6")]
        pub target: ::core::option::Option<super::Uri>,
        /// Specific version of the  code system
        #[prost(message, optional, tag = "7")]
        pub target_version: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "8")]
        pub element: prost::alloc::vec::Vec<group::SourceElement>,
        #[prost(message, optional, tag = "9")]
        pub unmapped: ::core::option::Option<group::Unmapped>,
    }
    /// Nested message and enum types in `Group`.
    pub mod group {
        /// Mappings for a concept from the source set
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SourceElement {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Identifies element being mapped
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::Code>,
            /// Display for the code
            #[prost(message, optional, tag = "5")]
            pub display: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "6")]
            pub target: prost::alloc::vec::Vec<source_element::TargetElement>,
        }
        /// Nested message and enum types in `SourceElement`.
        pub mod source_element {
            /// Concept in target system for element
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct TargetElement {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Code that identifies the target element
                #[prost(message, optional, tag = "4")]
                pub code: ::core::option::Option<super::super::super::Code>,
                /// Display for the code
                #[prost(message, optional, tag = "5")]
                pub display: ::core::option::Option<super::super::super::String>,
                #[prost(message, optional, tag = "6")]
                pub equivalence: ::core::option::Option<target_element::EquivalenceCode>,
                /// Description of status/issues in mapping
                #[prost(message, optional, tag = "7")]
                pub comment: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "8")]
                pub depends_on: prost::alloc::vec::Vec<target_element::OtherElement>,
                /// Other concepts that this mapping also produces
                #[prost(message, repeated, tag = "9")]
                pub product: prost::alloc::vec::Vec<target_element::OtherElement>,
            }
            /// Nested message and enum types in `TargetElement`.
            pub mod target_element {
                /// relatedto | equivalent | equal | wider | subsumes | narrower |
                /// specializes | inexact | unmatched | disjoint
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct EquivalenceCode {
                    #[prost(
                        enumeration = "super::super::super::super::concept_map_equivalence_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// Other elements required for this mapping (from context)
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct OtherElement {
                    /// Unique id for inter-element referencing
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored even if unrecognized
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Reference to property mapping depends on
                    #[prost(message, optional, tag = "4")]
                    pub property: ::core::option::Option<super::super::super::super::Uri>,
                    /// Code System (if necessary)
                    #[prost(message, optional, tag = "5")]
                    pub system: ::core::option::Option<super::super::super::super::Canonical>,
                    /// Value of the referenced element
                    #[prost(message, optional, tag = "6")]
                    pub value: ::core::option::Option<super::super::super::super::String>,
                    /// Display for the code (if value is a code)
                    #[prost(message, optional, tag = "7")]
                    pub display: ::core::option::Option<super::super::super::super::String>,
                }
            }
        }
        /// What to do when there is no mapping for the source concept
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Unmapped {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub mode: ::core::option::Option<unmapped::ModeCode>,
            /// Fixed code when mode = fixed
            #[prost(message, optional, tag = "5")]
            pub code: ::core::option::Option<super::super::Code>,
            /// Display for the code
            #[prost(message, optional, tag = "6")]
            pub display: ::core::option::Option<super::super::String>,
            /// canonical reference to an additional ConceptMap to use for mapping if
            /// the source concept is unmapped
            #[prost(message, optional, tag = "7")]
            pub url: ::core::option::Option<super::super::Canonical>,
        }
        /// Nested message and enum types in `Unmapped`.
        pub mod unmapped {
            /// provided | fixed | other-map
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ModeCode {
                #[prost(
                    enumeration = "super::super::super::concept_map_group_unmapped_mode_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Condition, last updated
/// 2019-11-01T09:29:23.356+11:00. Detailed information about conditions,
/// problems or diagnoses. See <http://hl7.org/fhir/StructureDefinition/Condition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Condition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this condition
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | recurrence | relapse | inactive | remission | resolved
    #[prost(message, optional, tag = "11")]
    pub clinical_status: ::core::option::Option<CodeableConcept>,
    /// unconfirmed | provisional | differential | confirmed | refuted |
    /// entered-in-error
    #[prost(message, optional, tag = "12")]
    pub verification_status: ::core::option::Option<CodeableConcept>,
    /// problem-list-item | encounter-diagnosis
    #[prost(message, repeated, tag = "13")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Subjective severity of condition
    #[prost(message, optional, tag = "14")]
    pub severity: ::core::option::Option<CodeableConcept>,
    /// Identification of the condition, problem or diagnosis
    #[prost(message, optional, tag = "15")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Anatomical location, if relevant
    #[prost(message, repeated, tag = "16")]
    pub body_site: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who has the condition?
    #[prost(message, optional, tag = "17")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter created as part of
    #[prost(message, optional, tag = "18")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "19")]
    pub onset: ::core::option::Option<condition::OnsetX>,
    #[prost(message, optional, tag = "20")]
    pub abatement: ::core::option::Option<condition::AbatementX>,
    /// Date record was first recorded
    #[prost(message, optional, tag = "21")]
    pub recorded_date: ::core::option::Option<DateTime>,
    /// Who recorded the condition
    #[prost(message, optional, tag = "22")]
    pub recorder: ::core::option::Option<Reference>,
    /// Person who asserts this condition
    #[prost(message, optional, tag = "23")]
    pub asserter: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "24")]
    pub stage: prost::alloc::vec::Vec<condition::Stage>,
    #[prost(message, repeated, tag = "25")]
    pub evidence: prost::alloc::vec::Vec<condition::Evidence>,
    /// Additional information about the Condition
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `Condition`.
pub mod condition {
    /// Estimated or actual date,  date-time, or age
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OnsetX {
        #[prost(oneof = "onset_x::Choice", tags = "1, 2, 3, 4, 5")]
        pub choice: ::core::option::Option<onset_x::Choice>,
    }
    /// Nested message and enum types in `OnsetX`.
    pub mod onset_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Age(super::super::Age),
            #[prost(message, tag = "3")]
            Period(super::super::Period),
            #[prost(message, tag = "4")]
            Range(super::super::Range),
            #[prost(message, tag = "5")]
            StringValue(super::super::String),
        }
    }
    /// When in resolution/remission
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AbatementX {
        #[prost(oneof = "abatement_x::Choice", tags = "1, 2, 3, 4, 5")]
        pub choice: ::core::option::Option<abatement_x::Choice>,
    }
    /// Nested message and enum types in `AbatementX`.
    pub mod abatement_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Age(super::super::Age),
            #[prost(message, tag = "3")]
            Period(super::super::Period),
            #[prost(message, tag = "4")]
            Range(super::super::Range),
            #[prost(message, tag = "5")]
            StringValue(super::super::String),
        }
    }
    /// Stage/grade, usually assessed formally
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Stage {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Simple summary (disease specific)
        #[prost(message, optional, tag = "4")]
        pub summary: ::core::option::Option<super::CodeableConcept>,
        /// Formal record of assessment
        #[prost(message, repeated, tag = "5")]
        pub assessment: prost::alloc::vec::Vec<super::Reference>,
        /// Kind of staging
        #[prost(message, optional, tag = "6")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
    }
    /// Supporting evidence
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Evidence {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Manifestation/symptom
        #[prost(message, repeated, tag = "4")]
        pub code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Supporting information found elsewhere
        #[prost(message, repeated, tag = "5")]
        pub detail: prost::alloc::vec::Vec<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for Consent, last updated
/// 2019-11-01T09:29:23.356+11:00. A healthcare consumer's  choices to permit or
/// deny recipients or roles to perform actions for specific purposes and periods
/// of time. See <http://hl7.org/fhir/StructureDefinition/Consent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Consent {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifier for this record (external references)
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<consent::StatusCode>,
    /// Which of the four areas this resource covers (extensible)
    #[prost(message, optional, tag = "12")]
    pub scope: ::core::option::Option<CodeableConcept>,
    /// Classification of the consent statement - for indexing/retrieval
    #[prost(message, repeated, tag = "13")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who the consent applies to
    #[prost(message, optional, tag = "14")]
    pub patient: ::core::option::Option<Reference>,
    /// When this Consent was created or indexed
    #[prost(message, optional, tag = "15")]
    pub date_time: ::core::option::Option<DateTime>,
    /// Who is agreeing to the policy and rules
    #[prost(message, repeated, tag = "16")]
    pub performer: prost::alloc::vec::Vec<Reference>,
    /// Custodian of the consent
    #[prost(message, repeated, tag = "17")]
    pub organization: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "18")]
    pub source: ::core::option::Option<consent::SourceX>,
    #[prost(message, repeated, tag = "19")]
    pub policy: prost::alloc::vec::Vec<consent::Policy>,
    /// Regulation that this consents to
    #[prost(message, optional, tag = "20")]
    pub policy_rule: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "21")]
    pub verification: prost::alloc::vec::Vec<consent::Verification>,
    #[prost(message, optional, tag = "22")]
    pub provision: ::core::option::Option<consent::Provision>,
}
/// Nested message and enum types in `Consent`.
pub mod consent {
    /// draft | proposed | active | rejected | inactive | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::consent_state_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Source from which this consent is taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SourceX {
        #[prost(oneof = "source_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<source_x::Choice>,
    }
    /// Nested message and enum types in `SourceX`.
    pub mod source_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Policies covered by this consent
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Policy {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Enforcement source for policy
        #[prost(message, optional, tag = "4")]
        pub authority: ::core::option::Option<super::Uri>,
        /// Specific policy covered by this consent
        #[prost(message, optional, tag = "5")]
        pub uri: ::core::option::Option<super::Uri>,
    }
    /// Consent Verified by patient or family
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Verification {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Has been verified
        #[prost(message, optional, tag = "4")]
        pub verified: ::core::option::Option<super::Boolean>,
        /// Person who verified
        #[prost(message, optional, tag = "5")]
        pub verified_with: ::core::option::Option<super::Reference>,
        /// When consent verified
        #[prost(message, optional, tag = "6")]
        pub verification_date: ::core::option::Option<super::DateTime>,
    }
    /// Constraints to the base Consent.policyRule
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Provision {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<provision::TypeCode>,
        /// Timeframe for this rule
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
        #[prost(message, repeated, tag = "6")]
        pub actor: prost::alloc::vec::Vec<provision::ProvisionActor>,
        /// Actions controlled by this rule
        #[prost(message, repeated, tag = "7")]
        pub action: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Security Labels that define affected resources
        #[prost(message, repeated, tag = "8")]
        pub security_label: prost::alloc::vec::Vec<super::Coding>,
        /// Context of activities covered by this rule
        #[prost(message, repeated, tag = "9")]
        pub purpose: prost::alloc::vec::Vec<super::Coding>,
        /// e.g. Resource Type, Profile, CDA, etc.
        #[prost(message, repeated, tag = "10")]
        pub class_value: prost::alloc::vec::Vec<super::Coding>,
        /// e.g. LOINC or SNOMED CT code, etc. in the content
        #[prost(message, repeated, tag = "11")]
        pub code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Timeframe for data controlled by this rule
        #[prost(message, optional, tag = "12")]
        pub data_period: ::core::option::Option<super::Period>,
        #[prost(message, repeated, tag = "13")]
        pub data: prost::alloc::vec::Vec<provision::ProvisionData>,
        /// Nested Exception Rules
        #[prost(message, repeated, tag = "14")]
        pub provision: prost::alloc::vec::Vec<Provision>,
    }
    /// Nested message and enum types in `Provision`.
    pub mod provision {
        /// deny | permit
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(
                enumeration = "super::super::consent_provision_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Who|what controlled by this rule (or group, by role)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ProvisionActor {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// How the actor is involved
            #[prost(message, optional, tag = "4")]
            pub role: ::core::option::Option<super::super::CodeableConcept>,
            /// Resource for the actor (or group, by role)
            #[prost(message, optional, tag = "5")]
            pub reference: ::core::option::Option<super::super::Reference>,
        }
        /// Data controlled by this rule
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ProvisionData {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub meaning: ::core::option::Option<provision_data::MeaningCode>,
            /// The actual data reference
            #[prost(message, optional, tag = "5")]
            pub reference: ::core::option::Option<super::super::Reference>,
        }
        /// Nested message and enum types in `ProvisionData`.
        pub mod provision_data {
            /// instance | related | dependents | authoredby
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct MeaningCode {
                #[prost(
                    enumeration = "super::super::super::consent_data_meaning_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Contract, last updated
/// 2019-11-01T09:29:23.356+11:00. Legal Agreement. See
/// <http://hl7.org/fhir/StructureDefinition/Contract>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Contract {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Contract number
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Basal definition
    #[prost(message, optional, tag = "11")]
    pub url: ::core::option::Option<Uri>,
    /// Business edition
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<contract::StatusCode>,
    /// Negotiation status
    #[prost(message, optional, tag = "14")]
    pub legal_state: ::core::option::Option<CodeableConcept>,
    /// Source Contract Definition
    #[prost(message, optional, tag = "15")]
    pub instantiates_canonical: ::core::option::Option<Reference>,
    /// External Contract Definition
    #[prost(message, optional, tag = "16")]
    pub instantiates_uri: ::core::option::Option<Uri>,
    /// Content derived from the basal information
    #[prost(message, optional, tag = "17")]
    pub content_derivative: ::core::option::Option<CodeableConcept>,
    /// When this Contract was issued
    #[prost(message, optional, tag = "18")]
    pub issued: ::core::option::Option<DateTime>,
    /// Effective time
    #[prost(message, optional, tag = "19")]
    pub applies: ::core::option::Option<Period>,
    /// Contract cessation cause
    #[prost(message, optional, tag = "20")]
    pub expiration_type: ::core::option::Option<CodeableConcept>,
    /// Contract Target Entity
    #[prost(message, repeated, tag = "21")]
    pub subject: prost::alloc::vec::Vec<Reference>,
    /// Authority under which this Contract has standing
    #[prost(message, repeated, tag = "22")]
    pub authority: prost::alloc::vec::Vec<Reference>,
    /// A sphere of control governed by an authoritative jurisdiction,
    /// organization, or person
    #[prost(message, repeated, tag = "23")]
    pub domain: prost::alloc::vec::Vec<Reference>,
    /// Specific Location
    #[prost(message, repeated, tag = "24")]
    pub site: prost::alloc::vec::Vec<Reference>,
    /// Computer friendly designation
    #[prost(message, optional, tag = "25")]
    pub name: ::core::option::Option<String>,
    /// Human Friendly name
    #[prost(message, optional, tag = "26")]
    pub title: ::core::option::Option<String>,
    /// Subordinate Friendly name
    #[prost(message, optional, tag = "27")]
    pub subtitle: ::core::option::Option<String>,
    /// Acronym or short name
    #[prost(message, repeated, tag = "28")]
    pub alias: prost::alloc::vec::Vec<String>,
    /// Source of Contract
    #[prost(message, optional, tag = "29")]
    pub author: ::core::option::Option<Reference>,
    /// Range of Legal Concerns
    #[prost(message, optional, tag = "30")]
    pub scope: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "31")]
    pub topic: ::core::option::Option<contract::TopicX>,
    /// Legal instrument category
    #[prost(message, optional, tag = "32")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Subtype within the context of type
    #[prost(message, repeated, tag = "33")]
    pub sub_type: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, optional, tag = "34")]
    pub content_definition: ::core::option::Option<contract::ContentDefinition>,
    #[prost(message, repeated, tag = "35")]
    pub term: prost::alloc::vec::Vec<contract::Term>,
    /// Extra Information
    #[prost(message, repeated, tag = "36")]
    pub supporting_info: prost::alloc::vec::Vec<Reference>,
    /// Key event in Contract History
    #[prost(message, repeated, tag = "37")]
    pub relevant_history: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "38")]
    pub signer: prost::alloc::vec::Vec<contract::Signatory>,
    #[prost(message, repeated, tag = "39")]
    pub friendly: prost::alloc::vec::Vec<contract::FriendlyLanguage>,
    #[prost(message, repeated, tag = "40")]
    pub legal: prost::alloc::vec::Vec<contract::LegalLanguage>,
    #[prost(message, repeated, tag = "41")]
    pub rule: prost::alloc::vec::Vec<contract::ComputableLanguage>,
    #[prost(message, optional, tag = "42")]
    pub legally_binding: ::core::option::Option<contract::LegallyBindingX>,
}
/// Nested message and enum types in `Contract`.
pub mod contract {
    /// amended | appended | cancelled | disputed | entered-in-error | executable |
    /// executed | negotiable | offered | policy | rejected | renewed | revoked |
    /// resolved | terminated
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::contract_resource_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Focus of contract interest
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TopicX {
        #[prost(oneof = "topic_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<topic_x::Choice>,
    }
    /// Nested message and enum types in `TopicX`.
    pub mod topic_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Contract precursor content
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ContentDefinition {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Content structure and use
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Detailed Content Type Definition
        #[prost(message, optional, tag = "5")]
        pub sub_type: ::core::option::Option<super::CodeableConcept>,
        /// Publisher Entity
        #[prost(message, optional, tag = "6")]
        pub publisher: ::core::option::Option<super::Reference>,
        /// When published
        #[prost(message, optional, tag = "7")]
        pub publication_date: ::core::option::Option<super::DateTime>,
        #[prost(message, optional, tag = "8")]
        pub publication_status: ::core::option::Option<content_definition::PublicationStatusCode>,
        /// Publication Ownership
        #[prost(message, optional, tag = "9")]
        pub copyright: ::core::option::Option<super::Markdown>,
    }
    /// Nested message and enum types in `ContentDefinition`.
    pub mod content_definition {
        /// amended | appended | cancelled | disputed | entered-in-error | executable
        /// | executed | negotiable | offered | policy | rejected | renewed | revoked
        /// | resolved | terminated
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PublicationStatusCode {
            #[prost(
                enumeration = "super::super::contract_resource_publication_status_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Contract Term List
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Term {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Contract Term Number
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Contract Term Issue Date Time
        #[prost(message, optional, tag = "5")]
        pub issued: ::core::option::Option<super::DateTime>,
        /// Contract Term Effective Time
        #[prost(message, optional, tag = "6")]
        pub applies: ::core::option::Option<super::Period>,
        #[prost(message, optional, tag = "7")]
        pub topic: ::core::option::Option<term::TopicX>,
        /// Contract Term Type or Form
        #[prost(message, optional, tag = "8")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Contract Term Type specific classification
        #[prost(message, optional, tag = "9")]
        pub sub_type: ::core::option::Option<super::CodeableConcept>,
        /// Term Statement
        #[prost(message, optional, tag = "10")]
        pub text: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "11")]
        pub security_label: prost::alloc::vec::Vec<term::SecurityLabel>,
        #[prost(message, optional, tag = "12")]
        pub offer: ::core::option::Option<term::ContractOffer>,
        #[prost(message, repeated, tag = "13")]
        pub asset: prost::alloc::vec::Vec<term::ContractAsset>,
        #[prost(message, repeated, tag = "14")]
        pub action: prost::alloc::vec::Vec<term::Action>,
        /// Nested Contract Term Group
        #[prost(message, repeated, tag = "15")]
        pub group: prost::alloc::vec::Vec<Term>,
    }
    /// Nested message and enum types in `Term`.
    pub mod term {
        /// Term Concern
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TopicX {
            #[prost(oneof = "topic_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<topic_x::Choice>,
        }
        /// Nested message and enum types in `TopicX`.
        pub mod topic_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
        /// Protection for the Term
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SecurityLabel {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Link to Security Labels
            #[prost(message, repeated, tag = "4")]
            pub number: prost::alloc::vec::Vec<super::super::UnsignedInt>,
            /// Confidentiality Protection
            #[prost(message, optional, tag = "5")]
            pub classification: ::core::option::Option<super::super::Coding>,
            /// Applicable Policy
            #[prost(message, repeated, tag = "6")]
            pub category: prost::alloc::vec::Vec<super::super::Coding>,
            /// Handling Instructions
            #[prost(message, repeated, tag = "7")]
            pub control: prost::alloc::vec::Vec<super::super::Coding>,
        }
        /// Context of the Contract term
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ContractOffer {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Offer business ID
            #[prost(message, repeated, tag = "4")]
            pub identifier: prost::alloc::vec::Vec<super::super::Identifier>,
            #[prost(message, repeated, tag = "5")]
            pub party: prost::alloc::vec::Vec<contract_offer::ContractParty>,
            /// Negotiable offer asset
            #[prost(message, optional, tag = "6")]
            pub topic: ::core::option::Option<super::super::Reference>,
            /// Contract Offer Type or Form
            #[prost(message, optional, tag = "7")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Accepting party choice
            #[prost(message, optional, tag = "8")]
            pub decision: ::core::option::Option<super::super::CodeableConcept>,
            /// How decision is conveyed
            #[prost(message, repeated, tag = "9")]
            pub decision_mode: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            #[prost(message, repeated, tag = "10")]
            pub answer: prost::alloc::vec::Vec<contract_offer::Answer>,
            /// Human readable offer text
            #[prost(message, optional, tag = "11")]
            pub text: ::core::option::Option<super::super::String>,
            /// Pointer to text
            #[prost(message, repeated, tag = "12")]
            pub link_id: prost::alloc::vec::Vec<super::super::String>,
            /// Offer restriction numbers
            #[prost(message, repeated, tag = "13")]
            pub security_label_number: prost::alloc::vec::Vec<super::super::UnsignedInt>,
        }
        /// Nested message and enum types in `ContractOffer`.
        pub mod contract_offer {
            /// Offer Recipient
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ContractParty {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Referenced entity
                #[prost(message, repeated, tag = "4")]
                pub reference: prost::alloc::vec::Vec<super::super::super::Reference>,
                /// Participant engagement type
                #[prost(message, optional, tag = "5")]
                pub role: ::core::option::Option<super::super::super::CodeableConcept>,
            }
            /// Response to offer text
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Answer {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                #[prost(message, optional, tag = "4")]
                pub value: ::core::option::Option<answer::ValueX>,
            }
            /// Nested message and enum types in `Answer`.
            pub mod answer {
                /// The actual answer response
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ValueX {
                    #[prost(
                        oneof = "value_x::Choice",
                        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12"
                    )]
                    pub choice: ::core::option::Option<value_x::Choice>,
                }
                /// Nested message and enum types in `ValueX`.
                pub mod value_x {
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Oneof)]
                    pub enum Choice {
                        #[prost(message, tag = "1")]
                        Boolean(super::super::super::super::super::Boolean),
                        #[prost(message, tag = "2")]
                        Decimal(super::super::super::super::super::Decimal),
                        #[prost(message, tag = "3")]
                        Integer(super::super::super::super::super::Integer),
                        #[prost(message, tag = "4")]
                        Date(super::super::super::super::super::Date),
                        #[prost(message, tag = "5")]
                        DateTime(super::super::super::super::super::DateTime),
                        #[prost(message, tag = "6")]
                        Time(super::super::super::super::super::Time),
                        #[prost(message, tag = "7")]
                        StringValue(super::super::super::super::super::String),
                        #[prost(message, tag = "8")]
                        Uri(super::super::super::super::super::Uri),
                        #[prost(message, tag = "9")]
                        Attachment(super::super::super::super::super::Attachment),
                        #[prost(message, tag = "10")]
                        Coding(super::super::super::super::super::Coding),
                        #[prost(message, tag = "11")]
                        Quantity(super::super::super::super::super::Quantity),
                        #[prost(message, tag = "12")]
                        Reference(super::super::super::super::super::Reference),
                    }
                }
            }
        }
        /// Contract Term Asset List
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ContractAsset {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Range of asset
            #[prost(message, optional, tag = "4")]
            pub scope: ::core::option::Option<super::super::CodeableConcept>,
            /// Asset category
            #[prost(message, repeated, tag = "5")]
            pub r#type: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Associated entities
            #[prost(message, repeated, tag = "6")]
            pub type_reference: prost::alloc::vec::Vec<super::super::Reference>,
            /// Asset sub-category
            #[prost(message, repeated, tag = "7")]
            pub subtype: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Kinship of the asset
            #[prost(message, optional, tag = "8")]
            pub relationship: ::core::option::Option<super::super::Coding>,
            #[prost(message, repeated, tag = "9")]
            pub context: prost::alloc::vec::Vec<contract_asset::AssetContext>,
            /// Quality desctiption of asset
            #[prost(message, optional, tag = "10")]
            pub condition: ::core::option::Option<super::super::String>,
            /// Asset availability types
            #[prost(message, repeated, tag = "11")]
            pub period_type: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Time period of the asset
            #[prost(message, repeated, tag = "12")]
            pub period: prost::alloc::vec::Vec<super::super::Period>,
            /// Time period
            #[prost(message, repeated, tag = "13")]
            pub use_period: prost::alloc::vec::Vec<super::super::Period>,
            /// Asset clause or question text
            #[prost(message, optional, tag = "14")]
            pub text: ::core::option::Option<super::super::String>,
            /// Pointer to asset text
            #[prost(message, repeated, tag = "15")]
            pub link_id: prost::alloc::vec::Vec<super::super::String>,
            /// Response to assets
            #[prost(message, repeated, tag = "16")]
            pub answer: prost::alloc::vec::Vec<contract_offer::Answer>,
            /// Asset restriction numbers
            #[prost(message, repeated, tag = "17")]
            pub security_label_number: prost::alloc::vec::Vec<super::super::UnsignedInt>,
            #[prost(message, repeated, tag = "18")]
            pub valued_item: prost::alloc::vec::Vec<contract_asset::ValuedItem>,
        }
        /// Nested message and enum types in `ContractAsset`.
        pub mod contract_asset {
            /// Circumstance of the asset
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct AssetContext {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Creator,custodian or owner
                #[prost(message, optional, tag = "4")]
                pub reference: ::core::option::Option<super::super::super::Reference>,
                /// Codeable asset context
                #[prost(message, repeated, tag = "5")]
                pub code: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Context description
                #[prost(message, optional, tag = "6")]
                pub text: ::core::option::Option<super::super::super::String>,
            }
            /// Contract Valued Item List
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ValuedItem {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                #[prost(message, optional, tag = "4")]
                pub entity: ::core::option::Option<valued_item::EntityX>,
                /// Contract Valued Item Number
                #[prost(message, optional, tag = "5")]
                pub identifier: ::core::option::Option<super::super::super::Identifier>,
                /// Contract Valued Item Effective Tiem
                #[prost(message, optional, tag = "6")]
                pub effective_time: ::core::option::Option<super::super::super::DateTime>,
                /// Count of Contract Valued Items
                #[prost(message, optional, tag = "7")]
                pub quantity: ::core::option::Option<super::super::super::SimpleQuantity>,
                /// Contract Valued Item fee, charge, or cost
                #[prost(message, optional, tag = "8")]
                pub unit_price: ::core::option::Option<super::super::super::Money>,
                /// Contract Valued Item Price Scaling Factor
                #[prost(message, optional, tag = "9")]
                pub factor: ::core::option::Option<super::super::super::Decimal>,
                /// Contract Valued Item Difficulty Scaling Factor
                #[prost(message, optional, tag = "10")]
                pub points: ::core::option::Option<super::super::super::Decimal>,
                /// Total Contract Valued Item Value
                #[prost(message, optional, tag = "11")]
                pub net: ::core::option::Option<super::super::super::Money>,
                /// Terms of valuation
                #[prost(message, optional, tag = "12")]
                pub payment: ::core::option::Option<super::super::super::String>,
                /// When payment is due
                #[prost(message, optional, tag = "13")]
                pub payment_date: ::core::option::Option<super::super::super::DateTime>,
                /// Who will make payment
                #[prost(message, optional, tag = "14")]
                pub responsible: ::core::option::Option<super::super::super::Reference>,
                /// Who will receive payment
                #[prost(message, optional, tag = "15")]
                pub recipient: ::core::option::Option<super::super::super::Reference>,
                /// Pointer to specific item
                #[prost(message, repeated, tag = "16")]
                pub link_id: prost::alloc::vec::Vec<super::super::super::String>,
                /// Security Labels that define affected terms
                #[prost(message, repeated, tag = "17")]
                pub security_label_number: prost::alloc::vec::Vec<super::super::super::UnsignedInt>,
            }
            /// Nested message and enum types in `ValuedItem`.
            pub mod valued_item {
                /// Contract Valued Item Type
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct EntityX {
                    #[prost(oneof = "entity_x::Choice", tags = "1, 2")]
                    pub choice: ::core::option::Option<entity_x::Choice>,
                }
                /// Nested message and enum types in `EntityX`.
                pub mod entity_x {
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Oneof)]
                    pub enum Choice {
                        #[prost(message, tag = "1")]
                        CodeableConcept(super::super::super::super::super::CodeableConcept),
                        #[prost(message, tag = "2")]
                        Reference(super::super::super::super::super::Reference),
                    }
                }
            }
        }
        /// Entity being ascribed responsibility
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Action {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// True if the term prohibits the  action
            #[prost(message, optional, tag = "4")]
            pub do_not_perform: ::core::option::Option<super::super::Boolean>,
            /// Type or form of the action
            #[prost(message, optional, tag = "5")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            #[prost(message, repeated, tag = "6")]
            pub subject: prost::alloc::vec::Vec<action::ActionSubject>,
            /// Purpose for the Contract Term Action
            #[prost(message, optional, tag = "7")]
            pub intent: ::core::option::Option<super::super::CodeableConcept>,
            /// Pointer to specific item
            #[prost(message, repeated, tag = "8")]
            pub link_id: prost::alloc::vec::Vec<super::super::String>,
            /// State of the action
            #[prost(message, optional, tag = "9")]
            pub status: ::core::option::Option<super::super::CodeableConcept>,
            /// Episode associated with action
            #[prost(message, optional, tag = "10")]
            pub context: ::core::option::Option<super::super::Reference>,
            /// Pointer to specific item
            #[prost(message, repeated, tag = "11")]
            pub context_link_id: prost::alloc::vec::Vec<super::super::String>,
            #[prost(message, optional, tag = "12")]
            pub occurrence: ::core::option::Option<action::OccurrenceX>,
            /// Who asked for action
            #[prost(message, repeated, tag = "13")]
            pub requester: prost::alloc::vec::Vec<super::super::Reference>,
            /// Pointer to specific item
            #[prost(message, repeated, tag = "14")]
            pub requester_link_id: prost::alloc::vec::Vec<super::super::String>,
            /// Kind of service performer
            #[prost(message, repeated, tag = "15")]
            pub performer_type: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Competency of the performer
            #[prost(message, optional, tag = "16")]
            pub performer_role: ::core::option::Option<super::super::CodeableConcept>,
            /// Actor that wil execute (or not) the action
            #[prost(message, optional, tag = "17")]
            pub performer: ::core::option::Option<super::super::Reference>,
            /// Pointer to specific item
            #[prost(message, repeated, tag = "18")]
            pub performer_link_id: prost::alloc::vec::Vec<super::super::String>,
            /// Why is action (not) needed?
            #[prost(message, repeated, tag = "19")]
            pub reason_code: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Why is action (not) needed?
            #[prost(message, repeated, tag = "20")]
            pub reason_reference: prost::alloc::vec::Vec<super::super::Reference>,
            /// Why action is to be performed
            #[prost(message, repeated, tag = "21")]
            pub reason: prost::alloc::vec::Vec<super::super::String>,
            /// Pointer to specific item
            #[prost(message, repeated, tag = "22")]
            pub reason_link_id: prost::alloc::vec::Vec<super::super::String>,
            /// Comments about the action
            #[prost(message, repeated, tag = "23")]
            pub note: prost::alloc::vec::Vec<super::super::Annotation>,
            /// Action restriction numbers
            #[prost(message, repeated, tag = "24")]
            pub security_label_number: prost::alloc::vec::Vec<super::super::UnsignedInt>,
        }
        /// Nested message and enum types in `Action`.
        pub mod action {
            /// Entity of the action
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ActionSubject {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Entity of the action
                #[prost(message, repeated, tag = "4")]
                pub reference: prost::alloc::vec::Vec<super::super::super::Reference>,
                /// Role type of the agent
                #[prost(message, optional, tag = "5")]
                pub role: ::core::option::Option<super::super::super::CodeableConcept>,
            }
            /// When action happens
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct OccurrenceX {
                #[prost(oneof = "occurrence_x::Choice", tags = "1, 2, 3")]
                pub choice: ::core::option::Option<occurrence_x::Choice>,
            }
            /// Nested message and enum types in `OccurrenceX`.
            pub mod occurrence_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    DateTime(super::super::super::super::DateTime),
                    #[prost(message, tag = "2")]
                    Period(super::super::super::super::Period),
                    #[prost(message, tag = "3")]
                    Timing(super::super::super::super::Timing),
                }
            }
        }
    }
    /// Contract Signatory
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Signatory {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Contract Signatory Role
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::Coding>,
        /// Contract Signatory Party
        #[prost(message, optional, tag = "5")]
        pub party: ::core::option::Option<super::Reference>,
        /// Contract Documentation Signature
        #[prost(message, repeated, tag = "6")]
        pub signature: prost::alloc::vec::Vec<super::Signature>,
    }
    /// Contract Friendly Language
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FriendlyLanguage {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub content: ::core::option::Option<friendly_language::ContentX>,
    }
    /// Nested message and enum types in `FriendlyLanguage`.
    pub mod friendly_language {
        /// Easily comprehended representation of this Contract
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ContentX {
            #[prost(oneof = "content_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<content_x::Choice>,
        }
        /// Nested message and enum types in `ContentX`.
        pub mod content_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Contract Legal Language
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct LegalLanguage {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub content: ::core::option::Option<legal_language::ContentX>,
    }
    /// Nested message and enum types in `LegalLanguage`.
    pub mod legal_language {
        /// Contract Legal Text
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ContentX {
            #[prost(oneof = "content_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<content_x::Choice>,
        }
        /// Nested message and enum types in `ContentX`.
        pub mod content_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Computable Contract Language
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ComputableLanguage {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub content: ::core::option::Option<computable_language::ContentX>,
    }
    /// Nested message and enum types in `ComputableLanguage`.
    pub mod computable_language {
        /// Computable Contract Rules
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ContentX {
            #[prost(oneof = "content_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<content_x::Choice>,
        }
        /// Nested message and enum types in `ContentX`.
        pub mod content_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Binding Contract
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct LegallyBindingX {
        #[prost(oneof = "legally_binding_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<legally_binding_x::Choice>,
    }
    /// Nested message and enum types in `LegallyBindingX`.
    pub mod legally_binding_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for Coverage, last updated
/// 2019-11-01T09:29:23.356+11:00. Insurance or medical plan or a payment
/// agreement. See <http://hl7.org/fhir/StructureDefinition/Coverage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Coverage {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for the coverage
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<coverage::StatusCode>,
    /// Coverage category such as medical or accident
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Owner of the policy
    #[prost(message, optional, tag = "13")]
    pub policy_holder: ::core::option::Option<Reference>,
    /// Subscriber to the policy
    #[prost(message, optional, tag = "14")]
    pub subscriber: ::core::option::Option<Reference>,
    /// ID assigned to the subscriber
    #[prost(message, optional, tag = "15")]
    pub subscriber_id: ::core::option::Option<String>,
    /// Plan beneficiary
    #[prost(message, optional, tag = "16")]
    pub beneficiary: ::core::option::Option<Reference>,
    /// Dependent number
    #[prost(message, optional, tag = "17")]
    pub dependent: ::core::option::Option<String>,
    /// Beneficiary relationship to the subscriber
    #[prost(message, optional, tag = "18")]
    pub relationship: ::core::option::Option<CodeableConcept>,
    /// Coverage start and end dates
    #[prost(message, optional, tag = "19")]
    pub period: ::core::option::Option<Period>,
    /// Issuer of the policy
    #[prost(message, repeated, tag = "20")]
    pub payor: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "21")]
    pub class_value: prost::alloc::vec::Vec<coverage::Class>,
    /// Relative order of the coverage
    #[prost(message, optional, tag = "22")]
    pub order: ::core::option::Option<PositiveInt>,
    /// Insurer network
    #[prost(message, optional, tag = "23")]
    pub network: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "24")]
    pub cost_to_beneficiary: prost::alloc::vec::Vec<coverage::CostToBeneficiary>,
    /// Reimbursement to insurer
    #[prost(message, optional, tag = "25")]
    pub subrogation: ::core::option::Option<Boolean>,
    /// Contract details
    #[prost(message, repeated, tag = "26")]
    pub contract: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `Coverage`.
pub mod coverage {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::financial_resource_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Additional coverage classifications
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Class {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of class such as 'group' or 'plan'
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Value associated with the type
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<super::String>,
        /// Human readable description of the type and value
        #[prost(message, optional, tag = "6")]
        pub name: ::core::option::Option<super::String>,
    }
    /// Patient payments for services/products
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CostToBeneficiary {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Cost category
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<cost_to_beneficiary::ValueX>,
        #[prost(message, repeated, tag = "6")]
        pub exception: prost::alloc::vec::Vec<cost_to_beneficiary::Exemption>,
    }
    /// Nested message and enum types in `CostToBeneficiary`.
    pub mod cost_to_beneficiary {
        /// The amount or percentage due from the beneficiary
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(oneof = "value_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Quantity(super::super::super::SimpleQuantity),
                #[prost(message, tag = "2")]
                Money(super::super::super::Money),
            }
        }
        /// Exceptions for patient payments
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Exemption {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Exception category
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// The effective period of the exception
            #[prost(message, optional, tag = "5")]
            pub period: ::core::option::Option<super::super::Period>,
        }
    }
}
/// Auto-generated from StructureDefinition for CoverageEligibilityRequest, last
/// updated 2019-11-01T09:29:23.356+11:00. CoverageEligibilityRequest resource.
/// See <http://hl7.org/fhir/StructureDefinition/CoverageEligibilityRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CoverageEligibilityRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for coverage eligiblity request
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<coverage_eligibility_request::StatusCode>,
    /// Desired processing priority
    #[prost(message, optional, tag = "12")]
    pub priority: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "13")]
    pub purpose: prost::alloc::vec::Vec<coverage_eligibility_request::PurposeCode>,
    /// Intended recipient of products and services
    #[prost(message, optional, tag = "14")]
    pub patient: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "15")]
    pub serviced: ::core::option::Option<coverage_eligibility_request::ServicedX>,
    /// Creation date
    #[prost(message, optional, tag = "16")]
    pub created: ::core::option::Option<DateTime>,
    /// Author
    #[prost(message, optional, tag = "17")]
    pub enterer: ::core::option::Option<Reference>,
    /// Party responsible for the request
    #[prost(message, optional, tag = "18")]
    pub provider: ::core::option::Option<Reference>,
    /// Coverage issuer
    #[prost(message, optional, tag = "19")]
    pub insurer: ::core::option::Option<Reference>,
    /// Servicing facility
    #[prost(message, optional, tag = "20")]
    pub facility: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "21")]
    pub supporting_info:
        prost::alloc::vec::Vec<coverage_eligibility_request::SupportingInformation>,
    #[prost(message, repeated, tag = "22")]
    pub insurance: prost::alloc::vec::Vec<coverage_eligibility_request::Insurance>,
    #[prost(message, repeated, tag = "23")]
    pub item: prost::alloc::vec::Vec<coverage_eligibility_request::Details>,
}
/// Nested message and enum types in `CoverageEligibilityRequest`.
pub mod coverage_eligibility_request {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::financial_resource_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// auth-requirements | benefits | discovery | validation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PurposeCode {
        #[prost(
            enumeration = "super::eligibility_request_purpose_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Estimated date or dates of service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ServicedX {
        #[prost(oneof = "serviced_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<serviced_x::Choice>,
    }
    /// Nested message and enum types in `ServicedX`.
    pub mod serviced_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Supporting information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SupportingInformation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Information instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Data to be provided
        #[prost(message, optional, tag = "5")]
        pub information: ::core::option::Option<super::Reference>,
        /// Applies to all items
        #[prost(message, optional, tag = "6")]
        pub applies_to_all: ::core::option::Option<super::Boolean>,
    }
    /// Patient insurance information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Insurance {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Applicable coverage
        #[prost(message, optional, tag = "4")]
        pub focal: ::core::option::Option<super::Boolean>,
        /// Insurance information
        #[prost(message, optional, tag = "5")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// Additional provider contract number
        #[prost(message, optional, tag = "6")]
        pub business_arrangement: ::core::option::Option<super::String>,
    }
    /// Item to be evaluated for eligibiity
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Details {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Applicable exception or supporting information
        #[prost(message, repeated, tag = "4")]
        pub supporting_info_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Benefit classification
        #[prost(message, optional, tag = "5")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Billing, service, product, or drug code
        #[prost(message, optional, tag = "6")]
        pub product_or_service: ::core::option::Option<super::CodeableConcept>,
        /// Product or service billing modifiers
        #[prost(message, repeated, tag = "7")]
        pub modifier: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Perfoming practitioner
        #[prost(message, optional, tag = "8")]
        pub provider: ::core::option::Option<super::Reference>,
        /// Count of products or services
        #[prost(message, optional, tag = "9")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Fee, charge or cost per item
        #[prost(message, optional, tag = "10")]
        pub unit_price: ::core::option::Option<super::Money>,
        /// Servicing facility
        #[prost(message, optional, tag = "11")]
        pub facility: ::core::option::Option<super::Reference>,
        #[prost(message, repeated, tag = "12")]
        pub diagnosis: prost::alloc::vec::Vec<details::Diagnosis>,
        /// Product or service details
        #[prost(message, repeated, tag = "13")]
        pub detail: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Nested message and enum types in `Details`.
    pub mod details {
        /// Applicable diagnosis
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Diagnosis {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub diagnosis: ::core::option::Option<diagnosis::DiagnosisX>,
        }
        /// Nested message and enum types in `Diagnosis`.
        pub mod diagnosis {
            /// Nature of illness or problem
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct DiagnosisX {
                #[prost(oneof = "diagnosis_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<diagnosis_x::Choice>,
            }
            /// Nested message and enum types in `DiagnosisX`.
            pub mod diagnosis_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    CodeableConcept(super::super::super::super::CodeableConcept),
                    #[prost(message, tag = "2")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for CoverageEligibilityResponse, last
/// updated 2019-11-01T09:29:23.356+11:00. CoverageEligibilityResponse resource.
/// See <http://hl7.org/fhir/StructureDefinition/CoverageEligibilityResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CoverageEligibilityResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for coverage eligiblity request
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<coverage_eligibility_response::StatusCode>,
    #[prost(message, repeated, tag = "12")]
    pub purpose: prost::alloc::vec::Vec<coverage_eligibility_response::PurposeCode>,
    /// Intended recipient of products and services
    #[prost(message, optional, tag = "13")]
    pub patient: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "14")]
    pub serviced: ::core::option::Option<coverage_eligibility_response::ServicedX>,
    /// Response creation date
    #[prost(message, optional, tag = "15")]
    pub created: ::core::option::Option<DateTime>,
    /// Party responsible for the request
    #[prost(message, optional, tag = "16")]
    pub requestor: ::core::option::Option<Reference>,
    /// Eligibility request reference
    #[prost(message, optional, tag = "17")]
    pub request: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "18")]
    pub outcome: ::core::option::Option<coverage_eligibility_response::OutcomeCode>,
    /// Disposition Message
    #[prost(message, optional, tag = "19")]
    pub disposition: ::core::option::Option<String>,
    /// Coverage issuer
    #[prost(message, optional, tag = "20")]
    pub insurer: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "21")]
    pub insurance: prost::alloc::vec::Vec<coverage_eligibility_response::Insurance>,
    /// Preauthorization reference
    #[prost(message, optional, tag = "22")]
    pub pre_auth_ref: ::core::option::Option<String>,
    /// Printed form identifier
    #[prost(message, optional, tag = "23")]
    pub form: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "24")]
    pub error: prost::alloc::vec::Vec<coverage_eligibility_response::Errors>,
}
/// Nested message and enum types in `CoverageEligibilityResponse`.
pub mod coverage_eligibility_response {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::financial_resource_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// auth-requirements | benefits | discovery | validation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PurposeCode {
        #[prost(
            enumeration = "super::eligibility_response_purpose_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Estimated date or dates of service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ServicedX {
        #[prost(oneof = "serviced_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<serviced_x::Choice>,
    }
    /// Nested message and enum types in `ServicedX`.
    pub mod serviced_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// queued | complete | error | partial
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OutcomeCode {
        #[prost(enumeration = "super::claim_processing_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Patient insurance information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Insurance {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Insurance information
        #[prost(message, optional, tag = "4")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// Coverage inforce indicator
        #[prost(message, optional, tag = "5")]
        pub inforce: ::core::option::Option<super::Boolean>,
        /// When the benefits are applicable
        #[prost(message, optional, tag = "6")]
        pub benefit_period: ::core::option::Option<super::Period>,
        #[prost(message, repeated, tag = "7")]
        pub item: prost::alloc::vec::Vec<insurance::Items>,
    }
    /// Nested message and enum types in `Insurance`.
    pub mod insurance {
        /// Benefits and authorization details
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Items {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Benefit classification
            #[prost(message, optional, tag = "4")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Billing, service, product, or drug code
            #[prost(message, optional, tag = "5")]
            pub product_or_service: ::core::option::Option<super::super::CodeableConcept>,
            /// Product or service billing modifiers
            #[prost(message, repeated, tag = "6")]
            pub modifier: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Performing practitioner
            #[prost(message, optional, tag = "7")]
            pub provider: ::core::option::Option<super::super::Reference>,
            /// Excluded from the plan
            #[prost(message, optional, tag = "8")]
            pub excluded: ::core::option::Option<super::super::Boolean>,
            /// Short name for the benefit
            #[prost(message, optional, tag = "9")]
            pub name: ::core::option::Option<super::super::String>,
            /// Description of the benefit or services covered
            #[prost(message, optional, tag = "10")]
            pub description: ::core::option::Option<super::super::String>,
            /// In or out of network
            #[prost(message, optional, tag = "11")]
            pub network: ::core::option::Option<super::super::CodeableConcept>,
            /// Individual or family
            #[prost(message, optional, tag = "12")]
            pub unit: ::core::option::Option<super::super::CodeableConcept>,
            /// Annual or lifetime
            #[prost(message, optional, tag = "13")]
            pub term: ::core::option::Option<super::super::CodeableConcept>,
            #[prost(message, repeated, tag = "14")]
            pub benefit: prost::alloc::vec::Vec<items::Benefit>,
            /// Authorization required flag
            #[prost(message, optional, tag = "15")]
            pub authorization_required: ::core::option::Option<super::super::Boolean>,
            /// Type of required supporting materials
            #[prost(message, repeated, tag = "16")]
            pub authorization_supporting: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Preauthorization requirements endpoint
            #[prost(message, optional, tag = "17")]
            pub authorization_url: ::core::option::Option<super::super::Uri>,
        }
        /// Nested message and enum types in `Items`.
        pub mod items {
            /// Benefit Summary
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Benefit {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Benefit classification
                #[prost(message, optional, tag = "4")]
                pub r#type: ::core::option::Option<super::super::super::CodeableConcept>,
                #[prost(message, optional, tag = "5")]
                pub allowed: ::core::option::Option<benefit::AllowedX>,
                #[prost(message, optional, tag = "6")]
                pub used: ::core::option::Option<benefit::UsedX>,
            }
            /// Nested message and enum types in `Benefit`.
            pub mod benefit {
                /// Benefits allowed
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct AllowedX {
                    #[prost(oneof = "allowed_x::Choice", tags = "1, 2, 3")]
                    pub choice: ::core::option::Option<allowed_x::Choice>,
                }
                /// Nested message and enum types in `AllowedX`.
                pub mod allowed_x {
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Oneof)]
                    pub enum Choice {
                        #[prost(message, tag = "1")]
                        UnsignedInt(super::super::super::super::super::UnsignedInt),
                        #[prost(message, tag = "2")]
                        StringValue(super::super::super::super::super::String),
                        #[prost(message, tag = "3")]
                        Money(super::super::super::super::super::Money),
                    }
                }
                /// Benefits used
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct UsedX {
                    #[prost(oneof = "used_x::Choice", tags = "1, 2, 3")]
                    pub choice: ::core::option::Option<used_x::Choice>,
                }
                /// Nested message and enum types in `UsedX`.
                pub mod used_x {
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Oneof)]
                    pub enum Choice {
                        #[prost(message, tag = "1")]
                        UnsignedInt(super::super::super::super::super::UnsignedInt),
                        #[prost(message, tag = "2")]
                        StringValue(super::super::super::super::super::String),
                        #[prost(message, tag = "3")]
                        Money(super::super::super::super::super::Money),
                    }
                }
            }
        }
    }
    /// Processing errors
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Errors {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Error code detailing processing issues
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
    }
}
/// Auto-generated from StructureDefinition for DetectedIssue, last updated
/// 2019-11-01T09:29:23.356+11:00. Clinical issue with action. See
/// <http://hl7.org/fhir/StructureDefinition/DetectedIssue>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DetectedIssue {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique id for the detected issue
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<detected_issue::StatusCode>,
    /// Issue Category, e.g. drug-drug, duplicate therapy, etc.
    #[prost(message, optional, tag = "12")]
    pub code: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "13")]
    pub severity: ::core::option::Option<detected_issue::SeverityCode>,
    /// Associated patient
    #[prost(message, optional, tag = "14")]
    pub patient: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "15")]
    pub identified: ::core::option::Option<detected_issue::IdentifiedX>,
    /// The provider or device that identified the issue
    #[prost(message, optional, tag = "16")]
    pub author: ::core::option::Option<Reference>,
    /// Problem resource
    #[prost(message, repeated, tag = "17")]
    pub implicated: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "18")]
    pub evidence: prost::alloc::vec::Vec<detected_issue::Evidence>,
    /// Description and context
    #[prost(message, optional, tag = "19")]
    pub detail: ::core::option::Option<String>,
    /// Authority for issue
    #[prost(message, optional, tag = "20")]
    pub reference: ::core::option::Option<Uri>,
    #[prost(message, repeated, tag = "21")]
    pub mitigation: prost::alloc::vec::Vec<detected_issue::Mitigation>,
}
/// Nested message and enum types in `DetectedIssue`.
pub mod detected_issue {
    /// registered | preliminary | final | amended +
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::observation_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// high | moderate | low
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SeverityCode {
        #[prost(enumeration = "super::detected_issue_severity_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// When identified
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct IdentifiedX {
        #[prost(oneof = "identified_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<identified_x::Choice>,
    }
    /// Nested message and enum types in `IdentifiedX`.
    pub mod identified_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Supporting evidence
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Evidence {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Manifestation
        #[prost(message, repeated, tag = "4")]
        pub code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Supporting information
        #[prost(message, repeated, tag = "5")]
        pub detail: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Step taken to address
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Mitigation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// What mitigation?
        #[prost(message, optional, tag = "4")]
        pub action: ::core::option::Option<super::CodeableConcept>,
        /// Date committed
        #[prost(message, optional, tag = "5")]
        pub date: ::core::option::Option<super::DateTime>,
        /// Who is committing?
        #[prost(message, optional, tag = "6")]
        pub author: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for Device, last updated
/// 2019-11-01T09:29:23.356+11:00. Item used in healthcare. See
/// <http://hl7.org/fhir/StructureDefinition/Device>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Device {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Instance identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// The reference to the definition for the device
    #[prost(message, optional, tag = "11")]
    pub definition: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "12")]
    pub udi_carrier: prost::alloc::vec::Vec<device::UdiCarrier>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<device::StatusCode>,
    /// online | paused | standby | offline | not-ready | transduc-discon |
    /// hw-discon | off
    #[prost(message, repeated, tag = "14")]
    pub status_reason: prost::alloc::vec::Vec<CodeableConcept>,
    /// The distinct identification string
    #[prost(message, optional, tag = "15")]
    pub distinct_identifier: ::core::option::Option<String>,
    /// Name of device manufacturer
    #[prost(message, optional, tag = "16")]
    pub manufacturer: ::core::option::Option<String>,
    /// Date when the device was made
    #[prost(message, optional, tag = "17")]
    pub manufacture_date: ::core::option::Option<DateTime>,
    /// Date and time of expiry of this device (if applicable)
    #[prost(message, optional, tag = "18")]
    pub expiration_date: ::core::option::Option<DateTime>,
    /// Lot number of manufacture
    #[prost(message, optional, tag = "19")]
    pub lot_number: ::core::option::Option<String>,
    /// Serial number assigned by the manufacturer
    #[prost(message, optional, tag = "20")]
    pub serial_number: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "21")]
    pub device_name: prost::alloc::vec::Vec<device::DeviceName>,
    /// The model number for the device
    #[prost(message, optional, tag = "22")]
    pub model_number: ::core::option::Option<String>,
    /// The part number of the device
    #[prost(message, optional, tag = "23")]
    pub part_number: ::core::option::Option<String>,
    /// The kind or type of device
    #[prost(message, optional, tag = "24")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "25")]
    pub specialization: prost::alloc::vec::Vec<device::Specialization>,
    #[prost(message, repeated, tag = "26")]
    pub version: prost::alloc::vec::Vec<device::Version>,
    #[prost(message, repeated, tag = "27")]
    pub property: prost::alloc::vec::Vec<device::Property>,
    /// Patient to whom Device is affixed
    #[prost(message, optional, tag = "28")]
    pub patient: ::core::option::Option<Reference>,
    /// Organization responsible for device
    #[prost(message, optional, tag = "29")]
    pub owner: ::core::option::Option<Reference>,
    /// Details for human/organization for support
    #[prost(message, repeated, tag = "30")]
    pub contact: prost::alloc::vec::Vec<ContactPoint>,
    /// Where the device is found
    #[prost(message, optional, tag = "31")]
    pub location: ::core::option::Option<Reference>,
    /// Network address to contact device
    #[prost(message, optional, tag = "32")]
    pub url: ::core::option::Option<Uri>,
    /// Device notes and comments
    #[prost(message, repeated, tag = "33")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Safety Characteristics of Device
    #[prost(message, repeated, tag = "34")]
    pub safety: prost::alloc::vec::Vec<CodeableConcept>,
    /// The parent device
    #[prost(message, optional, tag = "35")]
    pub parent: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `Device`.
pub mod device {
    /// Unique Device Identifier (UDI) Barcode string
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UdiCarrier {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Mandatory fixed portion of UDI
        #[prost(message, optional, tag = "4")]
        pub device_identifier: ::core::option::Option<super::String>,
        /// UDI Issuing Organization
        #[prost(message, optional, tag = "5")]
        pub issuer: ::core::option::Option<super::Uri>,
        /// Regional UDI authority
        #[prost(message, optional, tag = "6")]
        pub jurisdiction: ::core::option::Option<super::Uri>,
        /// UDI Machine Readable Barcode String
        #[prost(message, optional, tag = "7")]
        pub carrier_aidc: ::core::option::Option<super::Base64Binary>,
        /// UDI Human Readable Barcode String
        #[prost(message, optional, tag = "8")]
        pub carrier_hrf: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "9")]
        pub entry_type: ::core::option::Option<udi_carrier::EntryTypeCode>,
    }
    /// Nested message and enum types in `UdiCarrier`.
    pub mod udi_carrier {
        /// barcode | rfid | manual +
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct EntryTypeCode {
            #[prost(enumeration = "super::super::udi_entry_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// active | inactive | entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::fhir_device_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// The name of the device as given by the manufacturer
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DeviceName {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The name of the device
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<device_name::TypeCode>,
    }
    /// Nested message and enum types in `DeviceName`.
    pub mod device_name {
        /// udi-label-name | user-friendly-name | patient-reported-name |
        /// manufacturer-name | model-name | other
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::device_name_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// The capabilities supported on a  device, the standards to which the device
    /// conforms for a particular purpose, and used for the communication
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Specialization {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The standard that is used to operate and communicate
        #[prost(message, optional, tag = "4")]
        pub system_type: ::core::option::Option<super::CodeableConcept>,
        /// The version of the standard that is used to operate and communicate
        #[prost(message, optional, tag = "5")]
        pub version: ::core::option::Option<super::String>,
    }
    /// The actual design of the device or software version running on the device
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Version {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The type of the device version
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// A single component of the device version
        #[prost(message, optional, tag = "5")]
        pub component: ::core::option::Option<super::Identifier>,
        /// The version text
        #[prost(message, optional, tag = "6")]
        pub value: ::core::option::Option<super::String>,
    }
    /// The actual configuration settings of a device as it actually operates,
    /// e.g., regulation status, time properties
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Property {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Code that specifies the property DeviceDefinitionPropetyCode (Extensible)
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Property value as a quantity
        #[prost(message, repeated, tag = "5")]
        pub value_quantity: prost::alloc::vec::Vec<super::Quantity>,
        /// Property value as a code, e.g., NTP4 (synced to NTP)
        #[prost(message, repeated, tag = "6")]
        pub value_code: prost::alloc::vec::Vec<super::CodeableConcept>,
    }
}
/// Auto-generated from StructureDefinition for DeviceDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. An instance of a medical-related component of
/// a medical device. See
/// <http://hl7.org/fhir/StructureDefinition/DeviceDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Instance identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, repeated, tag = "11")]
    pub udi_device_identifier: prost::alloc::vec::Vec<device_definition::UdiDeviceIdentifier>,
    #[prost(message, optional, tag = "12")]
    pub manufacturer: ::core::option::Option<device_definition::ManufacturerX>,
    #[prost(message, repeated, tag = "13")]
    pub device_name: prost::alloc::vec::Vec<device_definition::DeviceName>,
    /// The model number for the device
    #[prost(message, optional, tag = "14")]
    pub model_number: ::core::option::Option<String>,
    /// What kind of device or device system this is
    #[prost(message, optional, tag = "15")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "16")]
    pub specialization: prost::alloc::vec::Vec<device_definition::Specialization>,
    /// Available versions
    #[prost(message, repeated, tag = "17")]
    pub version: prost::alloc::vec::Vec<String>,
    /// Safety characteristics of the device
    #[prost(message, repeated, tag = "18")]
    pub safety: prost::alloc::vec::Vec<CodeableConcept>,
    /// Shelf Life and storage information
    #[prost(message, repeated, tag = "19")]
    pub shelf_life_storage: prost::alloc::vec::Vec<ProductShelfLife>,
    /// Dimensions, color etc.
    #[prost(message, optional, tag = "20")]
    pub physical_characteristics: ::core::option::Option<ProdCharacteristic>,
    /// Language code for the human-readable text strings produced by the device
    /// (all supported)
    #[prost(message, repeated, tag = "21")]
    pub language_code: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "22")]
    pub capability: prost::alloc::vec::Vec<device_definition::Capability>,
    #[prost(message, repeated, tag = "23")]
    pub property: prost::alloc::vec::Vec<device_definition::Property>,
    /// Organization responsible for device
    #[prost(message, optional, tag = "24")]
    pub owner: ::core::option::Option<Reference>,
    /// Details for human/organization for support
    #[prost(message, repeated, tag = "25")]
    pub contact: prost::alloc::vec::Vec<ContactPoint>,
    /// Network address to contact device
    #[prost(message, optional, tag = "26")]
    pub url: ::core::option::Option<Uri>,
    /// Access to on-line information
    #[prost(message, optional, tag = "27")]
    pub online_information: ::core::option::Option<Uri>,
    /// Device notes and comments
    #[prost(message, repeated, tag = "28")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// The quantity of the device present in the packaging (e.g. the number of
    /// devices present in a pack, or the number of devices in the same package of
    /// the medicinal product)
    #[prost(message, optional, tag = "29")]
    pub quantity: ::core::option::Option<Quantity>,
    /// The parent device it can be part of
    #[prost(message, optional, tag = "30")]
    pub parent_device: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "31")]
    pub material: prost::alloc::vec::Vec<device_definition::Material>,
}
/// Nested message and enum types in `DeviceDefinition`.
pub mod device_definition {
    /// Unique Device Identifier (UDI) Barcode string
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UdiDeviceIdentifier {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The identifier that is to be associated with every Device that references
        /// this DeviceDefintiion for the issuer and jurisdication porvided in the
        /// DeviceDefinition.udiDeviceIdentifier
        #[prost(message, optional, tag = "4")]
        pub device_identifier: ::core::option::Option<super::String>,
        /// The organization that assigns the identifier algorithm
        #[prost(message, optional, tag = "5")]
        pub issuer: ::core::option::Option<super::Uri>,
        /// The jurisdiction to which the deviceIdentifier applies
        #[prost(message, optional, tag = "6")]
        pub jurisdiction: ::core::option::Option<super::Uri>,
    }
    /// Name of device manufacturer
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ManufacturerX {
        #[prost(oneof = "manufacturer_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<manufacturer_x::Choice>,
    }
    /// Nested message and enum types in `ManufacturerX`.
    pub mod manufacturer_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            StringValue(super::super::String),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// A name given to the device to identify it
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DeviceName {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The name of the device
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<device_name::TypeCode>,
    }
    /// Nested message and enum types in `DeviceName`.
    pub mod device_name {
        /// udi-label-name | user-friendly-name | patient-reported-name |
        /// manufacturer-name | model-name | other
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::device_name_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// The capabilities supported on a  device, the standards to which the device
    /// conforms for a particular purpose, and used for the communication
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Specialization {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The standard that is used to operate and communicate
        #[prost(message, optional, tag = "4")]
        pub system_type: ::core::option::Option<super::String>,
        /// The version of the standard that is used to operate and communicate
        #[prost(message, optional, tag = "5")]
        pub version: ::core::option::Option<super::String>,
    }
    /// Device capabilities
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Capability {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of capability
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Description of capability
        #[prost(message, repeated, tag = "5")]
        pub description: prost::alloc::vec::Vec<super::CodeableConcept>,
    }
    /// The actual configuration settings of a device as it actually operates,
    /// e.g., regulation status, time properties
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Property {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Code that specifies the property DeviceDefinitionPropetyCode (Extensible)
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Property value as a quantity
        #[prost(message, repeated, tag = "5")]
        pub value_quantity: prost::alloc::vec::Vec<super::Quantity>,
        /// Property value as a code, e.g., NTP4 (synced to NTP)
        #[prost(message, repeated, tag = "6")]
        pub value_code: prost::alloc::vec::Vec<super::CodeableConcept>,
    }
    /// A substance used to create the material(s) of which the device is made
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Material {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The substance
        #[prost(message, optional, tag = "4")]
        pub substance: ::core::option::Option<super::CodeableConcept>,
        /// Indicates an alternative material of the device
        #[prost(message, optional, tag = "5")]
        pub alternate: ::core::option::Option<super::Boolean>,
        /// Whether the substance is a known or suspected allergen
        #[prost(message, optional, tag = "6")]
        pub allergenic_indicator: ::core::option::Option<super::Boolean>,
    }
}
/// Auto-generated from StructureDefinition for DeviceMetric, last updated
/// 2019-11-01T09:29:23.356+11:00. Measurement, calculation or setting capability
/// of a medical device. See <http://hl7.org/fhir/StructureDefinition/DeviceMetric>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetric {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Instance identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Identity of metric, for example Heart Rate or PEEP Setting
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Unit of Measure for the Metric
    #[prost(message, optional, tag = "12")]
    pub unit: ::core::option::Option<CodeableConcept>,
    /// Describes the link to the source Device
    #[prost(message, optional, tag = "13")]
    pub source: ::core::option::Option<Reference>,
    /// Describes the link to the parent Device
    #[prost(message, optional, tag = "14")]
    pub parent: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "15")]
    pub operational_status: ::core::option::Option<device_metric::OperationalStatusCode>,
    #[prost(message, optional, tag = "16")]
    pub color: ::core::option::Option<device_metric::ColorCode>,
    #[prost(message, optional, tag = "17")]
    pub category: ::core::option::Option<device_metric::CategoryCode>,
    /// Describes the measurement repetition time
    #[prost(message, optional, tag = "18")]
    pub measurement_period: ::core::option::Option<Timing>,
    #[prost(message, repeated, tag = "19")]
    pub calibration: prost::alloc::vec::Vec<device_metric::Calibration>,
}
/// Nested message and enum types in `DeviceMetric`.
pub mod device_metric {
    /// on | off | standby | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OperationalStatusCode {
        #[prost(
            enumeration = "super::device_metric_operational_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// black | red | green | yellow | blue | magenta | cyan | white
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ColorCode {
        #[prost(enumeration = "super::device_metric_color_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// measurement | setting | calculation | unspecified
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CategoryCode {
        #[prost(enumeration = "super::device_metric_category_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Describes the calibrations that have been performed or that are required to
    /// be performed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Calibration {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<calibration::TypeCode>,
        #[prost(message, optional, tag = "5")]
        pub state: ::core::option::Option<calibration::StateCode>,
        /// Describes the time last calibration has been performed
        #[prost(message, optional, tag = "6")]
        pub time: ::core::option::Option<super::Instant>,
    }
    /// Nested message and enum types in `Calibration`.
    pub mod calibration {
        /// unspecified | offset | gain | two-point
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(
                enumeration = "super::super::device_metric_calibration_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// not-calibrated | calibration-required | calibrated | unspecified
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct StateCode {
            #[prost(
                enumeration = "super::super::device_metric_calibration_state_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for DeviceRequest, last updated
/// 2019-11-01T09:29:23.356+11:00. Medical device request. See
/// <http://hl7.org/fhir/StructureDefinition/DeviceRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Request identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates FHIR protocol or definition
    #[prost(message, repeated, tag = "11")]
    pub instantiates_canonical: prost::alloc::vec::Vec<Canonical>,
    /// Instantiates external protocol or definition
    #[prost(message, repeated, tag = "12")]
    pub instantiates_uri: prost::alloc::vec::Vec<Uri>,
    /// What request fulfills
    #[prost(message, repeated, tag = "13")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// What request replaces
    #[prost(message, repeated, tag = "14")]
    pub prior_request: prost::alloc::vec::Vec<Reference>,
    /// Identifier of composite request
    #[prost(message, optional, tag = "15")]
    pub group_identifier: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<device_request::StatusCode>,
    #[prost(message, optional, tag = "17")]
    pub intent: ::core::option::Option<device_request::IntentCode>,
    #[prost(message, optional, tag = "18")]
    pub priority: ::core::option::Option<device_request::PriorityCode>,
    #[prost(message, optional, tag = "19")]
    pub code: ::core::option::Option<device_request::CodeX>,
    #[prost(message, repeated, tag = "20")]
    pub parameter: prost::alloc::vec::Vec<device_request::Parameter>,
    /// Focus of request
    #[prost(message, optional, tag = "21")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter motivating request
    #[prost(message, optional, tag = "22")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "23")]
    pub occurrence: ::core::option::Option<device_request::OccurrenceX>,
    /// When recorded
    #[prost(message, optional, tag = "24")]
    pub authored_on: ::core::option::Option<DateTime>,
    /// Who/what is requesting diagnostics
    #[prost(message, optional, tag = "25")]
    pub requester: ::core::option::Option<Reference>,
    /// Filler role
    #[prost(message, optional, tag = "26")]
    pub performer_type: ::core::option::Option<CodeableConcept>,
    /// Requested Filler
    #[prost(message, optional, tag = "27")]
    pub performer: ::core::option::Option<Reference>,
    /// Coded Reason for request
    #[prost(message, repeated, tag = "28")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Linked Reason for request
    #[prost(message, repeated, tag = "29")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Associated insurance coverage
    #[prost(message, repeated, tag = "30")]
    pub insurance: prost::alloc::vec::Vec<Reference>,
    /// Additional clinical information
    #[prost(message, repeated, tag = "31")]
    pub supporting_info: prost::alloc::vec::Vec<Reference>,
    /// Notes or comments
    #[prost(message, repeated, tag = "32")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Request provenance
    #[prost(message, repeated, tag = "33")]
    pub relevant_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `DeviceRequest`.
pub mod device_request {
    /// draft | active | on-hold | revoked | completed | entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::request_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// proposal | plan | directive | order | original-order | reflex-order |
    /// filler-order | instance-order | option
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct IntentCode {
        #[prost(enumeration = "super::request_intent_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// routine | urgent | asap | stat
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PriorityCode {
        #[prost(enumeration = "super::request_priority_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Device requested
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CodeX {
        #[prost(oneof = "code_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<code_x::Choice>,
    }
    /// Nested message and enum types in `CodeX`.
    pub mod code_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Reference(super::super::Reference),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// Device details
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Parameter {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Device detail
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<parameter::ValueX>,
    }
    /// Nested message and enum types in `Parameter`.
    pub mod parameter {
        /// Value of detail
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4")]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "3")]
                Range(super::super::super::Range),
                #[prost(message, tag = "4")]
                Boolean(super::super::super::Boolean),
            }
        }
    }
    /// Desired time or schedule for use
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OccurrenceX {
        #[prost(oneof = "occurrence_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<occurrence_x::Choice>,
    }
    /// Nested message and enum types in `OccurrenceX`.
    pub mod occurrence_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
        }
    }
}
/// Auto-generated from StructureDefinition for DeviceUseStatement, last updated
/// 2019-11-01T09:29:23.356+11:00. Record of use of a device. See
/// <http://hl7.org/fhir/StructureDefinition/DeviceUseStatement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceUseStatement {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier for this record
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Fulfills plan, proposal or order
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<device_use_statement::StatusCode>,
    /// Patient using device
    #[prost(message, optional, tag = "13")]
    pub subject: ::core::option::Option<Reference>,
    /// Supporting information
    #[prost(message, repeated, tag = "14")]
    pub derived_from: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "15")]
    pub timing: ::core::option::Option<device_use_statement::TimingX>,
    /// When statement was recorded
    #[prost(message, optional, tag = "16")]
    pub recorded_on: ::core::option::Option<DateTime>,
    /// Who made the statement
    #[prost(message, optional, tag = "17")]
    pub source: ::core::option::Option<Reference>,
    /// Reference to device used
    #[prost(message, optional, tag = "18")]
    pub device: ::core::option::Option<Reference>,
    /// Why device was used
    #[prost(message, repeated, tag = "19")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why was DeviceUseStatement performed?
    #[prost(message, repeated, tag = "20")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Target body site
    #[prost(message, optional, tag = "21")]
    pub body_site: ::core::option::Option<CodeableConcept>,
    /// Addition details (comments, instructions)
    #[prost(message, repeated, tag = "22")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `DeviceUseStatement`.
pub mod device_use_statement {
    /// active | completed | entered-in-error +
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::device_use_statement_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// How often  the device was used
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TimingX {
        #[prost(oneof = "timing_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<timing_x::Choice>,
    }
    /// Nested message and enum types in `TimingX`.
    pub mod timing_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Timing(super::super::Timing),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            DateTime(super::super::DateTime),
        }
    }
}
/// Auto-generated from StructureDefinition for DiagnosticReport, last updated
/// 2019-11-01T09:29:23.356+11:00. A Diagnostic report - a combination of request
/// information, atomic results, images, interpretation, as well as formatted
/// reports. See <http://hl7.org/fhir/StructureDefinition/DiagnosticReport>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReport {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier for report
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// What was requested
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<diagnostic_report::StatusCode>,
    /// Service category
    #[prost(message, repeated, tag = "13")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Name/Code for this diagnostic report
    #[prost(message, optional, tag = "14")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// The subject of the report - usually, but not always, the patient
    #[prost(message, optional, tag = "15")]
    pub subject: ::core::option::Option<Reference>,
    /// Health care event when test ordered
    #[prost(message, optional, tag = "16")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "17")]
    pub effective: ::core::option::Option<diagnostic_report::EffectiveX>,
    /// DateTime this version was made
    #[prost(message, optional, tag = "18")]
    pub issued: ::core::option::Option<Instant>,
    /// Responsible Diagnostic Service
    #[prost(message, repeated, tag = "19")]
    pub performer: prost::alloc::vec::Vec<Reference>,
    /// Primary result interpreter
    #[prost(message, repeated, tag = "20")]
    pub results_interpreter: prost::alloc::vec::Vec<Reference>,
    /// Specimens this report is based on
    #[prost(message, repeated, tag = "21")]
    pub specimen: prost::alloc::vec::Vec<Reference>,
    /// Observations
    #[prost(message, repeated, tag = "22")]
    pub result: prost::alloc::vec::Vec<Reference>,
    /// Reference to full details of imaging associated with the diagnostic report
    #[prost(message, repeated, tag = "23")]
    pub imaging_study: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "24")]
    pub media: prost::alloc::vec::Vec<diagnostic_report::Media>,
    /// Clinical conclusion (interpretation) of test results
    #[prost(message, optional, tag = "25")]
    pub conclusion: ::core::option::Option<String>,
    /// Codes for the clinical conclusion of test results
    #[prost(message, repeated, tag = "26")]
    pub conclusion_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Entire report as issued
    #[prost(message, repeated, tag = "27")]
    pub presented_form: prost::alloc::vec::Vec<Attachment>,
}
/// Nested message and enum types in `DiagnosticReport`.
pub mod diagnostic_report {
    /// registered | partial | preliminary | final +
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::diagnostic_report_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Clinically relevant time/time-period for report
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EffectiveX {
        #[prost(oneof = "effective_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<effective_x::Choice>,
    }
    /// Nested message and enum types in `EffectiveX`.
    pub mod effective_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Key images associated with this report
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Media {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Comment about the image (e.g. explanation)
        #[prost(message, optional, tag = "4")]
        pub comment: ::core::option::Option<super::String>,
        /// Reference to the image source
        #[prost(message, optional, tag = "5")]
        pub link: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for DocumentManifest, last updated
/// 2019-11-01T09:29:23.356+11:00. A list that defines a set of documents. See
/// <http://hl7.org/fhir/StructureDefinition/DocumentManifest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DocumentManifest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique Identifier for the set of documents
    #[prost(message, optional, tag = "10")]
    pub master_identifier: ::core::option::Option<Identifier>,
    /// Other identifiers for the manifest
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<document_manifest::StatusCode>,
    /// Kind of document set
    #[prost(message, optional, tag = "13")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// The subject of the set of documents
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// When this document manifest created
    #[prost(message, optional, tag = "15")]
    pub created: ::core::option::Option<DateTime>,
    /// Who and/or what authored the DocumentManifest
    #[prost(message, repeated, tag = "16")]
    pub author: prost::alloc::vec::Vec<Reference>,
    /// Intended to get notified about this set of documents
    #[prost(message, repeated, tag = "17")]
    pub recipient: prost::alloc::vec::Vec<Reference>,
    /// The source system/application/software
    #[prost(message, optional, tag = "18")]
    pub source: ::core::option::Option<Uri>,
    /// Human-readable description (title)
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<String>,
    /// Items in manifest
    #[prost(message, repeated, tag = "20")]
    pub content: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "21")]
    pub related: prost::alloc::vec::Vec<document_manifest::Related>,
}
/// Nested message and enum types in `DocumentManifest`.
pub mod document_manifest {
    /// current | superseded | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::document_reference_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Related things
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Related {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifiers of things that are related
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Related Resource
        #[prost(message, optional, tag = "5")]
        pub r#ref: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for DocumentReference, last updated
/// 2019-11-01T09:29:23.356+11:00. A reference to a document. See
/// <http://hl7.org/fhir/StructureDefinition/DocumentReference>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DocumentReference {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Master Version Specific Identifier
    #[prost(message, optional, tag = "10")]
    pub master_identifier: ::core::option::Option<Identifier>,
    /// Other identifiers for the document
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<document_reference::StatusCode>,
    #[prost(message, optional, tag = "13")]
    pub doc_status: ::core::option::Option<document_reference::DocStatusCode>,
    /// Kind of document (LOINC if possible)
    #[prost(message, optional, tag = "14")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Categorization of document
    #[prost(message, repeated, tag = "15")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who/what is the subject of the document
    #[prost(message, optional, tag = "16")]
    pub subject: ::core::option::Option<Reference>,
    /// When this document reference was created
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<Instant>,
    /// Who and/or what authored the document
    #[prost(message, repeated, tag = "18")]
    pub author: prost::alloc::vec::Vec<Reference>,
    /// Who/what authenticated the document
    #[prost(message, optional, tag = "19")]
    pub authenticator: ::core::option::Option<Reference>,
    /// Organization which maintains the document
    #[prost(message, optional, tag = "20")]
    pub custodian: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "21")]
    pub relates_to: prost::alloc::vec::Vec<document_reference::RelatesTo>,
    /// Human-readable description
    #[prost(message, optional, tag = "22")]
    pub description: ::core::option::Option<String>,
    /// Document security-tags
    #[prost(message, repeated, tag = "23")]
    pub security_label: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "24")]
    pub content: prost::alloc::vec::Vec<document_reference::Content>,
    #[prost(message, optional, tag = "25")]
    pub context: ::core::option::Option<document_reference::Context>,
}
/// Nested message and enum types in `DocumentReference`.
pub mod document_reference {
    /// current | superseded | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::document_reference_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// preliminary | final | amended | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DocStatusCode {
        #[prost(enumeration = "super::composition_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Relationships to other documents
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelatesTo {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<relates_to::CodeType>,
        /// Target of the relationship
        #[prost(message, optional, tag = "5")]
        pub target: ::core::option::Option<super::Reference>,
    }
    /// Nested message and enum types in `RelatesTo`.
    pub mod relates_to {
        /// replaces | transforms | signs | appends
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CodeType {
            #[prost(
                enumeration = "super::super::document_relationship_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Document referenced
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Content {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Where to access the document
        #[prost(message, optional, tag = "4")]
        pub attachment: ::core::option::Option<super::Attachment>,
        /// Format/content rules for the document
        #[prost(message, optional, tag = "5")]
        pub format: ::core::option::Option<super::Coding>,
    }
    /// Clinical context of document
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Context {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Context of the document  content
        #[prost(message, repeated, tag = "4")]
        pub encounter: prost::alloc::vec::Vec<super::Reference>,
        /// Main clinical acts documented
        #[prost(message, repeated, tag = "5")]
        pub event: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Time of service that is being documented
        #[prost(message, optional, tag = "6")]
        pub period: ::core::option::Option<super::Period>,
        /// Kind of facility where patient was seen
        #[prost(message, optional, tag = "7")]
        pub facility_type: ::core::option::Option<super::CodeableConcept>,
        /// Additional details about where the content was created (e.g. clinical
        /// specialty)
        #[prost(message, optional, tag = "8")]
        pub practice_setting: ::core::option::Option<super::CodeableConcept>,
        /// Patient demographics from source
        #[prost(message, optional, tag = "9")]
        pub source_patient_info: ::core::option::Option<super::Reference>,
        /// Related identifiers or resources
        #[prost(message, repeated, tag = "10")]
        pub related: prost::alloc::vec::Vec<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for EffectEvidenceSynthesis, last
/// updated 2019-11-01T09:29:23.356+11:00. A quantified estimate of effect based
/// on a body of evidence. See
/// <http://hl7.org/fhir/StructureDefinition/EffectEvidenceSynthesis>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EffectEvidenceSynthesis {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this effect evidence synthesis, represented as a
    /// URI (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the effect evidence synthesis
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the effect evidence synthesis
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this effect evidence synthesis (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this effect evidence synthesis (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<effect_evidence_synthesis::StatusCode>,
    /// Date last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the effect evidence synthesis
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Used for footnotes or explanatory notes
    #[prost(message, repeated, tag = "20")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "21")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for effect evidence synthesis (if applicable)
    #[prost(message, repeated, tag = "22")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "23")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the effect evidence synthesis was approved by publisher
    #[prost(message, optional, tag = "24")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the effect evidence synthesis was last reviewed
    #[prost(message, optional, tag = "25")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the effect evidence synthesis is expected to be used
    #[prost(message, optional, tag = "26")]
    pub effective_period: ::core::option::Option<Period>,
    /// The category of the EffectEvidenceSynthesis, such as Education, Treatment,
    /// Assessment, etc.
    #[prost(message, repeated, tag = "27")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "28")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "29")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "30")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "31")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "32")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Type of synthesis
    #[prost(message, optional, tag = "33")]
    pub synthesis_type: ::core::option::Option<CodeableConcept>,
    /// Type of study
    #[prost(message, optional, tag = "34")]
    pub study_type: ::core::option::Option<CodeableConcept>,
    /// What population?
    #[prost(message, optional, tag = "35")]
    pub population: ::core::option::Option<Reference>,
    /// What exposure?
    #[prost(message, optional, tag = "36")]
    pub exposure: ::core::option::Option<Reference>,
    /// What comparison exposure?
    #[prost(message, optional, tag = "37")]
    pub exposure_alternative: ::core::option::Option<Reference>,
    /// What outcome?
    #[prost(message, optional, tag = "38")]
    pub outcome: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "39")]
    pub sample_size: ::core::option::Option<effect_evidence_synthesis::SampleSize>,
    #[prost(message, repeated, tag = "40")]
    pub results_by_exposure: prost::alloc::vec::Vec<effect_evidence_synthesis::ResultsByExposure>,
    #[prost(message, repeated, tag = "41")]
    pub effect_estimate: prost::alloc::vec::Vec<effect_evidence_synthesis::EffectEstimate>,
    #[prost(message, repeated, tag = "42")]
    pub certainty: prost::alloc::vec::Vec<effect_evidence_synthesis::Certainty>,
}
/// Nested message and enum types in `EffectEvidenceSynthesis`.
pub mod effect_evidence_synthesis {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// What sample size was involved?
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SampleSize {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Description of sample size
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// How many studies?
        #[prost(message, optional, tag = "5")]
        pub number_of_studies: ::core::option::Option<super::Integer>,
        /// How many participants?
        #[prost(message, optional, tag = "6")]
        pub number_of_participants: ::core::option::Option<super::Integer>,
    }
    /// What was the result per exposure?
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ResultsByExposure {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Description of results by exposure
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub exposure_state: ::core::option::Option<results_by_exposure::ExposureStateCode>,
        /// Variant exposure states
        #[prost(message, optional, tag = "6")]
        pub variant_state: ::core::option::Option<super::CodeableConcept>,
        /// Risk evidence synthesis
        #[prost(message, optional, tag = "7")]
        pub risk_evidence_synthesis: ::core::option::Option<super::Reference>,
    }
    /// Nested message and enum types in `ResultsByExposure`.
    pub mod results_by_exposure {
        /// exposure | exposure-alternative
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ExposureStateCode {
            #[prost(enumeration = "super::super::exposure_state_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// What was the estimated effect
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EffectEstimate {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Description of effect estimate
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Type of efffect estimate
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Variant exposure states
        #[prost(message, optional, tag = "6")]
        pub variant_state: ::core::option::Option<super::CodeableConcept>,
        /// Point estimate
        #[prost(message, optional, tag = "7")]
        pub value: ::core::option::Option<super::Decimal>,
        /// What unit is the outcome described in?
        #[prost(message, optional, tag = "8")]
        pub unit_of_measure: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "9")]
        pub precision_estimate: prost::alloc::vec::Vec<effect_estimate::PrecisionEstimate>,
    }
    /// Nested message and enum types in `EffectEstimate`.
    pub mod effect_estimate {
        /// How precise the estimate is
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PrecisionEstimate {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of precision estimate
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Level of confidence interval
            #[prost(message, optional, tag = "5")]
            pub level: ::core::option::Option<super::super::Decimal>,
            /// Lower bound
            #[prost(message, optional, tag = "6")]
            pub from: ::core::option::Option<super::super::Decimal>,
            /// Upper bound
            #[prost(message, optional, tag = "7")]
            pub to: ::core::option::Option<super::super::Decimal>,
        }
    }
    /// How certain is the effect
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Certainty {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Certainty rating
        #[prost(message, repeated, tag = "4")]
        pub rating: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Used for footnotes or explanatory notes
        #[prost(message, repeated, tag = "5")]
        pub note: prost::alloc::vec::Vec<super::Annotation>,
        #[prost(message, repeated, tag = "6")]
        pub certainty_subcomponent: prost::alloc::vec::Vec<certainty::CertaintySubcomponent>,
    }
    /// Nested message and enum types in `Certainty`.
    pub mod certainty {
        /// A component that contributes to the overall certainty
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CertaintySubcomponent {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of subcomponent of certainty rating
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Subcomponent certainty rating
            #[prost(message, repeated, tag = "5")]
            pub rating: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Used for footnotes or explanatory notes
            #[prost(message, repeated, tag = "6")]
            pub note: prost::alloc::vec::Vec<super::super::Annotation>,
        }
    }
}
/// Auto-generated from StructureDefinition for Encounter, last updated
/// 2019-11-01T09:29:23.356+11:00. An interaction during which services are
/// provided to the patient. See
/// <http://hl7.org/fhir/StructureDefinition/Encounter>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Encounter {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifier(s) by which this encounter is known
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<encounter::StatusCode>,
    #[prost(message, repeated, tag = "12")]
    pub status_history: prost::alloc::vec::Vec<encounter::StatusHistory>,
    /// Classification of patient encounter
    #[prost(message, optional, tag = "13")]
    pub class_value: ::core::option::Option<Coding>,
    #[prost(message, repeated, tag = "14")]
    pub class_history: prost::alloc::vec::Vec<encounter::ClassHistory>,
    /// Specific type of encounter
    #[prost(message, repeated, tag = "15")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Specific type of service
    #[prost(message, optional, tag = "16")]
    pub service_type: ::core::option::Option<CodeableConcept>,
    /// Indicates the urgency of the encounter
    #[prost(message, optional, tag = "17")]
    pub priority: ::core::option::Option<CodeableConcept>,
    /// The patient or group present at the encounter
    #[prost(message, optional, tag = "18")]
    pub subject: ::core::option::Option<Reference>,
    /// Episode(s) of care that this encounter should be recorded against
    #[prost(message, repeated, tag = "19")]
    pub episode_of_care: prost::alloc::vec::Vec<Reference>,
    /// The ServiceRequest that initiated this encounter
    #[prost(message, repeated, tag = "20")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "21")]
    pub participant: prost::alloc::vec::Vec<encounter::Participant>,
    /// The appointment that scheduled this encounter
    #[prost(message, repeated, tag = "22")]
    pub appointment: prost::alloc::vec::Vec<Reference>,
    /// The start and end time of the encounter
    #[prost(message, optional, tag = "23")]
    pub period: ::core::option::Option<Period>,
    /// Quantity of time the encounter lasted (less time absent)
    #[prost(message, optional, tag = "24")]
    pub length: ::core::option::Option<Duration>,
    /// Coded reason the encounter takes place
    #[prost(message, repeated, tag = "25")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Reason the encounter takes place (reference)
    #[prost(message, repeated, tag = "26")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "27")]
    pub diagnosis: prost::alloc::vec::Vec<encounter::Diagnosis>,
    /// The set of accounts that may be used for billing for this Encounter
    #[prost(message, repeated, tag = "28")]
    pub account: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "29")]
    pub hospitalization: ::core::option::Option<encounter::Hospitalization>,
    #[prost(message, repeated, tag = "30")]
    pub location: prost::alloc::vec::Vec<encounter::Location>,
    /// The organization (facility) responsible for this encounter
    #[prost(message, optional, tag = "31")]
    pub service_provider: ::core::option::Option<Reference>,
    /// Another Encounter this encounter is part of
    #[prost(message, optional, tag = "32")]
    pub part_of: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `Encounter`.
pub mod encounter {
    /// planned | arrived | triaged | in-progress | onleave | finished | cancelled
    /// +
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::encounter_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// List of past encounter statuses
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusHistory {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub status: ::core::option::Option<status_history::StatusCode>,
        /// The time that the episode was in the specified status
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// Nested message and enum types in `StatusHistory`.
    pub mod status_history {
        /// planned | arrived | triaged | in-progress | onleave | finished |
        /// cancelled +
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct StatusCode {
            #[prost(enumeration = "super::super::encounter_status_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// List of past encounter classes
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ClassHistory {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// inpatient | outpatient | ambulatory | emergency +
        #[prost(message, optional, tag = "4")]
        pub class_value: ::core::option::Option<super::Coding>,
        /// The time that the episode was in the specified class
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// List of participants involved in the encounter
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Role of participant in encounter
        #[prost(message, repeated, tag = "4")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Period of time during the encounter that the participant participated
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
        /// Persons involved in the encounter other than the patient
        #[prost(message, optional, tag = "6")]
        pub individual: ::core::option::Option<super::Reference>,
    }
    /// The list of diagnosis relevant to this encounter
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Diagnosis {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The diagnosis or procedure relevant to the encounter
        #[prost(message, optional, tag = "4")]
        pub condition: ::core::option::Option<super::Reference>,
        /// Role that this diagnosis has within the encounter (e.g. admission,
        /// billing, discharge …)
        #[prost(message, optional, tag = "5")]
        pub r#use: ::core::option::Option<super::CodeableConcept>,
        /// Ranking of the diagnosis (for each role type)
        #[prost(message, optional, tag = "6")]
        pub rank: ::core::option::Option<super::PositiveInt>,
    }
    /// Details about the admission to a healthcare service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Hospitalization {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Pre-admission identifier
        #[prost(message, optional, tag = "4")]
        pub pre_admission_identifier: ::core::option::Option<super::Identifier>,
        /// The location/organization from which the patient came before admission
        #[prost(message, optional, tag = "5")]
        pub origin: ::core::option::Option<super::Reference>,
        /// From where patient was admitted (physician referral, transfer)
        #[prost(message, optional, tag = "6")]
        pub admit_source: ::core::option::Option<super::CodeableConcept>,
        /// The type of hospital re-admission that has occurred (if any). If the
        /// value is absent, then this is not identified as a readmission
        #[prost(message, optional, tag = "7")]
        pub re_admission: ::core::option::Option<super::CodeableConcept>,
        /// Diet preferences reported by the patient
        #[prost(message, repeated, tag = "8")]
        pub diet_preference: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Special courtesies (VIP, board member)
        #[prost(message, repeated, tag = "9")]
        pub special_courtesy: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Wheelchair, translator, stretcher, etc.
        #[prost(message, repeated, tag = "10")]
        pub special_arrangement: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Location/organization to which the patient is discharged
        #[prost(message, optional, tag = "11")]
        pub destination: ::core::option::Option<super::Reference>,
        /// Category or kind of location after discharge
        #[prost(message, optional, tag = "12")]
        pub discharge_disposition: ::core::option::Option<super::CodeableConcept>,
    }
    /// List of locations where the patient has been
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Location {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Location the encounter takes place
        #[prost(message, optional, tag = "4")]
        pub location: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "5")]
        pub status: ::core::option::Option<location::StatusCode>,
        /// The physical type of the location (usually the level in the location
        /// hierachy - bed room ward etc.)
        #[prost(message, optional, tag = "6")]
        pub physical_type: ::core::option::Option<super::CodeableConcept>,
        /// Time period during which the patient was present at the location
        #[prost(message, optional, tag = "7")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// Nested message and enum types in `Location`.
    pub mod location {
        /// planned | active | reserved | completed
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct StatusCode {
            #[prost(
                enumeration = "super::super::encounter_location_status_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for Endpoint, last updated
/// 2019-11-01T09:29:23.356+11:00. The technical details of an endpoint that can
/// be used for electronic services. See
/// <http://hl7.org/fhir/StructureDefinition/Endpoint>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Endpoint {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifies this endpoint across multiple systems
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<endpoint::StatusCode>,
    /// Protocol/Profile/Standard to be used with this endpoint connection
    #[prost(message, optional, tag = "12")]
    pub connection_type: ::core::option::Option<Coding>,
    /// A name that this endpoint can be identified by
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Organization that manages this endpoint (might not be the organization that
    /// exposes the endpoint)
    #[prost(message, optional, tag = "14")]
    pub managing_organization: ::core::option::Option<Reference>,
    /// Contact details for source (e.g. troubleshooting)
    #[prost(message, repeated, tag = "15")]
    pub contact: prost::alloc::vec::Vec<ContactPoint>,
    /// Interval the endpoint is expected to be operational
    #[prost(message, optional, tag = "16")]
    pub period: ::core::option::Option<Period>,
    /// The type of content that may be used at this endpoint (e.g. XDS Discharge
    /// summaries)
    #[prost(message, repeated, tag = "17")]
    pub payload_type: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "18")]
    pub payload_mime_type: prost::alloc::vec::Vec<endpoint::PayloadMimeTypeCode>,
    /// The technical base address for connecting to this endpoint
    #[prost(message, optional, tag = "19")]
    pub address: ::core::option::Option<Url>,
    /// Usage depends on the channel type
    #[prost(message, repeated, tag = "20")]
    pub header: prost::alloc::vec::Vec<String>,
}
/// Nested message and enum types in `Endpoint`.
pub mod endpoint {
    /// active | suspended | error | off | entered-in-error | test
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::endpoint_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Mimetype to send. If not specified, the content could be anything
    /// (including no payload, if the connectionType defined this)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PayloadMimeTypeCode {
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// This valueset is not enumerable, and so is represented as a string.
        #[prost(string, tag = "4")]
        pub value: prost::alloc::string::String,
    }
}
/// Auto-generated from StructureDefinition for EnrollmentRequest, last updated
/// 2019-11-01T09:29:23.356+11:00. Enroll in coverage. See
/// <http://hl7.org/fhir/StructureDefinition/EnrollmentRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EnrollmentRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<enrollment_request::StatusCode>,
    /// Creation date
    #[prost(message, optional, tag = "12")]
    pub created: ::core::option::Option<DateTime>,
    /// Target
    #[prost(message, optional, tag = "13")]
    pub insurer: ::core::option::Option<Reference>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "14")]
    pub provider: ::core::option::Option<Reference>,
    /// The subject to be enrolled
    #[prost(message, optional, tag = "15")]
    pub candidate: ::core::option::Option<Reference>,
    /// Insurance information
    #[prost(message, optional, tag = "16")]
    pub coverage: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `EnrollmentRequest`.
pub mod enrollment_request {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::financial_resource_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for EnrollmentResponse, last updated
/// 2019-11-01T09:29:23.356+11:00. EnrollmentResponse resource. See
/// <http://hl7.org/fhir/StructureDefinition/EnrollmentResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EnrollmentResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<enrollment_response::StatusCode>,
    /// Claim reference
    #[prost(message, optional, tag = "12")]
    pub request: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "13")]
    pub outcome: ::core::option::Option<enrollment_response::OutcomeCode>,
    /// Disposition Message
    #[prost(message, optional, tag = "14")]
    pub disposition: ::core::option::Option<String>,
    /// Creation date
    #[prost(message, optional, tag = "15")]
    pub created: ::core::option::Option<DateTime>,
    /// Insurer
    #[prost(message, optional, tag = "16")]
    pub organization: ::core::option::Option<Reference>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "17")]
    pub request_provider: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `EnrollmentResponse`.
pub mod enrollment_response {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::financial_resource_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// queued | complete | error | partial
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OutcomeCode {
        #[prost(enumeration = "super::claim_processing_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for EpisodeOfCare, last updated
/// 2019-11-01T09:29:23.356+11:00. An association of a Patient with an
/// Organization and  Healthcare Provider(s) for a period of time that the
/// Organization assumes some level of responsibility. See
/// <http://hl7.org/fhir/StructureDefinition/EpisodeOfCare>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EpisodeOfCare {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier(s) relevant for this EpisodeOfCare
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<episode_of_care::StatusCode>,
    #[prost(message, repeated, tag = "12")]
    pub status_history: prost::alloc::vec::Vec<episode_of_care::StatusHistory>,
    /// Type/class  - e.g. specialist referral, disease management
    #[prost(message, repeated, tag = "13")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "14")]
    pub diagnosis: prost::alloc::vec::Vec<episode_of_care::Diagnosis>,
    /// The patient who is the focus of this episode of care
    #[prost(message, optional, tag = "15")]
    pub patient: ::core::option::Option<Reference>,
    /// Organization that assumes care
    #[prost(message, optional, tag = "16")]
    pub managing_organization: ::core::option::Option<Reference>,
    /// Interval during responsibility is assumed
    #[prost(message, optional, tag = "17")]
    pub period: ::core::option::Option<Period>,
    /// Originating Referral Request(s)
    #[prost(message, repeated, tag = "18")]
    pub referral_request: prost::alloc::vec::Vec<Reference>,
    /// Care manager/care coordinator for the patient
    #[prost(message, optional, tag = "19")]
    pub care_manager: ::core::option::Option<Reference>,
    /// Other practitioners facilitating this episode of care
    #[prost(message, repeated, tag = "20")]
    pub team: prost::alloc::vec::Vec<Reference>,
    /// The set of accounts that may be used for billing for this EpisodeOfCare
    #[prost(message, repeated, tag = "21")]
    pub account: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `EpisodeOfCare`.
pub mod episode_of_care {
    /// planned | waitlist | active | onhold | finished | cancelled |
    /// entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::episode_of_care_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Past list of status codes (the current status may be included to cover the
    /// start date of the status)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusHistory {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub status: ::core::option::Option<status_history::StatusCode>,
        /// Duration the EpisodeOfCare was in the specified status
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// Nested message and enum types in `StatusHistory`.
    pub mod status_history {
        /// planned | waitlist | active | onhold | finished | cancelled |
        /// entered-in-error
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct StatusCode {
            #[prost(
                enumeration = "super::super::episode_of_care_status_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// The list of diagnosis relevant to this episode of care
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Diagnosis {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Conditions/problems/diagnoses this episode of care is for
        #[prost(message, optional, tag = "4")]
        pub condition: ::core::option::Option<super::Reference>,
        /// Role that this diagnosis has within the episode of care (e.g. admission,
        /// billing, discharge …)
        #[prost(message, optional, tag = "5")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Ranking of the diagnosis (for each role type)
        #[prost(message, optional, tag = "6")]
        pub rank: ::core::option::Option<super::PositiveInt>,
    }
}
/// Auto-generated from StructureDefinition for EventDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. A description of when an event can occur. See
/// <http://hl7.org/fhir/StructureDefinition/EventDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EventDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this event definition, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the event definition
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the event definition
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this event definition (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this event definition (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Subordinate title of the event definition
    #[prost(message, optional, tag = "15")]
    pub subtitle: ::core::option::Option<String>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<event_definition::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "17")]
    pub experimental: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "18")]
    pub subject: ::core::option::Option<event_definition::SubjectX>,
    /// Date last changed
    #[prost(message, optional, tag = "19")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "20")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "21")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the event definition
    #[prost(message, optional, tag = "22")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "23")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for event definition (if applicable)
    #[prost(message, repeated, tag = "24")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this event definition is defined
    #[prost(message, optional, tag = "25")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the event definition
    #[prost(message, optional, tag = "26")]
    pub usage: ::core::option::Option<String>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "27")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the event definition was approved by publisher
    #[prost(message, optional, tag = "28")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the event definition was last reviewed
    #[prost(message, optional, tag = "29")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the event definition is expected to be used
    #[prost(message, optional, tag = "30")]
    pub effective_period: ::core::option::Option<Period>,
    /// E.g. Education, Treatment, Assessment, etc.
    #[prost(message, repeated, tag = "31")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "32")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "33")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "34")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "35")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "36")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// "when" the event occurs (multiple = 'or')
    #[prost(message, repeated, tag = "37")]
    pub trigger: prost::alloc::vec::Vec<TriggerDefinition>,
}
/// Nested message and enum types in `EventDefinition`.
pub mod event_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Type of individual the event definition is focused on
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SubjectX {
        #[prost(oneof = "subject_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<subject_x::Choice>,
    }
    /// Nested message and enum types in `SubjectX`.
    pub mod subject_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for Evidence, last updated
/// 2019-11-01T09:29:23.356+11:00. A research context or question. See
/// <http://hl7.org/fhir/StructureDefinition/Evidence>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Evidence {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this evidence, represented as a URI (globally
    /// unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the evidence
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the evidence
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this evidence (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this evidence (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Title for use in informal contexts
    #[prost(message, optional, tag = "15")]
    pub short_title: ::core::option::Option<String>,
    /// Subordinate title of the Evidence
    #[prost(message, optional, tag = "16")]
    pub subtitle: ::core::option::Option<String>,
    #[prost(message, optional, tag = "17")]
    pub status: ::core::option::Option<evidence::StatusCode>,
    /// Date last changed
    #[prost(message, optional, tag = "18")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "19")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "20")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the evidence
    #[prost(message, optional, tag = "21")]
    pub description: ::core::option::Option<Markdown>,
    /// Used for footnotes or explanatory notes
    #[prost(message, repeated, tag = "22")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "23")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for evidence (if applicable)
    #[prost(message, repeated, tag = "24")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "25")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the evidence was approved by publisher
    #[prost(message, optional, tag = "26")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the evidence was last reviewed
    #[prost(message, optional, tag = "27")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the evidence is expected to be used
    #[prost(message, optional, tag = "28")]
    pub effective_period: ::core::option::Option<Period>,
    /// The category of the Evidence, such as Education, Treatment, Assessment,
    /// etc.
    #[prost(message, repeated, tag = "29")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "30")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "31")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "32")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "33")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "34")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// What population?
    #[prost(message, optional, tag = "35")]
    pub exposure_background: ::core::option::Option<Reference>,
    /// What exposure?
    #[prost(message, repeated, tag = "36")]
    pub exposure_variant: prost::alloc::vec::Vec<Reference>,
    /// What outcome?
    #[prost(message, repeated, tag = "37")]
    pub outcome: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `Evidence`.
pub mod evidence {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for EvidenceVariable, last updated
/// 2019-11-01T09:29:23.356+11:00. A population, intervention, or exposure
/// definition. See <http://hl7.org/fhir/StructureDefinition/EvidenceVariable>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EvidenceVariable {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this evidence variable, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the evidence variable
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the evidence variable
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this evidence variable (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this evidence variable (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Title for use in informal contexts
    #[prost(message, optional, tag = "15")]
    pub short_title: ::core::option::Option<String>,
    /// Subordinate title of the EvidenceVariable
    #[prost(message, optional, tag = "16")]
    pub subtitle: ::core::option::Option<String>,
    #[prost(message, optional, tag = "17")]
    pub status: ::core::option::Option<evidence_variable::StatusCode>,
    /// Date last changed
    #[prost(message, optional, tag = "18")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "19")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "20")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the evidence variable
    #[prost(message, optional, tag = "21")]
    pub description: ::core::option::Option<Markdown>,
    /// Used for footnotes or explanatory notes
    #[prost(message, repeated, tag = "22")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "23")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for evidence variable (if applicable)
    #[prost(message, repeated, tag = "24")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "25")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the evidence variable was approved by publisher
    #[prost(message, optional, tag = "26")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the evidence variable was last reviewed
    #[prost(message, optional, tag = "27")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the evidence variable is expected to be used
    #[prost(message, optional, tag = "28")]
    pub effective_period: ::core::option::Option<Period>,
    /// The category of the EvidenceVariable, such as Education, Treatment,
    /// Assessment, etc.
    #[prost(message, repeated, tag = "29")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "30")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "31")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "32")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "33")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "34")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    #[prost(message, optional, tag = "35")]
    pub r#type: ::core::option::Option<evidence_variable::TypeCode>,
    #[prost(message, repeated, tag = "36")]
    pub characteristic: prost::alloc::vec::Vec<evidence_variable::Characteristic>,
}
/// Nested message and enum types in `EvidenceVariable`.
pub mod evidence_variable {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// dichotomous | continuous | descriptive
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::evidence_variable_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// What defines the members of the evidence element
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Characteristic {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Natural language description of the characteristic
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub definition: ::core::option::Option<characteristic::DefinitionX>,
        /// What code/value pairs define members?
        #[prost(message, repeated, tag = "6")]
        pub usage_context: prost::alloc::vec::Vec<super::UsageContext>,
        /// Whether the characteristic includes or excludes members
        #[prost(message, optional, tag = "7")]
        pub exclude: ::core::option::Option<super::Boolean>,
        #[prost(message, optional, tag = "8")]
        pub participant_effective: ::core::option::Option<characteristic::ParticipantEffectiveX>,
        /// Observation time from study start
        #[prost(message, optional, tag = "9")]
        pub time_from_start: ::core::option::Option<super::Duration>,
        #[prost(message, optional, tag = "10")]
        pub group_measure: ::core::option::Option<characteristic::GroupMeasureCode>,
    }
    /// Nested message and enum types in `Characteristic`.
    pub mod characteristic {
        /// What code or expression defines members?
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DefinitionX {
            #[prost(oneof = "definition_x::Choice", tags = "1, 2, 3, 4, 5, 6")]
            pub choice: ::core::option::Option<definition_x::Choice>,
        }
        /// Nested message and enum types in `DefinitionX`.
        pub mod definition_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "2")]
                Canonical(super::super::super::Canonical),
                #[prost(message, tag = "3")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "4")]
                Expression(super::super::super::Expression),
                #[prost(message, tag = "5")]
                DataRequirement(super::super::super::DataRequirement),
                #[prost(message, tag = "6")]
                TriggerDefinition(super::super::super::TriggerDefinition),
            }
        }
        /// What time period do participants cover
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ParticipantEffectiveX {
            #[prost(oneof = "participant_effective_x::Choice", tags = "1, 2, 3, 4")]
            pub choice: ::core::option::Option<participant_effective_x::Choice>,
        }
        /// Nested message and enum types in `ParticipantEffectiveX`.
        pub mod participant_effective_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
                #[prost(message, tag = "3")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "4")]
                Timing(super::super::super::Timing),
            }
        }
        /// mean | median | mean-of-mean | mean-of-median | median-of-mean |
        /// median-of-median
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct GroupMeasureCode {
            #[prost(enumeration = "super::super::group_measure_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for ExampleScenario, last updated
/// 2019-11-01T09:29:23.356+11:00. Example of workflow instance. See
/// <http://hl7.org/fhir/StructureDefinition/ExampleScenario>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExampleScenario {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this example scenario, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the example scenario
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the example scenario
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this example scenario (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<example_scenario::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "19")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for example scenario (if applicable)
    #[prost(message, repeated, tag = "20")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "21")]
    pub copyright: ::core::option::Option<Markdown>,
    /// The purpose of the example, e.g. to illustrate a scenario
    #[prost(message, optional, tag = "22")]
    pub purpose: ::core::option::Option<Markdown>,
    #[prost(message, repeated, tag = "23")]
    pub actor: prost::alloc::vec::Vec<example_scenario::Actor>,
    #[prost(message, repeated, tag = "24")]
    pub instance: prost::alloc::vec::Vec<example_scenario::Instance>,
    #[prost(message, repeated, tag = "25")]
    pub process: prost::alloc::vec::Vec<example_scenario::Process>,
    /// Another nested workflow
    #[prost(message, repeated, tag = "26")]
    pub workflow: prost::alloc::vec::Vec<Canonical>,
}
/// Nested message and enum types in `ExampleScenario`.
pub mod example_scenario {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Actor participating in the resource
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Actor {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// ID or acronym of the actor
        #[prost(message, optional, tag = "4")]
        pub actor_id: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<actor::TypeCode>,
        /// The name of the actor as shown in the page
        #[prost(message, optional, tag = "6")]
        pub name: ::core::option::Option<super::String>,
        /// The description of the actor
        #[prost(message, optional, tag = "7")]
        pub description: ::core::option::Option<super::Markdown>,
    }
    /// Nested message and enum types in `Actor`.
    pub mod actor {
        /// person | entity
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(
                enumeration = "super::super::example_scenario_actor_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Each resource and each version that is present in the workflow
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Instance {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The id of the resource for referencing
        #[prost(message, optional, tag = "4")]
        pub resource_id: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub resource_type: ::core::option::Option<instance::ResourceTypeCode>,
        /// A short name for the resource instance
        #[prost(message, optional, tag = "6")]
        pub name: ::core::option::Option<super::String>,
        /// Human-friendly description of the resource instance
        #[prost(message, optional, tag = "7")]
        pub description: ::core::option::Option<super::Markdown>,
        #[prost(message, repeated, tag = "8")]
        pub version: prost::alloc::vec::Vec<instance::Version>,
        #[prost(message, repeated, tag = "9")]
        pub contained_instance: prost::alloc::vec::Vec<instance::ContainedInstance>,
    }
    /// Nested message and enum types in `Instance`.
    pub mod instance {
        /// The type of the resource
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ResourceTypeCode {
            #[prost(enumeration = "super::super::resource_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// A specific version of the resource
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Version {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The identifier of a specific version of a resource
            #[prost(message, optional, tag = "4")]
            pub version_id: ::core::option::Option<super::super::String>,
            /// The description of the resource version
            #[prost(message, optional, tag = "5")]
            pub description: ::core::option::Option<super::super::Markdown>,
        }
        /// Resources contained in the instance
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ContainedInstance {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Each resource contained in the instance
            #[prost(message, optional, tag = "4")]
            pub resource_id: ::core::option::Option<super::super::String>,
            /// A specific version of a resource contained in the instance
            #[prost(message, optional, tag = "5")]
            pub version_id: ::core::option::Option<super::super::String>,
        }
    }
    /// Each major process - a group of operations
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Process {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The diagram title of the group of operations
        #[prost(message, optional, tag = "4")]
        pub title: ::core::option::Option<super::String>,
        /// A longer description of the group of operations
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::Markdown>,
        /// Description of initial status before the process starts
        #[prost(message, optional, tag = "6")]
        pub pre_conditions: ::core::option::Option<super::Markdown>,
        /// Description of final status after the process ends
        #[prost(message, optional, tag = "7")]
        pub post_conditions: ::core::option::Option<super::Markdown>,
        #[prost(message, repeated, tag = "8")]
        pub step: prost::alloc::vec::Vec<process::Step>,
    }
    /// Nested message and enum types in `Process`.
    pub mod process {
        /// Each step of the process
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Step {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Nested process
            #[prost(message, repeated, tag = "4")]
            pub process: prost::alloc::vec::Vec<super::Process>,
            /// If there is a pause in the flow
            #[prost(message, optional, tag = "5")]
            pub pause: ::core::option::Option<super::super::Boolean>,
            #[prost(message, optional, tag = "6")]
            pub operation: ::core::option::Option<step::Operation>,
            #[prost(message, repeated, tag = "7")]
            pub alternative: prost::alloc::vec::Vec<step::Alternative>,
        }
        /// Nested message and enum types in `Step`.
        pub mod step {
            /// Each interaction or action
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Operation {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// The sequential number of the interaction
                #[prost(message, optional, tag = "4")]
                pub number: ::core::option::Option<super::super::super::String>,
                /// The type of operation - CRUD
                #[prost(message, optional, tag = "5")]
                pub r#type: ::core::option::Option<super::super::super::String>,
                /// The human-friendly name of the interaction
                #[prost(message, optional, tag = "6")]
                pub name: ::core::option::Option<super::super::super::String>,
                /// Who starts the transaction
                #[prost(message, optional, tag = "7")]
                pub initiator: ::core::option::Option<super::super::super::String>,
                /// Who receives the transaction
                #[prost(message, optional, tag = "8")]
                pub receiver: ::core::option::Option<super::super::super::String>,
                /// A comment to be inserted in the diagram
                #[prost(message, optional, tag = "9")]
                pub description: ::core::option::Option<super::super::super::Markdown>,
                /// Whether the initiator is deactivated right after the transaction
                #[prost(message, optional, tag = "10")]
                pub initiator_active: ::core::option::Option<super::super::super::Boolean>,
                /// Whether the receiver is deactivated right after the transaction
                #[prost(message, optional, tag = "11")]
                pub receiver_active: ::core::option::Option<super::super::super::Boolean>,
                /// Each resource instance used by the initiator
                #[prost(message, optional, tag = "12")]
                pub request: ::core::option::Option<super::super::instance::ContainedInstance>,
                /// Each resource instance used by the responder
                #[prost(message, optional, tag = "13")]
                pub response: ::core::option::Option<super::super::instance::ContainedInstance>,
            }
            /// Alternate non-typical step action
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Alternative {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Label for alternative
                #[prost(message, optional, tag = "4")]
                pub title: ::core::option::Option<super::super::super::String>,
                /// A human-readable description of each option
                #[prost(message, optional, tag = "5")]
                pub description: ::core::option::Option<super::super::super::Markdown>,
                /// What happens in each alternative option
                #[prost(message, repeated, tag = "6")]
                pub step: prost::alloc::vec::Vec<super::Step>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for ExplanationOfBenefit, last
/// updated 2019-11-01T09:29:23.356+11:00. Explanation of Benefit resource. See
/// <http://hl7.org/fhir/StructureDefinition/ExplanationOfBenefit>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExplanationOfBenefit {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for the resource
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<explanation_of_benefit::StatusCode>,
    /// Category or discipline
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// More granular claim type
    #[prost(message, optional, tag = "13")]
    pub sub_type: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "14")]
    pub r#use: ::core::option::Option<explanation_of_benefit::UseCode>,
    /// The recipient of the products and services
    #[prost(message, optional, tag = "15")]
    pub patient: ::core::option::Option<Reference>,
    /// Relevant time frame for the claim
    #[prost(message, optional, tag = "16")]
    pub billable_period: ::core::option::Option<Period>,
    /// Response creation date
    #[prost(message, optional, tag = "17")]
    pub created: ::core::option::Option<DateTime>,
    /// Author of the claim
    #[prost(message, optional, tag = "18")]
    pub enterer: ::core::option::Option<Reference>,
    /// Party responsible for reimbursement
    #[prost(message, optional, tag = "19")]
    pub insurer: ::core::option::Option<Reference>,
    /// Party responsible for the claim
    #[prost(message, optional, tag = "20")]
    pub provider: ::core::option::Option<Reference>,
    /// Desired processing urgency
    #[prost(message, optional, tag = "21")]
    pub priority: ::core::option::Option<CodeableConcept>,
    /// For whom to reserve funds
    #[prost(message, optional, tag = "22")]
    pub funds_reserve_requested: ::core::option::Option<CodeableConcept>,
    /// Funds reserved status
    #[prost(message, optional, tag = "23")]
    pub funds_reserve: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "24")]
    pub related: prost::alloc::vec::Vec<explanation_of_benefit::RelatedClaim>,
    /// Prescription authorizing services or products
    #[prost(message, optional, tag = "25")]
    pub prescription: ::core::option::Option<Reference>,
    /// Original prescription if superceded by fulfiller
    #[prost(message, optional, tag = "26")]
    pub original_prescription: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "27")]
    pub payee: ::core::option::Option<explanation_of_benefit::Payee>,
    /// Treatment Referral
    #[prost(message, optional, tag = "28")]
    pub referral: ::core::option::Option<Reference>,
    /// Servicing Facility
    #[prost(message, optional, tag = "29")]
    pub facility: ::core::option::Option<Reference>,
    /// Claim reference
    #[prost(message, optional, tag = "30")]
    pub claim: ::core::option::Option<Reference>,
    /// Claim response reference
    #[prost(message, optional, tag = "31")]
    pub claim_response: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "32")]
    pub outcome: ::core::option::Option<explanation_of_benefit::OutcomeCode>,
    /// Disposition Message
    #[prost(message, optional, tag = "33")]
    pub disposition: ::core::option::Option<String>,
    /// Preauthorization reference
    #[prost(message, repeated, tag = "34")]
    pub pre_auth_ref: prost::alloc::vec::Vec<String>,
    /// Preauthorization in-effect period
    #[prost(message, repeated, tag = "35")]
    pub pre_auth_ref_period: prost::alloc::vec::Vec<Period>,
    #[prost(message, repeated, tag = "36")]
    pub care_team: prost::alloc::vec::Vec<explanation_of_benefit::CareTeam>,
    #[prost(message, repeated, tag = "37")]
    pub supporting_info: prost::alloc::vec::Vec<explanation_of_benefit::SupportingInformation>,
    #[prost(message, repeated, tag = "38")]
    pub diagnosis: prost::alloc::vec::Vec<explanation_of_benefit::Diagnosis>,
    #[prost(message, repeated, tag = "39")]
    pub procedure: prost::alloc::vec::Vec<explanation_of_benefit::Procedure>,
    /// Precedence (primary, secondary, etc.)
    #[prost(message, optional, tag = "40")]
    pub precedence: ::core::option::Option<PositiveInt>,
    #[prost(message, repeated, tag = "41")]
    pub insurance: prost::alloc::vec::Vec<explanation_of_benefit::Insurance>,
    #[prost(message, optional, tag = "42")]
    pub accident: ::core::option::Option<explanation_of_benefit::Accident>,
    #[prost(message, repeated, tag = "43")]
    pub item: prost::alloc::vec::Vec<explanation_of_benefit::Item>,
    #[prost(message, repeated, tag = "44")]
    pub add_item: prost::alloc::vec::Vec<explanation_of_benefit::AddedItem>,
    /// Header-level adjudication
    #[prost(message, repeated, tag = "45")]
    pub adjudication: prost::alloc::vec::Vec<explanation_of_benefit::item::Adjudication>,
    #[prost(message, repeated, tag = "46")]
    pub total: prost::alloc::vec::Vec<explanation_of_benefit::Total>,
    #[prost(message, optional, tag = "47")]
    pub payment: ::core::option::Option<explanation_of_benefit::Payment>,
    /// Printed form identifier
    #[prost(message, optional, tag = "48")]
    pub form_code: ::core::option::Option<CodeableConcept>,
    /// Printed reference or actual form
    #[prost(message, optional, tag = "49")]
    pub form: ::core::option::Option<Attachment>,
    #[prost(message, repeated, tag = "50")]
    pub process_note: prost::alloc::vec::Vec<explanation_of_benefit::Note>,
    /// When the benefits are applicable
    #[prost(message, optional, tag = "51")]
    pub benefit_period: ::core::option::Option<Period>,
    #[prost(message, repeated, tag = "52")]
    pub benefit_balance: prost::alloc::vec::Vec<explanation_of_benefit::BenefitBalance>,
}
/// Nested message and enum types in `ExplanationOfBenefit`.
pub mod explanation_of_benefit {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::explanation_of_benefit_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// claim | preauthorization | predetermination
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UseCode {
        #[prost(enumeration = "super::use_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Prior or corollary claims
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelatedClaim {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to the related claim
        #[prost(message, optional, tag = "4")]
        pub claim: ::core::option::Option<super::Reference>,
        /// How the reference claim is related
        #[prost(message, optional, tag = "5")]
        pub relationship: ::core::option::Option<super::CodeableConcept>,
        /// File or case reference
        #[prost(message, optional, tag = "6")]
        pub reference: ::core::option::Option<super::Identifier>,
    }
    /// Recipient of benefits payable
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payee {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Category of recipient
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Recipient reference
        #[prost(message, optional, tag = "5")]
        pub party: ::core::option::Option<super::Reference>,
    }
    /// queued | complete | error | partial
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OutcomeCode {
        #[prost(enumeration = "super::claim_processing_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Care Team members
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CareTeam {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Order of care team
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Practitioner or organization
        #[prost(message, optional, tag = "5")]
        pub provider: ::core::option::Option<super::Reference>,
        /// Indicator of the lead practitioner
        #[prost(message, optional, tag = "6")]
        pub responsible: ::core::option::Option<super::Boolean>,
        /// Function within the team
        #[prost(message, optional, tag = "7")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Practitioner credential or specialization
        #[prost(message, optional, tag = "8")]
        pub qualification: ::core::option::Option<super::CodeableConcept>,
    }
    /// Supporting information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SupportingInformation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Information instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Classification of the supplied information
        #[prost(message, optional, tag = "5")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Type of information
        #[prost(message, optional, tag = "6")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "7")]
        pub timing: ::core::option::Option<supporting_information::TimingX>,
        #[prost(message, optional, tag = "8")]
        pub value: ::core::option::Option<supporting_information::ValueX>,
        /// Explanation for the information
        #[prost(message, optional, tag = "9")]
        pub reason: ::core::option::Option<super::Coding>,
    }
    /// Nested message and enum types in `SupportingInformation`.
    pub mod supporting_information {
        /// When it occurred
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimingX {
            #[prost(oneof = "timing_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<timing_x::Choice>,
        }
        /// Nested message and enum types in `TimingX`.
        pub mod timing_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Data to be provided
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5")]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "2")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "3")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "4")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "5")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Pertinent diagnosis information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Diagnosis {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Diagnosis instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        #[prost(message, optional, tag = "5")]
        pub diagnosis: ::core::option::Option<diagnosis::DiagnosisX>,
        /// Timing or nature of the diagnosis
        #[prost(message, repeated, tag = "6")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Present on admission
        #[prost(message, optional, tag = "7")]
        pub on_admission: ::core::option::Option<super::CodeableConcept>,
        /// Package billing code
        #[prost(message, optional, tag = "8")]
        pub package_code: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Diagnosis`.
    pub mod diagnosis {
        /// Nature of illness or problem
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DiagnosisX {
            #[prost(oneof = "diagnosis_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<diagnosis_x::Choice>,
        }
        /// Nested message and enum types in `DiagnosisX`.
        pub mod diagnosis_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Clinical procedures performed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Procedure {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Procedure instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Category of Procedure
        #[prost(message, repeated, tag = "5")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// When the procedure was performed
        #[prost(message, optional, tag = "6")]
        pub date: ::core::option::Option<super::DateTime>,
        #[prost(message, optional, tag = "7")]
        pub procedure: ::core::option::Option<procedure::ProcedureX>,
        /// Unique device identifier
        #[prost(message, repeated, tag = "8")]
        pub udi: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Nested message and enum types in `Procedure`.
    pub mod procedure {
        /// Specific clinical procedure
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ProcedureX {
            #[prost(oneof = "procedure_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<procedure_x::Choice>,
        }
        /// Nested message and enum types in `ProcedureX`.
        pub mod procedure_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Patient insurance information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Insurance {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Coverage to be used for adjudication
        #[prost(message, optional, tag = "4")]
        pub focal: ::core::option::Option<super::Boolean>,
        /// Insurance information
        #[prost(message, optional, tag = "5")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// Prior authorization reference number
        #[prost(message, repeated, tag = "6")]
        pub pre_auth_ref: prost::alloc::vec::Vec<super::String>,
    }
    /// Details of the event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Accident {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// When the incident occurred
        #[prost(message, optional, tag = "4")]
        pub date: ::core::option::Option<super::Date>,
        /// The nature of the accident
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "6")]
        pub location: ::core::option::Option<accident::LocationX>,
    }
    /// Nested message and enum types in `Accident`.
    pub mod accident {
        /// Where the event occurred
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct LocationX {
            #[prost(oneof = "location_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<location_x::Choice>,
        }
        /// Nested message and enum types in `LocationX`.
        pub mod location_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Address(super::super::super::Address),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Product or service provided
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Item instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Applicable care team members
        #[prost(message, repeated, tag = "5")]
        pub care_team_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable diagnoses
        #[prost(message, repeated, tag = "6")]
        pub diagnosis_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable procedures
        #[prost(message, repeated, tag = "7")]
        pub procedure_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable exception and supporting information
        #[prost(message, repeated, tag = "8")]
        pub information_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Revenue or cost center code
        #[prost(message, optional, tag = "9")]
        pub revenue: ::core::option::Option<super::CodeableConcept>,
        /// Benefit classification
        #[prost(message, optional, tag = "10")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Billing, service, product, or drug code
        #[prost(message, optional, tag = "11")]
        pub product_or_service: ::core::option::Option<super::CodeableConcept>,
        /// Product or service billing modifiers
        #[prost(message, repeated, tag = "12")]
        pub modifier: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Program the product or service is provided under
        #[prost(message, repeated, tag = "13")]
        pub program_code: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, optional, tag = "14")]
        pub serviced: ::core::option::Option<item::ServicedX>,
        #[prost(message, optional, tag = "15")]
        pub location: ::core::option::Option<item::LocationX>,
        /// Count of products or services
        #[prost(message, optional, tag = "16")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Fee, charge or cost per item
        #[prost(message, optional, tag = "17")]
        pub unit_price: ::core::option::Option<super::Money>,
        /// Price scaling factor
        #[prost(message, optional, tag = "18")]
        pub factor: ::core::option::Option<super::Decimal>,
        /// Total item cost
        #[prost(message, optional, tag = "19")]
        pub net: ::core::option::Option<super::Money>,
        /// Unique device identifier
        #[prost(message, repeated, tag = "20")]
        pub udi: prost::alloc::vec::Vec<super::Reference>,
        /// Anatomical location
        #[prost(message, optional, tag = "21")]
        pub body_site: ::core::option::Option<super::CodeableConcept>,
        /// Anatomical sub-location
        #[prost(message, repeated, tag = "22")]
        pub sub_site: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Encounters related to this billed item
        #[prost(message, repeated, tag = "23")]
        pub encounter: prost::alloc::vec::Vec<super::Reference>,
        /// Applicable note numbers
        #[prost(message, repeated, tag = "24")]
        pub note_number: prost::alloc::vec::Vec<super::PositiveInt>,
        #[prost(message, repeated, tag = "25")]
        pub adjudication: prost::alloc::vec::Vec<item::Adjudication>,
        #[prost(message, repeated, tag = "26")]
        pub detail: prost::alloc::vec::Vec<item::Detail>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// Date or dates of service or product delivery
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ServicedX {
            #[prost(oneof = "serviced_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<serviced_x::Choice>,
        }
        /// Nested message and enum types in `ServicedX`.
        pub mod serviced_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Place of service or where product was supplied
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct LocationX {
            #[prost(oneof = "location_x::Choice", tags = "1, 2, 3")]
            pub choice: ::core::option::Option<location_x::Choice>,
        }
        /// Nested message and enum types in `LocationX`.
        pub mod location_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Address(super::super::super::Address),
                #[prost(message, tag = "3")]
                Reference(super::super::super::Reference),
            }
        }
        /// Adjudication details
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Adjudication {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of adjudication information
            #[prost(message, optional, tag = "4")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Explanation of adjudication outcome
            #[prost(message, optional, tag = "5")]
            pub reason: ::core::option::Option<super::super::CodeableConcept>,
            /// Monetary amount
            #[prost(message, optional, tag = "6")]
            pub amount: ::core::option::Option<super::super::Money>,
            /// Non-monitary value
            #[prost(message, optional, tag = "7")]
            pub value: ::core::option::Option<super::super::Decimal>,
        }
        /// Additional items
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Detail {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Product or service provided
            #[prost(message, optional, tag = "4")]
            pub sequence: ::core::option::Option<super::super::PositiveInt>,
            /// Revenue or cost center code
            #[prost(message, optional, tag = "5")]
            pub revenue: ::core::option::Option<super::super::CodeableConcept>,
            /// Benefit classification
            #[prost(message, optional, tag = "6")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Billing, service, product, or drug code
            #[prost(message, optional, tag = "7")]
            pub product_or_service: ::core::option::Option<super::super::CodeableConcept>,
            /// Service/Product billing modifiers
            #[prost(message, repeated, tag = "8")]
            pub modifier: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Program the product or service is provided under
            #[prost(message, repeated, tag = "9")]
            pub program_code: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Count of products or services
            #[prost(message, optional, tag = "10")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// Fee, charge or cost per item
            #[prost(message, optional, tag = "11")]
            pub unit_price: ::core::option::Option<super::super::Money>,
            /// Price scaling factor
            #[prost(message, optional, tag = "12")]
            pub factor: ::core::option::Option<super::super::Decimal>,
            /// Total item cost
            #[prost(message, optional, tag = "13")]
            pub net: ::core::option::Option<super::super::Money>,
            /// Unique device identifier
            #[prost(message, repeated, tag = "14")]
            pub udi: prost::alloc::vec::Vec<super::super::Reference>,
            /// Applicable note numbers
            #[prost(message, repeated, tag = "15")]
            pub note_number: prost::alloc::vec::Vec<super::super::PositiveInt>,
            /// Detail level adjudication details
            #[prost(message, repeated, tag = "16")]
            pub adjudication: prost::alloc::vec::Vec<Adjudication>,
            #[prost(message, repeated, tag = "17")]
            pub sub_detail: prost::alloc::vec::Vec<detail::SubDetail>,
        }
        /// Nested message and enum types in `Detail`.
        pub mod detail {
            /// Additional items
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct SubDetail {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Product or service provided
                #[prost(message, optional, tag = "4")]
                pub sequence: ::core::option::Option<super::super::super::PositiveInt>,
                /// Revenue or cost center code
                #[prost(message, optional, tag = "5")]
                pub revenue: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Benefit classification
                #[prost(message, optional, tag = "6")]
                pub category: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Billing, service, product, or drug code
                #[prost(message, optional, tag = "7")]
                pub product_or_service:
                    ::core::option::Option<super::super::super::CodeableConcept>,
                /// Service/Product billing modifiers
                #[prost(message, repeated, tag = "8")]
                pub modifier: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Program the product or service is provided under
                #[prost(message, repeated, tag = "9")]
                pub program_code: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Count of products or services
                #[prost(message, optional, tag = "10")]
                pub quantity: ::core::option::Option<super::super::super::SimpleQuantity>,
                /// Fee, charge or cost per item
                #[prost(message, optional, tag = "11")]
                pub unit_price: ::core::option::Option<super::super::super::Money>,
                /// Price scaling factor
                #[prost(message, optional, tag = "12")]
                pub factor: ::core::option::Option<super::super::super::Decimal>,
                /// Total item cost
                #[prost(message, optional, tag = "13")]
                pub net: ::core::option::Option<super::super::super::Money>,
                /// Unique device identifier
                #[prost(message, repeated, tag = "14")]
                pub udi: prost::alloc::vec::Vec<super::super::super::Reference>,
                /// Applicable note numbers
                #[prost(message, repeated, tag = "15")]
                pub note_number: prost::alloc::vec::Vec<super::super::super::PositiveInt>,
                /// Subdetail level adjudication details
                #[prost(message, repeated, tag = "16")]
                pub adjudication: prost::alloc::vec::Vec<super::Adjudication>,
            }
        }
    }
    /// Insurer added line items
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AddedItem {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Item sequence number
        #[prost(message, repeated, tag = "4")]
        pub item_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Detail sequence number
        #[prost(message, repeated, tag = "5")]
        pub detail_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Subdetail sequence number
        #[prost(message, repeated, tag = "6")]
        pub sub_detail_sequence: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Authorized providers
        #[prost(message, repeated, tag = "7")]
        pub provider: prost::alloc::vec::Vec<super::Reference>,
        /// Billing, service, product, or drug code
        #[prost(message, optional, tag = "8")]
        pub product_or_service: ::core::option::Option<super::CodeableConcept>,
        /// Service/Product billing modifiers
        #[prost(message, repeated, tag = "9")]
        pub modifier: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Program the product or service is provided under
        #[prost(message, repeated, tag = "10")]
        pub program_code: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, optional, tag = "11")]
        pub serviced: ::core::option::Option<added_item::ServicedX>,
        #[prost(message, optional, tag = "12")]
        pub location: ::core::option::Option<added_item::LocationX>,
        /// Count of products or services
        #[prost(message, optional, tag = "13")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Fee, charge or cost per item
        #[prost(message, optional, tag = "14")]
        pub unit_price: ::core::option::Option<super::Money>,
        /// Price scaling factor
        #[prost(message, optional, tag = "15")]
        pub factor: ::core::option::Option<super::Decimal>,
        /// Total item cost
        #[prost(message, optional, tag = "16")]
        pub net: ::core::option::Option<super::Money>,
        /// Anatomical location
        #[prost(message, optional, tag = "17")]
        pub body_site: ::core::option::Option<super::CodeableConcept>,
        /// Anatomical sub-location
        #[prost(message, repeated, tag = "18")]
        pub sub_site: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Applicable note numbers
        #[prost(message, repeated, tag = "19")]
        pub note_number: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Added items adjudication
        #[prost(message, repeated, tag = "20")]
        pub adjudication: prost::alloc::vec::Vec<item::Adjudication>,
        #[prost(message, repeated, tag = "21")]
        pub detail: prost::alloc::vec::Vec<added_item::AddedItemDetail>,
    }
    /// Nested message and enum types in `AddedItem`.
    pub mod added_item {
        /// Date or dates of service or product delivery
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ServicedX {
            #[prost(oneof = "serviced_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<serviced_x::Choice>,
        }
        /// Nested message and enum types in `ServicedX`.
        pub mod serviced_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Place of service or where product was supplied
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct LocationX {
            #[prost(oneof = "location_x::Choice", tags = "1, 2, 3")]
            pub choice: ::core::option::Option<location_x::Choice>,
        }
        /// Nested message and enum types in `LocationX`.
        pub mod location_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Address(super::super::super::Address),
                #[prost(message, tag = "3")]
                Reference(super::super::super::Reference),
            }
        }
        /// Insurer added line items
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AddedItemDetail {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Billing, service, product, or drug code
            #[prost(message, optional, tag = "4")]
            pub product_or_service: ::core::option::Option<super::super::CodeableConcept>,
            /// Service/Product billing modifiers
            #[prost(message, repeated, tag = "5")]
            pub modifier: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Count of products or services
            #[prost(message, optional, tag = "6")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// Fee, charge or cost per item
            #[prost(message, optional, tag = "7")]
            pub unit_price: ::core::option::Option<super::super::Money>,
            /// Price scaling factor
            #[prost(message, optional, tag = "8")]
            pub factor: ::core::option::Option<super::super::Decimal>,
            /// Total item cost
            #[prost(message, optional, tag = "9")]
            pub net: ::core::option::Option<super::super::Money>,
            /// Applicable note numbers
            #[prost(message, repeated, tag = "10")]
            pub note_number: prost::alloc::vec::Vec<super::super::PositiveInt>,
            /// Added items adjudication
            #[prost(message, repeated, tag = "11")]
            pub adjudication: prost::alloc::vec::Vec<super::item::Adjudication>,
            #[prost(message, repeated, tag = "12")]
            pub sub_detail: prost::alloc::vec::Vec<added_item_detail::AddedItemDetailSubDetail>,
        }
        /// Nested message and enum types in `AddedItemDetail`.
        pub mod added_item_detail {
            /// Insurer added line items
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct AddedItemDetailSubDetail {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Billing, service, product, or drug code
                #[prost(message, optional, tag = "4")]
                pub product_or_service:
                    ::core::option::Option<super::super::super::CodeableConcept>,
                /// Service/Product billing modifiers
                #[prost(message, repeated, tag = "5")]
                pub modifier: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Count of products or services
                #[prost(message, optional, tag = "6")]
                pub quantity: ::core::option::Option<super::super::super::SimpleQuantity>,
                /// Fee, charge or cost per item
                #[prost(message, optional, tag = "7")]
                pub unit_price: ::core::option::Option<super::super::super::Money>,
                /// Price scaling factor
                #[prost(message, optional, tag = "8")]
                pub factor: ::core::option::Option<super::super::super::Decimal>,
                /// Total item cost
                #[prost(message, optional, tag = "9")]
                pub net: ::core::option::Option<super::super::super::Money>,
                /// Applicable note numbers
                #[prost(message, repeated, tag = "10")]
                pub note_number: prost::alloc::vec::Vec<super::super::super::PositiveInt>,
                /// Added items adjudication
                #[prost(message, repeated, tag = "11")]
                pub adjudication: prost::alloc::vec::Vec<super::super::item::Adjudication>,
            }
        }
    }
    /// Adjudication totals
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Total {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of adjudication information
        #[prost(message, optional, tag = "4")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Financial total for the category
        #[prost(message, optional, tag = "5")]
        pub amount: ::core::option::Option<super::Money>,
    }
    /// Payment Details
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payment {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Partial or complete payment
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Payment adjustment for non-claim issues
        #[prost(message, optional, tag = "5")]
        pub adjustment: ::core::option::Option<super::Money>,
        /// Explanation for the variance
        #[prost(message, optional, tag = "6")]
        pub adjustment_reason: ::core::option::Option<super::CodeableConcept>,
        /// Expected date of payment
        #[prost(message, optional, tag = "7")]
        pub date: ::core::option::Option<super::Date>,
        /// Payable amount after adjustment
        #[prost(message, optional, tag = "8")]
        pub amount: ::core::option::Option<super::Money>,
        /// Business identifier for the payment
        #[prost(message, optional, tag = "9")]
        pub identifier: ::core::option::Option<super::Identifier>,
    }
    /// Note concerning adjudication
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Note {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Note instance identifier
        #[prost(message, optional, tag = "4")]
        pub number: ::core::option::Option<super::PositiveInt>,
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<note::TypeCode>,
        /// Note explanatory text
        #[prost(message, optional, tag = "6")]
        pub text: ::core::option::Option<super::String>,
        /// Language of the text
        #[prost(message, optional, tag = "7")]
        pub language: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Note`.
    pub mod note {
        /// display | print | printoper
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::note_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Balance by Benefit Category
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct BenefitBalance {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Benefit classification
        #[prost(message, optional, tag = "4")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Excluded from the plan
        #[prost(message, optional, tag = "5")]
        pub excluded: ::core::option::Option<super::Boolean>,
        /// Short name for the benefit
        #[prost(message, optional, tag = "6")]
        pub name: ::core::option::Option<super::String>,
        /// Description of the benefit or services covered
        #[prost(message, optional, tag = "7")]
        pub description: ::core::option::Option<super::String>,
        /// In or out of network
        #[prost(message, optional, tag = "8")]
        pub network: ::core::option::Option<super::CodeableConcept>,
        /// Individual or family
        #[prost(message, optional, tag = "9")]
        pub unit: ::core::option::Option<super::CodeableConcept>,
        /// Annual or lifetime
        #[prost(message, optional, tag = "10")]
        pub term: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "11")]
        pub financial: prost::alloc::vec::Vec<benefit_balance::Benefit>,
    }
    /// Nested message and enum types in `BenefitBalance`.
    pub mod benefit_balance {
        /// Benefit Summary
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Benefit {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Benefit classification
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            #[prost(message, optional, tag = "5")]
            pub allowed: ::core::option::Option<benefit::AllowedX>,
            #[prost(message, optional, tag = "6")]
            pub used: ::core::option::Option<benefit::UsedX>,
        }
        /// Nested message and enum types in `Benefit`.
        pub mod benefit {
            /// Benefits allowed
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct AllowedX {
                #[prost(oneof = "allowed_x::Choice", tags = "1, 2, 3")]
                pub choice: ::core::option::Option<allowed_x::Choice>,
            }
            /// Nested message and enum types in `AllowedX`.
            pub mod allowed_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    UnsignedInt(super::super::super::super::UnsignedInt),
                    #[prost(message, tag = "2")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "3")]
                    Money(super::super::super::super::Money),
                }
            }
            /// Benefits used
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct UsedX {
                #[prost(oneof = "used_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<used_x::Choice>,
            }
            /// Nested message and enum types in `UsedX`.
            pub mod used_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    UnsignedInt(super::super::super::super::UnsignedInt),
                    #[prost(message, tag = "2")]
                    Money(super::super::super::super::Money),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for FamilyMemberHistory, last updated
/// 2019-11-01T09:29:23.356+11:00. Information about patient's relatives,
/// relevant for patient. See
/// <http://hl7.org/fhir/StructureDefinition/FamilyMemberHistory>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyMemberHistory {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Id(s) for this record
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates FHIR protocol or definition
    #[prost(message, repeated, tag = "11")]
    pub instantiates_canonical: prost::alloc::vec::Vec<Canonical>,
    /// Instantiates external protocol or definition
    #[prost(message, repeated, tag = "12")]
    pub instantiates_uri: prost::alloc::vec::Vec<Uri>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<family_member_history::StatusCode>,
    /// subject-unknown | withheld | unable-to-obtain | deferred
    #[prost(message, optional, tag = "14")]
    pub data_absent_reason: ::core::option::Option<CodeableConcept>,
    /// Patient history is about
    #[prost(message, optional, tag = "15")]
    pub patient: ::core::option::Option<Reference>,
    /// When history was recorded or last updated
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// The family member described
    #[prost(message, optional, tag = "17")]
    pub name: ::core::option::Option<String>,
    /// Relationship to the subject
    #[prost(message, optional, tag = "18")]
    pub relationship: ::core::option::Option<CodeableConcept>,
    /// male | female | other | unknown
    #[prost(message, optional, tag = "19")]
    pub sex: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "20")]
    pub born: ::core::option::Option<family_member_history::BornX>,
    #[prost(message, optional, tag = "21")]
    pub age: ::core::option::Option<family_member_history::AgeX>,
    /// Age is estimated?
    #[prost(message, optional, tag = "22")]
    pub estimated_age: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "23")]
    pub deceased: ::core::option::Option<family_member_history::DeceasedX>,
    /// Why was family member history performed?
    #[prost(message, repeated, tag = "24")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why was family member history performed?
    #[prost(message, repeated, tag = "25")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// General note about related person
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "27")]
    pub condition: prost::alloc::vec::Vec<family_member_history::Condition>,
}
/// Nested message and enum types in `FamilyMemberHistory`.
pub mod family_member_history {
    /// partial | completed | entered-in-error | health-unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::family_history_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// (approximate) date of birth
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct BornX {
        #[prost(oneof = "born_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<born_x::Choice>,
    }
    /// Nested message and enum types in `BornX`.
    pub mod born_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Period(super::super::Period),
            #[prost(message, tag = "2")]
            Date(super::super::Date),
            #[prost(message, tag = "3")]
            StringValue(super::super::String),
        }
    }
    /// (approximate) age
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AgeX {
        #[prost(oneof = "age_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<age_x::Choice>,
    }
    /// Nested message and enum types in `AgeX`.
    pub mod age_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Age(super::super::Age),
            #[prost(message, tag = "2")]
            Range(super::super::Range),
            #[prost(message, tag = "3")]
            StringValue(super::super::String),
        }
    }
    /// Dead? How old/when?
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DeceasedX {
        #[prost(oneof = "deceased_x::Choice", tags = "1, 2, 3, 4, 5")]
        pub choice: ::core::option::Option<deceased_x::Choice>,
    }
    /// Nested message and enum types in `DeceasedX`.
    pub mod deceased_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            Age(super::super::Age),
            #[prost(message, tag = "3")]
            Range(super::super::Range),
            #[prost(message, tag = "4")]
            Date(super::super::Date),
            #[prost(message, tag = "5")]
            StringValue(super::super::String),
        }
    }
    /// Condition that the related person had
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Condition {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Condition suffered by relation
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// deceased | permanent disability | etc.
        #[prost(message, optional, tag = "5")]
        pub outcome: ::core::option::Option<super::CodeableConcept>,
        /// Whether the condition contributed to the cause of death
        #[prost(message, optional, tag = "6")]
        pub contributed_to_death: ::core::option::Option<super::Boolean>,
        #[prost(message, optional, tag = "7")]
        pub onset: ::core::option::Option<condition::OnsetX>,
        /// Extra information about condition
        #[prost(message, repeated, tag = "8")]
        pub note: prost::alloc::vec::Vec<super::Annotation>,
    }
    /// Nested message and enum types in `Condition`.
    pub mod condition {
        /// When condition first manifested
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct OnsetX {
            #[prost(oneof = "onset_x::Choice", tags = "1, 2, 3, 4")]
            pub choice: ::core::option::Option<onset_x::Choice>,
        }
        /// Nested message and enum types in `OnsetX`.
        pub mod onset_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Age(super::super::super::Age),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
                #[prost(message, tag = "3")]
                Period(super::super::super::Period),
                #[prost(message, tag = "4")]
                StringValue(super::super::super::String),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Flag, last updated
/// 2019-11-01T09:29:23.356+11:00. Key information to flag to healthcare
/// providers. See <http://hl7.org/fhir/StructureDefinition/Flag>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Flag {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<flag::StatusCode>,
    /// Clinical, administrative, etc.
    #[prost(message, repeated, tag = "12")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Coded or textual message to display to user
    #[prost(message, optional, tag = "13")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who/What is flag about?
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Time period when flag is active
    #[prost(message, optional, tag = "15")]
    pub period: ::core::option::Option<Period>,
    /// Alert relevant during encounter
    #[prost(message, optional, tag = "16")]
    pub encounter: ::core::option::Option<Reference>,
    /// Flag creator
    #[prost(message, optional, tag = "17")]
    pub author: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `Flag`.
pub mod flag {
    /// active | inactive | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::flag_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Goal, last updated
/// 2019-11-01T09:29:23.356+11:00. Describes the intended objective(s) for a
/// patient, group or organization. See
/// <http://hl7.org/fhir/StructureDefinition/Goal>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Goal {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this goal
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub lifecycle_status: ::core::option::Option<goal::LifecycleStatusCode>,
    /// in-progress | improving | worsening | no-change | achieved | sustaining |
    /// not-achieved | no-progress | not-attainable
    #[prost(message, optional, tag = "12")]
    pub achievement_status: ::core::option::Option<CodeableConcept>,
    /// E.g. Treatment, dietary, behavioral, etc.
    #[prost(message, repeated, tag = "13")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// high-priority | medium-priority | low-priority
    #[prost(message, optional, tag = "14")]
    pub priority: ::core::option::Option<CodeableConcept>,
    /// Code or text describing goal
    #[prost(message, optional, tag = "15")]
    pub description: ::core::option::Option<CodeableConcept>,
    /// Who this goal is intended for
    #[prost(message, optional, tag = "16")]
    pub subject: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "17")]
    pub start: ::core::option::Option<goal::StartX>,
    #[prost(message, repeated, tag = "18")]
    pub target: prost::alloc::vec::Vec<goal::Target>,
    /// When goal status took effect
    #[prost(message, optional, tag = "19")]
    pub status_date: ::core::option::Option<Date>,
    /// Reason for current status
    #[prost(message, optional, tag = "20")]
    pub status_reason: ::core::option::Option<String>,
    /// Who's responsible for creating Goal?
    #[prost(message, optional, tag = "21")]
    pub expressed_by: ::core::option::Option<Reference>,
    /// Issues addressed by this goal
    #[prost(message, repeated, tag = "22")]
    pub addresses: prost::alloc::vec::Vec<Reference>,
    /// Comments about the goal
    #[prost(message, repeated, tag = "23")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// What result was achieved regarding the goal?
    #[prost(message, repeated, tag = "24")]
    pub outcome_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Observation that resulted from goal
    #[prost(message, repeated, tag = "25")]
    pub outcome_reference: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `Goal`.
pub mod goal {
    /// proposed | planned | accepted | active | on-hold | completed | cancelled |
    /// entered-in-error | rejected
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct LifecycleStatusCode {
        #[prost(enumeration = "super::goal_lifecycle_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// When goal pursuit begins
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StartX {
        #[prost(oneof = "start_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<start_x::Choice>,
    }
    /// Nested message and enum types in `StartX`.
    pub mod start_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// Target outcome for the goal
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Target {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The parameter whose value is being tracked
        #[prost(message, optional, tag = "4")]
        pub measure: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub detail: ::core::option::Option<target::DetailX>,
        #[prost(message, optional, tag = "6")]
        pub due: ::core::option::Option<target::DueX>,
    }
    /// Nested message and enum types in `Target`.
    pub mod target {
        /// The target value to be achieved
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DetailX {
            #[prost(oneof = "detail_x::Choice", tags = "1, 2, 3, 4, 5, 6, 7")]
            pub choice: ::core::option::Option<detail_x::Choice>,
        }
        /// Nested message and enum types in `DetailX`.
        pub mod detail_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
                #[prost(message, tag = "3")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "4")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "5")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "6")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "7")]
                Ratio(super::super::super::Ratio),
            }
        }
        /// Reach goal on or before
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DueX {
            #[prost(oneof = "due_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<due_x::Choice>,
        }
        /// Nested message and enum types in `DueX`.
        pub mod due_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Duration(super::super::super::Duration),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for GraphDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. Definition of a graph of resources. See
/// <http://hl7.org/fhir/StructureDefinition/GraphDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GraphDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this graph definition, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the graph definition
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this graph definition (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<graph_definition::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "14")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "15")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "16")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "17")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the graph definition
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "19")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for graph definition (if applicable)
    #[prost(message, repeated, tag = "20")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this graph definition is defined
    #[prost(message, optional, tag = "21")]
    pub purpose: ::core::option::Option<Markdown>,
    #[prost(message, optional, tag = "22")]
    pub start: ::core::option::Option<graph_definition::StartCode>,
    /// Profile on base resource
    #[prost(message, optional, tag = "23")]
    pub profile: ::core::option::Option<Canonical>,
    #[prost(message, repeated, tag = "24")]
    pub link: prost::alloc::vec::Vec<graph_definition::Link>,
}
/// Nested message and enum types in `GraphDefinition`.
pub mod graph_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Type of resource at which the graph starts
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StartCode {
        #[prost(enumeration = "super::resource_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Links this graph makes rules about
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Link {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Path in the resource that contains the link
        #[prost(message, optional, tag = "4")]
        pub path: ::core::option::Option<super::String>,
        /// Which slice (if profiled)
        #[prost(message, optional, tag = "5")]
        pub slice_name: ::core::option::Option<super::String>,
        /// Minimum occurrences for this link
        #[prost(message, optional, tag = "6")]
        pub min: ::core::option::Option<super::Integer>,
        /// Maximum occurrences for this link
        #[prost(message, optional, tag = "7")]
        pub max: ::core::option::Option<super::String>,
        /// Why this link is specified
        #[prost(message, optional, tag = "8")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "9")]
        pub target: prost::alloc::vec::Vec<link::Target>,
    }
    /// Nested message and enum types in `Link`.
    pub mod link {
        /// Potential target for the link
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Target {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<target::TypeCode>,
            /// Criteria for reverse lookup
            #[prost(message, optional, tag = "5")]
            pub params: ::core::option::Option<super::super::String>,
            /// Profile for the target resource
            #[prost(message, optional, tag = "6")]
            pub profile: ::core::option::Option<super::super::Canonical>,
            #[prost(message, repeated, tag = "7")]
            pub compartment: prost::alloc::vec::Vec<target::Compartment>,
            /// Additional links from target resource
            #[prost(message, repeated, tag = "8")]
            pub link: prost::alloc::vec::Vec<super::Link>,
        }
        /// Nested message and enum types in `Target`.
        pub mod target {
            /// Type of resource this link refers to
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct TypeCode {
                #[prost(
                    enumeration = "super::super::super::resource_type_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// Compartment Consistency Rules
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Compartment {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                #[prost(message, optional, tag = "4")]
                pub r#use: ::core::option::Option<compartment::UseCode>,
                #[prost(message, optional, tag = "5")]
                pub code: ::core::option::Option<compartment::CodeType>,
                #[prost(message, optional, tag = "6")]
                pub rule: ::core::option::Option<compartment::RuleCode>,
                /// Custom rule, as a FHIRPath expression
                #[prost(message, optional, tag = "7")]
                pub expression: ::core::option::Option<super::super::super::String>,
                /// Documentation for FHIRPath expression
                #[prost(message, optional, tag = "8")]
                pub description: ::core::option::Option<super::super::super::String>,
            }
            /// Nested message and enum types in `Compartment`.
            pub mod compartment {
                /// condition | requirement
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct UseCode {
                    #[prost(
                        enumeration = "super::super::super::super::graph_compartment_use_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// Patient | Encounter | RelatedPerson | Practitioner | Device
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct CodeType {
                    #[prost(
                        enumeration = "super::super::super::super::compartment_type_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// identical | matching | different | custom
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct RuleCode {
                    #[prost(
                        enumeration = "super::super::super::super::graph_compartment_rule_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Group, last updated
/// 2019-11-01T09:29:23.356+11:00. Group of multiple entities. See
/// <http://hl7.org/fhir/StructureDefinition/Group>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Group {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique id
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this group's record is in active use
    #[prost(message, optional, tag = "11")]
    pub active: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<group::TypeCode>,
    /// Descriptive or actual
    #[prost(message, optional, tag = "13")]
    pub actual: ::core::option::Option<Boolean>,
    /// Kind of Group members
    #[prost(message, optional, tag = "14")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Label for Group
    #[prost(message, optional, tag = "15")]
    pub name: ::core::option::Option<String>,
    /// Number of members
    #[prost(message, optional, tag = "16")]
    pub quantity: ::core::option::Option<UnsignedInt>,
    /// Entity that is the custodian of the Group's definition
    #[prost(message, optional, tag = "17")]
    pub managing_entity: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "18")]
    pub characteristic: prost::alloc::vec::Vec<group::Characteristic>,
    #[prost(message, repeated, tag = "19")]
    pub member: prost::alloc::vec::Vec<group::Member>,
}
/// Nested message and enum types in `Group`.
pub mod group {
    /// person | animal | practitioner | device | medication | substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::group_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Include / Exclude group members by Trait
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Characteristic {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Kind of characteristic
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<characteristic::ValueX>,
        /// Group includes or excludes
        #[prost(message, optional, tag = "6")]
        pub exclude: ::core::option::Option<super::Boolean>,
        /// Period over which characteristic is tested
        #[prost(message, optional, tag = "7")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// Nested message and enum types in `Characteristic`.
    pub mod characteristic {
        /// Value held by characteristic
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5")]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "3")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "4")]
                Range(super::super::super::Range),
                #[prost(message, tag = "5")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Who or what is in group
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Member {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to the group member
        #[prost(message, optional, tag = "4")]
        pub entity: ::core::option::Option<super::Reference>,
        /// Period member belonged to the group
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
        /// If member is no longer in group
        #[prost(message, optional, tag = "6")]
        pub inactive: ::core::option::Option<super::Boolean>,
    }
}
/// Auto-generated from StructureDefinition for GuidanceResponse, last updated
/// 2019-11-01T09:29:23.356+11:00. The formal response to a guidance request. See
/// <http://hl7.org/fhir/StructureDefinition/GuidanceResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GuidanceResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The identifier of the request associated with this response, if any
    #[prost(message, optional, tag = "10")]
    pub request_identifier: ::core::option::Option<Identifier>,
    /// Business identifier
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "12")]
    pub module: ::core::option::Option<guidance_response::ModuleX>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<guidance_response::StatusCode>,
    /// Patient the request was performed for
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter during which the response was returned
    #[prost(message, optional, tag = "15")]
    pub encounter: ::core::option::Option<Reference>,
    /// When the guidance response was processed
    #[prost(message, optional, tag = "16")]
    pub occurrence_date_time: ::core::option::Option<DateTime>,
    /// Device returning the guidance
    #[prost(message, optional, tag = "17")]
    pub performer: ::core::option::Option<Reference>,
    /// Why guidance is needed
    #[prost(message, repeated, tag = "18")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why guidance is needed
    #[prost(message, repeated, tag = "19")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Additional notes about the response
    #[prost(message, repeated, tag = "20")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Messages resulting from the evaluation of the artifact or artifacts
    #[prost(message, repeated, tag = "21")]
    pub evaluation_message: prost::alloc::vec::Vec<Reference>,
    /// The output parameters of the evaluation, if any
    #[prost(message, optional, tag = "22")]
    pub output_parameters: ::core::option::Option<Reference>,
    /// Proposed actions, if any
    #[prost(message, optional, tag = "23")]
    pub result: ::core::option::Option<Reference>,
    /// Additional required data
    #[prost(message, repeated, tag = "24")]
    pub data_requirement: prost::alloc::vec::Vec<DataRequirement>,
}
/// Nested message and enum types in `GuidanceResponse`.
pub mod guidance_response {
    /// What guidance was requested
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ModuleX {
        #[prost(oneof = "module_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<module_x::Choice>,
    }
    /// Nested message and enum types in `ModuleX`.
    pub mod module_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Canonical(super::super::Canonical),
            #[prost(message, tag = "3")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// success | data-requested | data-required | in-progress | failure |
    /// entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::guidance_response_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for HealthcareService, last updated
/// 2019-11-01T09:29:23.356+11:00. The details of a healthcare service available
/// at a location. See <http://hl7.org/fhir/StructureDefinition/HealthcareService>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HealthcareService {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifiers for this item
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this HealthcareService record is in active use
    #[prost(message, optional, tag = "11")]
    pub active: ::core::option::Option<Boolean>,
    /// Organization that provides this service
    #[prost(message, optional, tag = "12")]
    pub provided_by: ::core::option::Option<Reference>,
    /// Broad category of service being performed or delivered
    #[prost(message, repeated, tag = "13")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Type of service that may be delivered or performed
    #[prost(message, repeated, tag = "14")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Specialties handled by the HealthcareService
    #[prost(message, repeated, tag = "15")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// Location(s) where service may be provided
    #[prost(message, repeated, tag = "16")]
    pub location: prost::alloc::vec::Vec<Reference>,
    /// Description of service as presented to a consumer while searching
    #[prost(message, optional, tag = "17")]
    pub name: ::core::option::Option<String>,
    /// Additional description and/or any specific issues not covered elsewhere
    #[prost(message, optional, tag = "18")]
    pub comment: ::core::option::Option<String>,
    /// Extra details about the service that can't be placed in the other fields
    #[prost(message, optional, tag = "19")]
    pub extra_details: ::core::option::Option<Markdown>,
    /// Facilitates quick identification of the service
    #[prost(message, optional, tag = "20")]
    pub photo: ::core::option::Option<Attachment>,
    /// Contacts related to the healthcare service
    #[prost(message, repeated, tag = "21")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// Location(s) service is intended for/available to
    #[prost(message, repeated, tag = "22")]
    pub coverage_area: prost::alloc::vec::Vec<Reference>,
    /// Conditions under which service is available/offered
    #[prost(message, repeated, tag = "23")]
    pub service_provision_code: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "24")]
    pub eligibility: prost::alloc::vec::Vec<healthcare_service::Eligibility>,
    /// Programs that this service is applicable to
    #[prost(message, repeated, tag = "25")]
    pub program: prost::alloc::vec::Vec<CodeableConcept>,
    /// Collection of characteristics (attributes)
    #[prost(message, repeated, tag = "26")]
    pub characteristic: prost::alloc::vec::Vec<CodeableConcept>,
    /// The language that this service is offered in
    #[prost(message, repeated, tag = "27")]
    pub communication: prost::alloc::vec::Vec<CodeableConcept>,
    /// Ways that the service accepts referrals
    #[prost(message, repeated, tag = "28")]
    pub referral_method: prost::alloc::vec::Vec<CodeableConcept>,
    /// If an appointment is required for access to this service
    #[prost(message, optional, tag = "29")]
    pub appointment_required: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "30")]
    pub available_time: prost::alloc::vec::Vec<healthcare_service::AvailableTime>,
    #[prost(message, repeated, tag = "31")]
    pub not_available: prost::alloc::vec::Vec<healthcare_service::NotAvailable>,
    /// Description of availability exceptions
    #[prost(message, optional, tag = "32")]
    pub availability_exceptions: ::core::option::Option<String>,
    /// Technical endpoints providing access to electronic services operated for
    /// the healthcare service
    #[prost(message, repeated, tag = "33")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `HealthcareService`.
pub mod healthcare_service {
    /// Specific eligibility requirements required to use the service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Eligibility {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Coded value for the eligibility
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Describes the eligibility conditions for the service
        #[prost(message, optional, tag = "5")]
        pub comment: ::core::option::Option<super::Markdown>,
    }
    /// Times the Service Site is available
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AvailableTime {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub days_of_week: prost::alloc::vec::Vec<available_time::DaysOfWeekCode>,
        /// Always available? e.g. 24 hour service
        #[prost(message, optional, tag = "5")]
        pub all_day: ::core::option::Option<super::Boolean>,
        /// Opening time of day (ignored if allDay = true)
        #[prost(message, optional, tag = "6")]
        pub available_start_time: ::core::option::Option<super::Time>,
        /// Closing time of day (ignored if allDay = true)
        #[prost(message, optional, tag = "7")]
        pub available_end_time: ::core::option::Option<super::Time>,
    }
    /// Nested message and enum types in `AvailableTime`.
    pub mod available_time {
        /// mon | tue | wed | thu | fri | sat | sun
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DaysOfWeekCode {
            #[prost(enumeration = "super::super::days_of_week_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Not available during this time due to provided reason
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct NotAvailable {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reason presented to the user explaining why time not available
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Service not available from this date
        #[prost(message, optional, tag = "5")]
        pub during: ::core::option::Option<super::Period>,
    }
}
/// Auto-generated from StructureDefinition for ImagingStudy, last updated
/// 2019-11-01T09:29:23.356+11:00. A set of images produced in single study (one
/// or more series of references images). See
/// <http://hl7.org/fhir/StructureDefinition/ImagingStudy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImagingStudy {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifiers for the whole study
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<imaging_study::StatusCode>,
    /// All series modality if actual acquisition modalities
    #[prost(message, repeated, tag = "12")]
    pub modality: prost::alloc::vec::Vec<Coding>,
    /// Who or what is the subject of the study
    #[prost(message, optional, tag = "13")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter with which this imaging study is associated
    #[prost(message, optional, tag = "14")]
    pub encounter: ::core::option::Option<Reference>,
    /// When the study was started
    #[prost(message, optional, tag = "15")]
    pub started: ::core::option::Option<DateTime>,
    /// Request fulfilled
    #[prost(message, repeated, tag = "16")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Referring physician
    #[prost(message, optional, tag = "17")]
    pub referrer: ::core::option::Option<Reference>,
    /// Who interpreted images
    #[prost(message, repeated, tag = "18")]
    pub interpreter: prost::alloc::vec::Vec<Reference>,
    /// Study access endpoint
    #[prost(message, repeated, tag = "19")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
    /// Number of Study Related Series
    #[prost(message, optional, tag = "20")]
    pub number_of_series: ::core::option::Option<UnsignedInt>,
    /// Number of Study Related Instances
    #[prost(message, optional, tag = "21")]
    pub number_of_instances: ::core::option::Option<UnsignedInt>,
    /// The performed Procedure reference
    #[prost(message, optional, tag = "22")]
    pub procedure_reference: ::core::option::Option<Reference>,
    /// The performed procedure code
    #[prost(message, repeated, tag = "23")]
    pub procedure_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Where ImagingStudy occurred
    #[prost(message, optional, tag = "24")]
    pub location: ::core::option::Option<Reference>,
    /// Why the study was requested
    #[prost(message, repeated, tag = "25")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why was study performed
    #[prost(message, repeated, tag = "26")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// User-defined comments
    #[prost(message, repeated, tag = "27")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Institution-generated description
    #[prost(message, optional, tag = "28")]
    pub description: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "29")]
    pub series: prost::alloc::vec::Vec<imaging_study::Series>,
}
/// Nested message and enum types in `ImagingStudy`.
pub mod imaging_study {
    /// registered | available | cancelled | entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::imaging_study_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Each study has one or more series of instances
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Series {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// DICOM Series Instance UID for the series
        #[prost(message, optional, tag = "4")]
        pub uid: ::core::option::Option<super::Id>,
        /// Numeric identifier of this series
        #[prost(message, optional, tag = "5")]
        pub number: ::core::option::Option<super::UnsignedInt>,
        /// The modality of the instances in the series
        #[prost(message, optional, tag = "6")]
        pub modality: ::core::option::Option<super::Coding>,
        /// A short human readable summary of the series
        #[prost(message, optional, tag = "7")]
        pub description: ::core::option::Option<super::String>,
        /// Number of Series Related Instances
        #[prost(message, optional, tag = "8")]
        pub number_of_instances: ::core::option::Option<super::UnsignedInt>,
        /// Series access endpoint
        #[prost(message, repeated, tag = "9")]
        pub endpoint: prost::alloc::vec::Vec<super::Reference>,
        /// Body part examined
        #[prost(message, optional, tag = "10")]
        pub body_site: ::core::option::Option<super::Coding>,
        /// Body part laterality
        #[prost(message, optional, tag = "11")]
        pub laterality: ::core::option::Option<super::Coding>,
        /// Specimen imaged
        #[prost(message, repeated, tag = "12")]
        pub specimen: prost::alloc::vec::Vec<super::Reference>,
        /// When the series started
        #[prost(message, optional, tag = "13")]
        pub started: ::core::option::Option<super::DateTime>,
        #[prost(message, repeated, tag = "14")]
        pub performer: prost::alloc::vec::Vec<series::Performer>,
        #[prost(message, repeated, tag = "15")]
        pub instance: prost::alloc::vec::Vec<series::Instance>,
    }
    /// Nested message and enum types in `Series`.
    pub mod series {
        /// Who performed the series
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Performer {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of performance
            #[prost(message, optional, tag = "4")]
            pub function: ::core::option::Option<super::super::CodeableConcept>,
            /// Who performed the series
            #[prost(message, optional, tag = "5")]
            pub actor: ::core::option::Option<super::super::Reference>,
        }
        /// A single SOP instance from the series
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Instance {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// DICOM SOP Instance UID
            #[prost(message, optional, tag = "4")]
            pub uid: ::core::option::Option<super::super::Id>,
            /// DICOM class type
            #[prost(message, optional, tag = "5")]
            pub sop_class: ::core::option::Option<super::super::Coding>,
            /// The number of this instance in the series
            #[prost(message, optional, tag = "6")]
            pub number: ::core::option::Option<super::super::UnsignedInt>,
            /// Description of instance
            #[prost(message, optional, tag = "7")]
            pub title: ::core::option::Option<super::super::String>,
        }
    }
}
/// Auto-generated from StructureDefinition for Immunization, last updated
/// 2019-11-01T09:29:23.356+11:00. Immunization event information. See
/// <http://hl7.org/fhir/StructureDefinition/Immunization>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Immunization {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<immunization::StatusCode>,
    /// Reason not done
    #[prost(message, optional, tag = "12")]
    pub status_reason: ::core::option::Option<CodeableConcept>,
    /// Vaccine product administered
    #[prost(message, optional, tag = "13")]
    pub vaccine_code: ::core::option::Option<CodeableConcept>,
    /// Who was immunized
    #[prost(message, optional, tag = "14")]
    pub patient: ::core::option::Option<Reference>,
    /// Encounter immunization was part of
    #[prost(message, optional, tag = "15")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "16")]
    pub occurrence: ::core::option::Option<immunization::OccurrenceX>,
    /// When the immunization was first captured in the subject's record
    #[prost(message, optional, tag = "17")]
    pub recorded: ::core::option::Option<DateTime>,
    /// Indicates context the data was recorded in
    #[prost(message, optional, tag = "18")]
    pub primary_source: ::core::option::Option<Boolean>,
    /// Indicates the source of a secondarily reported record
    #[prost(message, optional, tag = "19")]
    pub report_origin: ::core::option::Option<CodeableConcept>,
    /// Where immunization occurred
    #[prost(message, optional, tag = "20")]
    pub location: ::core::option::Option<Reference>,
    /// Vaccine manufacturer
    #[prost(message, optional, tag = "21")]
    pub manufacturer: ::core::option::Option<Reference>,
    /// Vaccine lot number
    #[prost(message, optional, tag = "22")]
    pub lot_number: ::core::option::Option<String>,
    /// Vaccine expiration date
    #[prost(message, optional, tag = "23")]
    pub expiration_date: ::core::option::Option<Date>,
    /// Body site vaccine  was administered
    #[prost(message, optional, tag = "24")]
    pub site: ::core::option::Option<CodeableConcept>,
    /// How vaccine entered body
    #[prost(message, optional, tag = "25")]
    pub route: ::core::option::Option<CodeableConcept>,
    /// Amount of vaccine administered
    #[prost(message, optional, tag = "26")]
    pub dose_quantity: ::core::option::Option<SimpleQuantity>,
    #[prost(message, repeated, tag = "27")]
    pub performer: prost::alloc::vec::Vec<immunization::Performer>,
    /// Additional immunization notes
    #[prost(message, repeated, tag = "28")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Why immunization occurred
    #[prost(message, repeated, tag = "29")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why immunization occurred
    #[prost(message, repeated, tag = "30")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Dose potency
    #[prost(message, optional, tag = "31")]
    pub is_subpotent: ::core::option::Option<Boolean>,
    /// Reason for being subpotent
    #[prost(message, repeated, tag = "32")]
    pub subpotent_reason: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "33")]
    pub education: prost::alloc::vec::Vec<immunization::Education>,
    /// Patient eligibility for a vaccination program
    #[prost(message, repeated, tag = "34")]
    pub program_eligibility: prost::alloc::vec::Vec<CodeableConcept>,
    /// Funding source for the vaccine
    #[prost(message, optional, tag = "35")]
    pub funding_source: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "36")]
    pub reaction: prost::alloc::vec::Vec<immunization::Reaction>,
    #[prost(message, repeated, tag = "37")]
    pub protocol_applied: prost::alloc::vec::Vec<immunization::ProtocolApplied>,
}
/// Nested message and enum types in `Immunization`.
pub mod immunization {
    /// completed | entered-in-error | not-done
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::immunization_status_codes_value_set::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Vaccine administration date
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OccurrenceX {
        #[prost(oneof = "occurrence_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<occurrence_x::Choice>,
    }
    /// Nested message and enum types in `OccurrenceX`.
    pub mod occurrence_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            StringValue(super::super::String),
        }
    }
    /// Who performed event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Performer {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// What type of performance was done
        #[prost(message, optional, tag = "4")]
        pub function: ::core::option::Option<super::CodeableConcept>,
        /// Individual or organization who was performing
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
    }
    /// Educational material presented to patient
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Education {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Educational material document identifier
        #[prost(message, optional, tag = "4")]
        pub document_type: ::core::option::Option<super::String>,
        /// Educational material reference pointer
        #[prost(message, optional, tag = "5")]
        pub reference: ::core::option::Option<super::Uri>,
        /// Educational material publication date
        #[prost(message, optional, tag = "6")]
        pub publication_date: ::core::option::Option<super::DateTime>,
        /// Educational material presentation date
        #[prost(message, optional, tag = "7")]
        pub presentation_date: ::core::option::Option<super::DateTime>,
    }
    /// Details of a reaction that follows immunization
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Reaction {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// When reaction started
        #[prost(message, optional, tag = "4")]
        pub date: ::core::option::Option<super::DateTime>,
        /// Additional information on reaction
        #[prost(message, optional, tag = "5")]
        pub detail: ::core::option::Option<super::Reference>,
        /// Indicates self-reported reaction
        #[prost(message, optional, tag = "6")]
        pub reported: ::core::option::Option<super::Boolean>,
    }
    /// Protocol followed by the provider
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ProtocolApplied {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name of vaccine series
        #[prost(message, optional, tag = "4")]
        pub series: ::core::option::Option<super::String>,
        /// Who is responsible for publishing the recommendations
        #[prost(message, optional, tag = "5")]
        pub authority: ::core::option::Option<super::Reference>,
        /// Vaccine preventatable disease being targetted
        #[prost(message, repeated, tag = "6")]
        pub target_disease: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, optional, tag = "7")]
        pub dose_number: ::core::option::Option<protocol_applied::DoseNumberX>,
        #[prost(message, optional, tag = "8")]
        pub series_doses: ::core::option::Option<protocol_applied::SeriesDosesX>,
    }
    /// Nested message and enum types in `ProtocolApplied`.
    pub mod protocol_applied {
        /// Dose number within series
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DoseNumberX {
            #[prost(oneof = "dose_number_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<dose_number_x::Choice>,
        }
        /// Nested message and enum types in `DoseNumberX`.
        pub mod dose_number_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "2")]
                StringValue(super::super::super::String),
            }
        }
        /// Recommended number of doses for immunity
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SeriesDosesX {
            #[prost(oneof = "series_doses_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<series_doses_x::Choice>,
        }
        /// Nested message and enum types in `SeriesDosesX`.
        pub mod series_doses_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "2")]
                StringValue(super::super::super::String),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for ImmunizationEvaluation, last
/// updated 2019-11-01T09:29:23.356+11:00. Immunization evaluation information.
/// See <http://hl7.org/fhir/StructureDefinition/ImmunizationEvaluation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImmunizationEvaluation {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<immunization_evaluation::StatusCode>,
    /// Who this evaluation is for
    #[prost(message, optional, tag = "12")]
    pub patient: ::core::option::Option<Reference>,
    /// Date evaluation was performed
    #[prost(message, optional, tag = "13")]
    pub date: ::core::option::Option<DateTime>,
    /// Who is responsible for publishing the recommendations
    #[prost(message, optional, tag = "14")]
    pub authority: ::core::option::Option<Reference>,
    /// Evaluation target disease
    #[prost(message, optional, tag = "15")]
    pub target_disease: ::core::option::Option<CodeableConcept>,
    /// Immunization being evaluated
    #[prost(message, optional, tag = "16")]
    pub immunization_event: ::core::option::Option<Reference>,
    /// Status of the dose relative to published recommendations
    #[prost(message, optional, tag = "17")]
    pub dose_status: ::core::option::Option<CodeableConcept>,
    /// Reason for the dose status
    #[prost(message, repeated, tag = "18")]
    pub dose_status_reason: prost::alloc::vec::Vec<CodeableConcept>,
    /// Evaluation notes
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<String>,
    /// Name of vaccine series
    #[prost(message, optional, tag = "20")]
    pub series: ::core::option::Option<String>,
    #[prost(message, optional, tag = "21")]
    pub dose_number: ::core::option::Option<immunization_evaluation::DoseNumberX>,
    #[prost(message, optional, tag = "22")]
    pub series_doses: ::core::option::Option<immunization_evaluation::SeriesDosesX>,
}
/// Nested message and enum types in `ImmunizationEvaluation`.
pub mod immunization_evaluation {
    /// completed | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::immunization_evaluation_status_codes_value_set::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Dose number within series
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DoseNumberX {
        #[prost(oneof = "dose_number_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<dose_number_x::Choice>,
    }
    /// Nested message and enum types in `DoseNumberX`.
    pub mod dose_number_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "2")]
            StringValue(super::super::String),
        }
    }
    /// Recommended number of doses for immunity
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SeriesDosesX {
        #[prost(oneof = "series_doses_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<series_doses_x::Choice>,
    }
    /// Nested message and enum types in `SeriesDosesX`.
    pub mod series_doses_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "2")]
            StringValue(super::super::String),
        }
    }
}
/// Auto-generated from StructureDefinition for ImmunizationRecommendation, last
/// updated 2019-11-01T09:29:23.356+11:00. Guidance or advice relating to an
/// immunization. See
/// <http://hl7.org/fhir/StructureDefinition/ImmunizationRecommendation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImmunizationRecommendation {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Who this profile is for
    #[prost(message, optional, tag = "11")]
    pub patient: ::core::option::Option<Reference>,
    /// Date recommendation(s) created
    #[prost(message, optional, tag = "12")]
    pub date: ::core::option::Option<DateTime>,
    /// Who is responsible for protocol
    #[prost(message, optional, tag = "13")]
    pub authority: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "14")]
    pub recommendation: prost::alloc::vec::Vec<immunization_recommendation::Recommendation>,
}
/// Nested message and enum types in `ImmunizationRecommendation`.
pub mod immunization_recommendation {
    /// Vaccine administration recommendations
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Recommendation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Vaccine  or vaccine group recommendation applies to
        #[prost(message, repeated, tag = "4")]
        pub vaccine_code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Disease to be immunized against
        #[prost(message, optional, tag = "5")]
        pub target_disease: ::core::option::Option<super::CodeableConcept>,
        /// Vaccine which is contraindicated to fulfill the recommendation
        #[prost(message, repeated, tag = "6")]
        pub contraindicated_vaccine_code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Vaccine recommendation status
        #[prost(message, optional, tag = "7")]
        pub forecast_status: ::core::option::Option<super::CodeableConcept>,
        /// Vaccine administration status reason
        #[prost(message, repeated, tag = "8")]
        pub forecast_reason: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, repeated, tag = "9")]
        pub date_criterion: prost::alloc::vec::Vec<recommendation::DateCriterion>,
        /// Protocol details
        #[prost(message, optional, tag = "10")]
        pub description: ::core::option::Option<super::String>,
        /// Name of vaccination series
        #[prost(message, optional, tag = "11")]
        pub series: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "12")]
        pub dose_number: ::core::option::Option<recommendation::DoseNumberX>,
        #[prost(message, optional, tag = "13")]
        pub series_doses: ::core::option::Option<recommendation::SeriesDosesX>,
        /// Past immunizations supporting recommendation
        #[prost(message, repeated, tag = "14")]
        pub supporting_immunization: prost::alloc::vec::Vec<super::Reference>,
        /// Patient observations supporting recommendation
        #[prost(message, repeated, tag = "15")]
        pub supporting_patient_information: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Nested message and enum types in `Recommendation`.
    pub mod recommendation {
        /// Dates governing proposed immunization
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DateCriterion {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of date
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// Recommended date
            #[prost(message, optional, tag = "5")]
            pub value: ::core::option::Option<super::super::DateTime>,
        }
        /// Recommended dose number within series
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DoseNumberX {
            #[prost(oneof = "dose_number_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<dose_number_x::Choice>,
        }
        /// Nested message and enum types in `DoseNumberX`.
        pub mod dose_number_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "2")]
                StringValue(super::super::super::String),
            }
        }
        /// Recommended number of doses for immunity
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SeriesDosesX {
            #[prost(oneof = "series_doses_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<series_doses_x::Choice>,
        }
        /// Nested message and enum types in `SeriesDosesX`.
        pub mod series_doses_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "2")]
                StringValue(super::super::super::String),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for ImplementationGuide, last updated
/// 2019-11-01T09:29:23.356+11:00. A set of rules about how FHIR is used. See
/// <http://hl7.org/fhir/StructureDefinition/ImplementationGuide>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImplementationGuide {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this implementation guide, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the implementation guide
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this implementation guide (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this implementation guide (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<implementation_guide::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the implementation guide
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for implementation guide (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "22")]
    pub copyright: ::core::option::Option<Markdown>,
    /// NPM Package name for IG
    #[prost(message, optional, tag = "23")]
    pub package_id: ::core::option::Option<Id>,
    #[prost(message, optional, tag = "24")]
    pub license: ::core::option::Option<implementation_guide::LicenseCode>,
    #[prost(message, repeated, tag = "25")]
    pub fhir_version: prost::alloc::vec::Vec<implementation_guide::FhirVersionCode>,
    #[prost(message, repeated, tag = "26")]
    pub depends_on: prost::alloc::vec::Vec<implementation_guide::DependsOn>,
    #[prost(message, repeated, tag = "27")]
    pub global: prost::alloc::vec::Vec<implementation_guide::Global>,
    #[prost(message, optional, tag = "28")]
    pub definition: ::core::option::Option<implementation_guide::Definition>,
    #[prost(message, optional, tag = "29")]
    pub manifest: ::core::option::Option<implementation_guide::Manifest>,
}
/// Nested message and enum types in `ImplementationGuide`.
pub mod implementation_guide {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// SPDX license code for this IG (or not-open-source)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct LicenseCode {
        #[prost(enumeration = "super::spdx_license_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// FHIR Version(s) this Implementation Guide targets
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FhirVersionCode {
        #[prost(enumeration = "super::fhir_version_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Another Implementation guide this depends on
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DependsOn {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identity of the IG that this depends on
        #[prost(message, optional, tag = "4")]
        pub uri: ::core::option::Option<super::Canonical>,
        /// NPM Package name for IG this depends on
        #[prost(message, optional, tag = "5")]
        pub package_id: ::core::option::Option<super::Id>,
        /// Version of the IG
        #[prost(message, optional, tag = "6")]
        pub version: ::core::option::Option<super::String>,
    }
    /// Profiles that apply globally
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Global {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<global::TypeCode>,
        /// Profile that all resources must conform to
        #[prost(message, optional, tag = "5")]
        pub profile: ::core::option::Option<super::Canonical>,
    }
    /// Nested message and enum types in `Global`.
    pub mod global {
        /// Type this profile applies to
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::resource_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Information needed to build the IG
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Definition {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub grouping: prost::alloc::vec::Vec<definition::Grouping>,
        #[prost(message, repeated, tag = "5")]
        pub resource: prost::alloc::vec::Vec<definition::Resource>,
        #[prost(message, optional, tag = "6")]
        pub page: ::core::option::Option<definition::Page>,
        #[prost(message, repeated, tag = "7")]
        pub parameter: prost::alloc::vec::Vec<definition::Parameter>,
        #[prost(message, repeated, tag = "8")]
        pub template: prost::alloc::vec::Vec<definition::Template>,
    }
    /// Nested message and enum types in `Definition`.
    pub mod definition {
        /// Grouping used to present related resources in the IG
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Grouping {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Descriptive name for the package
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::String>,
            /// Human readable text describing the package
            #[prost(message, optional, tag = "5")]
            pub description: ::core::option::Option<super::super::String>,
        }
        /// Resource in the implementation guide
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Resource {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Location of the resource
            #[prost(message, optional, tag = "4")]
            pub reference: ::core::option::Option<super::super::Reference>,
            #[prost(message, repeated, tag = "5")]
            pub fhir_version: prost::alloc::vec::Vec<resource::FhirVersionCode>,
            /// Human Name for the resource
            #[prost(message, optional, tag = "6")]
            pub name: ::core::option::Option<super::super::String>,
            /// Reason why included in guide
            #[prost(message, optional, tag = "7")]
            pub description: ::core::option::Option<super::super::String>,
            #[prost(message, optional, tag = "8")]
            pub example: ::core::option::Option<resource::ExampleX>,
            /// Grouping this is part of
            #[prost(message, optional, tag = "9")]
            pub grouping_id: ::core::option::Option<super::super::Id>,
        }
        /// Nested message and enum types in `Resource`.
        pub mod resource {
            /// Versions this applies to (if different to IG)
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct FhirVersionCode {
                #[prost(
                    enumeration = "super::super::super::fhir_version_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// Is an example/What is this an example of?
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ExampleX {
                #[prost(oneof = "example_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<example_x::Choice>,
            }
            /// Nested message and enum types in `ExampleX`.
            pub mod example_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "2")]
                    Canonical(super::super::super::super::Canonical),
                }
            }
        }
        /// Page/Section in the Guide
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Page {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<page::NameX>,
            /// Short title shown for navigational assistance
            #[prost(message, optional, tag = "5")]
            pub title: ::core::option::Option<super::super::String>,
            #[prost(message, optional, tag = "6")]
            pub generation: ::core::option::Option<page::GenerationCode>,
            /// Nested Pages / Sections
            #[prost(message, repeated, tag = "7")]
            pub page: prost::alloc::vec::Vec<Page>,
        }
        /// Nested message and enum types in `Page`.
        pub mod page {
            /// Where to find that page
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct NameX {
                #[prost(oneof = "name_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<name_x::Choice>,
            }
            /// Nested message and enum types in `NameX`.
            pub mod name_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Url(super::super::super::super::Url),
                    #[prost(message, tag = "2")]
                    Reference(super::super::super::super::Reference),
                }
            }
            /// html | markdown | xml | generated
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct GenerationCode {
                #[prost(
                    enumeration = "super::super::super::guide_page_generation_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
        /// Defines how IG is built by tools
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Parameter {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<parameter::CodeType>,
            /// Value for named type
            #[prost(message, optional, tag = "5")]
            pub value: ::core::option::Option<super::super::String>,
        }
        /// Nested message and enum types in `Parameter`.
        pub mod parameter {
            /// apply | path-resource | path-pages | path-tx-cache |
            /// expansion-parameter | rule-broken-links | generate-xml | generate-json
            /// | generate-turtle | html-template
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct CodeType {
                #[prost(
                    enumeration = "super::super::super::guide_parameter_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
        /// A template for building resources
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Template {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of template specified
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::Code>,
            /// The source location for the template
            #[prost(message, optional, tag = "5")]
            pub source: ::core::option::Option<super::super::String>,
            /// The scope in which the template applies
            #[prost(message, optional, tag = "6")]
            pub scope: ::core::option::Option<super::super::String>,
        }
    }
    /// Information about an assembled IG
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Manifest {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Location of rendered implementation guide
        #[prost(message, optional, tag = "4")]
        pub rendering: ::core::option::Option<super::Url>,
        #[prost(message, repeated, tag = "5")]
        pub resource: prost::alloc::vec::Vec<manifest::ManifestResource>,
        #[prost(message, repeated, tag = "6")]
        pub page: prost::alloc::vec::Vec<manifest::ManifestPage>,
        /// Image within the IG
        #[prost(message, repeated, tag = "7")]
        pub image: prost::alloc::vec::Vec<super::String>,
        /// Additional linkable file in IG
        #[prost(message, repeated, tag = "8")]
        pub other: prost::alloc::vec::Vec<super::String>,
    }
    /// Nested message and enum types in `Manifest`.
    pub mod manifest {
        /// Resource in the implementation guide
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ManifestResource {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Location of the resource
            #[prost(message, optional, tag = "4")]
            pub reference: ::core::option::Option<super::super::Reference>,
            #[prost(message, optional, tag = "5")]
            pub example: ::core::option::Option<manifest_resource::ExampleX>,
            /// Relative path for page in IG
            #[prost(message, optional, tag = "6")]
            pub relative_path: ::core::option::Option<super::super::Url>,
        }
        /// Nested message and enum types in `ManifestResource`.
        pub mod manifest_resource {
            /// Is an example/What is this an example of?
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ExampleX {
                #[prost(oneof = "example_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<example_x::Choice>,
            }
            /// Nested message and enum types in `ExampleX`.
            pub mod example_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "2")]
                    Canonical(super::super::super::super::Canonical),
                }
            }
        }
        /// HTML page within the parent IG
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ManifestPage {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// HTML page name
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::String>,
            /// Title of the page, for references
            #[prost(message, optional, tag = "5")]
            pub title: ::core::option::Option<super::super::String>,
            /// Anchor available on the page
            #[prost(message, repeated, tag = "6")]
            pub anchor: prost::alloc::vec::Vec<super::super::String>,
        }
    }
}
/// Auto-generated from StructureDefinition for InsurancePlan, last updated
/// 2019-11-01T09:29:23.356+11:00. Details of a Health Insurance product/plan
/// provided by an organization. See
/// <http://hl7.org/fhir/StructureDefinition/InsurancePlan>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct InsurancePlan {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for Product
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<insurance_plan::StatusCode>,
    /// Kind of product
    #[prost(message, repeated, tag = "12")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Official name
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Alternate names
    #[prost(message, repeated, tag = "14")]
    pub alias: prost::alloc::vec::Vec<String>,
    /// When the product is available
    #[prost(message, optional, tag = "15")]
    pub period: ::core::option::Option<Period>,
    /// Plan issuer
    #[prost(message, optional, tag = "16")]
    pub owned_by: ::core::option::Option<Reference>,
    /// Product administrator
    #[prost(message, optional, tag = "17")]
    pub administered_by: ::core::option::Option<Reference>,
    /// Where product applies
    #[prost(message, repeated, tag = "18")]
    pub coverage_area: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "19")]
    pub contact: prost::alloc::vec::Vec<insurance_plan::Contact>,
    /// Technical endpoint
    #[prost(message, repeated, tag = "20")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
    /// What networks are Included
    #[prost(message, repeated, tag = "21")]
    pub network: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "22")]
    pub coverage: prost::alloc::vec::Vec<insurance_plan::Coverage>,
    #[prost(message, repeated, tag = "23")]
    pub plan: prost::alloc::vec::Vec<insurance_plan::Plan>,
}
/// Nested message and enum types in `InsurancePlan`.
pub mod insurance_plan {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Contact for the product
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Contact {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The type of contact
        #[prost(message, optional, tag = "4")]
        pub purpose: ::core::option::Option<super::CodeableConcept>,
        /// A name associated with the contact
        #[prost(message, optional, tag = "5")]
        pub name: ::core::option::Option<super::HumanName>,
        /// Contact details (telephone, email, etc.)  for a contact
        #[prost(message, repeated, tag = "6")]
        pub telecom: prost::alloc::vec::Vec<super::ContactPoint>,
        /// Visiting or postal addresses for the contact
        #[prost(message, optional, tag = "7")]
        pub address: ::core::option::Option<super::Address>,
    }
    /// Coverage details
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Coverage {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of coverage
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// What networks provide coverage
        #[prost(message, repeated, tag = "5")]
        pub network: prost::alloc::vec::Vec<super::Reference>,
        #[prost(message, repeated, tag = "6")]
        pub benefit: prost::alloc::vec::Vec<coverage::CoverageBenefit>,
    }
    /// Nested message and enum types in `Coverage`.
    pub mod coverage {
        /// List of benefits
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CoverageBenefit {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of benefit
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Referral requirements
            #[prost(message, optional, tag = "5")]
            pub requirement: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "6")]
            pub limit: prost::alloc::vec::Vec<coverage_benefit::Limit>,
        }
        /// Nested message and enum types in `CoverageBenefit`.
        pub mod coverage_benefit {
            /// Benefit limits
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Limit {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Maximum value allowed
                #[prost(message, optional, tag = "4")]
                pub value: ::core::option::Option<super::super::super::Quantity>,
                /// Benefit limit details
                #[prost(message, optional, tag = "5")]
                pub code: ::core::option::Option<super::super::super::CodeableConcept>,
            }
        }
    }
    /// Plan details
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Plan {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Business Identifier for Product
        #[prost(message, repeated, tag = "4")]
        pub identifier: prost::alloc::vec::Vec<super::Identifier>,
        /// Type of plan
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Where product applies
        #[prost(message, repeated, tag = "6")]
        pub coverage_area: prost::alloc::vec::Vec<super::Reference>,
        /// What networks provide coverage
        #[prost(message, repeated, tag = "7")]
        pub network: prost::alloc::vec::Vec<super::Reference>,
        #[prost(message, repeated, tag = "8")]
        pub general_cost: prost::alloc::vec::Vec<plan::GeneralCost>,
        #[prost(message, repeated, tag = "9")]
        pub specific_cost: prost::alloc::vec::Vec<plan::SpecificCost>,
    }
    /// Nested message and enum types in `Plan`.
    pub mod plan {
        /// Overall costs
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct GeneralCost {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of cost
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Number of enrollees
            #[prost(message, optional, tag = "5")]
            pub group_size: ::core::option::Option<super::super::PositiveInt>,
            /// Cost value
            #[prost(message, optional, tag = "6")]
            pub cost: ::core::option::Option<super::super::Money>,
            /// Additional cost information
            #[prost(message, optional, tag = "7")]
            pub comment: ::core::option::Option<super::super::String>,
        }
        /// Specific costs
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SpecificCost {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// General category of benefit
            #[prost(message, optional, tag = "4")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            #[prost(message, repeated, tag = "5")]
            pub benefit: prost::alloc::vec::Vec<specific_cost::PlanBenefit>,
        }
        /// Nested message and enum types in `SpecificCost`.
        pub mod specific_cost {
            /// Benefits list
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct PlanBenefit {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Type of specific benefit
                #[prost(message, optional, tag = "4")]
                pub r#type: ::core::option::Option<super::super::super::CodeableConcept>,
                #[prost(message, repeated, tag = "5")]
                pub cost: prost::alloc::vec::Vec<plan_benefit::Cost>,
            }
            /// Nested message and enum types in `PlanBenefit`.
            pub mod plan_benefit {
                /// List of the costs
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct Cost {
                    /// Unique id for inter-element referencing
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored even if unrecognized
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Type of cost
                    #[prost(message, optional, tag = "4")]
                    pub r#type: ::core::option::Option<super::super::super::super::CodeableConcept>,
                    /// in-network | out-of-network | other
                    #[prost(message, optional, tag = "5")]
                    pub applicability:
                        ::core::option::Option<super::super::super::super::CodeableConcept>,
                    /// Additional information about the cost
                    #[prost(message, repeated, tag = "6")]
                    pub qualifiers:
                        prost::alloc::vec::Vec<super::super::super::super::CodeableConcept>,
                    /// The actual cost value
                    #[prost(message, optional, tag = "7")]
                    pub value: ::core::option::Option<super::super::super::super::Quantity>,
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Invoice, last updated
/// 2019-11-01T09:29:23.356+11:00. Invoice containing ChargeItems from an
/// Account. See <http://hl7.org/fhir/StructureDefinition/Invoice>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Invoice {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for item
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<invoice::StatusCode>,
    /// Reason for cancellation of this Invoice
    #[prost(message, optional, tag = "12")]
    pub cancelled_reason: ::core::option::Option<String>,
    /// Type of Invoice
    #[prost(message, optional, tag = "13")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Recipient(s) of goods and services
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Recipient of this invoice
    #[prost(message, optional, tag = "15")]
    pub recipient: ::core::option::Option<Reference>,
    /// Invoice date / posting date
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    #[prost(message, repeated, tag = "17")]
    pub participant: prost::alloc::vec::Vec<invoice::Participant>,
    /// Issuing Organization of Invoice
    #[prost(message, optional, tag = "18")]
    pub issuer: ::core::option::Option<Reference>,
    /// Account that is being balanced
    #[prost(message, optional, tag = "19")]
    pub account: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "20")]
    pub line_item: prost::alloc::vec::Vec<invoice::LineItem>,
    /// Components of Invoice total
    #[prost(message, repeated, tag = "21")]
    pub total_price_component: prost::alloc::vec::Vec<invoice::line_item::PriceComponent>,
    /// Net total of this Invoice
    #[prost(message, optional, tag = "22")]
    pub total_net: ::core::option::Option<Money>,
    /// Gross total of this Invoice
    #[prost(message, optional, tag = "23")]
    pub total_gross: ::core::option::Option<Money>,
    /// Payment details
    #[prost(message, optional, tag = "24")]
    pub payment_terms: ::core::option::Option<Markdown>,
    /// Comments made about the invoice
    #[prost(message, repeated, tag = "25")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `Invoice`.
pub mod invoice {
    /// draft | issued | balanced | cancelled | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::invoice_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Participant in creation of this Invoice
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of involvement in creation of this Invoice
        #[prost(message, optional, tag = "4")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Individual who was involved
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
    }
    /// Line items of this Invoice
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct LineItem {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Sequence number of line item
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        #[prost(message, optional, tag = "5")]
        pub charge_item: ::core::option::Option<line_item::ChargeItemX>,
        #[prost(message, repeated, tag = "6")]
        pub price_component: prost::alloc::vec::Vec<line_item::PriceComponent>,
    }
    /// Nested message and enum types in `LineItem`.
    pub mod line_item {
        /// Reference to ChargeItem containing details of this line item or an inline
        /// billing code
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ChargeItemX {
            #[prost(oneof = "charge_item_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<charge_item_x::Choice>,
        }
        /// Nested message and enum types in `ChargeItemX`.
        pub mod charge_item_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "2")]
                CodeableConcept(super::super::super::CodeableConcept),
            }
        }
        /// Components of total line item price
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PriceComponent {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<price_component::TypeCode>,
            /// Code identifying the specific component
            #[prost(message, optional, tag = "5")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// Factor used for calculating this component
            #[prost(message, optional, tag = "6")]
            pub factor: ::core::option::Option<super::super::Decimal>,
            /// Monetary amount associated with this component
            #[prost(message, optional, tag = "7")]
            pub amount: ::core::option::Option<super::super::Money>,
        }
        /// Nested message and enum types in `PriceComponent`.
        pub mod price_component {
            /// base | surcharge | deduction | discount | tax | informational
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct TypeCode {
                #[prost(
                    enumeration = "super::super::super::invoice_price_component_type_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Library, last updated
/// 2019-11-01T09:29:23.356+11:00. Represents a library of quality improvement
/// components. See <http://hl7.org/fhir/StructureDefinition/Library>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Library {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this library, represented as a URI (globally
    /// unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the library
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the library
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this library (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this library (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Subordinate title of the library
    #[prost(message, optional, tag = "15")]
    pub subtitle: ::core::option::Option<String>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<library::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "17")]
    pub experimental: ::core::option::Option<Boolean>,
    /// logic-library | model-definition | asset-collection | module-definition
    #[prost(message, optional, tag = "18")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "19")]
    pub subject: ::core::option::Option<library::SubjectX>,
    /// Date last changed
    #[prost(message, optional, tag = "20")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "21")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "22")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the library
    #[prost(message, optional, tag = "23")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "24")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for library (if applicable)
    #[prost(message, repeated, tag = "25")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this library is defined
    #[prost(message, optional, tag = "26")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the library
    #[prost(message, optional, tag = "27")]
    pub usage: ::core::option::Option<String>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "28")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the library was approved by publisher
    #[prost(message, optional, tag = "29")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the library was last reviewed
    #[prost(message, optional, tag = "30")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the library is expected to be used
    #[prost(message, optional, tag = "31")]
    pub effective_period: ::core::option::Option<Period>,
    /// E.g. Education, Treatment, Assessment, etc.
    #[prost(message, repeated, tag = "32")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "33")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "34")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "35")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "36")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "37")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Parameters defined by the library
    #[prost(message, repeated, tag = "38")]
    pub parameter: prost::alloc::vec::Vec<ParameterDefinition>,
    /// What data is referenced by this library
    #[prost(message, repeated, tag = "39")]
    pub data_requirement: prost::alloc::vec::Vec<DataRequirement>,
    /// Contents of the library, either embedded or referenced
    #[prost(message, repeated, tag = "40")]
    pub content: prost::alloc::vec::Vec<Attachment>,
}
/// Nested message and enum types in `Library`.
pub mod library {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Type of individual the library content is focused on
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SubjectX {
        #[prost(oneof = "subject_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<subject_x::Choice>,
    }
    /// Nested message and enum types in `SubjectX`.
    pub mod subject_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for Linkage, last updated
/// 2019-11-01T09:29:23.356+11:00. Links records for 'same' item. See
/// <http://hl7.org/fhir/StructureDefinition/Linkage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Linkage {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Whether this linkage assertion is active or not
    #[prost(message, optional, tag = "10")]
    pub active: ::core::option::Option<Boolean>,
    /// Who is responsible for linkages
    #[prost(message, optional, tag = "11")]
    pub author: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "12")]
    pub item: prost::alloc::vec::Vec<linkage::Item>,
}
/// Nested message and enum types in `Linkage`.
pub mod linkage {
    /// Item to be linked
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<item::TypeCode>,
        /// Resource being linked
        #[prost(message, optional, tag = "5")]
        pub resource: ::core::option::Option<super::Reference>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// source | alternate | historical
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::linkage_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for List, last updated
/// 2019-11-01T09:29:23.356+11:00. A list is a curated collection of resources.
/// See <http://hl7.org/fhir/StructureDefinition/List>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct List {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<list::StatusCode>,
    #[prost(message, optional, tag = "12")]
    pub mode: ::core::option::Option<list::ModeCode>,
    /// Descriptive name for the list
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// What the purpose of this list is
    #[prost(message, optional, tag = "14")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// If all resources have the same subject
    #[prost(message, optional, tag = "15")]
    pub subject: ::core::option::Option<Reference>,
    /// Context in which list created
    #[prost(message, optional, tag = "16")]
    pub encounter: ::core::option::Option<Reference>,
    /// When the list was prepared
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<DateTime>,
    /// Who and/or what defined the list contents (aka Author)
    #[prost(message, optional, tag = "18")]
    pub source: ::core::option::Option<Reference>,
    /// What order the list has
    #[prost(message, optional, tag = "19")]
    pub ordered_by: ::core::option::Option<CodeableConcept>,
    /// Comments about the list
    #[prost(message, repeated, tag = "20")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "21")]
    pub entry: prost::alloc::vec::Vec<list::Entry>,
    /// Why list is empty
    #[prost(message, optional, tag = "22")]
    pub empty_reason: ::core::option::Option<CodeableConcept>,
}
/// Nested message and enum types in `List`.
pub mod list {
    /// current | retired | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::list_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// working | snapshot | changes
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ModeCode {
        #[prost(enumeration = "super::list_mode_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Entries in the list
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Entry {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Status/Workflow information about this item
        #[prost(message, optional, tag = "4")]
        pub flag: ::core::option::Option<super::CodeableConcept>,
        /// If this item is actually marked as deleted
        #[prost(message, optional, tag = "5")]
        pub deleted: ::core::option::Option<super::Boolean>,
        /// When item added to list
        #[prost(message, optional, tag = "6")]
        pub date: ::core::option::Option<super::DateTime>,
        /// Actual entry
        #[prost(message, optional, tag = "7")]
        pub item: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for Location, last updated
/// 2019-11-01T09:29:23.356+11:00. Details and position information for a
/// physical place. See <http://hl7.org/fhir/StructureDefinition/Location>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Location {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique code or number identifying the location to its users
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<location::StatusCode>,
    /// The operational status of the location (typically only for a bed/room)
    #[prost(message, optional, tag = "12")]
    pub operational_status: ::core::option::Option<Coding>,
    /// Name of the location as used by humans
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// A list of alternate names that the location is known as, or was known as,
    /// in the past
    #[prost(message, repeated, tag = "14")]
    pub alias: prost::alloc::vec::Vec<String>,
    /// Additional details about the location that could be displayed as further
    /// information to identify the location beyond its name
    #[prost(message, optional, tag = "15")]
    pub description: ::core::option::Option<String>,
    #[prost(message, optional, tag = "16")]
    pub mode: ::core::option::Option<location::ModeCode>,
    /// Type of function performed
    #[prost(message, repeated, tag = "17")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Contact details of the location
    #[prost(message, repeated, tag = "18")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// Physical location
    #[prost(message, optional, tag = "19")]
    pub address: ::core::option::Option<Address>,
    /// Physical form of the location
    #[prost(message, optional, tag = "20")]
    pub physical_type: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "21")]
    pub position: ::core::option::Option<location::Position>,
    /// Organization responsible for provisioning and upkeep
    #[prost(message, optional, tag = "22")]
    pub managing_organization: ::core::option::Option<Reference>,
    /// Another Location this one is physically a part of
    #[prost(message, optional, tag = "23")]
    pub part_of: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "24")]
    pub hours_of_operation: prost::alloc::vec::Vec<location::HoursOfOperation>,
    /// Description of availability exceptions
    #[prost(message, optional, tag = "25")]
    pub availability_exceptions: ::core::option::Option<String>,
    /// Technical endpoints providing access to services operated for the location
    #[prost(message, repeated, tag = "26")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `Location`.
pub mod location {
    /// active | suspended | inactive
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::location_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// instance | kind
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ModeCode {
        #[prost(enumeration = "super::location_mode_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// The absolute geographic location
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Position {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Longitude with WGS84 datum
        #[prost(message, optional, tag = "4")]
        pub longitude: ::core::option::Option<super::Decimal>,
        /// Latitude with WGS84 datum
        #[prost(message, optional, tag = "5")]
        pub latitude: ::core::option::Option<super::Decimal>,
        /// Altitude with WGS84 datum
        #[prost(message, optional, tag = "6")]
        pub altitude: ::core::option::Option<super::Decimal>,
    }
    /// What days/times during a week is this location usually open
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct HoursOfOperation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub days_of_week: prost::alloc::vec::Vec<hours_of_operation::DaysOfWeekCode>,
        /// The Location is open all day
        #[prost(message, optional, tag = "5")]
        pub all_day: ::core::option::Option<super::Boolean>,
        /// Time that the Location opens
        #[prost(message, optional, tag = "6")]
        pub opening_time: ::core::option::Option<super::Time>,
        /// Time that the Location closes
        #[prost(message, optional, tag = "7")]
        pub closing_time: ::core::option::Option<super::Time>,
    }
    /// Nested message and enum types in `HoursOfOperation`.
    pub mod hours_of_operation {
        /// mon | tue | wed | thu | fri | sat | sun
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DaysOfWeekCode {
            #[prost(enumeration = "super::super::days_of_week_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for Measure, last updated
/// 2019-11-01T09:29:23.356+11:00. A quality measure definition. See
/// <http://hl7.org/fhir/StructureDefinition/Measure>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Measure {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this measure, represented as a URI (globally
    /// unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the measure
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the measure
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this measure (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this measure (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Subordinate title of the measure
    #[prost(message, optional, tag = "15")]
    pub subtitle: ::core::option::Option<String>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<measure::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "17")]
    pub experimental: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "18")]
    pub subject: ::core::option::Option<measure::SubjectX>,
    /// Date last changed
    #[prost(message, optional, tag = "19")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "20")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "21")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the measure
    #[prost(message, optional, tag = "22")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "23")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for measure (if applicable)
    #[prost(message, repeated, tag = "24")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this measure is defined
    #[prost(message, optional, tag = "25")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the measure
    #[prost(message, optional, tag = "26")]
    pub usage: ::core::option::Option<String>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "27")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the measure was approved by publisher
    #[prost(message, optional, tag = "28")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the measure was last reviewed
    #[prost(message, optional, tag = "29")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the measure is expected to be used
    #[prost(message, optional, tag = "30")]
    pub effective_period: ::core::option::Option<Period>,
    /// The category of the measure, such as Education, Treatment, Assessment, etc.
    #[prost(message, repeated, tag = "31")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "32")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "33")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "34")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "35")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "36")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Logic used by the measure
    #[prost(message, repeated, tag = "37")]
    pub library: prost::alloc::vec::Vec<Canonical>,
    /// Disclaimer for use of the measure or its referenced content
    #[prost(message, optional, tag = "38")]
    pub disclaimer: ::core::option::Option<Markdown>,
    /// proportion | ratio | continuous-variable | cohort
    #[prost(message, optional, tag = "39")]
    pub scoring: ::core::option::Option<CodeableConcept>,
    /// opportunity | all-or-nothing | linear | weighted
    #[prost(message, optional, tag = "40")]
    pub composite_scoring: ::core::option::Option<CodeableConcept>,
    /// process | outcome | structure | patient-reported-outcome | composite
    #[prost(message, repeated, tag = "41")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    /// How risk adjustment is applied for this measure
    #[prost(message, optional, tag = "42")]
    pub risk_adjustment: ::core::option::Option<String>,
    /// How is rate aggregation performed for this measure
    #[prost(message, optional, tag = "43")]
    pub rate_aggregation: ::core::option::Option<String>,
    /// Detailed description of why the measure exists
    #[prost(message, optional, tag = "44")]
    pub rationale: ::core::option::Option<Markdown>,
    /// Summary of clinical guidelines
    #[prost(message, optional, tag = "45")]
    pub clinical_recommendation_statement: ::core::option::Option<Markdown>,
    /// increase | decrease
    #[prost(message, optional, tag = "46")]
    pub improvement_notation: ::core::option::Option<CodeableConcept>,
    /// Defined terms used in the measure documentation
    #[prost(message, repeated, tag = "47")]
    pub definition: prost::alloc::vec::Vec<Markdown>,
    /// Additional guidance for implementers
    #[prost(message, optional, tag = "48")]
    pub guidance: ::core::option::Option<Markdown>,
    #[prost(message, repeated, tag = "49")]
    pub group: prost::alloc::vec::Vec<measure::Group>,
    #[prost(message, repeated, tag = "50")]
    pub supplemental_data: prost::alloc::vec::Vec<measure::SupplementalData>,
}
/// Nested message and enum types in `Measure`.
pub mod measure {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SubjectX {
        #[prost(oneof = "subject_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<subject_x::Choice>,
    }
    /// Nested message and enum types in `SubjectX`.
    pub mod subject_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Population criteria group
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Group {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Meaning of the group
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Summary description
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "6")]
        pub population: prost::alloc::vec::Vec<group::Population>,
        #[prost(message, repeated, tag = "7")]
        pub stratifier: prost::alloc::vec::Vec<group::Stratifier>,
    }
    /// Nested message and enum types in `Group`.
    pub mod group {
        /// Population criteria
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Population {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// initial-population | numerator | numerator-exclusion | denominator |
            /// denominator-exclusion | denominator-exception | measure-population |
            /// measure-population-exclusion | measure-observation
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// The human readable description of this population criteria
            #[prost(message, optional, tag = "5")]
            pub description: ::core::option::Option<super::super::String>,
            /// The criteria that defines this population
            #[prost(message, optional, tag = "6")]
            pub criteria: ::core::option::Option<super::super::Expression>,
        }
        /// Stratifier criteria for the measure
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Stratifier {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Meaning of the stratifier
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// The human readable description of this stratifier
            #[prost(message, optional, tag = "5")]
            pub description: ::core::option::Option<super::super::String>,
            /// How the measure should be stratified
            #[prost(message, optional, tag = "6")]
            pub criteria: ::core::option::Option<super::super::Expression>,
            #[prost(message, repeated, tag = "7")]
            pub component: prost::alloc::vec::Vec<stratifier::Component>,
        }
        /// Nested message and enum types in `Stratifier`.
        pub mod stratifier {
            /// Stratifier criteria component for the measure
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Component {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Meaning of the stratifier component
                #[prost(message, optional, tag = "4")]
                pub code: ::core::option::Option<super::super::super::CodeableConcept>,
                /// The human readable description of this stratifier component
                #[prost(message, optional, tag = "5")]
                pub description: ::core::option::Option<super::super::super::String>,
                /// Component of how the measure should be stratified
                #[prost(message, optional, tag = "6")]
                pub criteria: ::core::option::Option<super::super::super::Expression>,
            }
        }
    }
    /// What other data should be reported with the measure
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SupplementalData {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Meaning of the supplemental data
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// supplemental-data | risk-adjustment-factor
        #[prost(message, repeated, tag = "5")]
        pub usage: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// The human readable description of this supplemental data
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        /// Expression describing additional data to be reported
        #[prost(message, optional, tag = "7")]
        pub criteria: ::core::option::Option<super::Expression>,
    }
}
/// Auto-generated from StructureDefinition for MeasureReport, last updated
/// 2019-11-01T09:29:23.356+11:00. Results of a measure evaluation. See
/// <http://hl7.org/fhir/StructureDefinition/MeasureReport>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureReport {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Additional identifier for the MeasureReport
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<measure_report::StatusCode>,
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<measure_report::TypeCode>,
    /// What measure was calculated
    #[prost(message, optional, tag = "13")]
    pub measure: ::core::option::Option<Canonical>,
    /// What individual(s) the report is for
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// When the report was generated
    #[prost(message, optional, tag = "15")]
    pub date: ::core::option::Option<DateTime>,
    /// Who is reporting the data
    #[prost(message, optional, tag = "16")]
    pub reporter: ::core::option::Option<Reference>,
    /// What period the report covers
    #[prost(message, optional, tag = "17")]
    pub period: ::core::option::Option<Period>,
    /// increase | decrease
    #[prost(message, optional, tag = "18")]
    pub improvement_notation: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "19")]
    pub group: prost::alloc::vec::Vec<measure_report::Group>,
    /// What data was used to calculate the measure score
    #[prost(message, repeated, tag = "20")]
    pub evaluated_resource: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `MeasureReport`.
pub mod measure_report {
    /// complete | pending | error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::measure_report_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// individual | subject-list | summary | data-collection
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::measure_report_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Measure results for each group
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Group {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Meaning of the group
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "5")]
        pub population: prost::alloc::vec::Vec<group::Population>,
        /// What score this group achieved
        #[prost(message, optional, tag = "6")]
        pub measure_score: ::core::option::Option<super::Quantity>,
        #[prost(message, repeated, tag = "7")]
        pub stratifier: prost::alloc::vec::Vec<group::Stratifier>,
    }
    /// Nested message and enum types in `Group`.
    pub mod group {
        /// The populations in the group
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Population {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// initial-population | numerator | numerator-exclusion | denominator |
            /// denominator-exclusion | denominator-exception | measure-population |
            /// measure-population-exclusion | measure-observation
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// Size of the population
            #[prost(message, optional, tag = "5")]
            pub count: ::core::option::Option<super::super::Integer>,
            /// For subject-list reports, the subject results in this population
            #[prost(message, optional, tag = "6")]
            pub subject_results: ::core::option::Option<super::super::Reference>,
        }
        /// Stratification results
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Stratifier {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// What stratifier of the group
            #[prost(message, repeated, tag = "4")]
            pub code: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            #[prost(message, repeated, tag = "5")]
            pub stratum: prost::alloc::vec::Vec<stratifier::StratifierGroup>,
        }
        /// Nested message and enum types in `Stratifier`.
        pub mod stratifier {
            /// Stratum results, one for each unique value, or set of values, in the
            /// stratifier, or stratifier components
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct StratifierGroup {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// The stratum value, e.g. male
                #[prost(message, optional, tag = "4")]
                pub value: ::core::option::Option<super::super::super::CodeableConcept>,
                #[prost(message, repeated, tag = "5")]
                pub component: prost::alloc::vec::Vec<stratifier_group::Component>,
                #[prost(message, repeated, tag = "6")]
                pub population: prost::alloc::vec::Vec<stratifier_group::StratifierGroupPopulation>,
                /// What score this stratum achieved
                #[prost(message, optional, tag = "7")]
                pub measure_score: ::core::option::Option<super::super::super::Quantity>,
            }
            /// Nested message and enum types in `StratifierGroup`.
            pub mod stratifier_group {
                /// Stratifier component values
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct Component {
                    /// Unique id for inter-element referencing
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored even if unrecognized
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// What stratifier component of the group
                    #[prost(message, optional, tag = "4")]
                    pub code: ::core::option::Option<super::super::super::super::CodeableConcept>,
                    /// The stratum component value, e.g. male
                    #[prost(message, optional, tag = "5")]
                    pub value: ::core::option::Option<super::super::super::super::CodeableConcept>,
                }
                /// Population results in this stratum
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct StratifierGroupPopulation {
                    /// Unique id for inter-element referencing
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored even if unrecognized
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// initial-population | numerator | numerator-exclusion | denominator
                    /// | denominator-exclusion | denominator-exception |
                    /// measure-population | measure-population-exclusion |
                    /// measure-observation
                    #[prost(message, optional, tag = "4")]
                    pub code: ::core::option::Option<super::super::super::super::CodeableConcept>,
                    /// Size of the population
                    #[prost(message, optional, tag = "5")]
                    pub count: ::core::option::Option<super::super::super::super::Integer>,
                    /// For subject-list reports, the subject results in this population
                    #[prost(message, optional, tag = "6")]
                    pub subject_results:
                        ::core::option::Option<super::super::super::super::Reference>,
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Media, last updated
/// 2019-11-01T09:29:23.356+11:00. A photo, video, or audio recording acquired or
/// used in healthcare. The actual content may be inline or provided by direct
/// reference. See <http://hl7.org/fhir/StructureDefinition/Media>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Media {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifier(s) for the image
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Procedure that caused this media to be created
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced event
    #[prost(message, repeated, tag = "12")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<media::StatusCode>,
    /// Classification of media as image, video, or audio
    #[prost(message, optional, tag = "14")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// The type of acquisition equipment/process
    #[prost(message, optional, tag = "15")]
    pub modality: ::core::option::Option<CodeableConcept>,
    /// Imaging view, e.g. Lateral or Antero-posterior
    #[prost(message, optional, tag = "16")]
    pub view: ::core::option::Option<CodeableConcept>,
    /// Who/What this Media is a record of
    #[prost(message, optional, tag = "17")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter associated with media
    #[prost(message, optional, tag = "18")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "19")]
    pub created: ::core::option::Option<media::CreatedX>,
    /// Date/Time this version was made available
    #[prost(message, optional, tag = "20")]
    pub issued: ::core::option::Option<Instant>,
    /// The person who generated the image
    #[prost(message, optional, tag = "21")]
    pub operator: ::core::option::Option<Reference>,
    /// Why was event performed?
    #[prost(message, repeated, tag = "22")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Observed body part
    #[prost(message, optional, tag = "23")]
    pub body_site: ::core::option::Option<CodeableConcept>,
    /// Name of the device/manufacturer
    #[prost(message, optional, tag = "24")]
    pub device_name: ::core::option::Option<String>,
    /// Observing Device
    #[prost(message, optional, tag = "25")]
    pub device: ::core::option::Option<Reference>,
    /// Height of the image in pixels (photo/video)
    #[prost(message, optional, tag = "26")]
    pub height: ::core::option::Option<PositiveInt>,
    /// Width of the image in pixels (photo/video)
    #[prost(message, optional, tag = "27")]
    pub width: ::core::option::Option<PositiveInt>,
    /// Number of frames if > 1 (photo)
    #[prost(message, optional, tag = "28")]
    pub frames: ::core::option::Option<PositiveInt>,
    /// Length in seconds (audio / video)
    #[prost(message, optional, tag = "29")]
    pub duration: ::core::option::Option<Decimal>,
    /// Actual Media - reference or data
    #[prost(message, optional, tag = "30")]
    pub content: ::core::option::Option<Attachment>,
    /// Comments made about the media
    #[prost(message, repeated, tag = "31")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `Media`.
pub mod media {
    /// preparation | in-progress | not-done | on-hold | stopped | completed |
    /// entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::event_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// When Media was collected
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CreatedX {
        #[prost(oneof = "created_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<created_x::Choice>,
    }
    /// Nested message and enum types in `CreatedX`.
    pub mod created_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
}
/// Auto-generated from StructureDefinition for Medication, last updated
/// 2019-11-01T09:29:23.356+11:00. Definition of a Medication. See
/// <http://hl7.org/fhir/StructureDefinition/Medication>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Medication {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier for this medication
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Codes that identify this medication
    #[prost(message, optional, tag = "11")]
    pub code: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<medication::StatusCode>,
    /// Manufacturer of the item
    #[prost(message, optional, tag = "13")]
    pub manufacturer: ::core::option::Option<Reference>,
    /// powder | tablets | capsule +
    #[prost(message, optional, tag = "14")]
    pub form: ::core::option::Option<CodeableConcept>,
    /// Amount of drug in package
    #[prost(message, optional, tag = "15")]
    pub amount: ::core::option::Option<Ratio>,
    #[prost(message, repeated, tag = "16")]
    pub ingredient: prost::alloc::vec::Vec<medication::Ingredient>,
    #[prost(message, optional, tag = "17")]
    pub batch: ::core::option::Option<medication::Batch>,
}
/// Nested message and enum types in `Medication`.
pub mod medication {
    /// active | inactive | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::medication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Active or inactive ingredient
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Ingredient {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub item: ::core::option::Option<ingredient::ItemX>,
        /// Active ingredient indicator
        #[prost(message, optional, tag = "5")]
        pub is_active: ::core::option::Option<super::Boolean>,
        /// Quantity of ingredient present
        #[prost(message, optional, tag = "6")]
        pub strength: ::core::option::Option<super::Ratio>,
    }
    /// Nested message and enum types in `Ingredient`.
    pub mod ingredient {
        /// The actual ingredient or content
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ItemX {
            #[prost(oneof = "item_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<item_x::Choice>,
        }
        /// Nested message and enum types in `ItemX`.
        pub mod item_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Details about packaged medications
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Batch {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifier assigned to batch
        #[prost(message, optional, tag = "4")]
        pub lot_number: ::core::option::Option<super::String>,
        /// When batch will expire
        #[prost(message, optional, tag = "5")]
        pub expiration_date: ::core::option::Option<super::DateTime>,
    }
}
/// Auto-generated from StructureDefinition for MedicationAdministration, last
/// updated 2019-11-01T09:29:23.356+11:00. Administration of medication to a
/// patient. See <http://hl7.org/fhir/StructureDefinition/MedicationAdministration>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationAdministration {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates protocol or definition
    #[prost(message, repeated, tag = "11")]
    pub instantiates: prost::alloc::vec::Vec<Uri>,
    /// Part of referenced event
    #[prost(message, repeated, tag = "12")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<medication_administration::StatusCode>,
    /// Reason administration not performed
    #[prost(message, repeated, tag = "14")]
    pub status_reason: prost::alloc::vec::Vec<CodeableConcept>,
    /// Type of medication usage
    #[prost(message, optional, tag = "15")]
    pub category: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "16")]
    pub medication: ::core::option::Option<medication_administration::MedicationX>,
    /// Who received medication
    #[prost(message, optional, tag = "17")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or Episode of Care administered as part of
    #[prost(message, optional, tag = "18")]
    pub context: ::core::option::Option<Reference>,
    /// Additional information to support administration
    #[prost(message, repeated, tag = "19")]
    pub supporting_information: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "20")]
    pub effective: ::core::option::Option<medication_administration::EffectiveX>,
    #[prost(message, repeated, tag = "21")]
    pub performer: prost::alloc::vec::Vec<medication_administration::Performer>,
    /// Reason administration performed
    #[prost(message, repeated, tag = "22")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Condition or observation that supports why the medication was administered
    #[prost(message, repeated, tag = "23")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Request administration performed against
    #[prost(message, optional, tag = "24")]
    pub request: ::core::option::Option<Reference>,
    /// Device used to administer
    #[prost(message, repeated, tag = "25")]
    pub device: prost::alloc::vec::Vec<Reference>,
    /// Information about the administration
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, optional, tag = "27")]
    pub dosage: ::core::option::Option<medication_administration::Dosage>,
    /// A list of events of interest in the lifecycle
    #[prost(message, repeated, tag = "28")]
    pub event_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `MedicationAdministration`.
pub mod medication_administration {
    /// in-progress | not-done | on-hold | completed | entered-in-error | stopped |
    /// unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::medication_administration_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// What was administered
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MedicationX {
        #[prost(oneof = "medication_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<medication_x::Choice>,
    }
    /// Nested message and enum types in `MedicationX`.
    pub mod medication_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Start and end time of administration
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EffectiveX {
        #[prost(oneof = "effective_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<effective_x::Choice>,
    }
    /// Nested message and enum types in `EffectiveX`.
    pub mod effective_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Who performed the medication administration and what they did
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Performer {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of performance
        #[prost(message, optional, tag = "4")]
        pub function: ::core::option::Option<super::CodeableConcept>,
        /// Who performed the medication administration
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
    }
    /// Details of how medication was taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Dosage {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Free text dosage instructions e.g. SIG
        #[prost(message, optional, tag = "4")]
        pub text: ::core::option::Option<super::String>,
        /// Body site administered to
        #[prost(message, optional, tag = "5")]
        pub site: ::core::option::Option<super::CodeableConcept>,
        /// Path of substance into body
        #[prost(message, optional, tag = "6")]
        pub route: ::core::option::Option<super::CodeableConcept>,
        /// How drug was administered
        #[prost(message, optional, tag = "7")]
        pub method: ::core::option::Option<super::CodeableConcept>,
        /// Amount of medication per dose
        #[prost(message, optional, tag = "8")]
        pub dose: ::core::option::Option<super::SimpleQuantity>,
        #[prost(message, optional, tag = "9")]
        pub rate: ::core::option::Option<dosage::RateX>,
    }
    /// Nested message and enum types in `Dosage`.
    pub mod dosage {
        /// Dose quantity per unit of time
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RateX {
            #[prost(oneof = "rate_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<rate_x::Choice>,
        }
        /// Nested message and enum types in `RateX`.
        pub mod rate_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "2")]
                Quantity(super::super::super::SimpleQuantity),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for MedicationDispense, last updated
/// 2019-11-01T09:29:23.356+11:00. Dispensing a medication to a named patient.
/// See <http://hl7.org/fhir/StructureDefinition/MedicationDispense>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationDispense {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Event that dispense is part of
    #[prost(message, repeated, tag = "11")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<medication_dispense::StatusCode>,
    #[prost(message, optional, tag = "13")]
    pub status_reason: ::core::option::Option<medication_dispense::StatusReasonX>,
    /// Type of medication dispense
    #[prost(message, optional, tag = "14")]
    pub category: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "15")]
    pub medication: ::core::option::Option<medication_dispense::MedicationX>,
    /// Who the dispense is for
    #[prost(message, optional, tag = "16")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter / Episode associated with event
    #[prost(message, optional, tag = "17")]
    pub context: ::core::option::Option<Reference>,
    /// Information that supports the dispensing of the medication
    #[prost(message, repeated, tag = "18")]
    pub supporting_information: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "19")]
    pub performer: prost::alloc::vec::Vec<medication_dispense::Performer>,
    /// Where the dispense occurred
    #[prost(message, optional, tag = "20")]
    pub location: ::core::option::Option<Reference>,
    /// Medication order that authorizes the dispense
    #[prost(message, repeated, tag = "21")]
    pub authorizing_prescription: prost::alloc::vec::Vec<Reference>,
    /// Trial fill, partial fill, emergency fill, etc.
    #[prost(message, optional, tag = "22")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Amount dispensed
    #[prost(message, optional, tag = "23")]
    pub quantity: ::core::option::Option<SimpleQuantity>,
    /// Amount of medication expressed as a timing amount
    #[prost(message, optional, tag = "24")]
    pub days_supply: ::core::option::Option<SimpleQuantity>,
    /// When product was packaged and reviewed
    #[prost(message, optional, tag = "25")]
    pub when_prepared: ::core::option::Option<DateTime>,
    /// When product was given out
    #[prost(message, optional, tag = "26")]
    pub when_handed_over: ::core::option::Option<DateTime>,
    /// Where the medication was sent
    #[prost(message, optional, tag = "27")]
    pub destination: ::core::option::Option<Reference>,
    /// Who collected the medication
    #[prost(message, repeated, tag = "28")]
    pub receiver: prost::alloc::vec::Vec<Reference>,
    /// Information about the dispense
    #[prost(message, repeated, tag = "29")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// How the medication is to be used by the patient or administered by the
    /// caregiver
    #[prost(message, repeated, tag = "30")]
    pub dosage_instruction: prost::alloc::vec::Vec<Dosage>,
    #[prost(message, optional, tag = "31")]
    pub substitution: ::core::option::Option<medication_dispense::Substitution>,
    /// Clinical issue with action
    #[prost(message, repeated, tag = "32")]
    pub detected_issue: prost::alloc::vec::Vec<Reference>,
    /// A list of relevant lifecycle events
    #[prost(message, repeated, tag = "33")]
    pub event_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `MedicationDispense`.
pub mod medication_dispense {
    /// preparation | in-progress | cancelled | on-hold | completed |
    /// entered-in-error | stopped | declined | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::medication_dispense_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Why a dispense was not performed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusReasonX {
        #[prost(oneof = "status_reason_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<status_reason_x::Choice>,
    }
    /// Nested message and enum types in `StatusReasonX`.
    pub mod status_reason_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// What medication was supplied
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MedicationX {
        #[prost(oneof = "medication_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<medication_x::Choice>,
    }
    /// Nested message and enum types in `MedicationX`.
    pub mod medication_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Who performed event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Performer {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Who performed the dispense and what they did
        #[prost(message, optional, tag = "4")]
        pub function: ::core::option::Option<super::CodeableConcept>,
        /// Individual who was performing
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
    }
    /// Whether a substitution was performed on the dispense
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Substitution {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Whether a substitution was or was not performed on the dispense
        #[prost(message, optional, tag = "4")]
        pub was_substituted: ::core::option::Option<super::Boolean>,
        /// Code signifying whether a different drug was dispensed from what was
        /// prescribed
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Why was substitution made
        #[prost(message, repeated, tag = "6")]
        pub reason: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Who is responsible for the substitution
        #[prost(message, repeated, tag = "7")]
        pub responsible_party: prost::alloc::vec::Vec<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for MedicationKnowledge, last updated
/// 2019-11-01T09:29:23.356+11:00. Definition of Medication Knowledge. See
/// <http://hl7.org/fhir/StructureDefinition/MedicationKnowledge>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationKnowledge {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Code that identifies this medication
    #[prost(message, optional, tag = "10")]
    pub code: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<medication_knowledge::StatusCode>,
    /// Manufacturer of the item
    #[prost(message, optional, tag = "12")]
    pub manufacturer: ::core::option::Option<Reference>,
    /// powder | tablets | capsule +
    #[prost(message, optional, tag = "13")]
    pub dose_form: ::core::option::Option<CodeableConcept>,
    /// Amount of drug in package
    #[prost(message, optional, tag = "14")]
    pub amount: ::core::option::Option<SimpleQuantity>,
    /// Additional names for a medication
    #[prost(message, repeated, tag = "15")]
    pub synonym: prost::alloc::vec::Vec<String>,
    #[prost(message, repeated, tag = "16")]
    pub related_medication_knowledge:
        prost::alloc::vec::Vec<medication_knowledge::RelatedMedicationKnowledge>,
    /// A medication resource that is associated with this medication
    #[prost(message, repeated, tag = "17")]
    pub associated_medication: prost::alloc::vec::Vec<Reference>,
    /// Category of the medication or product
    #[prost(message, repeated, tag = "18")]
    pub product_type: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "19")]
    pub monograph: prost::alloc::vec::Vec<medication_knowledge::Monograph>,
    #[prost(message, repeated, tag = "20")]
    pub ingredient: prost::alloc::vec::Vec<medication_knowledge::Ingredient>,
    /// The instructions for preparing the medication
    #[prost(message, optional, tag = "21")]
    pub preparation_instruction: ::core::option::Option<Markdown>,
    /// The intended or approved route of administration
    #[prost(message, repeated, tag = "22")]
    pub intended_route: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "23")]
    pub cost: prost::alloc::vec::Vec<medication_knowledge::Cost>,
    #[prost(message, repeated, tag = "24")]
    pub monitoring_program: prost::alloc::vec::Vec<medication_knowledge::MonitoringProgram>,
    #[prost(message, repeated, tag = "25")]
    pub administration_guidelines:
        prost::alloc::vec::Vec<medication_knowledge::AdministrationGuidelines>,
    #[prost(message, repeated, tag = "26")]
    pub medicine_classification:
        prost::alloc::vec::Vec<medication_knowledge::MedicineClassification>,
    #[prost(message, optional, tag = "27")]
    pub packaging: ::core::option::Option<medication_knowledge::Packaging>,
    #[prost(message, repeated, tag = "28")]
    pub drug_characteristic: prost::alloc::vec::Vec<medication_knowledge::DrugCharacteristic>,
    /// Potential clinical issue with or between medication(s)
    #[prost(message, repeated, tag = "29")]
    pub contraindication: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "30")]
    pub regulatory: prost::alloc::vec::Vec<medication_knowledge::Regulatory>,
    #[prost(message, repeated, tag = "31")]
    pub kinetics: prost::alloc::vec::Vec<medication_knowledge::Kinetics>,
}
/// Nested message and enum types in `MedicationKnowledge`.
pub mod medication_knowledge {
    /// active | inactive | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::medication_knowledge_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Associated or related medication information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelatedMedicationKnowledge {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Category of medicationKnowledge
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Associated documentation about the associated medication knowledge
        #[prost(message, repeated, tag = "5")]
        pub reference: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Associated documentation about the medication
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Monograph {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The category of medication document
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Associated documentation about the medication
        #[prost(message, optional, tag = "5")]
        pub source: ::core::option::Option<super::Reference>,
    }
    /// Active or inactive ingredient
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Ingredient {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub item: ::core::option::Option<ingredient::ItemX>,
        /// Active ingredient indicator
        #[prost(message, optional, tag = "5")]
        pub is_active: ::core::option::Option<super::Boolean>,
        /// Quantity of ingredient present
        #[prost(message, optional, tag = "6")]
        pub strength: ::core::option::Option<super::Ratio>,
    }
    /// Nested message and enum types in `Ingredient`.
    pub mod ingredient {
        /// Medication(s) or substance(s) contained in the medication
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ItemX {
            #[prost(oneof = "item_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<item_x::Choice>,
        }
        /// Nested message and enum types in `ItemX`.
        pub mod item_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// The pricing of the medication
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Cost {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The category of the cost information
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// The source or owner for the price information
        #[prost(message, optional, tag = "5")]
        pub source: ::core::option::Option<super::String>,
        /// The price of the medication
        #[prost(message, optional, tag = "6")]
        pub cost: ::core::option::Option<super::Money>,
    }
    /// Program under which a medication is reviewed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MonitoringProgram {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of program under which the medication is monitored
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Name of the reviewing program
        #[prost(message, optional, tag = "5")]
        pub name: ::core::option::Option<super::String>,
    }
    /// Guidelines for administration of the medication
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AdministrationGuidelines {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub dosage: prost::alloc::vec::Vec<administration_guidelines::Dosage>,
        #[prost(message, optional, tag = "5")]
        pub indication: ::core::option::Option<administration_guidelines::IndicationX>,
        #[prost(message, repeated, tag = "6")]
        pub patient_characteristics:
            prost::alloc::vec::Vec<administration_guidelines::PatientCharacteristics>,
    }
    /// Nested message and enum types in `AdministrationGuidelines`.
    pub mod administration_guidelines {
        /// Dosage for the medication for the specific guidelines
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Dosage {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of dosage
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Dosage for the medication for the specific guidelines
            #[prost(message, repeated, tag = "5")]
            pub dosage: prost::alloc::vec::Vec<super::super::Dosage>,
        }
        /// Indication for use that apply to the specific administration guidelines
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct IndicationX {
            #[prost(oneof = "indication_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<indication_x::Choice>,
        }
        /// Nested message and enum types in `IndicationX`.
        pub mod indication_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
        /// Characteristics of the patient that are relevant to the administration
        /// guidelines
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PatientCharacteristics {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub characteristic: ::core::option::Option<patient_characteristics::CharacteristicX>,
            /// The specific characteristic
            #[prost(message, repeated, tag = "5")]
            pub value: prost::alloc::vec::Vec<super::super::String>,
        }
        /// Nested message and enum types in `PatientCharacteristics`.
        pub mod patient_characteristics {
            /// Specific characteristic that is relevant to the administration
            /// guideline
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct CharacteristicX {
                #[prost(oneof = "characteristic_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<characteristic_x::Choice>,
            }
            /// Nested message and enum types in `CharacteristicX`.
            pub mod characteristic_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    CodeableConcept(super::super::super::super::CodeableConcept),
                    #[prost(message, tag = "2")]
                    Quantity(super::super::super::super::SimpleQuantity),
                }
            }
        }
    }
    /// Categorization of the medication within a formulary or classification
    /// system
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MedicineClassification {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The type of category for the medication (for example, therapeutic
        /// classification, therapeutic sub-classification)
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Specific category assigned to the medication
        #[prost(message, repeated, tag = "5")]
        pub classification: prost::alloc::vec::Vec<super::CodeableConcept>,
    }
    /// Details about packaged medications
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Packaging {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// A code that defines the specific type of packaging that the medication
        /// can be found in
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// The number of product units the package would contain if fully loaded
        #[prost(message, optional, tag = "5")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
    }
    /// Specifies descriptive properties of the medicine
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DrugCharacteristic {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Code specifying the type of characteristic of medication
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<drug_characteristic::ValueX>,
    }
    /// Nested message and enum types in `DrugCharacteristic`.
    pub mod drug_characteristic {
        /// Description of the characteristic
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4")]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "3")]
                Quantity(super::super::super::SimpleQuantity),
                #[prost(message, tag = "4")]
                Base64Binary(super::super::super::Base64Binary),
            }
        }
    }
    /// Regulatory information about a medication
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Regulatory {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Specifies the authority of the regulation
        #[prost(message, optional, tag = "4")]
        pub regulatory_authority: ::core::option::Option<super::Reference>,
        #[prost(message, repeated, tag = "5")]
        pub substitution: prost::alloc::vec::Vec<regulatory::Substitution>,
        #[prost(message, repeated, tag = "6")]
        pub schedule: prost::alloc::vec::Vec<regulatory::Schedule>,
        #[prost(message, optional, tag = "7")]
        pub max_dispense: ::core::option::Option<regulatory::MaxDispense>,
    }
    /// Nested message and enum types in `Regulatory`.
    pub mod regulatory {
        /// Specifies if changes are allowed when dispensing a medication from a
        /// regulatory perspective
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Substitution {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Specifies the type of substitution allowed
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Specifies if regulation allows for changes in the medication when
            /// dispensing
            #[prost(message, optional, tag = "5")]
            pub allowed: ::core::option::Option<super::super::Boolean>,
        }
        /// Specifies the schedule of a medication in jurisdiction
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Schedule {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Specifies the specific drug schedule
            #[prost(message, optional, tag = "4")]
            pub schedule: ::core::option::Option<super::super::CodeableConcept>,
        }
        /// The maximum number of units of the medication that can be dispensed in a
        /// period
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct MaxDispense {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The maximum number of units of the medication that can be dispensed
            #[prost(message, optional, tag = "4")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// The period that applies to the maximum number of units
            #[prost(message, optional, tag = "5")]
            pub period: ::core::option::Option<super::super::Duration>,
        }
    }
    /// The time course of drug absorption, distribution, metabolism and excretion
    /// of a medication from the body
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Kinetics {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The drug concentration measured at certain discrete points in time
        #[prost(message, repeated, tag = "4")]
        pub area_under_curve: prost::alloc::vec::Vec<super::SimpleQuantity>,
        /// The median lethal dose of a drug
        #[prost(message, repeated, tag = "5")]
        pub lethal_dose50: prost::alloc::vec::Vec<super::SimpleQuantity>,
        /// Time required for concentration in the body to decrease by half
        #[prost(message, optional, tag = "6")]
        pub half_life_period: ::core::option::Option<super::Duration>,
    }
}
/// Auto-generated from StructureDefinition for MedicationRequest, last updated
/// 2019-11-01T09:29:23.356+11:00. Ordering of medication for patient or group.
/// See <http://hl7.org/fhir/StructureDefinition/MedicationRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External ids for this request
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<medication_request::StatusCode>,
    /// Reason for current status
    #[prost(message, optional, tag = "12")]
    pub status_reason: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "13")]
    pub intent: ::core::option::Option<medication_request::IntentCode>,
    /// Type of medication usage
    #[prost(message, repeated, tag = "14")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, optional, tag = "15")]
    pub priority: ::core::option::Option<medication_request::PriorityCode>,
    /// True if request is prohibiting action
    #[prost(message, optional, tag = "16")]
    pub do_not_perform: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "17")]
    pub reported: ::core::option::Option<medication_request::ReportedX>,
    #[prost(message, optional, tag = "18")]
    pub medication: ::core::option::Option<medication_request::MedicationX>,
    /// Who or group medication request is for
    #[prost(message, optional, tag = "19")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter created as part of encounter/admission/stay
    #[prost(message, optional, tag = "20")]
    pub encounter: ::core::option::Option<Reference>,
    /// Information to support ordering of the medication
    #[prost(message, repeated, tag = "21")]
    pub supporting_information: prost::alloc::vec::Vec<Reference>,
    /// When request was initially authored
    #[prost(message, optional, tag = "22")]
    pub authored_on: ::core::option::Option<DateTime>,
    /// Who/What requested the Request
    #[prost(message, optional, tag = "23")]
    pub requester: ::core::option::Option<Reference>,
    /// Intended performer of administration
    #[prost(message, optional, tag = "24")]
    pub performer: ::core::option::Option<Reference>,
    /// Desired kind of performer of the medication administration
    #[prost(message, optional, tag = "25")]
    pub performer_type: ::core::option::Option<CodeableConcept>,
    /// Person who entered the request
    #[prost(message, optional, tag = "26")]
    pub recorder: ::core::option::Option<Reference>,
    /// Reason or indication for ordering or not ordering the medication
    #[prost(message, repeated, tag = "27")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Condition or observation that supports why the prescription is being
    /// written
    #[prost(message, repeated, tag = "28")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Instantiates FHIR protocol or definition
    #[prost(message, repeated, tag = "29")]
    pub instantiates_canonical: prost::alloc::vec::Vec<Canonical>,
    /// Instantiates external protocol or definition
    #[prost(message, repeated, tag = "30")]
    pub instantiates_uri: prost::alloc::vec::Vec<Uri>,
    /// What request fulfills
    #[prost(message, repeated, tag = "31")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Composite request this is part of
    #[prost(message, optional, tag = "32")]
    pub group_identifier: ::core::option::Option<Identifier>,
    /// Overall pattern of medication administration
    #[prost(message, optional, tag = "33")]
    pub course_of_therapy_type: ::core::option::Option<CodeableConcept>,
    /// Associated insurance coverage
    #[prost(message, repeated, tag = "34")]
    pub insurance: prost::alloc::vec::Vec<Reference>,
    /// Information about the prescription
    #[prost(message, repeated, tag = "35")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// How the medication should be taken
    #[prost(message, repeated, tag = "36")]
    pub dosage_instruction: prost::alloc::vec::Vec<Dosage>,
    #[prost(message, optional, tag = "37")]
    pub dispense_request: ::core::option::Option<medication_request::DispenseRequest>,
    #[prost(message, optional, tag = "38")]
    pub substitution: ::core::option::Option<medication_request::Substitution>,
    /// An order/prescription that is being replaced
    #[prost(message, optional, tag = "39")]
    pub prior_prescription: ::core::option::Option<Reference>,
    /// Clinical Issue with action
    #[prost(message, repeated, tag = "40")]
    pub detected_issue: prost::alloc::vec::Vec<Reference>,
    /// A list of events of interest in the lifecycle
    #[prost(message, repeated, tag = "41")]
    pub event_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `MedicationRequest`.
pub mod medication_request {
    /// active | on-hold | cancelled | completed | entered-in-error | stopped |
    /// draft | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::medicationrequest_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// proposal | plan | order | original-order | reflex-order | filler-order |
    /// instance-order | option
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct IntentCode {
        #[prost(
            enumeration = "super::medication_request_intent_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// routine | urgent | asap | stat
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PriorityCode {
        #[prost(enumeration = "super::request_priority_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Reported rather than primary record
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ReportedX {
        #[prost(oneof = "reported_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<reported_x::Choice>,
    }
    /// Nested message and enum types in `ReportedX`.
    pub mod reported_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Medication to be taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MedicationX {
        #[prost(oneof = "medication_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<medication_x::Choice>,
    }
    /// Nested message and enum types in `MedicationX`.
    pub mod medication_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Medication supply authorization
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DispenseRequest {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub initial_fill: ::core::option::Option<dispense_request::InitialFill>,
        /// Minimum period of time between dispenses
        #[prost(message, optional, tag = "5")]
        pub dispense_interval: ::core::option::Option<super::Duration>,
        /// Time period supply is authorized for
        #[prost(message, optional, tag = "6")]
        pub validity_period: ::core::option::Option<super::Period>,
        /// Number of refills authorized
        #[prost(message, optional, tag = "7")]
        pub number_of_repeats_allowed: ::core::option::Option<super::UnsignedInt>,
        /// Amount of medication to supply per dispense
        #[prost(message, optional, tag = "8")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Number of days supply per dispense
        #[prost(message, optional, tag = "9")]
        pub expected_supply_duration: ::core::option::Option<super::Duration>,
        /// Intended dispenser
        #[prost(message, optional, tag = "10")]
        pub performer: ::core::option::Option<super::Reference>,
    }
    /// Nested message and enum types in `DispenseRequest`.
    pub mod dispense_request {
        /// First fill details
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct InitialFill {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// First fill quantity
            #[prost(message, optional, tag = "4")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// First fill duration
            #[prost(message, optional, tag = "5")]
            pub duration: ::core::option::Option<super::super::Duration>,
        }
    }
    /// Any restrictions on medication substitution
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Substitution {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub allowed: ::core::option::Option<substitution::AllowedX>,
        /// Why should (not) substitution be made
        #[prost(message, optional, tag = "5")]
        pub reason: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Substitution`.
    pub mod substitution {
        /// Whether substitution is allowed or not
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AllowedX {
            #[prost(oneof = "allowed_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<allowed_x::Choice>,
        }
        /// Nested message and enum types in `AllowedX`.
        pub mod allowed_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "2")]
                CodeableConcept(super::super::super::CodeableConcept),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for MedicationStatement, last updated
/// 2019-11-01T09:29:23.356+11:00. Record of medication being taken by a patient.
/// See <http://hl7.org/fhir/StructureDefinition/MedicationStatement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationStatement {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Fulfils plan, proposal or order
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced event
    #[prost(message, repeated, tag = "12")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<medication_statement::StatusCode>,
    /// Reason for current status
    #[prost(message, repeated, tag = "14")]
    pub status_reason: prost::alloc::vec::Vec<CodeableConcept>,
    /// Type of medication usage
    #[prost(message, optional, tag = "15")]
    pub category: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "16")]
    pub medication: ::core::option::Option<medication_statement::MedicationX>,
    /// Who is/was taking  the medication
    #[prost(message, optional, tag = "17")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter / Episode associated with MedicationStatement
    #[prost(message, optional, tag = "18")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "19")]
    pub effective: ::core::option::Option<medication_statement::EffectiveX>,
    /// When the statement was asserted?
    #[prost(message, optional, tag = "20")]
    pub date_asserted: ::core::option::Option<DateTime>,
    /// Person or organization that provided the information about the taking of
    /// this medication
    #[prost(message, optional, tag = "21")]
    pub information_source: ::core::option::Option<Reference>,
    /// Additional supporting information
    #[prost(message, repeated, tag = "22")]
    pub derived_from: prost::alloc::vec::Vec<Reference>,
    /// Reason for why the medication is being/was taken
    #[prost(message, repeated, tag = "23")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Condition or observation that supports why the medication is being/was
    /// taken
    #[prost(message, repeated, tag = "24")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Further information about the statement
    #[prost(message, repeated, tag = "25")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Details of how medication is/was taken or should be taken
    #[prost(message, repeated, tag = "26")]
    pub dosage: prost::alloc::vec::Vec<Dosage>,
}
/// Nested message and enum types in `MedicationStatement`.
pub mod medication_statement {
    /// active | completed | entered-in-error | intended | stopped | on-hold |
    /// unknown | not-taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::medication_statement_status_codes::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// What medication was taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MedicationX {
        #[prost(oneof = "medication_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<medication_x::Choice>,
    }
    /// Nested message and enum types in `MedicationX`.
    pub mod medication_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// The date/time or interval when the medication is/was/will be taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EffectiveX {
        #[prost(oneof = "effective_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<effective_x::Choice>,
    }
    /// Nested message and enum types in `EffectiveX`.
    pub mod effective_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
}
/// Auto-generated from StructureDefinition for MedicinalProduct, last updated
/// 2019-11-01T09:29:23.356+11:00. Detailed definition of a medicinal product,
/// typically for uses other than direct patient care (e.g. regulatory use). See
/// <http://hl7.org/fhir/StructureDefinition/MedicinalProduct>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicinalProduct {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier for this product. Could be an MPID
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Regulatory type, e.g. Investigational or Authorized
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// If this medicine applies to human or veterinary uses
    #[prost(message, optional, tag = "12")]
    pub domain: ::core::option::Option<Coding>,
    /// The dose form for a single part product, or combined form of a multiple
    /// part product
    #[prost(message, optional, tag = "13")]
    pub combined_pharmaceutical_dose_form: ::core::option::Option<CodeableConcept>,
    /// The legal status of supply of the medicinal product as classified by the
    /// regulator
    #[prost(message, optional, tag = "14")]
    pub legal_status_of_supply: ::core::option::Option<CodeableConcept>,
    /// Whether the Medicinal Product is subject to additional monitoring for
    /// regulatory reasons
    #[prost(message, optional, tag = "15")]
    pub additional_monitoring_indicator: ::core::option::Option<CodeableConcept>,
    /// Whether the Medicinal Product is subject to special measures for regulatory
    /// reasons
    #[prost(message, repeated, tag = "16")]
    pub special_measures: prost::alloc::vec::Vec<String>,
    /// If authorised for use in children
    #[prost(message, optional, tag = "17")]
    pub paediatric_use_indicator: ::core::option::Option<CodeableConcept>,
    /// Allows the product to be classified by various systems
    #[prost(message, repeated, tag = "18")]
    pub product_classification: prost::alloc::vec::Vec<CodeableConcept>,
    /// Marketing status of the medicinal product, in contrast to marketing
    /// authorizaton
    #[prost(message, repeated, tag = "19")]
    pub marketing_status: prost::alloc::vec::Vec<MarketingStatus>,
    /// Pharmaceutical aspects of product
    #[prost(message, repeated, tag = "20")]
    pub pharmaceutical_product: prost::alloc::vec::Vec<Reference>,
    /// Package representation for the product
    #[prost(message, repeated, tag = "21")]
    pub packaged_medicinal_product: prost::alloc::vec::Vec<Reference>,
    /// Supporting documentation, typically for regulatory submission
    #[prost(message, repeated, tag = "22")]
    pub attached_document: prost::alloc::vec::Vec<Reference>,
    /// A master file for to the medicinal product (e.g. Pharmacovigilance System
    /// Master File)
    #[prost(message, repeated, tag = "23")]
    pub master_file: prost::alloc::vec::Vec<Reference>,
    /// A product specific contact, person (in a role), or an organization
    #[prost(message, repeated, tag = "24")]
    pub contact: prost::alloc::vec::Vec<Reference>,
    /// Clinical trials or studies that this product is involved in
    #[prost(message, repeated, tag = "25")]
    pub clinical_trial: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "26")]
    pub name: prost::alloc::vec::Vec<medicinal_product::Name>,
    /// Reference to another product, e.g. for linking authorised to
    /// investigational product
    #[prost(message, repeated, tag = "27")]
    pub cross_reference: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, repeated, tag = "28")]
    pub manufacturing_business_operation:
        prost::alloc::vec::Vec<medicinal_product::ManufacturingBusinessOperation>,
    #[prost(message, repeated, tag = "29")]
    pub special_designation: prost::alloc::vec::Vec<medicinal_product::SpecialDesignation>,
}
/// Nested message and enum types in `MedicinalProduct`.
pub mod medicinal_product {
    /// The product's name, including full name and possibly coded parts
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Name {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The full product name
        #[prost(message, optional, tag = "4")]
        pub product_name: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "5")]
        pub name_part: prost::alloc::vec::Vec<name::NamePart>,
        #[prost(message, repeated, tag = "6")]
        pub country_language: prost::alloc::vec::Vec<name::CountryLanguage>,
    }
    /// Nested message and enum types in `Name`.
    pub mod name {
        /// Coding words or phrases of the name
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct NamePart {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// A fragment of a product name
            #[prost(message, optional, tag = "4")]
            pub part: ::core::option::Option<super::super::String>,
            /// Idenifying type for this part of the name (e.g. strength part)
            #[prost(message, optional, tag = "5")]
            pub r#type: ::core::option::Option<super::super::Coding>,
        }
        /// Country where the name applies
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CountryLanguage {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Country code for where this name applies
            #[prost(message, optional, tag = "4")]
            pub country: ::core::option::Option<super::super::CodeableConcept>,
            /// Jurisdiction code for where this name applies
            #[prost(message, optional, tag = "5")]
            pub jurisdiction: ::core::option::Option<super::super::CodeableConcept>,
            /// Language code for this name
            #[prost(message, optional, tag = "6")]
            pub language: ::core::option::Option<super::super::CodeableConcept>,
        }
    }
    /// An operation applied to the product, for manufacturing or adminsitrative
    /// purpose
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ManufacturingBusinessOperation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The type of manufacturing operation
        #[prost(message, optional, tag = "4")]
        pub operation_type: ::core::option::Option<super::CodeableConcept>,
        /// Regulatory authorization reference number
        #[prost(message, optional, tag = "5")]
        pub authorisation_reference_number: ::core::option::Option<super::Identifier>,
        /// Regulatory authorization date
        #[prost(message, optional, tag = "6")]
        pub effective_date: ::core::option::Option<super::DateTime>,
        /// To indicate if this proces is commercially confidential
        #[prost(message, optional, tag = "7")]
        pub confidentiality_indicator: ::core::option::Option<super::CodeableConcept>,
        /// The manufacturer or establishment associated with the process
        #[prost(message, repeated, tag = "8")]
        pub manufacturer: prost::alloc::vec::Vec<super::Reference>,
        /// A regulator which oversees the operation
        #[prost(message, optional, tag = "9")]
        pub regulator: ::core::option::Option<super::Reference>,
    }
    /// Indicates if the medicinal product has an orphan designation for the
    /// treatment of a rare disease
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SpecialDesignation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifier for the designation, or procedure number
        #[prost(message, repeated, tag = "4")]
        pub identifier: prost::alloc::vec::Vec<super::Identifier>,
        /// The type of special designation, e.g. orphan drug, minor use
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// The intended use of the product, e.g. prevention, treatment
        #[prost(message, optional, tag = "6")]
        pub intended_use: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "7")]
        pub indication: ::core::option::Option<special_designation::IndicationX>,
        /// For example granted, pending, expired or withdrawn
        #[prost(message, optional, tag = "8")]
        pub status: ::core::option::Option<super::CodeableConcept>,
        /// Date when the designation was granted
        #[prost(message, optional, tag = "9")]
        pub date: ::core::option::Option<super::DateTime>,
        /// Animal species for which this applies
        #[prost(message, optional, tag = "10")]
        pub species: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `SpecialDesignation`.
    pub mod special_designation {
        /// Condition for which the medicinal use applies
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct IndicationX {
            #[prost(oneof = "indication_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<indication_x::Choice>,
        }
        /// Nested message and enum types in `IndicationX`.
        pub mod indication_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for MedicinalProductAuthorization,
/// last updated 2019-11-01T09:29:23.356+11:00. The regulatory authorization of a
/// medicinal product. See
/// <http://hl7.org/fhir/StructureDefinition/MedicinalProductAuthorization>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicinalProductAuthorization {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier for the marketing authorization, as assigned by a
    /// regulator
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// The medicinal product that is being authorized
    #[prost(message, optional, tag = "11")]
    pub subject: ::core::option::Option<Reference>,
    /// The country in which the marketing authorization has been granted
    #[prost(message, repeated, tag = "12")]
    pub country: prost::alloc::vec::Vec<CodeableConcept>,
    /// Jurisdiction within a country
    #[prost(message, repeated, tag = "13")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// The status of the marketing authorization
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<CodeableConcept>,
    /// The date at which the given status has become applicable
    #[prost(message, optional, tag = "15")]
    pub status_date: ::core::option::Option<DateTime>,
    /// The date when a suspended the marketing or the marketing authorization of
    /// the product is anticipated to be restored
    #[prost(message, optional, tag = "16")]
    pub restore_date: ::core::option::Option<DateTime>,
    /// The beginning of the time period in which the marketing authorization is in
    /// the specific status shall be specified A complete date consisting of day,
    /// month and year shall be specified using the ISO 8601 date format
    #[prost(message, optional, tag = "17")]
    pub validity_period: ::core::option::Option<Period>,
    /// A period of time after authorization before generic product applicatiosn
    /// can be submitted
    #[prost(message, optional, tag = "18")]
    pub data_exclusivity_period: ::core::option::Option<Period>,
    /// The date when the first authorization was granted by a Medicines Regulatory
    /// Agency
    #[prost(message, optional, tag = "19")]
    pub date_of_first_authorization: ::core::option::Option<DateTime>,
    /// Date of first marketing authorization for a company's new medicinal product
    /// in any country in the World
    #[prost(message, optional, tag = "20")]
    pub international_birth_date: ::core::option::Option<DateTime>,
    /// The legal framework against which this authorization is granted
    #[prost(message, optional, tag = "21")]
    pub legal_basis: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "22")]
    pub jurisdictional_authorization:
        prost::alloc::vec::Vec<medicinal_product_authorization::JurisdictionalAuthorization>,
    /// Marketing Authorization Holder
    #[prost(message, optional, tag = "23")]
    pub holder: ::core::option::Option<Reference>,
    /// Medicines Regulatory Agency
    #[prost(message, optional, tag = "24")]
    pub regulator: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "25")]
    pub procedure: ::core::option::Option<medicinal_product_authorization::Procedure>,
}
/// Nested message and enum types in `MedicinalProductAuthorization`.
pub mod medicinal_product_authorization {
    /// Authorization in areas within a country
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct JurisdictionalAuthorization {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The assigned number for the marketing authorization
        #[prost(message, repeated, tag = "4")]
        pub identifier: prost::alloc::vec::Vec<super::Identifier>,
        /// Country of authorization
        #[prost(message, optional, tag = "5")]
        pub country: ::core::option::Option<super::CodeableConcept>,
        /// Jurisdiction within a country
        #[prost(message, repeated, tag = "6")]
        pub jurisdiction: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// The legal status of supply in a jurisdiction or region
        #[prost(message, optional, tag = "7")]
        pub legal_status_of_supply: ::core::option::Option<super::CodeableConcept>,
        /// The start and expected end date of the authorization
        #[prost(message, optional, tag = "8")]
        pub validity_period: ::core::option::Option<super::Period>,
    }
    /// The regulatory procedure for granting or amending a marketing authorization
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Procedure {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifier for this procedure
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Type of procedure
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "6")]
        pub date: ::core::option::Option<procedure::DateX>,
        /// Applcations submitted to obtain a marketing authorization
        #[prost(message, repeated, tag = "7")]
        pub application: prost::alloc::vec::Vec<Procedure>,
    }
    /// Nested message and enum types in `Procedure`.
    pub mod procedure {
        /// Date of procedure
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DateX {
            #[prost(oneof = "date_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<date_x::Choice>,
        }
        /// Nested message and enum types in `DateX`.
        pub mod date_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Period(super::super::super::Period),
                #[prost(message, tag = "2")]
                DateTime(super::super::super::DateTime),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for MedicinalProductContraindication,
/// last updated 2019-11-01T09:29:23.356+11:00. MedicinalProductContraindication.
/// See <http://hl7.org/fhir/StructureDefinition/MedicinalProductContraindication>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicinalProductContraindication {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The medication for which this is an indication
    #[prost(message, repeated, tag = "10")]
    pub subject: prost::alloc::vec::Vec<Reference>,
    /// The disease, symptom or procedure for the contraindication
    #[prost(message, optional, tag = "11")]
    pub disease: ::core::option::Option<CodeableConcept>,
    /// The status of the disease or symptom for the contraindication
    #[prost(message, optional, tag = "12")]
    pub disease_status: ::core::option::Option<CodeableConcept>,
    /// A comorbidity (concurrent condition) or coinfection
    #[prost(message, repeated, tag = "13")]
    pub comorbidity: prost::alloc::vec::Vec<CodeableConcept>,
    /// Information about the use of the medicinal product in relation to other
    /// therapies as part of the indication
    #[prost(message, repeated, tag = "14")]
    pub therapeutic_indication: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "15")]
    pub other_therapy: prost::alloc::vec::Vec<medicinal_product_contraindication::OtherTherapy>,
    /// The population group to which this applies
    #[prost(message, repeated, tag = "16")]
    pub population: prost::alloc::vec::Vec<Population>,
}
/// Nested message and enum types in `MedicinalProductContraindication`.
pub mod medicinal_product_contraindication {
    /// Information about the use of the medicinal product in relation to other
    /// therapies described as part of the indication
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OtherTherapy {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The type of relationship between the medicinal product indication or
        /// contraindication and another therapy
        #[prost(message, optional, tag = "4")]
        pub therapy_relationship_type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub medication: ::core::option::Option<other_therapy::MedicationX>,
    }
    /// Nested message and enum types in `OtherTherapy`.
    pub mod other_therapy {
        /// Reference to a specific medication (active substance, medicinal product
        /// or class of products) as part of an indication or contraindication
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct MedicationX {
            #[prost(oneof = "medication_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<medication_x::Choice>,
        }
        /// Nested message and enum types in `MedicationX`.
        pub mod medication_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for MedicinalProductIndication, last
/// updated 2019-11-01T09:29:23.356+11:00. MedicinalProductIndication. See
/// <http://hl7.org/fhir/StructureDefinition/MedicinalProductIndication>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicinalProductIndication {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The medication for which this is an indication
    #[prost(message, repeated, tag = "10")]
    pub subject: prost::alloc::vec::Vec<Reference>,
    /// The disease, symptom or procedure that is the indication for treatment
    #[prost(message, optional, tag = "11")]
    pub disease_symptom_procedure: ::core::option::Option<CodeableConcept>,
    /// The status of the disease or symptom for which the indication applies
    #[prost(message, optional, tag = "12")]
    pub disease_status: ::core::option::Option<CodeableConcept>,
    /// Comorbidity (concurrent condition) or co-infection as part of the
    /// indication
    #[prost(message, repeated, tag = "13")]
    pub comorbidity: prost::alloc::vec::Vec<CodeableConcept>,
    /// The intended effect, aim or strategy to be achieved by the indication
    #[prost(message, optional, tag = "14")]
    pub intended_effect: ::core::option::Option<CodeableConcept>,
    /// Timing or duration information as part of the indication
    #[prost(message, optional, tag = "15")]
    pub duration: ::core::option::Option<Quantity>,
    #[prost(message, repeated, tag = "16")]
    pub other_therapy: prost::alloc::vec::Vec<medicinal_product_indication::OtherTherapy>,
    /// Describe the undesirable effects of the medicinal product
    #[prost(message, repeated, tag = "17")]
    pub undesirable_effect: prost::alloc::vec::Vec<Reference>,
    /// The population group to which this applies
    #[prost(message, repeated, tag = "18")]
    pub population: prost::alloc::vec::Vec<Population>,
}
/// Nested message and enum types in `MedicinalProductIndication`.
pub mod medicinal_product_indication {
    /// Information about the use of the medicinal product in relation to other
    /// therapies described as part of the indication
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OtherTherapy {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The type of relationship between the medicinal product indication or
        /// contraindication and another therapy
        #[prost(message, optional, tag = "4")]
        pub therapy_relationship_type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub medication: ::core::option::Option<other_therapy::MedicationX>,
    }
    /// Nested message and enum types in `OtherTherapy`.
    pub mod other_therapy {
        /// Reference to a specific medication (active substance, medicinal product
        /// or class of products) as part of an indication or contraindication
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct MedicationX {
            #[prost(oneof = "medication_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<medication_x::Choice>,
        }
        /// Nested message and enum types in `MedicationX`.
        pub mod medication_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for MedicinalProductIngredient, last
/// updated 2019-11-01T09:29:23.356+11:00. An ingredient of a manufactured item
/// or pharmaceutical product. See
/// <http://hl7.org/fhir/StructureDefinition/MedicinalProductIngredient>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicinalProductIngredient {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifier for the ingredient
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Ingredient role e.g. Active ingredient, excipient
    #[prost(message, optional, tag = "11")]
    pub role: ::core::option::Option<CodeableConcept>,
    /// If the ingredient is a known or suspected allergen
    #[prost(message, optional, tag = "12")]
    pub allergenic_indicator: ::core::option::Option<Boolean>,
    /// Manufacturer of this Ingredient
    #[prost(message, repeated, tag = "13")]
    pub manufacturer: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "14")]
    pub specified_substance:
        prost::alloc::vec::Vec<medicinal_product_ingredient::SpecifiedSubstance>,
    #[prost(message, optional, tag = "15")]
    pub substance: ::core::option::Option<medicinal_product_ingredient::Substance>,
}
/// Nested message and enum types in `MedicinalProductIngredient`.
pub mod medicinal_product_ingredient {
    /// A specified substance that comprises this ingredient
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SpecifiedSubstance {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The specified substance
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// The group of specified substance, e.g. group 1 to 4
        #[prost(message, optional, tag = "5")]
        pub group: ::core::option::Option<super::CodeableConcept>,
        /// Confidentiality level of the specified substance as the ingredient
        #[prost(message, optional, tag = "6")]
        pub confidentiality: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "7")]
        pub strength: prost::alloc::vec::Vec<specified_substance::Strength>,
    }
    /// Nested message and enum types in `SpecifiedSubstance`.
    pub mod specified_substance {
        /// Quantity of the substance or specified substance present in the
        /// manufactured item or pharmaceutical product
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Strength {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The quantity of substance in the unit of presentation, or in the volume
            /// (or mass) of the single pharmaceutical product or manufactured item
            #[prost(message, optional, tag = "4")]
            pub presentation: ::core::option::Option<super::super::Ratio>,
            /// A lower limit for the quantity of substance in the unit of
            /// presentation. For use when there is a range of strengths, this is the
            /// lower limit, with the presentation attribute becoming the upper limit
            #[prost(message, optional, tag = "5")]
            pub presentation_low_limit: ::core::option::Option<super::super::Ratio>,
            /// The strength per unitary volume (or mass)
            #[prost(message, optional, tag = "6")]
            pub concentration: ::core::option::Option<super::super::Ratio>,
            /// A lower limit for the strength per unitary volume (or mass), for when
            /// there is a range. The concentration attribute then becomes the upper
            /// limit
            #[prost(message, optional, tag = "7")]
            pub concentration_low_limit: ::core::option::Option<super::super::Ratio>,
            /// For when strength is measured at a particular point or distance
            #[prost(message, optional, tag = "8")]
            pub measurement_point: ::core::option::Option<super::super::String>,
            /// The country or countries for which the strength range applies
            #[prost(message, repeated, tag = "9")]
            pub country: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            #[prost(message, repeated, tag = "10")]
            pub reference_strength: prost::alloc::vec::Vec<strength::ReferenceStrength>,
        }
        /// Nested message and enum types in `Strength`.
        pub mod strength {
            /// Strength expressed in terms of a reference substance
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ReferenceStrength {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Relevant reference substance
                #[prost(message, optional, tag = "4")]
                pub substance: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Strength expressed in terms of a reference substance
                #[prost(message, optional, tag = "5")]
                pub strength: ::core::option::Option<super::super::super::Ratio>,
                /// Strength expressed in terms of a reference substance
                #[prost(message, optional, tag = "6")]
                pub strength_low_limit: ::core::option::Option<super::super::super::Ratio>,
                /// For when strength is measured at a particular point or distance
                #[prost(message, optional, tag = "7")]
                pub measurement_point: ::core::option::Option<super::super::super::String>,
                /// The country or countries for which the strength range applies
                #[prost(message, repeated, tag = "8")]
                pub country: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
            }
        }
    }
    /// The ingredient substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Substance {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The ingredient substance
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Quantity of the substance or specified substance present in the
        /// manufactured item or pharmaceutical product
        #[prost(message, repeated, tag = "5")]
        pub strength: prost::alloc::vec::Vec<specified_substance::Strength>,
    }
}
/// Auto-generated from StructureDefinition for MedicinalProductInteraction, last
/// updated 2019-11-01T09:29:23.356+11:00. MedicinalProductInteraction. See
/// <http://hl7.org/fhir/StructureDefinition/MedicinalProductInteraction>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicinalProductInteraction {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The medication for which this is a described interaction
    #[prost(message, repeated, tag = "10")]
    pub subject: prost::alloc::vec::Vec<Reference>,
    /// The interaction described
    #[prost(message, optional, tag = "11")]
    pub description: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "12")]
    pub interactant: prost::alloc::vec::Vec<medicinal_product_interaction::Interactant>,
    /// The type of the interaction e.g. drug-drug interaction, drug-food
    /// interaction, drug-lab test interaction
    #[prost(message, optional, tag = "13")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// The effect of the interaction, for example "reduced gastric absorption of
    /// primary medication"
    #[prost(message, optional, tag = "14")]
    pub effect: ::core::option::Option<CodeableConcept>,
    /// The incidence of the interaction, e.g. theoretical, observed
    #[prost(message, optional, tag = "15")]
    pub incidence: ::core::option::Option<CodeableConcept>,
    /// Actions for managing the interaction
    #[prost(message, optional, tag = "16")]
    pub management: ::core::option::Option<CodeableConcept>,
}
/// Nested message and enum types in `MedicinalProductInteraction`.
pub mod medicinal_product_interaction {
    /// The specific medication, food or laboratory test that interacts
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Interactant {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub item: ::core::option::Option<interactant::ItemX>,
    }
    /// Nested message and enum types in `Interactant`.
    pub mod interactant {
        /// The specific medication, food or laboratory test that interacts
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ItemX {
            #[prost(oneof = "item_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<item_x::Choice>,
        }
        /// Nested message and enum types in `ItemX`.
        pub mod item_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "2")]
                CodeableConcept(super::super::super::CodeableConcept),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for MedicinalProductManufactured,
/// last updated 2019-11-01T09:29:23.356+11:00. The manufactured item as
/// contained in the packaged medicinal product. See
/// <http://hl7.org/fhir/StructureDefinition/MedicinalProductManufactured>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicinalProductManufactured {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Dose form as manufactured and before any transformation into the
    /// pharmaceutical product
    #[prost(message, optional, tag = "10")]
    pub manufactured_dose_form: ::core::option::Option<CodeableConcept>,
    /// The “real world” units in which the quantity of the manufactured item is
    /// described
    #[prost(message, optional, tag = "11")]
    pub unit_of_presentation: ::core::option::Option<CodeableConcept>,
    /// The quantity or "count number" of the manufactured item
    #[prost(message, optional, tag = "12")]
    pub quantity: ::core::option::Option<Quantity>,
    /// Manufacturer of the item (Note that this should be named "manufacturer" but
    /// it currently causes technical issues)
    #[prost(message, repeated, tag = "13")]
    pub manufacturer: prost::alloc::vec::Vec<Reference>,
    /// Ingredient
    #[prost(message, repeated, tag = "14")]
    pub ingredient: prost::alloc::vec::Vec<Reference>,
    /// Dimensions, color etc.
    #[prost(message, optional, tag = "15")]
    pub physical_characteristics: ::core::option::Option<ProdCharacteristic>,
    /// Other codeable characteristics
    #[prost(message, repeated, tag = "16")]
    pub other_characteristics: prost::alloc::vec::Vec<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for MedicinalProductPackaged, last
/// updated 2019-11-01T09:29:23.356+11:00. A medicinal product in a container or
/// package. See <http://hl7.org/fhir/StructureDefinition/MedicinalProductPackaged>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicinalProductPackaged {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// The product with this is a pack for
    #[prost(message, repeated, tag = "11")]
    pub subject: prost::alloc::vec::Vec<Reference>,
    /// Textual description
    #[prost(message, optional, tag = "12")]
    pub description: ::core::option::Option<String>,
    /// The legal status of supply of the medicinal product as classified by the
    /// regulator
    #[prost(message, optional, tag = "13")]
    pub legal_status_of_supply: ::core::option::Option<CodeableConcept>,
    /// Marketing information
    #[prost(message, repeated, tag = "14")]
    pub marketing_status: prost::alloc::vec::Vec<MarketingStatus>,
    /// Manufacturer of this Package Item
    #[prost(message, optional, tag = "15")]
    pub marketing_authorization: ::core::option::Option<Reference>,
    /// Manufacturer of this Package Item
    #[prost(message, repeated, tag = "16")]
    pub manufacturer: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "17")]
    pub batch_identifier: prost::alloc::vec::Vec<medicinal_product_packaged::BatchIdentifier>,
    #[prost(message, repeated, tag = "18")]
    pub package_item: prost::alloc::vec::Vec<medicinal_product_packaged::PackageItem>,
}
/// Nested message and enum types in `MedicinalProductPackaged`.
pub mod medicinal_product_packaged {
    /// Batch numbering
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct BatchIdentifier {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// A number appearing on the outer packaging of a specific batch
        #[prost(message, optional, tag = "4")]
        pub outer_packaging: ::core::option::Option<super::Identifier>,
        /// A number appearing on the immediate packaging (and not the outer
        /// packaging)
        #[prost(message, optional, tag = "5")]
        pub immediate_packaging: ::core::option::Option<super::Identifier>,
    }
    /// A packaging item, as a contained for medicine, possibly with other
    /// packaging items within
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PackageItem {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Including possibly Data Carrier Identifier
        #[prost(message, repeated, tag = "4")]
        pub identifier: prost::alloc::vec::Vec<super::Identifier>,
        /// The physical type of the container of the medicine
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// The quantity of this package in the medicinal product, at the current
        /// level of packaging. The outermost is always 1
        #[prost(message, optional, tag = "6")]
        pub quantity: ::core::option::Option<super::Quantity>,
        /// Material type of the package item
        #[prost(message, repeated, tag = "7")]
        pub material: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// A possible alternate material for the packaging
        #[prost(message, repeated, tag = "8")]
        pub alternate_material: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// A device accompanying a medicinal product
        #[prost(message, repeated, tag = "9")]
        pub device: prost::alloc::vec::Vec<super::Reference>,
        /// The manufactured item as contained in the packaged medicinal product
        #[prost(message, repeated, tag = "10")]
        pub manufactured_item: prost::alloc::vec::Vec<super::Reference>,
        /// Allows containers within containers
        #[prost(message, repeated, tag = "11")]
        pub package_item: prost::alloc::vec::Vec<PackageItem>,
        /// Dimensions, color etc.
        #[prost(message, optional, tag = "12")]
        pub physical_characteristics: ::core::option::Option<super::ProdCharacteristic>,
        /// Other codeable characteristics
        #[prost(message, repeated, tag = "13")]
        pub other_characteristics: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Shelf Life and storage information
        #[prost(message, repeated, tag = "14")]
        pub shelf_life_storage: prost::alloc::vec::Vec<super::ProductShelfLife>,
        /// Manufacturer of this Package Item
        #[prost(message, repeated, tag = "15")]
        pub manufacturer: prost::alloc::vec::Vec<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for MedicinalProductPharmaceutical,
/// last updated 2019-11-01T09:29:23.356+11:00. A pharmaceutical product
/// described in terms of its composition and dose form. See
/// <http://hl7.org/fhir/StructureDefinition/MedicinalProductPharmaceutical>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicinalProductPharmaceutical {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// An identifier for the pharmaceutical medicinal product
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// The administrable dose form, after necessary reconstitution
    #[prost(message, optional, tag = "11")]
    pub administrable_dose_form: ::core::option::Option<CodeableConcept>,
    /// Todo
    #[prost(message, optional, tag = "12")]
    pub unit_of_presentation: ::core::option::Option<CodeableConcept>,
    /// Ingredient
    #[prost(message, repeated, tag = "13")]
    pub ingredient: prost::alloc::vec::Vec<Reference>,
    /// Accompanying device
    #[prost(message, repeated, tag = "14")]
    pub device: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "15")]
    pub characteristics: prost::alloc::vec::Vec<medicinal_product_pharmaceutical::Characteristics>,
    #[prost(message, repeated, tag = "16")]
    pub route_of_administration:
        prost::alloc::vec::Vec<medicinal_product_pharmaceutical::RouteOfAdministration>,
}
/// Nested message and enum types in `MedicinalProductPharmaceutical`.
pub mod medicinal_product_pharmaceutical {
    /// Characteristics e.g. a products onset of action
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Characteristics {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// A coded characteristic
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// The status of characteristic e.g. assigned or pending
        #[prost(message, optional, tag = "5")]
        pub status: ::core::option::Option<super::CodeableConcept>,
    }
    /// The path by which the pharmaceutical product is taken into or makes contact
    /// with the body
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RouteOfAdministration {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Coded expression for the route
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// The first dose (dose quantity) administered in humans can be specified,
        /// for a product under investigation, using a numerical value and its unit
        /// of measurement
        #[prost(message, optional, tag = "5")]
        pub first_dose: ::core::option::Option<super::Quantity>,
        /// The maximum single dose that can be administered as per the protocol of a
        /// clinical trial can be specified using a numerical value and its unit of
        /// measurement
        #[prost(message, optional, tag = "6")]
        pub max_single_dose: ::core::option::Option<super::Quantity>,
        /// The maximum dose per day (maximum dose quantity to be administered in any
        /// one 24-h period) that can be administered as per the protocol referenced
        /// in the clinical trial authorisation
        #[prost(message, optional, tag = "7")]
        pub max_dose_per_day: ::core::option::Option<super::Quantity>,
        /// The maximum dose per treatment period that can be administered as per the
        /// protocol referenced in the clinical trial authorisation
        #[prost(message, optional, tag = "8")]
        pub max_dose_per_treatment_period: ::core::option::Option<super::Ratio>,
        /// The maximum treatment period during which an Investigational Medicinal
        /// Product can be administered as per the protocol referenced in the
        /// clinical trial authorisation
        #[prost(message, optional, tag = "9")]
        pub max_treatment_period: ::core::option::Option<super::Duration>,
        #[prost(message, repeated, tag = "10")]
        pub target_species: prost::alloc::vec::Vec<route_of_administration::TargetSpecies>,
    }
    /// Nested message and enum types in `RouteOfAdministration`.
    pub mod route_of_administration {
        /// A species for which this route applies
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TargetSpecies {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Coded expression for the species
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            #[prost(message, repeated, tag = "5")]
            pub withdrawal_period: prost::alloc::vec::Vec<target_species::WithdrawalPeriod>,
        }
        /// Nested message and enum types in `TargetSpecies`.
        pub mod target_species {
            /// A species specific time during which consumption of animal product is
            /// not appropriate
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct WithdrawalPeriod {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Coded expression for the type of tissue for which the withdrawal
                /// period applues, e.g. meat, milk
                #[prost(message, optional, tag = "4")]
                pub tissue: ::core::option::Option<super::super::super::CodeableConcept>,
                /// A value for the time
                #[prost(message, optional, tag = "5")]
                pub value: ::core::option::Option<super::super::super::Quantity>,
                /// Extra information about the withdrawal period
                #[prost(message, optional, tag = "6")]
                pub supporting_information: ::core::option::Option<super::super::super::String>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for
/// MedicinalProductUndesirableEffect, last updated
/// 2019-11-01T09:29:23.356+11:00. MedicinalProductUndesirableEffect. See
/// <http://hl7.org/fhir/StructureDefinition/MedicinalProductUndesirableEffect>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicinalProductUndesirableEffect {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The medication for which this is an indication
    #[prost(message, repeated, tag = "10")]
    pub subject: prost::alloc::vec::Vec<Reference>,
    /// The symptom, condition or undesirable effect
    #[prost(message, optional, tag = "11")]
    pub symptom_condition_effect: ::core::option::Option<CodeableConcept>,
    /// Classification of the effect
    #[prost(message, optional, tag = "12")]
    pub classification: ::core::option::Option<CodeableConcept>,
    /// The frequency of occurrence of the effect
    #[prost(message, optional, tag = "13")]
    pub frequency_of_occurrence: ::core::option::Option<CodeableConcept>,
    /// The population group to which this applies
    #[prost(message, repeated, tag = "14")]
    pub population: prost::alloc::vec::Vec<Population>,
}
/// Auto-generated from StructureDefinition for MessageDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. A resource that defines a type of message that
/// can be exchanged between systems. See
/// <http://hl7.org/fhir/StructureDefinition/MessageDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for a given MessageDefinition
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Primary key for the message definition on a given server
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the message definition
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this message definition (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this message definition (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Takes the place of
    #[prost(message, repeated, tag = "15")]
    pub replaces: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<message_definition::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "17")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "18")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "19")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "20")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the message definition
    #[prost(message, optional, tag = "21")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "22")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for message definition (if applicable)
    #[prost(message, repeated, tag = "23")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this message definition is defined
    #[prost(message, optional, tag = "24")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "25")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Definition this one is based on
    #[prost(message, optional, tag = "26")]
    pub base: ::core::option::Option<Canonical>,
    /// Protocol/workflow this is part of
    #[prost(message, repeated, tag = "27")]
    pub parent: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, optional, tag = "28")]
    pub event: ::core::option::Option<message_definition::EventX>,
    #[prost(message, optional, tag = "29")]
    pub category: ::core::option::Option<message_definition::CategoryCode>,
    #[prost(message, repeated, tag = "30")]
    pub focus: prost::alloc::vec::Vec<message_definition::Focus>,
    #[prost(message, optional, tag = "31")]
    pub response_required: ::core::option::Option<message_definition::ResponseRequiredCode>,
    #[prost(message, repeated, tag = "32")]
    pub allowed_response: prost::alloc::vec::Vec<message_definition::AllowedResponse>,
    /// Canonical reference to a GraphDefinition
    #[prost(message, repeated, tag = "33")]
    pub graph: prost::alloc::vec::Vec<Canonical>,
}
/// Nested message and enum types in `MessageDefinition`.
pub mod message_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Event code  or link to the EventDefinition
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EventX {
        #[prost(oneof = "event_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<event_x::Choice>,
    }
    /// Nested message and enum types in `EventX`.
    pub mod event_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Coding(super::super::Coding),
            #[prost(message, tag = "2")]
            Uri(super::super::Uri),
        }
    }
    /// consequence | currency | notification
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CategoryCode {
        #[prost(
            enumeration = "super::message_significance_category_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Resource(s) that are the subject of the event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Focus {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<focus::CodeType>,
        /// Profile that must be adhered to by focus
        #[prost(message, optional, tag = "5")]
        pub profile: ::core::option::Option<super::Canonical>,
        /// Minimum number of focuses of this type
        #[prost(message, optional, tag = "6")]
        pub min: ::core::option::Option<super::UnsignedInt>,
        /// Maximum number of focuses of this type
        #[prost(message, optional, tag = "7")]
        pub max: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Focus`.
    pub mod focus {
        /// Type of resource
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CodeType {
            #[prost(enumeration = "super::super::resource_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// always | on-error | never | on-success
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ResponseRequiredCode {
        #[prost(
            enumeration = "super::messageheader_response_request_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Responses to this message
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AllowedResponse {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to allowed message definition response
        #[prost(message, optional, tag = "4")]
        pub message: ::core::option::Option<super::Canonical>,
        /// When should this response be used
        #[prost(message, optional, tag = "5")]
        pub situation: ::core::option::Option<super::Markdown>,
    }
}
/// Auto-generated from StructureDefinition for MessageHeader, last updated
/// 2019-11-01T09:29:23.356+11:00. A resource that describes a message that is
/// exchanged between systems. See
/// <http://hl7.org/fhir/StructureDefinition/MessageHeader>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageHeader {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "10")]
    pub event: ::core::option::Option<message_header::EventX>,
    #[prost(message, repeated, tag = "11")]
    pub destination: prost::alloc::vec::Vec<message_header::MessageDestination>,
    /// Real world sender of the message
    #[prost(message, optional, tag = "12")]
    pub sender: ::core::option::Option<Reference>,
    /// The source of the data entry
    #[prost(message, optional, tag = "13")]
    pub enterer: ::core::option::Option<Reference>,
    /// The source of the decision
    #[prost(message, optional, tag = "14")]
    pub author: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "15")]
    pub source: ::core::option::Option<message_header::MessageSource>,
    /// Final responsibility for event
    #[prost(message, optional, tag = "16")]
    pub responsible: ::core::option::Option<Reference>,
    /// Cause of event
    #[prost(message, optional, tag = "17")]
    pub reason: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "18")]
    pub response: ::core::option::Option<message_header::Response>,
    /// The actual content of the message
    #[prost(message, repeated, tag = "19")]
    pub focus: prost::alloc::vec::Vec<Reference>,
    /// Link to the definition for this message
    #[prost(message, optional, tag = "20")]
    pub definition: ::core::option::Option<Canonical>,
}
/// Nested message and enum types in `MessageHeader`.
pub mod message_header {
    /// Code for the event this message represents or link to event definition
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EventX {
        #[prost(oneof = "event_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<event_x::Choice>,
    }
    /// Nested message and enum types in `EventX`.
    pub mod event_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Coding(super::super::Coding),
            #[prost(message, tag = "2")]
            Uri(super::super::Uri),
        }
    }
    /// Message destination application(s)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MessageDestination {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name of system
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Particular delivery destination within the destination
        #[prost(message, optional, tag = "5")]
        pub target: ::core::option::Option<super::Reference>,
        /// Actual destination address or id
        #[prost(message, optional, tag = "6")]
        pub endpoint: ::core::option::Option<super::Url>,
        /// Intended "real-world" recipient for the data
        #[prost(message, optional, tag = "7")]
        pub receiver: ::core::option::Option<super::Reference>,
    }
    /// Message source application
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MessageSource {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name of system
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Name of software running the system
        #[prost(message, optional, tag = "5")]
        pub software: ::core::option::Option<super::String>,
        /// Version of software running
        #[prost(message, optional, tag = "6")]
        pub version: ::core::option::Option<super::String>,
        /// Human contact for problems
        #[prost(message, optional, tag = "7")]
        pub contact: ::core::option::Option<super::ContactPoint>,
        /// Actual message source address or id
        #[prost(message, optional, tag = "8")]
        pub endpoint: ::core::option::Option<super::Url>,
    }
    /// If this is a reply to prior message
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Response {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Id of original message
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Id>,
        #[prost(message, optional, tag = "5")]
        pub code: ::core::option::Option<response::CodeType>,
        /// Specific list of hints/warnings/errors
        #[prost(message, optional, tag = "6")]
        pub details: ::core::option::Option<super::Reference>,
    }
    /// Nested message and enum types in `Response`.
    pub mod response {
        /// ok | transient-error | fatal-error
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CodeType {
            #[prost(enumeration = "super::super::response_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for MetadataResource, last updated
/// 2019-11-01T09:29:23.356+11:00. Common Ancestor declaration for definitional
/// resources. See <http://hl7.org/fhir/StructureDefinition/MetadataResource>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MetadataResource {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this metadata resource, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the metadata resource
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this metadata resource (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this metadata resource (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<metadata_resource::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the metadata resource
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for metadata resource (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
}
/// Nested message and enum types in `MetadataResource`.
pub mod metadata_resource {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for MolecularSequence, last updated
/// 2019-11-01T09:29:23.356+11:00. Information about a biological sequence. See
/// <http://hl7.org/fhir/StructureDefinition/MolecularSequence>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MolecularSequence {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique ID for this particular sequence. This is a FHIR-defined id
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<molecular_sequence::TypeCode>,
    /// Base number of coordinate system (0 for 0-based numbering or coordinates,
    /// inclusive start, exclusive end, 1 for 1-based numbering, inclusive start,
    /// inclusive end)
    #[prost(message, optional, tag = "12")]
    pub coordinate_system: ::core::option::Option<Integer>,
    /// Who and/or what this is about
    #[prost(message, optional, tag = "13")]
    pub patient: ::core::option::Option<Reference>,
    /// Specimen used for sequencing
    #[prost(message, optional, tag = "14")]
    pub specimen: ::core::option::Option<Reference>,
    /// The method for sequencing
    #[prost(message, optional, tag = "15")]
    pub device: ::core::option::Option<Reference>,
    /// Who should be responsible for test result
    #[prost(message, optional, tag = "16")]
    pub performer: ::core::option::Option<Reference>,
    /// The number of copies of the sequence of interest.  (RNASeq)
    #[prost(message, optional, tag = "17")]
    pub quantity: ::core::option::Option<Quantity>,
    #[prost(message, optional, tag = "18")]
    pub reference_seq: ::core::option::Option<molecular_sequence::ReferenceSeq>,
    #[prost(message, repeated, tag = "19")]
    pub variant: prost::alloc::vec::Vec<molecular_sequence::Variant>,
    /// Sequence that was observed
    #[prost(message, optional, tag = "20")]
    pub observed_seq: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "21")]
    pub quality: prost::alloc::vec::Vec<molecular_sequence::Quality>,
    /// Average number of reads representing a given nucleotide in the
    /// reconstructed sequence
    #[prost(message, optional, tag = "22")]
    pub read_coverage: ::core::option::Option<Integer>,
    #[prost(message, repeated, tag = "23")]
    pub repository: prost::alloc::vec::Vec<molecular_sequence::Repository>,
    /// Pointer to next atomic sequence
    #[prost(message, repeated, tag = "24")]
    pub pointer: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "25")]
    pub structure_variant: prost::alloc::vec::Vec<molecular_sequence::StructureVariant>,
}
/// Nested message and enum types in `MolecularSequence`.
pub mod molecular_sequence {
    /// aa | dna | rna
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::sequence_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// A sequence used as reference
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ReferenceSeq {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Chromosome containing genetic finding
        #[prost(message, optional, tag = "4")]
        pub chromosome: ::core::option::Option<super::CodeableConcept>,
        /// The Genome Build used for reference, following GRCh build versions e.g.
        /// 'GRCh 37'
        #[prost(message, optional, tag = "5")]
        pub genome_build: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "6")]
        pub orientation: ::core::option::Option<reference_seq::OrientationCode>,
        /// Reference identifier
        #[prost(message, optional, tag = "7")]
        pub reference_seq_id: ::core::option::Option<super::CodeableConcept>,
        /// A pointer to another MolecularSequence entity as reference sequence
        #[prost(message, optional, tag = "8")]
        pub reference_seq_pointer: ::core::option::Option<super::Reference>,
        /// A string to represent reference sequence
        #[prost(message, optional, tag = "9")]
        pub reference_seq_string: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "10")]
        pub strand: ::core::option::Option<reference_seq::StrandCode>,
        /// Start position of the window on the  reference sequence
        #[prost(message, optional, tag = "11")]
        pub window_start: ::core::option::Option<super::Integer>,
        /// End position of the window on the reference sequence
        #[prost(message, optional, tag = "12")]
        pub window_end: ::core::option::Option<super::Integer>,
    }
    /// Nested message and enum types in `ReferenceSeq`.
    pub mod reference_seq {
        /// sense | antisense
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct OrientationCode {
            #[prost(enumeration = "super::super::orientation_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// watson | crick
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct StrandCode {
            #[prost(enumeration = "super::super::strand_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Variant in sequence
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Variant {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Start position of the variant on the  reference sequence
        #[prost(message, optional, tag = "4")]
        pub start: ::core::option::Option<super::Integer>,
        /// End position of the variant on the reference sequence
        #[prost(message, optional, tag = "5")]
        pub end: ::core::option::Option<super::Integer>,
        /// Allele that was observed
        #[prost(message, optional, tag = "6")]
        pub observed_allele: ::core::option::Option<super::String>,
        /// Allele in the reference sequence
        #[prost(message, optional, tag = "7")]
        pub reference_allele: ::core::option::Option<super::String>,
        /// Extended CIGAR string for aligning the sequence with reference bases
        #[prost(message, optional, tag = "8")]
        pub cigar: ::core::option::Option<super::String>,
        /// Pointer to observed variant information
        #[prost(message, optional, tag = "9")]
        pub variant_pointer: ::core::option::Option<super::Reference>,
    }
    /// An set of value as quality of sequence
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Quality {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<quality::TypeCode>,
        /// Standard sequence for comparison
        #[prost(message, optional, tag = "5")]
        pub standard_sequence: ::core::option::Option<super::CodeableConcept>,
        /// Start position of the sequence
        #[prost(message, optional, tag = "6")]
        pub start: ::core::option::Option<super::Integer>,
        /// End position of the sequence
        #[prost(message, optional, tag = "7")]
        pub end: ::core::option::Option<super::Integer>,
        /// Quality score for the comparison
        #[prost(message, optional, tag = "8")]
        pub score: ::core::option::Option<super::Quantity>,
        /// Method to get quality
        #[prost(message, optional, tag = "9")]
        pub method: ::core::option::Option<super::CodeableConcept>,
        /// True positives from the perspective of the truth data
        #[prost(message, optional, tag = "10")]
        pub truth_tp: ::core::option::Option<super::Decimal>,
        /// True positives from the perspective of the query data
        #[prost(message, optional, tag = "11")]
        pub query_tp: ::core::option::Option<super::Decimal>,
        /// False negatives
        #[prost(message, optional, tag = "12")]
        pub truth_fn: ::core::option::Option<super::Decimal>,
        /// False positives
        #[prost(message, optional, tag = "13")]
        pub query_fp: ::core::option::Option<super::Decimal>,
        /// False positives where the non-REF alleles in the Truth and Query Call
        /// Sets match
        #[prost(message, optional, tag = "14")]
        pub gt_fp: ::core::option::Option<super::Decimal>,
        /// Precision of comparison
        #[prost(message, optional, tag = "15")]
        pub precision: ::core::option::Option<super::Decimal>,
        /// Recall of comparison
        #[prost(message, optional, tag = "16")]
        pub recall: ::core::option::Option<super::Decimal>,
        /// F-score
        #[prost(message, optional, tag = "17")]
        pub f_score: ::core::option::Option<super::Decimal>,
        #[prost(message, optional, tag = "18")]
        pub roc: ::core::option::Option<quality::Roc>,
    }
    /// Nested message and enum types in `Quality`.
    pub mod quality {
        /// indel | snp | unknown
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::quality_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Receiver Operator Characteristic (ROC) Curve
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Roc {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Genotype quality score
            #[prost(message, repeated, tag = "4")]
            pub score: prost::alloc::vec::Vec<super::super::Integer>,
            /// Roc score true positive numbers
            #[prost(message, repeated, tag = "5")]
            pub num_tp: prost::alloc::vec::Vec<super::super::Integer>,
            /// Roc score false positive numbers
            #[prost(message, repeated, tag = "6")]
            pub num_fp: prost::alloc::vec::Vec<super::super::Integer>,
            /// Roc score false negative numbers
            #[prost(message, repeated, tag = "7")]
            pub num_fn: prost::alloc::vec::Vec<super::super::Integer>,
            /// Precision of the GQ score
            #[prost(message, repeated, tag = "8")]
            pub precision: prost::alloc::vec::Vec<super::super::Decimal>,
            /// Sensitivity of the GQ score
            #[prost(message, repeated, tag = "9")]
            pub sensitivity: prost::alloc::vec::Vec<super::super::Decimal>,
            /// FScore of the GQ score
            #[prost(message, repeated, tag = "10")]
            pub f_measure: prost::alloc::vec::Vec<super::super::Decimal>,
        }
    }
    /// External repository which contains detailed report related with observedSeq
    /// in this resource
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Repository {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<repository::TypeCode>,
        /// URI of the repository
        #[prost(message, optional, tag = "5")]
        pub url: ::core::option::Option<super::Uri>,
        /// Repository's name
        #[prost(message, optional, tag = "6")]
        pub name: ::core::option::Option<super::String>,
        /// Id of the dataset that used to call for dataset in repository
        #[prost(message, optional, tag = "7")]
        pub dataset_id: ::core::option::Option<super::String>,
        /// Id of the variantset that used to call for variantset in repository
        #[prost(message, optional, tag = "8")]
        pub variantset_id: ::core::option::Option<super::String>,
        /// Id of the read
        #[prost(message, optional, tag = "9")]
        pub readset_id: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Repository`.
    pub mod repository {
        /// directlink | openapi | login | oauth | other
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::repository_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Structural variant
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StructureVariant {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Structural variant change type
        #[prost(message, optional, tag = "4")]
        pub variant_type: ::core::option::Option<super::CodeableConcept>,
        /// Does the structural variant have base pair resolution breakpoints?
        #[prost(message, optional, tag = "5")]
        pub exact: ::core::option::Option<super::Boolean>,
        /// Structural variant length
        #[prost(message, optional, tag = "6")]
        pub length: ::core::option::Option<super::Integer>,
        #[prost(message, optional, tag = "7")]
        pub outer: ::core::option::Option<structure_variant::Outer>,
        #[prost(message, optional, tag = "8")]
        pub inner: ::core::option::Option<structure_variant::Inner>,
    }
    /// Nested message and enum types in `StructureVariant`.
    pub mod structure_variant {
        /// Structural variant outer
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Outer {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Structural variant outer start
            #[prost(message, optional, tag = "4")]
            pub start: ::core::option::Option<super::super::Integer>,
            /// Structural variant outer end
            #[prost(message, optional, tag = "5")]
            pub end: ::core::option::Option<super::super::Integer>,
        }
        /// Structural variant inner
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Inner {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Structural variant inner start
            #[prost(message, optional, tag = "4")]
            pub start: ::core::option::Option<super::super::Integer>,
            /// Structural variant inner end
            #[prost(message, optional, tag = "5")]
            pub end: ::core::option::Option<super::super::Integer>,
        }
    }
}
/// Auto-generated from StructureDefinition for NamingSystem, last updated
/// 2019-11-01T09:29:23.356+11:00. System of unique identification. See
/// <http://hl7.org/fhir/StructureDefinition/NamingSystem>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NamingSystem {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Name for this naming system (computer friendly)
    #[prost(message, optional, tag = "10")]
    pub name: ::core::option::Option<String>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<naming_system::StatusCode>,
    #[prost(message, optional, tag = "12")]
    pub kind: ::core::option::Option<naming_system::KindCode>,
    /// Date last changed
    #[prost(message, optional, tag = "13")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "14")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "15")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Who maintains system namespace?
    #[prost(message, optional, tag = "16")]
    pub responsible: ::core::option::Option<String>,
    /// e.g. driver,  provider,  patient, bank etc.
    #[prost(message, optional, tag = "17")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Natural language description of the naming system
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "19")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for naming system (if applicable)
    #[prost(message, repeated, tag = "20")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// How/where is it used
    #[prost(message, optional, tag = "21")]
    pub usage: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "22")]
    pub unique_id: prost::alloc::vec::Vec<naming_system::UniqueId>,
}
/// Nested message and enum types in `NamingSystem`.
pub mod naming_system {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// codesystem | identifier | root
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct KindCode {
        #[prost(enumeration = "super::naming_system_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Unique identifiers used for system
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UniqueId {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<unique_id::TypeCode>,
        /// The unique identifier
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<super::String>,
        /// Is this the id that should be used for this type
        #[prost(message, optional, tag = "6")]
        pub preferred: ::core::option::Option<super::Boolean>,
        /// Notes about identifier usage
        #[prost(message, optional, tag = "7")]
        pub comment: ::core::option::Option<super::String>,
        /// When is identifier valid?
        #[prost(message, optional, tag = "8")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// Nested message and enum types in `UniqueId`.
    pub mod unique_id {
        /// oid | uuid | uri | other
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(
                enumeration = "super::super::naming_system_identifier_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for NutritionOrder, last updated
/// 2019-11-01T09:29:23.356+11:00. Diet, formula or nutritional supplement
/// request. See <http://hl7.org/fhir/StructureDefinition/NutritionOrder>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NutritionOrder {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifiers assigned to this order
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates FHIR protocol or definition
    #[prost(message, repeated, tag = "11")]
    pub instantiates_canonical: prost::alloc::vec::Vec<Canonical>,
    /// Instantiates external protocol or definition
    #[prost(message, repeated, tag = "12")]
    pub instantiates_uri: prost::alloc::vec::Vec<Uri>,
    /// Instantiates protocol or definition
    #[prost(message, repeated, tag = "13")]
    pub instantiates: prost::alloc::vec::Vec<Uri>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<nutrition_order::StatusCode>,
    #[prost(message, optional, tag = "15")]
    pub intent: ::core::option::Option<nutrition_order::IntentCode>,
    /// The person who requires the diet, formula or nutritional supplement
    #[prost(message, optional, tag = "16")]
    pub patient: ::core::option::Option<Reference>,
    /// The encounter associated with this nutrition order
    #[prost(message, optional, tag = "17")]
    pub encounter: ::core::option::Option<Reference>,
    /// Date and time the nutrition order was requested
    #[prost(message, optional, tag = "18")]
    pub date_time: ::core::option::Option<DateTime>,
    /// Who ordered the diet, formula or nutritional supplement
    #[prost(message, optional, tag = "19")]
    pub orderer: ::core::option::Option<Reference>,
    /// List of the patient's food and nutrition-related allergies and intolerances
    #[prost(message, repeated, tag = "20")]
    pub allergy_intolerance: prost::alloc::vec::Vec<Reference>,
    /// Order-specific modifier about the type of food that should be given
    #[prost(message, repeated, tag = "21")]
    pub food_preference_modifier: prost::alloc::vec::Vec<CodeableConcept>,
    /// Order-specific modifier about the type of food that should not be given
    #[prost(message, repeated, tag = "22")]
    pub exclude_food_modifier: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, optional, tag = "23")]
    pub oral_diet: ::core::option::Option<nutrition_order::OralDiet>,
    #[prost(message, repeated, tag = "24")]
    pub supplement: prost::alloc::vec::Vec<nutrition_order::Supplement>,
    #[prost(message, optional, tag = "25")]
    pub enteral_formula: ::core::option::Option<nutrition_order::EnteralFormula>,
    /// Comments
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `NutritionOrder`.
pub mod nutrition_order {
    /// draft | active | on-hold | revoked | completed | entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::request_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// proposal | plan | directive | order | original-order | reflex-order |
    /// filler-order | instance-order | option
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct IntentCode {
        #[prost(enumeration = "super::request_intent_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Oral diet components
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OralDiet {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of oral diet or diet restrictions that describe what can be consumed
        /// orally
        #[prost(message, repeated, tag = "4")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Scheduled frequency of diet
        #[prost(message, repeated, tag = "5")]
        pub schedule: prost::alloc::vec::Vec<super::Timing>,
        #[prost(message, repeated, tag = "6")]
        pub nutrient: prost::alloc::vec::Vec<oral_diet::Nutrient>,
        #[prost(message, repeated, tag = "7")]
        pub texture: prost::alloc::vec::Vec<oral_diet::Texture>,
        /// The required consistency of fluids and liquids provided to the patient
        #[prost(message, repeated, tag = "8")]
        pub fluid_consistency_type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Instructions or additional information about the oral diet
        #[prost(message, optional, tag = "9")]
        pub instruction: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `OralDiet`.
    pub mod oral_diet {
        /// Required  nutrient modifications
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Nutrient {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of nutrient that is being modified
            #[prost(message, optional, tag = "4")]
            pub modifier: ::core::option::Option<super::super::CodeableConcept>,
            /// Quantity of the specified nutrient
            #[prost(message, optional, tag = "5")]
            pub amount: ::core::option::Option<super::super::SimpleQuantity>,
        }
        /// Required  texture modifications
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Texture {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Code to indicate how to alter the texture of the foods, e.g. pureed
            #[prost(message, optional, tag = "4")]
            pub modifier: ::core::option::Option<super::super::CodeableConcept>,
            /// Concepts that are used to identify an entity that is ingested for
            /// nutritional purposes
            #[prost(message, optional, tag = "5")]
            pub food_type: ::core::option::Option<super::super::CodeableConcept>,
        }
    }
    /// Supplement components
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Supplement {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of supplement product requested
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Product or brand name of the nutritional supplement
        #[prost(message, optional, tag = "5")]
        pub product_name: ::core::option::Option<super::String>,
        /// Scheduled frequency of supplement
        #[prost(message, repeated, tag = "6")]
        pub schedule: prost::alloc::vec::Vec<super::Timing>,
        /// Amount of the nutritional supplement
        #[prost(message, optional, tag = "7")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Instructions or additional information about the oral supplement
        #[prost(message, optional, tag = "8")]
        pub instruction: ::core::option::Option<super::String>,
    }
    /// Enteral formula components
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EnteralFormula {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of enteral or infant formula
        #[prost(message, optional, tag = "4")]
        pub base_formula_type: ::core::option::Option<super::CodeableConcept>,
        /// Product or brand name of the enteral or infant formula
        #[prost(message, optional, tag = "5")]
        pub base_formula_product_name: ::core::option::Option<super::String>,
        /// Type of modular component to add to the feeding
        #[prost(message, optional, tag = "6")]
        pub additive_type: ::core::option::Option<super::CodeableConcept>,
        /// Product or brand name of the modular additive
        #[prost(message, optional, tag = "7")]
        pub additive_product_name: ::core::option::Option<super::String>,
        /// Amount of energy per specified volume that is required
        #[prost(message, optional, tag = "8")]
        pub caloric_density: ::core::option::Option<super::SimpleQuantity>,
        /// How the formula should enter the patient's gastrointestinal tract
        #[prost(message, optional, tag = "9")]
        pub routeof_administration: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "10")]
        pub administration: prost::alloc::vec::Vec<enteral_formula::Administration>,
        /// Upper limit on formula volume per unit of time
        #[prost(message, optional, tag = "11")]
        pub max_volume_to_deliver: ::core::option::Option<super::SimpleQuantity>,
        /// Formula feeding instructions expressed as text
        #[prost(message, optional, tag = "12")]
        pub administration_instruction: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `EnteralFormula`.
    pub mod enteral_formula {
        /// Formula feeding instruction as structured data
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Administration {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Scheduled frequency of enteral feeding
            #[prost(message, optional, tag = "4")]
            pub schedule: ::core::option::Option<super::super::Timing>,
            /// The volume of formula to provide
            #[prost(message, optional, tag = "5")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            #[prost(message, optional, tag = "6")]
            pub rate: ::core::option::Option<administration::RateX>,
        }
        /// Nested message and enum types in `Administration`.
        pub mod administration {
            /// Speed with which the formula is provided per period of time
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct RateX {
                #[prost(oneof = "rate_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<rate_x::Choice>,
            }
            /// Nested message and enum types in `RateX`.
            pub mod rate_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Quantity(super::super::super::super::SimpleQuantity),
                    #[prost(message, tag = "2")]
                    Ratio(super::super::super::super::Ratio),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Observation, last updated
/// 2019-11-01T09:29:23.356+11:00. Measurements and simple assertions. See
/// <http://hl7.org/fhir/StructureDefinition/Observation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Observation {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for observation
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Fulfills plan, proposal or order
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced event
    #[prost(message, repeated, tag = "12")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<observation::StatusCode>,
    /// Classification of  type of observation
    #[prost(message, repeated, tag = "14")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Type of observation (code / type)
    #[prost(message, optional, tag = "15")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who and/or what the observation is about
    #[prost(message, optional, tag = "16")]
    pub subject: ::core::option::Option<Reference>,
    /// What the observation is about, when it is not about the subject of record
    #[prost(message, repeated, tag = "17")]
    pub focus: prost::alloc::vec::Vec<Reference>,
    /// Healthcare event during which this observation is made
    #[prost(message, optional, tag = "18")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "19")]
    pub effective: ::core::option::Option<observation::EffectiveX>,
    /// Date/Time this version was made available
    #[prost(message, optional, tag = "20")]
    pub issued: ::core::option::Option<Instant>,
    /// Who is responsible for the observation
    #[prost(message, repeated, tag = "21")]
    pub performer: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "22")]
    pub value: ::core::option::Option<observation::ValueX>,
    /// Why the result is missing
    #[prost(message, optional, tag = "23")]
    pub data_absent_reason: ::core::option::Option<CodeableConcept>,
    /// High, low, normal, etc.
    #[prost(message, repeated, tag = "24")]
    pub interpretation: prost::alloc::vec::Vec<CodeableConcept>,
    /// Comments about the observation
    #[prost(message, repeated, tag = "25")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Observed body part
    #[prost(message, optional, tag = "26")]
    pub body_site: ::core::option::Option<CodeableConcept>,
    /// How it was done
    #[prost(message, optional, tag = "27")]
    pub method: ::core::option::Option<CodeableConcept>,
    /// Specimen used for this observation
    #[prost(message, optional, tag = "28")]
    pub specimen: ::core::option::Option<Reference>,
    /// (Measurement) Device
    #[prost(message, optional, tag = "29")]
    pub device: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "30")]
    pub reference_range: prost::alloc::vec::Vec<observation::ReferenceRange>,
    /// Related resource that belongs to the Observation group
    #[prost(message, repeated, tag = "31")]
    pub has_member: prost::alloc::vec::Vec<Reference>,
    /// Related measurements the observation is made from
    #[prost(message, repeated, tag = "32")]
    pub derived_from: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "33")]
    pub component: prost::alloc::vec::Vec<observation::Component>,
}
/// Nested message and enum types in `Observation`.
pub mod observation {
    /// registered | preliminary | final | amended +
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::observation_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Clinically relevant time/time-period for observation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EffectiveX {
        #[prost(oneof = "effective_x::Choice", tags = "1, 2, 3, 4")]
        pub choice: ::core::option::Option<effective_x::Choice>,
    }
    /// Nested message and enum types in `EffectiveX`.
    pub mod effective_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
            #[prost(message, tag = "4")]
            Instant(super::super::Instant),
        }
    }
    /// Actual result
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "3")]
            StringValue(super::super::String),
            #[prost(message, tag = "4")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "5")]
            Integer(super::super::Integer),
            #[prost(message, tag = "6")]
            Range(super::super::Range),
            #[prost(message, tag = "7")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "8")]
            SampledData(super::super::SampledData),
            #[prost(message, tag = "9")]
            Time(super::super::Time),
            #[prost(message, tag = "10")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "11")]
            Period(super::super::Period),
        }
    }
    /// Provides guide for interpretation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ReferenceRange {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Low Range, if relevant
        #[prost(message, optional, tag = "4")]
        pub low: ::core::option::Option<super::SimpleQuantity>,
        /// High Range, if relevant
        #[prost(message, optional, tag = "5")]
        pub high: ::core::option::Option<super::SimpleQuantity>,
        /// Reference range qualifier
        #[prost(message, optional, tag = "6")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Reference range population
        #[prost(message, repeated, tag = "7")]
        pub applies_to: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Applicable age range, if relevant
        #[prost(message, optional, tag = "8")]
        pub age: ::core::option::Option<super::Range>,
        /// Text based reference range in an observation
        #[prost(message, optional, tag = "9")]
        pub text: ::core::option::Option<super::String>,
    }
    /// Component results
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Component {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of component observation (code / type)
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<component::ValueX>,
        /// Why the component result is missing
        #[prost(message, optional, tag = "6")]
        pub data_absent_reason: ::core::option::Option<super::CodeableConcept>,
        /// High, low, normal, etc.
        #[prost(message, repeated, tag = "7")]
        pub interpretation: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Provides guide for interpretation of component result
        #[prost(message, repeated, tag = "8")]
        pub reference_range: prost::alloc::vec::Vec<ReferenceRange>,
    }
    /// Nested message and enum types in `Component`.
    pub mod component {
        /// Actual component result
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11")]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "2")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "3")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "4")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "5")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "6")]
                Range(super::super::super::Range),
                #[prost(message, tag = "7")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "8")]
                SampledData(super::super::super::SampledData),
                #[prost(message, tag = "9")]
                Time(super::super::super::Time),
                #[prost(message, tag = "10")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "11")]
                Period(super::super::super::Period),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for ObservationDefinition, last
/// updated 2019-11-01T09:29:23.356+11:00. Definition of an observation. See
/// <http://hl7.org/fhir/StructureDefinition/ObservationDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Category of observation
    #[prost(message, repeated, tag = "10")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Type of observation (code / type)
    #[prost(message, optional, tag = "11")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Business identifier for this ObservationDefinition instance
    #[prost(message, repeated, tag = "12")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, repeated, tag = "13")]
    pub permitted_data_type: prost::alloc::vec::Vec<observation_definition::PermittedDataTypeCode>,
    /// Multiple results allowed
    #[prost(message, optional, tag = "14")]
    pub multiple_results_allowed: ::core::option::Option<Boolean>,
    /// Method used to produce the observation
    #[prost(message, optional, tag = "15")]
    pub method: ::core::option::Option<CodeableConcept>,
    /// Preferred report name
    #[prost(message, optional, tag = "16")]
    pub preferred_report_name: ::core::option::Option<String>,
    #[prost(message, optional, tag = "17")]
    pub quantitative_details: ::core::option::Option<observation_definition::QuantitativeDetails>,
    #[prost(message, repeated, tag = "18")]
    pub qualified_interval: prost::alloc::vec::Vec<observation_definition::QualifiedInterval>,
    /// Value set of valid coded values for the observations conforming to this
    /// ObservationDefinition
    #[prost(message, optional, tag = "19")]
    pub valid_coded_value_set: ::core::option::Option<Reference>,
    /// Value set of normal coded values for the observations conforming to this
    /// ObservationDefinition
    #[prost(message, optional, tag = "20")]
    pub normal_coded_value_set: ::core::option::Option<Reference>,
    /// Value set of abnormal coded values for the observations conforming to this
    /// ObservationDefinition
    #[prost(message, optional, tag = "21")]
    pub abnormal_coded_value_set: ::core::option::Option<Reference>,
    /// Value set of critical coded values for the observations conforming to this
    /// ObservationDefinition
    #[prost(message, optional, tag = "22")]
    pub critical_coded_value_set: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `ObservationDefinition`.
pub mod observation_definition {
    /// Quantity | CodeableConcept | string | boolean | integer | Range | Ratio |
    /// SampledData | time | dateTime | Period
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PermittedDataTypeCode {
        #[prost(enumeration = "super::observation_data_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Characteristics of quantitative results
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct QuantitativeDetails {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Customary unit for quantitative results
        #[prost(message, optional, tag = "4")]
        pub customary_unit: ::core::option::Option<super::CodeableConcept>,
        /// SI unit for quantitative results
        #[prost(message, optional, tag = "5")]
        pub unit: ::core::option::Option<super::CodeableConcept>,
        /// SI to Customary unit conversion factor
        #[prost(message, optional, tag = "6")]
        pub conversion_factor: ::core::option::Option<super::Decimal>,
        /// Decimal precision of observation quantitative results
        #[prost(message, optional, tag = "7")]
        pub decimal_precision: ::core::option::Option<super::Integer>,
    }
    /// Qualified range for continuous and ordinal observation results
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct QualifiedInterval {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub category: ::core::option::Option<qualified_interval::CategoryCode>,
        /// The interval itself, for continuous or ordinal observations
        #[prost(message, optional, tag = "5")]
        pub range: ::core::option::Option<super::Range>,
        /// Range context qualifier
        #[prost(message, optional, tag = "6")]
        pub context: ::core::option::Option<super::CodeableConcept>,
        /// Targetted population of the range
        #[prost(message, repeated, tag = "7")]
        pub applies_to: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, optional, tag = "8")]
        pub gender: ::core::option::Option<qualified_interval::GenderCode>,
        /// Applicable age range, if relevant
        #[prost(message, optional, tag = "9")]
        pub age: ::core::option::Option<super::Range>,
        /// Applicable gestational age range, if relevant
        #[prost(message, optional, tag = "10")]
        pub gestational_age: ::core::option::Option<super::Range>,
        /// Condition associated with the reference range
        #[prost(message, optional, tag = "11")]
        pub condition: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `QualifiedInterval`.
    pub mod qualified_interval {
        /// reference | critical | absolute
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CategoryCode {
            #[prost(
                enumeration = "super::super::observation_range_category_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// male | female | other | unknown
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct GenderCode {
            #[prost(
                enumeration = "super::super::administrative_gender_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for OperationDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. Definition of an operation or a named query.
/// See <http://hl7.org/fhir/StructureDefinition/OperationDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this operation definition, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the operation definition
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this operation definition (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this operation definition (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<operation_definition::StatusCode>,
    #[prost(message, optional, tag = "15")]
    pub kind: ::core::option::Option<operation_definition::KindCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "16")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "18")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "19")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the operation definition
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "21")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for operation definition (if applicable)
    #[prost(message, repeated, tag = "22")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this operation definition is defined
    #[prost(message, optional, tag = "23")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Whether content is changed by the operation
    #[prost(message, optional, tag = "24")]
    pub affects_state: ::core::option::Option<Boolean>,
    /// Name used to invoke the operation
    #[prost(message, optional, tag = "25")]
    pub code: ::core::option::Option<Code>,
    /// Additional information about use
    #[prost(message, optional, tag = "26")]
    pub comment: ::core::option::Option<Markdown>,
    /// Marks this as a profile of the base
    #[prost(message, optional, tag = "27")]
    pub base: ::core::option::Option<Canonical>,
    #[prost(message, repeated, tag = "28")]
    pub resource: prost::alloc::vec::Vec<operation_definition::ResourceCode>,
    /// Invoke at the system level?
    #[prost(message, optional, tag = "29")]
    pub system: ::core::option::Option<Boolean>,
    /// Invoke at the type level?
    #[prost(message, optional, tag = "30")]
    pub r#type: ::core::option::Option<Boolean>,
    /// Invoke on an instance?
    #[prost(message, optional, tag = "31")]
    pub instance: ::core::option::Option<Boolean>,
    /// Validation information for in parameters
    #[prost(message, optional, tag = "32")]
    pub input_profile: ::core::option::Option<Canonical>,
    /// Validation information for out parameters
    #[prost(message, optional, tag = "33")]
    pub output_profile: ::core::option::Option<Canonical>,
    #[prost(message, repeated, tag = "34")]
    pub parameter: prost::alloc::vec::Vec<operation_definition::Parameter>,
    #[prost(message, repeated, tag = "35")]
    pub overload: prost::alloc::vec::Vec<operation_definition::Overload>,
}
/// Nested message and enum types in `OperationDefinition`.
pub mod operation_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// operation | query
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct KindCode {
        #[prost(enumeration = "super::operation_kind_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Types this operation applies to
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ResourceCode {
        #[prost(enumeration = "super::resource_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Parameters for the operation/query
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Parameter {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name in Parameters.parameter.name or in URL
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::Code>,
        #[prost(message, optional, tag = "5")]
        pub r#use: ::core::option::Option<parameter::UseCode>,
        /// Minimum Cardinality
        #[prost(message, optional, tag = "6")]
        pub min: ::core::option::Option<super::Integer>,
        /// Maximum Cardinality (a number or *)
        #[prost(message, optional, tag = "7")]
        pub max: ::core::option::Option<super::String>,
        /// Description of meaning/use
        #[prost(message, optional, tag = "8")]
        pub documentation: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "9")]
        pub r#type: ::core::option::Option<parameter::TypeCode>,
        /// If type is Reference | canonical, allowed targets
        #[prost(message, repeated, tag = "10")]
        pub target_profile: prost::alloc::vec::Vec<super::Canonical>,
        #[prost(message, optional, tag = "11")]
        pub search_type: ::core::option::Option<parameter::SearchTypeCode>,
        #[prost(message, optional, tag = "12")]
        pub binding: ::core::option::Option<parameter::Binding>,
        #[prost(message, repeated, tag = "13")]
        pub referenced_from: prost::alloc::vec::Vec<parameter::ReferencedFrom>,
        /// Parts of a nested Parameter
        #[prost(message, repeated, tag = "14")]
        pub part: prost::alloc::vec::Vec<Parameter>,
    }
    /// Nested message and enum types in `Parameter`.
    pub mod parameter {
        /// in | out
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct UseCode {
            #[prost(
                enumeration = "super::super::operation_parameter_use_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// What type this parameter has
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(
                enumeration = "super::super::fhir_all_types_value_set::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// number | date | string | token | reference | composite | quantity | uri |
        /// special
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SearchTypeCode {
            #[prost(enumeration = "super::super::search_param_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// ValueSet details if this is coded
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Binding {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub strength: ::core::option::Option<binding::StrengthCode>,
            /// Source of value set
            #[prost(message, optional, tag = "5")]
            pub value_set: ::core::option::Option<super::super::Canonical>,
        }
        /// Nested message and enum types in `Binding`.
        pub mod binding {
            /// required | extensible | preferred | example
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct StrengthCode {
                #[prost(
                    enumeration = "super::super::super::binding_strength_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
        /// References to this parameter
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ReferencedFrom {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Referencing parameter
            #[prost(message, optional, tag = "4")]
            pub source: ::core::option::Option<super::super::String>,
            /// Element id of reference
            #[prost(message, optional, tag = "5")]
            pub source_id: ::core::option::Option<super::super::String>,
        }
    }
    /// Define overloaded variants for when  generating code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Overload {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name of parameter to include in overload
        #[prost(message, repeated, tag = "4")]
        pub parameter_name: prost::alloc::vec::Vec<super::String>,
        /// Comments to go on overload
        #[prost(message, optional, tag = "5")]
        pub comment: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for OperationOutcome, last updated
/// 2019-11-01T09:29:23.356+11:00. Information about the success/failure of an
/// action. See <http://hl7.org/fhir/StructureDefinition/OperationOutcome>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationOutcome {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, repeated, tag = "10")]
    pub issue: prost::alloc::vec::Vec<operation_outcome::Issue>,
}
/// Nested message and enum types in `OperationOutcome`.
pub mod operation_outcome {
    /// A single issue associated with the action
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Issue {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub severity: ::core::option::Option<issue::SeverityCode>,
        #[prost(message, optional, tag = "5")]
        pub code: ::core::option::Option<issue::CodeType>,
        /// Additional details about the error
        #[prost(message, optional, tag = "6")]
        pub details: ::core::option::Option<super::CodeableConcept>,
        /// Additional diagnostic information about the issue
        #[prost(message, optional, tag = "7")]
        pub diagnostics: ::core::option::Option<super::String>,
        /// Deprecated: Path of element(s) related to issue
        #[prost(message, repeated, tag = "8")]
        pub location: prost::alloc::vec::Vec<super::String>,
        /// FHIRPath of element(s) related to issue
        #[prost(message, repeated, tag = "9")]
        pub expression: prost::alloc::vec::Vec<super::String>,
    }
    /// Nested message and enum types in `Issue`.
    pub mod issue {
        /// fatal | error | warning | information
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SeverityCode {
            #[prost(enumeration = "super::super::issue_severity_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Error or warning code
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CodeType {
            #[prost(enumeration = "super::super::issue_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for Organization, last updated
/// 2019-11-01T09:29:23.356+11:00. A grouping of people or organizations with a
/// common purpose. See <http://hl7.org/fhir/StructureDefinition/Organization>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Organization {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifies this organization  across multiple systems
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether the organization's record is still in active use
    #[prost(message, optional, tag = "11")]
    pub active: ::core::option::Option<Boolean>,
    /// Kind of organization
    #[prost(message, repeated, tag = "12")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Name used for the organization
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// A list of alternate names that the organization is known as, or was known
    /// as in the past
    #[prost(message, repeated, tag = "14")]
    pub alias: prost::alloc::vec::Vec<String>,
    /// A contact detail for the organization
    #[prost(message, repeated, tag = "15")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// An address for the organization
    #[prost(message, repeated, tag = "16")]
    pub address: prost::alloc::vec::Vec<Address>,
    /// The organization of which this organization forms a part
    #[prost(message, optional, tag = "17")]
    pub part_of: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<organization::Contact>,
    /// Technical endpoints providing access to services operated for the
    /// organization
    #[prost(message, repeated, tag = "19")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `Organization`.
pub mod organization {
    /// Contact for the organization for a certain purpose
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Contact {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The type of contact
        #[prost(message, optional, tag = "4")]
        pub purpose: ::core::option::Option<super::CodeableConcept>,
        /// A name associated with the contact
        #[prost(message, optional, tag = "5")]
        pub name: ::core::option::Option<super::HumanName>,
        /// Contact details (telephone, email, etc.)  for a contact
        #[prost(message, repeated, tag = "6")]
        pub telecom: prost::alloc::vec::Vec<super::ContactPoint>,
        /// Visiting or postal addresses for the contact
        #[prost(message, optional, tag = "7")]
        pub address: ::core::option::Option<super::Address>,
    }
}
/// Auto-generated from StructureDefinition for OrganizationAffiliation, last
/// updated 2019-11-01T09:29:23.356+11:00. Defines an
/// affiliation/assotiation/relationship between 2 distinct oganizations, that is
/// not a part-of relationship/sub-division relationship. See
/// <http://hl7.org/fhir/StructureDefinition/OrganizationAffiliation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OrganizationAffiliation {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifiers that are specific to this role
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this organization affiliation record is in active use
    #[prost(message, optional, tag = "11")]
    pub active: ::core::option::Option<Boolean>,
    /// The period during which the participatingOrganization is affiliated with
    /// the primary organization
    #[prost(message, optional, tag = "12")]
    pub period: ::core::option::Option<Period>,
    /// Organization where the role is available
    #[prost(message, optional, tag = "13")]
    pub organization: ::core::option::Option<Reference>,
    /// Organization that provides/performs the role (e.g. providing services or is
    /// a member of)
    #[prost(message, optional, tag = "14")]
    pub participating_organization: ::core::option::Option<Reference>,
    /// Health insurance provider network in which the participatingOrganization
    /// provides the role's services (if defined) at the indicated locations (if
    /// defined)
    #[prost(message, repeated, tag = "15")]
    pub network: prost::alloc::vec::Vec<Reference>,
    /// Definition of the role the participatingOrganization plays
    #[prost(message, repeated, tag = "16")]
    pub code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Specific specialty of the participatingOrganization in the context of the
    /// role
    #[prost(message, repeated, tag = "17")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// The location(s) at which the role occurs
    #[prost(message, repeated, tag = "18")]
    pub location: prost::alloc::vec::Vec<Reference>,
    /// Healthcare services provided through the role
    #[prost(message, repeated, tag = "19")]
    pub healthcare_service: prost::alloc::vec::Vec<Reference>,
    /// Contact details at the participatingOrganization relevant to this
    /// Affiliation
    #[prost(message, repeated, tag = "20")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// Technical endpoints providing access to services operated for this role
    #[prost(message, repeated, tag = "21")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
}
/// Auto-generated from StructureDefinition for Parameters, last updated
/// 2019-11-01T09:29:23.356+11:00. Operation Request or Response. See
/// <http://hl7.org/fhir/StructureDefinition/Parameters>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Parameters {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    #[prost(message, repeated, tag = "5")]
    pub parameter: prost::alloc::vec::Vec<parameters::Parameter>,
}
/// Nested message and enum types in `Parameters`.
pub mod parameters {
    /// Operation Parameter
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Parameter {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name from the definition
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<parameter::ValueX>,
        /// If parameter is a whole resource
        #[prost(message, optional, tag = "6")]
        pub resource: ::core::option::Option<::prost_wkt_types::Any>,
        /// Named part of a multi-part parameter
        #[prost(message, repeated, tag = "7")]
        pub part: prost::alloc::vec::Vec<Parameter>,
    }
    /// Nested message and enum types in `Parameter`.
    pub mod parameter {
        /// If parameter is a data type
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(
                oneof = "value_x::Choice",
                tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50"
            )]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Base64Binary(super::super::super::Base64Binary),
                #[prost(message, tag = "2")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "3")]
                Canonical(super::super::super::Canonical),
                #[prost(message, tag = "4")]
                Code(super::super::super::Code),
                #[prost(message, tag = "5")]
                Date(super::super::super::Date),
                #[prost(message, tag = "6")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "7")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "8")]
                Id(super::super::super::Id),
                #[prost(message, tag = "9")]
                Instant(super::super::super::Instant),
                #[prost(message, tag = "10")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "11")]
                Markdown(super::super::super::Markdown),
                #[prost(message, tag = "12")]
                Oid(super::super::super::Oid),
                #[prost(message, tag = "13")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "14")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "15")]
                Time(super::super::super::Time),
                #[prost(message, tag = "16")]
                UnsignedInt(super::super::super::UnsignedInt),
                #[prost(message, tag = "17")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "18")]
                Url(super::super::super::Url),
                #[prost(message, tag = "19")]
                Uuid(super::super::super::Uuid),
                #[prost(message, tag = "20")]
                Address(super::super::super::Address),
                #[prost(message, tag = "21")]
                Age(super::super::super::Age),
                #[prost(message, tag = "22")]
                Annotation(super::super::super::Annotation),
                #[prost(message, tag = "23")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "24")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "25")]
                Coding(super::super::super::Coding),
                #[prost(message, tag = "26")]
                ContactPoint(super::super::super::ContactPoint),
                #[prost(message, tag = "27")]
                Count(super::super::super::Count),
                #[prost(message, tag = "28")]
                Distance(super::super::super::Distance),
                #[prost(message, tag = "29")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "30")]
                HumanName(super::super::super::HumanName),
                #[prost(message, tag = "31")]
                Identifier(super::super::super::Identifier),
                #[prost(message, tag = "32")]
                Money(super::super::super::Money),
                #[prost(message, tag = "33")]
                Period(super::super::super::Period),
                #[prost(message, tag = "34")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "35")]
                Range(super::super::super::Range),
                #[prost(message, tag = "36")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "37")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "38")]
                SampledData(super::super::super::SampledData),
                #[prost(message, tag = "39")]
                Signature(super::super::super::Signature),
                #[prost(message, tag = "40")]
                Timing(super::super::super::Timing),
                #[prost(message, tag = "41")]
                ContactDetail(super::super::super::ContactDetail),
                #[prost(message, tag = "42")]
                Contributor(super::super::super::Contributor),
                #[prost(message, tag = "43")]
                DataRequirement(super::super::super::DataRequirement),
                #[prost(message, tag = "44")]
                Expression(super::super::super::Expression),
                #[prost(message, tag = "45")]
                ParameterDefinition(super::super::super::ParameterDefinition),
                #[prost(message, tag = "46")]
                RelatedArtifact(super::super::super::RelatedArtifact),
                #[prost(message, tag = "47")]
                TriggerDefinition(super::super::super::TriggerDefinition),
                #[prost(message, tag = "48")]
                UsageContext(super::super::super::UsageContext),
                #[prost(message, tag = "49")]
                Dosage(super::super::super::Dosage),
                #[prost(message, tag = "50")]
                Meta(super::super::super::Meta),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Patient, last updated
/// 2019-11-01T09:29:23.356+11:00. Information about an individual or animal
/// receiving health care services. See
/// <http://hl7.org/fhir/StructureDefinition/Patient>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Patient {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// An identifier for this patient
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this patient's record is in active use
    #[prost(message, optional, tag = "11")]
    pub active: ::core::option::Option<Boolean>,
    /// A name associated with the patient
    #[prost(message, repeated, tag = "12")]
    pub name: prost::alloc::vec::Vec<HumanName>,
    /// A contact detail for the individual
    #[prost(message, repeated, tag = "13")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    #[prost(message, optional, tag = "14")]
    pub gender: ::core::option::Option<patient::GenderCode>,
    /// The date of birth for the individual
    #[prost(message, optional, tag = "15")]
    pub birth_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "16")]
    pub deceased: ::core::option::Option<patient::DeceasedX>,
    /// An address for the individual
    #[prost(message, repeated, tag = "17")]
    pub address: prost::alloc::vec::Vec<Address>,
    /// Marital (civil) status of a patient
    #[prost(message, optional, tag = "18")]
    pub marital_status: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "19")]
    pub multiple_birth: ::core::option::Option<patient::MultipleBirthX>,
    /// Image of the patient
    #[prost(message, repeated, tag = "20")]
    pub photo: prost::alloc::vec::Vec<Attachment>,
    #[prost(message, repeated, tag = "21")]
    pub contact: prost::alloc::vec::Vec<patient::Contact>,
    #[prost(message, repeated, tag = "22")]
    pub communication: prost::alloc::vec::Vec<patient::Communication>,
    /// Patient's nominated primary care provider
    #[prost(message, repeated, tag = "23")]
    pub general_practitioner: prost::alloc::vec::Vec<Reference>,
    /// Organization that is the custodian of the patient record
    #[prost(message, optional, tag = "24")]
    pub managing_organization: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "25")]
    pub link: prost::alloc::vec::Vec<patient::Link>,
}
/// Nested message and enum types in `Patient`.
pub mod patient {
    /// male | female | other | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct GenderCode {
        #[prost(enumeration = "super::administrative_gender_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Indicates if the individual is deceased or not
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DeceasedX {
        #[prost(oneof = "deceased_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<deceased_x::Choice>,
    }
    /// Nested message and enum types in `DeceasedX`.
    pub mod deceased_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
        }
    }
    /// Whether patient is part of a multiple birth
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MultipleBirthX {
        #[prost(oneof = "multiple_birth_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<multiple_birth_x::Choice>,
    }
    /// Nested message and enum types in `MultipleBirthX`.
    pub mod multiple_birth_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            Integer(super::super::Integer),
        }
    }
    /// A contact party (e.g. guardian, partner, friend) for the patient
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Contact {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The kind of relationship
        #[prost(message, repeated, tag = "4")]
        pub relationship: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// A name associated with the contact person
        #[prost(message, optional, tag = "5")]
        pub name: ::core::option::Option<super::HumanName>,
        /// A contact detail for the person
        #[prost(message, repeated, tag = "6")]
        pub telecom: prost::alloc::vec::Vec<super::ContactPoint>,
        /// Address for the contact person
        #[prost(message, optional, tag = "7")]
        pub address: ::core::option::Option<super::Address>,
        #[prost(message, optional, tag = "8")]
        pub gender: ::core::option::Option<contact::GenderCode>,
        /// Organization that is associated with the contact
        #[prost(message, optional, tag = "9")]
        pub organization: ::core::option::Option<super::Reference>,
        /// The period during which this contact person or organization is valid to
        /// be contacted relating to this patient
        #[prost(message, optional, tag = "10")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// Nested message and enum types in `Contact`.
    pub mod contact {
        /// male | female | other | unknown
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct GenderCode {
            #[prost(
                enumeration = "super::super::administrative_gender_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// A language which may be used to communicate with the patient about his or
    /// her health
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Communication {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The language which can be used to communicate with the patient about his
        /// or her health
        #[prost(message, optional, tag = "4")]
        pub language: ::core::option::Option<super::CodeableConcept>,
        /// Language preference indicator
        #[prost(message, optional, tag = "5")]
        pub preferred: ::core::option::Option<super::Boolean>,
    }
    /// Link to another patient resource that concerns the same actual person
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Link {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The other patient or related person resource that the link refers to
        #[prost(message, optional, tag = "4")]
        pub other: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<link::TypeCode>,
    }
    /// Nested message and enum types in `Link`.
    pub mod link {
        /// replaced-by | replaces | refer | seealso
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::link_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for PaymentNotice, last updated
/// 2019-11-01T09:29:23.356+11:00. PaymentNotice request. See
/// <http://hl7.org/fhir/StructureDefinition/PaymentNotice>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PaymentNotice {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for the payment noctice
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<payment_notice::StatusCode>,
    /// Request reference
    #[prost(message, optional, tag = "12")]
    pub request: ::core::option::Option<Reference>,
    /// Response reference
    #[prost(message, optional, tag = "13")]
    pub response: ::core::option::Option<Reference>,
    /// Creation date
    #[prost(message, optional, tag = "14")]
    pub created: ::core::option::Option<DateTime>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "15")]
    pub provider: ::core::option::Option<Reference>,
    /// Payment reference
    #[prost(message, optional, tag = "16")]
    pub payment: ::core::option::Option<Reference>,
    /// Payment or clearing date
    #[prost(message, optional, tag = "17")]
    pub payment_date: ::core::option::Option<Date>,
    /// Party being paid
    #[prost(message, optional, tag = "18")]
    pub payee: ::core::option::Option<Reference>,
    /// Party being notified
    #[prost(message, optional, tag = "19")]
    pub recipient: ::core::option::Option<Reference>,
    /// Monetary amount of the payment
    #[prost(message, optional, tag = "20")]
    pub amount: ::core::option::Option<Money>,
    /// Issued or cleared Status of the payment
    #[prost(message, optional, tag = "21")]
    pub payment_status: ::core::option::Option<CodeableConcept>,
}
/// Nested message and enum types in `PaymentNotice`.
pub mod payment_notice {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::financial_resource_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for PaymentReconciliation, last
/// updated 2019-11-01T09:29:23.356+11:00. PaymentReconciliation resource. See
/// <http://hl7.org/fhir/StructureDefinition/PaymentReconciliation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PaymentReconciliation {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for a payment reconciliation
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<payment_reconciliation::StatusCode>,
    /// Period covered
    #[prost(message, optional, tag = "12")]
    pub period: ::core::option::Option<Period>,
    /// Creation date
    #[prost(message, optional, tag = "13")]
    pub created: ::core::option::Option<DateTime>,
    /// Party generating payment
    #[prost(message, optional, tag = "14")]
    pub payment_issuer: ::core::option::Option<Reference>,
    /// Reference to requesting resource
    #[prost(message, optional, tag = "15")]
    pub request: ::core::option::Option<Reference>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "16")]
    pub requestor: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "17")]
    pub outcome: ::core::option::Option<payment_reconciliation::OutcomeCode>,
    /// Disposition message
    #[prost(message, optional, tag = "18")]
    pub disposition: ::core::option::Option<String>,
    /// When payment issued
    #[prost(message, optional, tag = "19")]
    pub payment_date: ::core::option::Option<Date>,
    /// Total amount of Payment
    #[prost(message, optional, tag = "20")]
    pub payment_amount: ::core::option::Option<Money>,
    /// Business identifier for the payment
    #[prost(message, optional, tag = "21")]
    pub payment_identifier: ::core::option::Option<Identifier>,
    #[prost(message, repeated, tag = "22")]
    pub detail: prost::alloc::vec::Vec<payment_reconciliation::Details>,
    /// Printed form identifier
    #[prost(message, optional, tag = "23")]
    pub form_code: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "24")]
    pub process_note: prost::alloc::vec::Vec<payment_reconciliation::Notes>,
}
/// Nested message and enum types in `PaymentReconciliation`.
pub mod payment_reconciliation {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::financial_resource_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// queued | complete | error | partial
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OutcomeCode {
        #[prost(enumeration = "super::claim_processing_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Settlement particulars
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Details {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Business identifier of the payment detail
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Business identifier of the prior payment detail
        #[prost(message, optional, tag = "5")]
        pub predecessor: ::core::option::Option<super::Identifier>,
        /// Category of payment
        #[prost(message, optional, tag = "6")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Request giving rise to the payment
        #[prost(message, optional, tag = "7")]
        pub request: ::core::option::Option<super::Reference>,
        /// Submitter of the request
        #[prost(message, optional, tag = "8")]
        pub submitter: ::core::option::Option<super::Reference>,
        /// Response committing to a payment
        #[prost(message, optional, tag = "9")]
        pub response: ::core::option::Option<super::Reference>,
        /// Date of commitment to pay
        #[prost(message, optional, tag = "10")]
        pub date: ::core::option::Option<super::Date>,
        /// Contact for the response
        #[prost(message, optional, tag = "11")]
        pub responsible: ::core::option::Option<super::Reference>,
        /// Recipient of the payment
        #[prost(message, optional, tag = "12")]
        pub payee: ::core::option::Option<super::Reference>,
        /// Amount allocated to this payable
        #[prost(message, optional, tag = "13")]
        pub amount: ::core::option::Option<super::Money>,
    }
    /// Note concerning processing
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Notes {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<notes::TypeCode>,
        /// Note explanatory text
        #[prost(message, optional, tag = "5")]
        pub text: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Notes`.
    pub mod notes {
        /// display | print | printoper
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(enumeration = "super::super::note_type_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for Person, last updated
/// 2019-11-01T09:29:23.356+11:00. A generic person record. See
/// <http://hl7.org/fhir/StructureDefinition/Person>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Person {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// A human identifier for this person
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// A name associated with the person
    #[prost(message, repeated, tag = "11")]
    pub name: prost::alloc::vec::Vec<HumanName>,
    /// A contact detail for the person
    #[prost(message, repeated, tag = "12")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    #[prost(message, optional, tag = "13")]
    pub gender: ::core::option::Option<person::GenderCode>,
    /// The date on which the person was born
    #[prost(message, optional, tag = "14")]
    pub birth_date: ::core::option::Option<Date>,
    /// One or more addresses for the person
    #[prost(message, repeated, tag = "15")]
    pub address: prost::alloc::vec::Vec<Address>,
    /// Image of the person
    #[prost(message, optional, tag = "16")]
    pub photo: ::core::option::Option<Attachment>,
    /// The organization that is the custodian of the person record
    #[prost(message, optional, tag = "17")]
    pub managing_organization: ::core::option::Option<Reference>,
    /// This person's record is in active use
    #[prost(message, optional, tag = "18")]
    pub active: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "19")]
    pub link: prost::alloc::vec::Vec<person::Link>,
}
/// Nested message and enum types in `Person`.
pub mod person {
    /// male | female | other | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct GenderCode {
        #[prost(enumeration = "super::administrative_gender_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Link to a resource that concerns the same actual person
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Link {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The resource to which this actual person is associated
        #[prost(message, optional, tag = "4")]
        pub target: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "5")]
        pub assurance: ::core::option::Option<link::AssuranceCode>,
    }
    /// Nested message and enum types in `Link`.
    pub mod link {
        /// level1 | level2 | level3 | level4
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AssuranceCode {
            #[prost(
                enumeration = "super::super::identity_assurance_level_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for PlanDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. The definition of a plan for a series of
/// actions, independent of any specific patient or context. See
/// <http://hl7.org/fhir/StructureDefinition/PlanDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PlanDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this plan definition, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the plan definition
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the plan definition
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this plan definition (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this plan definition (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Subordinate title of the plan definition
    #[prost(message, optional, tag = "15")]
    pub subtitle: ::core::option::Option<String>,
    /// order-set | clinical-protocol | eca-rule | workflow-definition
    #[prost(message, optional, tag = "16")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "17")]
    pub status: ::core::option::Option<plan_definition::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "18")]
    pub experimental: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "19")]
    pub subject: ::core::option::Option<plan_definition::SubjectX>,
    /// Date last changed
    #[prost(message, optional, tag = "20")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "21")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "22")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the plan definition
    #[prost(message, optional, tag = "23")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "24")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for plan definition (if applicable)
    #[prost(message, repeated, tag = "25")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this plan definition is defined
    #[prost(message, optional, tag = "26")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the plan
    #[prost(message, optional, tag = "27")]
    pub usage: ::core::option::Option<String>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "28")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the plan definition was approved by publisher
    #[prost(message, optional, tag = "29")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the plan definition was last reviewed
    #[prost(message, optional, tag = "30")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the plan definition is expected to be used
    #[prost(message, optional, tag = "31")]
    pub effective_period: ::core::option::Option<Period>,
    /// E.g. Education, Treatment, Assessment
    #[prost(message, repeated, tag = "32")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "33")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "34")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "35")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "36")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations
    #[prost(message, repeated, tag = "37")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Logic used by the plan definition
    #[prost(message, repeated, tag = "38")]
    pub library: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, repeated, tag = "39")]
    pub goal: prost::alloc::vec::Vec<plan_definition::Goal>,
    #[prost(message, repeated, tag = "40")]
    pub action: prost::alloc::vec::Vec<plan_definition::Action>,
}
/// Nested message and enum types in `PlanDefinition`.
pub mod plan_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Type of individual the plan definition is focused on
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SubjectX {
        #[prost(oneof = "subject_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<subject_x::Choice>,
    }
    /// Nested message and enum types in `SubjectX`.
    pub mod subject_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// What the plan is trying to accomplish
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Goal {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// E.g. Treatment, dietary, behavioral
        #[prost(message, optional, tag = "4")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Code or text describing the goal
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::CodeableConcept>,
        /// high-priority | medium-priority | low-priority
        #[prost(message, optional, tag = "6")]
        pub priority: ::core::option::Option<super::CodeableConcept>,
        /// When goal pursuit begins
        #[prost(message, optional, tag = "7")]
        pub start: ::core::option::Option<super::CodeableConcept>,
        /// What does the goal address
        #[prost(message, repeated, tag = "8")]
        pub addresses: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Supporting documentation for the goal
        #[prost(message, repeated, tag = "9")]
        pub documentation: prost::alloc::vec::Vec<super::RelatedArtifact>,
        #[prost(message, repeated, tag = "10")]
        pub target: prost::alloc::vec::Vec<goal::Target>,
    }
    /// Nested message and enum types in `Goal`.
    pub mod goal {
        /// Target outcome for the goal
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Target {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The parameter whose value is to be tracked
            #[prost(message, optional, tag = "4")]
            pub measure: ::core::option::Option<super::super::CodeableConcept>,
            #[prost(message, optional, tag = "5")]
            pub detail: ::core::option::Option<target::DetailX>,
            /// Reach goal within
            #[prost(message, optional, tag = "6")]
            pub due: ::core::option::Option<super::super::Duration>,
        }
        /// Nested message and enum types in `Target`.
        pub mod target {
            /// The target value to be achieved
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct DetailX {
                #[prost(oneof = "detail_x::Choice", tags = "1, 2, 3")]
                pub choice: ::core::option::Option<detail_x::Choice>,
            }
            /// Nested message and enum types in `DetailX`.
            pub mod detail_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Quantity(super::super::super::super::Quantity),
                    #[prost(message, tag = "2")]
                    Range(super::super::super::super::Range),
                    #[prost(message, tag = "3")]
                    CodeableConcept(super::super::super::super::CodeableConcept),
                }
            }
        }
    }
    /// Action defined by the plan
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Action {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// User-visible prefix for the action (e.g. 1. or A.)
        #[prost(message, optional, tag = "4")]
        pub prefix: ::core::option::Option<super::String>,
        /// User-visible title
        #[prost(message, optional, tag = "5")]
        pub title: ::core::option::Option<super::String>,
        /// Brief description of the action
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        /// Static text equivalent of the action, used if the dynamic aspects cannot
        /// be interpreted by the receiving system
        #[prost(message, optional, tag = "7")]
        pub text_equivalent: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "8")]
        pub priority: ::core::option::Option<action::PriorityCode>,
        /// Code representing the meaning of the action or sub-actions
        #[prost(message, repeated, tag = "9")]
        pub code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Why the action should be performed
        #[prost(message, repeated, tag = "10")]
        pub reason: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Supporting documentation for the intended performer of the action
        #[prost(message, repeated, tag = "11")]
        pub documentation: prost::alloc::vec::Vec<super::RelatedArtifact>,
        /// What goals this action supports
        #[prost(message, repeated, tag = "12")]
        pub goal_id: prost::alloc::vec::Vec<super::Id>,
        #[prost(message, optional, tag = "13")]
        pub subject: ::core::option::Option<action::SubjectX>,
        /// When the action should be triggered
        #[prost(message, repeated, tag = "14")]
        pub trigger: prost::alloc::vec::Vec<super::TriggerDefinition>,
        #[prost(message, repeated, tag = "15")]
        pub condition: prost::alloc::vec::Vec<action::Condition>,
        /// Input data requirements
        #[prost(message, repeated, tag = "16")]
        pub input: prost::alloc::vec::Vec<super::DataRequirement>,
        /// Output data definition
        #[prost(message, repeated, tag = "17")]
        pub output: prost::alloc::vec::Vec<super::DataRequirement>,
        #[prost(message, repeated, tag = "18")]
        pub related_action: prost::alloc::vec::Vec<action::RelatedAction>,
        #[prost(message, optional, tag = "19")]
        pub timing: ::core::option::Option<action::TimingX>,
        #[prost(message, repeated, tag = "20")]
        pub participant: prost::alloc::vec::Vec<action::Participant>,
        /// create | update | remove | fire-event
        #[prost(message, optional, tag = "21")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "22")]
        pub grouping_behavior: ::core::option::Option<action::GroupingBehaviorCode>,
        #[prost(message, optional, tag = "23")]
        pub selection_behavior: ::core::option::Option<action::SelectionBehaviorCode>,
        #[prost(message, optional, tag = "24")]
        pub required_behavior: ::core::option::Option<action::RequiredBehaviorCode>,
        #[prost(message, optional, tag = "25")]
        pub precheck_behavior: ::core::option::Option<action::PrecheckBehaviorCode>,
        #[prost(message, optional, tag = "26")]
        pub cardinality_behavior: ::core::option::Option<action::CardinalityBehaviorCode>,
        #[prost(message, optional, tag = "27")]
        pub definition: ::core::option::Option<action::DefinitionX>,
        /// Transform to apply the template
        #[prost(message, optional, tag = "28")]
        pub transform: ::core::option::Option<super::Canonical>,
        #[prost(message, repeated, tag = "29")]
        pub dynamic_value: prost::alloc::vec::Vec<action::DynamicValue>,
        /// A sub-action
        #[prost(message, repeated, tag = "30")]
        pub action: prost::alloc::vec::Vec<Action>,
    }
    /// Nested message and enum types in `Action`.
    pub mod action {
        /// routine | urgent | asap | stat
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PriorityCode {
            #[prost(enumeration = "super::super::request_priority_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Type of individual the action is focused on
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SubjectX {
            #[prost(oneof = "subject_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<subject_x::Choice>,
        }
        /// Nested message and enum types in `SubjectX`.
        pub mod subject_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
        /// Whether or not the action is applicable
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Condition {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub kind: ::core::option::Option<condition::KindCode>,
            /// Boolean-valued expression
            #[prost(message, optional, tag = "5")]
            pub expression: ::core::option::Option<super::super::Expression>,
        }
        /// Nested message and enum types in `Condition`.
        pub mod condition {
            /// applicability | start | stop
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct KindCode {
                #[prost(
                    enumeration = "super::super::super::action_condition_kind_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
        /// Relationship to another action
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RelatedAction {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// What action is this related to
            #[prost(message, optional, tag = "4")]
            pub action_id: ::core::option::Option<super::super::Id>,
            #[prost(message, optional, tag = "5")]
            pub relationship: ::core::option::Option<related_action::RelationshipCode>,
            #[prost(message, optional, tag = "6")]
            pub offset: ::core::option::Option<related_action::OffsetX>,
        }
        /// Nested message and enum types in `RelatedAction`.
        pub mod related_action {
            /// before-start | before | before-end | concurrent-with-start | concurrent
            /// | concurrent-with-end | after-start | after | after-end
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct RelationshipCode {
                #[prost(
                    enumeration = "super::super::super::action_relationship_type_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// Time offset for the relationship
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct OffsetX {
                #[prost(oneof = "offset_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<offset_x::Choice>,
            }
            /// Nested message and enum types in `OffsetX`.
            pub mod offset_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Duration(super::super::super::super::Duration),
                    #[prost(message, tag = "2")]
                    Range(super::super::super::super::Range),
                }
            }
        }
        /// When the action should take place
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimingX {
            #[prost(oneof = "timing_x::Choice", tags = "1, 2, 3, 4, 5, 6")]
            pub choice: ::core::option::Option<timing_x::Choice>,
        }
        /// Nested message and enum types in `TimingX`.
        pub mod timing_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Age(super::super::super::Age),
                #[prost(message, tag = "3")]
                Period(super::super::super::Period),
                #[prost(message, tag = "4")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "5")]
                Range(super::super::super::Range),
                #[prost(message, tag = "6")]
                Timing(super::super::super::Timing),
            }
        }
        /// Who should participate in the action
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Participant {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<participant::TypeCode>,
            /// E.g. Nurse, Surgeon, Parent
            #[prost(message, optional, tag = "5")]
            pub role: ::core::option::Option<super::super::CodeableConcept>,
        }
        /// Nested message and enum types in `Participant`.
        pub mod participant {
            /// patient | practitioner | related-person | device
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct TypeCode {
                #[prost(
                    enumeration = "super::super::super::action_participant_type_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
        /// visual-group | logical-group | sentence-group
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct GroupingBehaviorCode {
            #[prost(
                enumeration = "super::super::action_grouping_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// any | all | all-or-none | exactly-one | at-most-one | one-or-more
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SelectionBehaviorCode {
            #[prost(
                enumeration = "super::super::action_selection_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// must | could | must-unless-documented
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RequiredBehaviorCode {
            #[prost(
                enumeration = "super::super::action_required_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// yes | no
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PrecheckBehaviorCode {
            #[prost(
                enumeration = "super::super::action_precheck_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// single | multiple
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CardinalityBehaviorCode {
            #[prost(
                enumeration = "super::super::action_cardinality_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Description of the activity to be performed
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DefinitionX {
            #[prost(oneof = "definition_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<definition_x::Choice>,
        }
        /// Nested message and enum types in `DefinitionX`.
        pub mod definition_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Canonical(super::super::super::Canonical),
                #[prost(message, tag = "2")]
                Uri(super::super::super::Uri),
            }
        }
        /// Dynamic aspects of the definition
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DynamicValue {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The path to the element to be set dynamically
            #[prost(message, optional, tag = "4")]
            pub path: ::core::option::Option<super::super::String>,
            /// An expression that provides the dynamic value for the customization
            #[prost(message, optional, tag = "5")]
            pub expression: ::core::option::Option<super::super::Expression>,
        }
    }
}
/// Auto-generated from StructureDefinition for Practitioner, last updated
/// 2019-11-01T09:29:23.356+11:00. A person with a  formal responsibility in the
/// provisioning of healthcare or related services. See
/// <http://hl7.org/fhir/StructureDefinition/Practitioner>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Practitioner {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// An identifier for the person as this agent
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this practitioner's record is in active use
    #[prost(message, optional, tag = "11")]
    pub active: ::core::option::Option<Boolean>,
    /// The name(s) associated with the practitioner
    #[prost(message, repeated, tag = "12")]
    pub name: prost::alloc::vec::Vec<HumanName>,
    /// A contact detail for the practitioner (that apply to all roles)
    #[prost(message, repeated, tag = "13")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// Address(es) of the practitioner that are not role specific (typically home
    /// address)
    #[prost(message, repeated, tag = "14")]
    pub address: prost::alloc::vec::Vec<Address>,
    #[prost(message, optional, tag = "15")]
    pub gender: ::core::option::Option<practitioner::GenderCode>,
    /// The date  on which the practitioner was born
    #[prost(message, optional, tag = "16")]
    pub birth_date: ::core::option::Option<Date>,
    /// Image of the person
    #[prost(message, repeated, tag = "17")]
    pub photo: prost::alloc::vec::Vec<Attachment>,
    #[prost(message, repeated, tag = "18")]
    pub qualification: prost::alloc::vec::Vec<practitioner::Qualification>,
    /// A language the practitioner can use in patient communication
    #[prost(message, repeated, tag = "19")]
    pub communication: prost::alloc::vec::Vec<CodeableConcept>,
}
/// Nested message and enum types in `Practitioner`.
pub mod practitioner {
    /// male | female | other | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct GenderCode {
        #[prost(enumeration = "super::administrative_gender_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Certification, licenses, or training pertaining to the provision of care
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Qualification {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// An identifier for this qualification for the practitioner
        #[prost(message, repeated, tag = "4")]
        pub identifier: prost::alloc::vec::Vec<super::Identifier>,
        /// Coded representation of the qualification
        #[prost(message, optional, tag = "5")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Period during which the qualification is valid
        #[prost(message, optional, tag = "6")]
        pub period: ::core::option::Option<super::Period>,
        /// Organization that regulates and issues the qualification
        #[prost(message, optional, tag = "7")]
        pub issuer: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for PractitionerRole, last updated
/// 2019-11-01T09:29:23.356+11:00. Roles/organizations the practitioner is
/// associated with. See <http://hl7.org/fhir/StructureDefinition/PractitionerRole>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PractitionerRole {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifiers that are specific to a role/location
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this practitioner role record is in active use
    #[prost(message, optional, tag = "11")]
    pub active: ::core::option::Option<Boolean>,
    /// The period during which the practitioner is authorized to perform in these
    /// role(s)
    #[prost(message, optional, tag = "12")]
    pub period: ::core::option::Option<Period>,
    /// Practitioner that is able to provide the defined services for the
    /// organization
    #[prost(message, optional, tag = "13")]
    pub practitioner: ::core::option::Option<Reference>,
    /// Organization where the roles are available
    #[prost(message, optional, tag = "14")]
    pub organization: ::core::option::Option<Reference>,
    /// Roles which this practitioner may perform
    #[prost(message, repeated, tag = "15")]
    pub code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Specific specialty of the practitioner
    #[prost(message, repeated, tag = "16")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// The location(s) at which this practitioner provides care
    #[prost(message, repeated, tag = "17")]
    pub location: prost::alloc::vec::Vec<Reference>,
    /// The list of healthcare services that this worker provides for this role's
    /// Organization/Location(s)
    #[prost(message, repeated, tag = "18")]
    pub healthcare_service: prost::alloc::vec::Vec<Reference>,
    /// Contact details that are specific to the role/location/service
    #[prost(message, repeated, tag = "19")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    #[prost(message, repeated, tag = "20")]
    pub available_time: prost::alloc::vec::Vec<practitioner_role::AvailableTime>,
    #[prost(message, repeated, tag = "21")]
    pub not_available: prost::alloc::vec::Vec<practitioner_role::NotAvailable>,
    /// Description of availability exceptions
    #[prost(message, optional, tag = "22")]
    pub availability_exceptions: ::core::option::Option<String>,
    /// Technical endpoints providing access to services operated for the
    /// practitioner with this role
    #[prost(message, repeated, tag = "23")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `PractitionerRole`.
pub mod practitioner_role {
    /// Times the Service Site is available
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AvailableTime {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub days_of_week: prost::alloc::vec::Vec<available_time::DaysOfWeekCode>,
        /// Always available? e.g. 24 hour service
        #[prost(message, optional, tag = "5")]
        pub all_day: ::core::option::Option<super::Boolean>,
        /// Opening time of day (ignored if allDay = true)
        #[prost(message, optional, tag = "6")]
        pub available_start_time: ::core::option::Option<super::Time>,
        /// Closing time of day (ignored if allDay = true)
        #[prost(message, optional, tag = "7")]
        pub available_end_time: ::core::option::Option<super::Time>,
    }
    /// Nested message and enum types in `AvailableTime`.
    pub mod available_time {
        /// mon | tue | wed | thu | fri | sat | sun
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DaysOfWeekCode {
            #[prost(enumeration = "super::super::days_of_week_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Not available during this time due to provided reason
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct NotAvailable {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reason presented to the user explaining why time not available
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Service not available from this date
        #[prost(message, optional, tag = "5")]
        pub during: ::core::option::Option<super::Period>,
    }
}
/// Auto-generated from StructureDefinition for Procedure, last updated
/// 2019-11-01T09:29:23.356+11:00. An action that is being or was performed on a
/// patient. See <http://hl7.org/fhir/StructureDefinition/Procedure>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Procedure {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Identifiers for this procedure
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates FHIR protocol or definition
    #[prost(message, repeated, tag = "11")]
    pub instantiates_canonical: prost::alloc::vec::Vec<Canonical>,
    /// Instantiates external protocol or definition
    #[prost(message, repeated, tag = "12")]
    pub instantiates_uri: prost::alloc::vec::Vec<Uri>,
    /// A request for this procedure
    #[prost(message, repeated, tag = "13")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced event
    #[prost(message, repeated, tag = "14")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<procedure::StatusCode>,
    /// Reason for current status
    #[prost(message, optional, tag = "16")]
    pub status_reason: ::core::option::Option<CodeableConcept>,
    /// Classification of the procedure
    #[prost(message, optional, tag = "17")]
    pub category: ::core::option::Option<CodeableConcept>,
    /// Identification of the procedure
    #[prost(message, optional, tag = "18")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who the procedure was performed on
    #[prost(message, optional, tag = "19")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter created as part of
    #[prost(message, optional, tag = "20")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "21")]
    pub performed: ::core::option::Option<procedure::PerformedX>,
    /// Who recorded the procedure
    #[prost(message, optional, tag = "22")]
    pub recorder: ::core::option::Option<Reference>,
    /// Person who asserts this procedure
    #[prost(message, optional, tag = "23")]
    pub asserter: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "24")]
    pub performer: prost::alloc::vec::Vec<procedure::Performer>,
    /// Where the procedure happened
    #[prost(message, optional, tag = "25")]
    pub location: ::core::option::Option<Reference>,
    /// Coded reason procedure performed
    #[prost(message, repeated, tag = "26")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// The justification that the procedure was performed
    #[prost(message, repeated, tag = "27")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Target body sites
    #[prost(message, repeated, tag = "28")]
    pub body_site: prost::alloc::vec::Vec<CodeableConcept>,
    /// The result of procedure
    #[prost(message, optional, tag = "29")]
    pub outcome: ::core::option::Option<CodeableConcept>,
    /// Any report resulting from the procedure
    #[prost(message, repeated, tag = "30")]
    pub report: prost::alloc::vec::Vec<Reference>,
    /// Complication following the procedure
    #[prost(message, repeated, tag = "31")]
    pub complication: prost::alloc::vec::Vec<CodeableConcept>,
    /// A condition that is a result of the procedure
    #[prost(message, repeated, tag = "32")]
    pub complication_detail: prost::alloc::vec::Vec<Reference>,
    /// Instructions for follow up
    #[prost(message, repeated, tag = "33")]
    pub follow_up: prost::alloc::vec::Vec<CodeableConcept>,
    /// Additional information about the procedure
    #[prost(message, repeated, tag = "34")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "35")]
    pub focal_device: prost::alloc::vec::Vec<procedure::FocalDevice>,
    /// Items used during procedure
    #[prost(message, repeated, tag = "36")]
    pub used_reference: prost::alloc::vec::Vec<Reference>,
    /// Coded items used during the procedure
    #[prost(message, repeated, tag = "37")]
    pub used_code: prost::alloc::vec::Vec<CodeableConcept>,
}
/// Nested message and enum types in `Procedure`.
pub mod procedure {
    /// preparation | in-progress | not-done | on-hold | stopped | completed |
    /// entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::event_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// When the procedure was performed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PerformedX {
        #[prost(oneof = "performed_x::Choice", tags = "1, 2, 3, 4, 5")]
        pub choice: ::core::option::Option<performed_x::Choice>,
    }
    /// Nested message and enum types in `PerformedX`.
    pub mod performed_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            StringValue(super::super::String),
            #[prost(message, tag = "4")]
            Age(super::super::Age),
            #[prost(message, tag = "5")]
            Range(super::super::Range),
        }
    }
    /// The people who performed the procedure
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Performer {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of performance
        #[prost(message, optional, tag = "4")]
        pub function: ::core::option::Option<super::CodeableConcept>,
        /// The reference to the practitioner
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
        /// Organization the device or practitioner was acting for
        #[prost(message, optional, tag = "6")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
    /// Manipulated, implanted, or removed device
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FocalDevice {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Kind of change to device
        #[prost(message, optional, tag = "4")]
        pub action: ::core::option::Option<super::CodeableConcept>,
        /// Device that was changed
        #[prost(message, optional, tag = "5")]
        pub manipulated: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for Provenance, last updated
/// 2019-11-01T09:29:23.356+11:00. Who, What, When for a set of resources. See
/// <http://hl7.org/fhir/StructureDefinition/Provenance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Provenance {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Target Reference(s) (usually version specific)
    #[prost(message, repeated, tag = "10")]
    pub target: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "11")]
    pub occurred: ::core::option::Option<provenance::OccurredX>,
    /// When the activity was recorded / updated
    #[prost(message, optional, tag = "12")]
    pub recorded: ::core::option::Option<Instant>,
    /// Policy or plan the activity was defined by
    #[prost(message, repeated, tag = "13")]
    pub policy: prost::alloc::vec::Vec<Uri>,
    /// Where the activity occurred, if relevant
    #[prost(message, optional, tag = "14")]
    pub location: ::core::option::Option<Reference>,
    /// Reason the activity is occurring
    #[prost(message, repeated, tag = "15")]
    pub reason: prost::alloc::vec::Vec<CodeableConcept>,
    /// Activity that occurred
    #[prost(message, optional, tag = "16")]
    pub activity: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "17")]
    pub agent: prost::alloc::vec::Vec<provenance::Agent>,
    #[prost(message, repeated, tag = "18")]
    pub entity: prost::alloc::vec::Vec<provenance::Entity>,
    /// Signature on target
    #[prost(message, repeated, tag = "19")]
    pub signature: prost::alloc::vec::Vec<Signature>,
}
/// Nested message and enum types in `Provenance`.
pub mod provenance {
    /// When the activity occurred
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OccurredX {
        #[prost(oneof = "occurred_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<occurred_x::Choice>,
    }
    /// Nested message and enum types in `OccurredX`.
    pub mod occurred_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Period(super::super::Period),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
        }
    }
    /// Actor involved
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Agent {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// How the agent participated
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// What the agents role was
        #[prost(message, repeated, tag = "5")]
        pub role: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Who participated
        #[prost(message, optional, tag = "6")]
        pub who: ::core::option::Option<super::Reference>,
        /// Who the agent is representing
        #[prost(message, optional, tag = "7")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
    /// An entity used in this activity
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Entity {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub role: ::core::option::Option<entity::RoleCode>,
        /// Identity of entity
        #[prost(message, optional, tag = "5")]
        pub what: ::core::option::Option<super::Reference>,
        /// Entity is attributed to this agent
        #[prost(message, repeated, tag = "6")]
        pub agent: prost::alloc::vec::Vec<Agent>,
    }
    /// Nested message and enum types in `Entity`.
    pub mod entity {
        /// derivation | revision | quotation | source | removal
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RoleCode {
            #[prost(
                enumeration = "super::super::provenance_entity_role_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for Questionnaire, last updated
/// 2019-11-01T09:29:23.356+11:00. A structured set of questions. See
/// <http://hl7.org/fhir/StructureDefinition/Questionnaire>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Questionnaire {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this questionnaire, represented as a URI (globally
    /// unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the questionnaire
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the questionnaire
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this questionnaire (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this questionnaire (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Instantiates protocol or definition
    #[prost(message, repeated, tag = "15")]
    pub derived_from: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<questionnaire::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "17")]
    pub experimental: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "18")]
    pub subject_type: prost::alloc::vec::Vec<questionnaire::SubjectTypeCode>,
    /// Date last changed
    #[prost(message, optional, tag = "19")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "20")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "21")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the questionnaire
    #[prost(message, optional, tag = "22")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "23")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for questionnaire (if applicable)
    #[prost(message, repeated, tag = "24")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this questionnaire is defined
    #[prost(message, optional, tag = "25")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "26")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the questionnaire was approved by publisher
    #[prost(message, optional, tag = "27")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the questionnaire was last reviewed
    #[prost(message, optional, tag = "28")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the questionnaire is expected to be used
    #[prost(message, optional, tag = "29")]
    pub effective_period: ::core::option::Option<Period>,
    /// Concept that represents the overall questionnaire
    #[prost(message, repeated, tag = "30")]
    pub code: prost::alloc::vec::Vec<Coding>,
    #[prost(message, repeated, tag = "31")]
    pub item: prost::alloc::vec::Vec<questionnaire::Item>,
}
/// Nested message and enum types in `Questionnaire`.
pub mod questionnaire {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Resource that can be subject of QuestionnaireResponse
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SubjectTypeCode {
        #[prost(enumeration = "super::resource_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Questions and sections within the Questionnaire
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Unique id for item in questionnaire
        #[prost(message, optional, tag = "4")]
        pub link_id: ::core::option::Option<super::String>,
        /// ElementDefinition - details for the item
        #[prost(message, optional, tag = "5")]
        pub definition: ::core::option::Option<super::Uri>,
        /// Corresponding concept for this item in a terminology
        #[prost(message, repeated, tag = "6")]
        pub code: prost::alloc::vec::Vec<super::Coding>,
        /// E.g. "1(a)", "2.5.3"
        #[prost(message, optional, tag = "7")]
        pub prefix: ::core::option::Option<super::String>,
        /// Primary text for the item
        #[prost(message, optional, tag = "8")]
        pub text: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "9")]
        pub r#type: ::core::option::Option<item::TypeCode>,
        #[prost(message, repeated, tag = "10")]
        pub enable_when: prost::alloc::vec::Vec<item::EnableWhen>,
        #[prost(message, optional, tag = "11")]
        pub enable_behavior: ::core::option::Option<item::EnableBehaviorCode>,
        /// Whether the item must be included in data results
        #[prost(message, optional, tag = "12")]
        pub required: ::core::option::Option<super::Boolean>,
        /// Whether the item may repeat
        #[prost(message, optional, tag = "13")]
        pub repeats: ::core::option::Option<super::Boolean>,
        /// Don't allow human editing
        #[prost(message, optional, tag = "14")]
        pub read_only: ::core::option::Option<super::Boolean>,
        /// No more than this many characters
        #[prost(message, optional, tag = "15")]
        pub max_length: ::core::option::Option<super::Integer>,
        /// Valueset containing permitted answers
        #[prost(message, optional, tag = "16")]
        pub answer_value_set: ::core::option::Option<super::Canonical>,
        #[prost(message, repeated, tag = "17")]
        pub answer_option: prost::alloc::vec::Vec<item::AnswerOption>,
        #[prost(message, repeated, tag = "18")]
        pub initial: prost::alloc::vec::Vec<item::Initial>,
        /// Nested questionnaire items
        #[prost(message, repeated, tag = "19")]
        pub item: prost::alloc::vec::Vec<Item>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// group | display | boolean | decimal | integer | date | dateTime +
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(
                enumeration = "super::super::questionnaire_item_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Only allow data when
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct EnableWhen {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Question that determines whether item is enabled
            #[prost(message, optional, tag = "4")]
            pub question: ::core::option::Option<super::super::String>,
            #[prost(message, optional, tag = "5")]
            pub operator: ::core::option::Option<enable_when::OperatorCode>,
            #[prost(message, optional, tag = "6")]
            pub answer: ::core::option::Option<enable_when::AnswerX>,
        }
        /// Nested message and enum types in `EnableWhen`.
        pub mod enable_when {
            /// exists | = | != | > | < | >= | <=
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct OperatorCode {
                #[prost(
                    enumeration = "super::super::super::questionnaire_item_operator_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// Value for question comparison based on operator
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct AnswerX {
                #[prost(oneof = "answer_x::Choice", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
                pub choice: ::core::option::Option<answer_x::Choice>,
            }
            /// Nested message and enum types in `AnswerX`.
            pub mod answer_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "2")]
                    Decimal(super::super::super::super::Decimal),
                    #[prost(message, tag = "3")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "4")]
                    Date(super::super::super::super::Date),
                    #[prost(message, tag = "5")]
                    DateTime(super::super::super::super::DateTime),
                    #[prost(message, tag = "6")]
                    Time(super::super::super::super::Time),
                    #[prost(message, tag = "7")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "8")]
                    Coding(super::super::super::super::Coding),
                    #[prost(message, tag = "9")]
                    Quantity(super::super::super::super::Quantity),
                    #[prost(message, tag = "10")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
        /// all | any
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct EnableBehaviorCode {
            #[prost(
                enumeration = "super::super::enable_when_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Permitted answer
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AnswerOption {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub value: ::core::option::Option<answer_option::ValueX>,
            /// Whether option is selected by default
            #[prost(message, optional, tag = "5")]
            pub initial_selected: ::core::option::Option<super::super::Boolean>,
        }
        /// Nested message and enum types in `AnswerOption`.
        pub mod answer_option {
            /// Answer value
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ValueX {
                #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5, 6")]
                pub choice: ::core::option::Option<value_x::Choice>,
            }
            /// Nested message and enum types in `ValueX`.
            pub mod value_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "2")]
                    Date(super::super::super::super::Date),
                    #[prost(message, tag = "3")]
                    Time(super::super::super::super::Time),
                    #[prost(message, tag = "4")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "5")]
                    Coding(super::super::super::super::Coding),
                    #[prost(message, tag = "6")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
        /// Initial value(s) when item is first rendered
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Initial {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub value: ::core::option::Option<initial::ValueX>,
        }
        /// Nested message and enum types in `Initial`.
        pub mod initial {
            /// Actual value for initializing the question
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ValueX {
                #[prost(
                    oneof = "value_x::Choice",
                    tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12"
                )]
                pub choice: ::core::option::Option<value_x::Choice>,
            }
            /// Nested message and enum types in `ValueX`.
            pub mod value_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "2")]
                    Decimal(super::super::super::super::Decimal),
                    #[prost(message, tag = "3")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "4")]
                    Date(super::super::super::super::Date),
                    #[prost(message, tag = "5")]
                    DateTime(super::super::super::super::DateTime),
                    #[prost(message, tag = "6")]
                    Time(super::super::super::super::Time),
                    #[prost(message, tag = "7")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "8")]
                    Uri(super::super::super::super::Uri),
                    #[prost(message, tag = "9")]
                    Attachment(super::super::super::super::Attachment),
                    #[prost(message, tag = "10")]
                    Coding(super::super::super::super::Coding),
                    #[prost(message, tag = "11")]
                    Quantity(super::super::super::super::Quantity),
                    #[prost(message, tag = "12")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for QuestionnaireResponse, last
/// updated 2019-11-01T09:29:23.356+11:00. A structured set of questions and
/// their answers. See
/// <http://hl7.org/fhir/StructureDefinition/QuestionnaireResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique id for this set of answers
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Request fulfilled by this QuestionnaireResponse
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of this action
    #[prost(message, repeated, tag = "12")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// Form being answered
    #[prost(message, optional, tag = "13")]
    pub questionnaire: ::core::option::Option<Canonical>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<questionnaire_response::StatusCode>,
    /// The subject of the questions
    #[prost(message, optional, tag = "15")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter created as part of
    #[prost(message, optional, tag = "16")]
    pub encounter: ::core::option::Option<Reference>,
    /// Date the answers were gathered
    #[prost(message, optional, tag = "17")]
    pub authored: ::core::option::Option<DateTime>,
    /// Person who received and recorded the answers
    #[prost(message, optional, tag = "18")]
    pub author: ::core::option::Option<Reference>,
    /// The person who answered the questions
    #[prost(message, optional, tag = "19")]
    pub source: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "20")]
    pub item: prost::alloc::vec::Vec<questionnaire_response::Item>,
}
/// Nested message and enum types in `QuestionnaireResponse`.
pub mod questionnaire_response {
    /// in-progress | completed | amended | entered-in-error | stopped
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::questionnaire_response_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Groups and questions
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Pointer to specific item from Questionnaire
        #[prost(message, optional, tag = "4")]
        pub link_id: ::core::option::Option<super::String>,
        /// ElementDefinition - details for the item
        #[prost(message, optional, tag = "5")]
        pub definition: ::core::option::Option<super::Uri>,
        /// Name for group or question text
        #[prost(message, optional, tag = "6")]
        pub text: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "7")]
        pub answer: prost::alloc::vec::Vec<item::Answer>,
        /// Nested questionnaire response items
        #[prost(message, repeated, tag = "8")]
        pub item: prost::alloc::vec::Vec<Item>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// The response(s) to the question
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Answer {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub value: ::core::option::Option<answer::ValueX>,
            /// Nested groups and questions
            #[prost(message, repeated, tag = "5")]
            pub item: prost::alloc::vec::Vec<super::Item>,
        }
        /// Nested message and enum types in `Answer`.
        pub mod answer {
            /// Single-valued answer to the question
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ValueX {
                #[prost(
                    oneof = "value_x::Choice",
                    tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12"
                )]
                pub choice: ::core::option::Option<value_x::Choice>,
            }
            /// Nested message and enum types in `ValueX`.
            pub mod value_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "2")]
                    Decimal(super::super::super::super::Decimal),
                    #[prost(message, tag = "3")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "4")]
                    Date(super::super::super::super::Date),
                    #[prost(message, tag = "5")]
                    DateTime(super::super::super::super::DateTime),
                    #[prost(message, tag = "6")]
                    Time(super::super::super::super::Time),
                    #[prost(message, tag = "7")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "8")]
                    Uri(super::super::super::super::Uri),
                    #[prost(message, tag = "9")]
                    Attachment(super::super::super::super::Attachment),
                    #[prost(message, tag = "10")]
                    Coding(super::super::super::super::Coding),
                    #[prost(message, tag = "11")]
                    Quantity(super::super::super::super::Quantity),
                    #[prost(message, tag = "12")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for RelatedPerson, last updated
/// 2019-11-01T09:29:23.356+11:00. A person that is related to a patient, but who
/// is not a direct target of care. See
/// <http://hl7.org/fhir/StructureDefinition/RelatedPerson>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RelatedPerson {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// A human identifier for this person
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this related person's record is in active use
    #[prost(message, optional, tag = "11")]
    pub active: ::core::option::Option<Boolean>,
    /// The patient this person is related to
    #[prost(message, optional, tag = "12")]
    pub patient: ::core::option::Option<Reference>,
    /// The nature of the relationship
    #[prost(message, repeated, tag = "13")]
    pub relationship: prost::alloc::vec::Vec<CodeableConcept>,
    /// A name associated with the person
    #[prost(message, repeated, tag = "14")]
    pub name: prost::alloc::vec::Vec<HumanName>,
    /// A contact detail for the person
    #[prost(message, repeated, tag = "15")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    #[prost(message, optional, tag = "16")]
    pub gender: ::core::option::Option<related_person::GenderCode>,
    /// The date on which the related person was born
    #[prost(message, optional, tag = "17")]
    pub birth_date: ::core::option::Option<Date>,
    /// Address where the related person can be contacted or visited
    #[prost(message, repeated, tag = "18")]
    pub address: prost::alloc::vec::Vec<Address>,
    /// Image of the person
    #[prost(message, repeated, tag = "19")]
    pub photo: prost::alloc::vec::Vec<Attachment>,
    /// Period of time that this relationship is considered valid
    #[prost(message, optional, tag = "20")]
    pub period: ::core::option::Option<Period>,
    #[prost(message, repeated, tag = "21")]
    pub communication: prost::alloc::vec::Vec<related_person::Communication>,
}
/// Nested message and enum types in `RelatedPerson`.
pub mod related_person {
    /// male | female | other | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct GenderCode {
        #[prost(enumeration = "super::administrative_gender_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// A language which may be used to communicate with about the patient's health
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Communication {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The language which can be used to communicate with the patient about his
        /// or her health
        #[prost(message, optional, tag = "4")]
        pub language: ::core::option::Option<super::CodeableConcept>,
        /// Language preference indicator
        #[prost(message, optional, tag = "5")]
        pub preferred: ::core::option::Option<super::Boolean>,
    }
}
/// Auto-generated from StructureDefinition for RequestGroup, last updated
/// 2019-11-01T09:29:23.356+11:00. A group of related requests. See
/// <http://hl7.org/fhir/StructureDefinition/RequestGroup>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RequestGroup {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates FHIR protocol or definition
    #[prost(message, repeated, tag = "11")]
    pub instantiates_canonical: prost::alloc::vec::Vec<Canonical>,
    /// Instantiates external protocol or definition
    #[prost(message, repeated, tag = "12")]
    pub instantiates_uri: prost::alloc::vec::Vec<Uri>,
    /// Fulfills plan, proposal, or order
    #[prost(message, repeated, tag = "13")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Request(s) replaced by this request
    #[prost(message, repeated, tag = "14")]
    pub replaces: prost::alloc::vec::Vec<Reference>,
    /// Composite request this is part of
    #[prost(message, optional, tag = "15")]
    pub group_identifier: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<request_group::StatusCode>,
    #[prost(message, optional, tag = "17")]
    pub intent: ::core::option::Option<request_group::IntentCode>,
    #[prost(message, optional, tag = "18")]
    pub priority: ::core::option::Option<request_group::PriorityCode>,
    /// What's being requested/ordered
    #[prost(message, optional, tag = "19")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who the request group is about
    #[prost(message, optional, tag = "20")]
    pub subject: ::core::option::Option<Reference>,
    /// Created as part of
    #[prost(message, optional, tag = "21")]
    pub encounter: ::core::option::Option<Reference>,
    /// When the request group was authored
    #[prost(message, optional, tag = "22")]
    pub authored_on: ::core::option::Option<DateTime>,
    /// Device or practitioner that authored the request group
    #[prost(message, optional, tag = "23")]
    pub author: ::core::option::Option<Reference>,
    /// Why the request group is needed
    #[prost(message, repeated, tag = "24")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why the request group is needed
    #[prost(message, repeated, tag = "25")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Additional notes about the response
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "27")]
    pub action: prost::alloc::vec::Vec<request_group::Action>,
}
/// Nested message and enum types in `RequestGroup`.
pub mod request_group {
    /// draft | active | on-hold | revoked | completed | entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::request_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// proposal | plan | directive | order | original-order | reflex-order |
    /// filler-order | instance-order | option
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct IntentCode {
        #[prost(enumeration = "super::request_intent_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// routine | urgent | asap | stat
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PriorityCode {
        #[prost(enumeration = "super::request_priority_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Proposed actions, if any
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Action {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// User-visible prefix for the action (e.g. 1. or A.)
        #[prost(message, optional, tag = "4")]
        pub prefix: ::core::option::Option<super::String>,
        /// User-visible title
        #[prost(message, optional, tag = "5")]
        pub title: ::core::option::Option<super::String>,
        /// Short description of the action
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        /// Static text equivalent of the action, used if the dynamic aspects cannot
        /// be interpreted by the receiving system
        #[prost(message, optional, tag = "7")]
        pub text_equivalent: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "8")]
        pub priority: ::core::option::Option<action::PriorityCode>,
        /// Code representing the meaning of the action or sub-actions
        #[prost(message, repeated, tag = "9")]
        pub code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Supporting documentation for the intended performer of the action
        #[prost(message, repeated, tag = "10")]
        pub documentation: prost::alloc::vec::Vec<super::RelatedArtifact>,
        #[prost(message, repeated, tag = "11")]
        pub condition: prost::alloc::vec::Vec<action::Condition>,
        #[prost(message, repeated, tag = "12")]
        pub related_action: prost::alloc::vec::Vec<action::RelatedAction>,
        #[prost(message, optional, tag = "13")]
        pub timing: ::core::option::Option<action::TimingX>,
        /// Who should perform the action
        #[prost(message, repeated, tag = "14")]
        pub participant: prost::alloc::vec::Vec<super::Reference>,
        /// create | update | remove | fire-event
        #[prost(message, optional, tag = "15")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "16")]
        pub grouping_behavior: ::core::option::Option<action::GroupingBehaviorCode>,
        #[prost(message, optional, tag = "17")]
        pub selection_behavior: ::core::option::Option<action::SelectionBehaviorCode>,
        #[prost(message, optional, tag = "18")]
        pub required_behavior: ::core::option::Option<action::RequiredBehaviorCode>,
        #[prost(message, optional, tag = "19")]
        pub precheck_behavior: ::core::option::Option<action::PrecheckBehaviorCode>,
        #[prost(message, optional, tag = "20")]
        pub cardinality_behavior: ::core::option::Option<action::CardinalityBehaviorCode>,
        /// The target of the action
        #[prost(message, optional, tag = "21")]
        pub resource: ::core::option::Option<super::Reference>,
        /// Sub action
        #[prost(message, repeated, tag = "22")]
        pub action: prost::alloc::vec::Vec<Action>,
    }
    /// Nested message and enum types in `Action`.
    pub mod action {
        /// routine | urgent | asap | stat
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PriorityCode {
            #[prost(enumeration = "super::super::request_priority_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Whether or not the action is applicable
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Condition {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub kind: ::core::option::Option<condition::KindCode>,
            /// Boolean-valued expression
            #[prost(message, optional, tag = "5")]
            pub expression: ::core::option::Option<super::super::Expression>,
        }
        /// Nested message and enum types in `Condition`.
        pub mod condition {
            /// applicability | start | stop
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct KindCode {
                #[prost(
                    enumeration = "super::super::super::action_condition_kind_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
        /// Relationship to another action
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RelatedAction {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// What action this is related to
            #[prost(message, optional, tag = "4")]
            pub action_id: ::core::option::Option<super::super::Id>,
            #[prost(message, optional, tag = "5")]
            pub relationship: ::core::option::Option<related_action::RelationshipCode>,
            #[prost(message, optional, tag = "6")]
            pub offset: ::core::option::Option<related_action::OffsetX>,
        }
        /// Nested message and enum types in `RelatedAction`.
        pub mod related_action {
            /// before-start | before | before-end | concurrent-with-start | concurrent
            /// | concurrent-with-end | after-start | after | after-end
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct RelationshipCode {
                #[prost(
                    enumeration = "super::super::super::action_relationship_type_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
            /// Time offset for the relationship
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct OffsetX {
                #[prost(oneof = "offset_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<offset_x::Choice>,
            }
            /// Nested message and enum types in `OffsetX`.
            pub mod offset_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Duration(super::super::super::super::Duration),
                    #[prost(message, tag = "2")]
                    Range(super::super::super::super::Range),
                }
            }
        }
        /// When the action should take place
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimingX {
            #[prost(oneof = "timing_x::Choice", tags = "1, 2, 3, 4, 5, 6")]
            pub choice: ::core::option::Option<timing_x::Choice>,
        }
        /// Nested message and enum types in `TimingX`.
        pub mod timing_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Age(super::super::super::Age),
                #[prost(message, tag = "3")]
                Period(super::super::super::Period),
                #[prost(message, tag = "4")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "5")]
                Range(super::super::super::Range),
                #[prost(message, tag = "6")]
                Timing(super::super::super::Timing),
            }
        }
        /// visual-group | logical-group | sentence-group
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct GroupingBehaviorCode {
            #[prost(
                enumeration = "super::super::action_grouping_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// any | all | all-or-none | exactly-one | at-most-one | one-or-more
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SelectionBehaviorCode {
            #[prost(
                enumeration = "super::super::action_selection_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// must | could | must-unless-documented
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RequiredBehaviorCode {
            #[prost(
                enumeration = "super::super::action_required_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// yes | no
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PrecheckBehaviorCode {
            #[prost(
                enumeration = "super::super::action_precheck_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// single | multiple
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CardinalityBehaviorCode {
            #[prost(
                enumeration = "super::super::action_cardinality_behavior_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for ResearchDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. A research context or question. See
/// <http://hl7.org/fhir/StructureDefinition/ResearchDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this research definition, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the research definition
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the research definition
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this research definition (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this research definition (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Title for use in informal contexts
    #[prost(message, optional, tag = "15")]
    pub short_title: ::core::option::Option<String>,
    /// Subordinate title of the ResearchDefinition
    #[prost(message, optional, tag = "16")]
    pub subtitle: ::core::option::Option<String>,
    #[prost(message, optional, tag = "17")]
    pub status: ::core::option::Option<research_definition::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "18")]
    pub experimental: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "19")]
    pub subject: ::core::option::Option<research_definition::SubjectX>,
    /// Date last changed
    #[prost(message, optional, tag = "20")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "21")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "22")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the research definition
    #[prost(message, optional, tag = "23")]
    pub description: ::core::option::Option<Markdown>,
    /// Used for footnotes or explanatory notes
    #[prost(message, repeated, tag = "24")]
    pub comment: prost::alloc::vec::Vec<String>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "25")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for research definition (if applicable)
    #[prost(message, repeated, tag = "26")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this research definition is defined
    #[prost(message, optional, tag = "27")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the ResearchDefinition
    #[prost(message, optional, tag = "28")]
    pub usage: ::core::option::Option<String>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "29")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the research definition was approved by publisher
    #[prost(message, optional, tag = "30")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the research definition was last reviewed
    #[prost(message, optional, tag = "31")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the research definition is expected to be used
    #[prost(message, optional, tag = "32")]
    pub effective_period: ::core::option::Option<Period>,
    /// The category of the ResearchDefinition, such as Education, Treatment,
    /// Assessment, etc.
    #[prost(message, repeated, tag = "33")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "34")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "35")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "36")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "37")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "38")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Logic used by the ResearchDefinition
    #[prost(message, repeated, tag = "39")]
    pub library: prost::alloc::vec::Vec<Canonical>,
    /// What population?
    #[prost(message, optional, tag = "40")]
    pub population: ::core::option::Option<Reference>,
    /// What exposure?
    #[prost(message, optional, tag = "41")]
    pub exposure: ::core::option::Option<Reference>,
    /// What alternative exposure state?
    #[prost(message, optional, tag = "42")]
    pub exposure_alternative: ::core::option::Option<Reference>,
    /// What outcome?
    #[prost(message, optional, tag = "43")]
    pub outcome: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `ResearchDefinition`.
pub mod research_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SubjectX {
        #[prost(oneof = "subject_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<subject_x::Choice>,
    }
    /// Nested message and enum types in `SubjectX`.
    pub mod subject_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for ResearchElementDefinition, last
/// updated 2019-11-01T09:29:23.356+11:00. A population, intervention, or
/// exposure definition. See
/// <http://hl7.org/fhir/StructureDefinition/ResearchElementDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchElementDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this research element definition, represented as a
    /// URI (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the research element definition
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the research element definition
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this research element definition (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this research element definition (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    /// Title for use in informal contexts
    #[prost(message, optional, tag = "15")]
    pub short_title: ::core::option::Option<String>,
    /// Subordinate title of the ResearchElementDefinition
    #[prost(message, optional, tag = "16")]
    pub subtitle: ::core::option::Option<String>,
    #[prost(message, optional, tag = "17")]
    pub status: ::core::option::Option<research_element_definition::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "18")]
    pub experimental: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "19")]
    pub subject: ::core::option::Option<research_element_definition::SubjectX>,
    /// Date last changed
    #[prost(message, optional, tag = "20")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "21")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "22")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the research element definition
    #[prost(message, optional, tag = "23")]
    pub description: ::core::option::Option<Markdown>,
    /// Used for footnotes or explanatory notes
    #[prost(message, repeated, tag = "24")]
    pub comment: prost::alloc::vec::Vec<String>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "25")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for research element definition (if applicable)
    #[prost(message, repeated, tag = "26")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this research element definition is defined
    #[prost(message, optional, tag = "27")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the ResearchElementDefinition
    #[prost(message, optional, tag = "28")]
    pub usage: ::core::option::Option<String>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "29")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the research element definition was approved by publisher
    #[prost(message, optional, tag = "30")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the research element definition was last reviewed
    #[prost(message, optional, tag = "31")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the research element definition is expected to be used
    #[prost(message, optional, tag = "32")]
    pub effective_period: ::core::option::Option<Period>,
    /// The category of the ResearchElementDefinition, such as Education,
    /// Treatment, Assessment, etc.
    #[prost(message, repeated, tag = "33")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "34")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "35")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "36")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "37")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "38")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Logic used by the ResearchElementDefinition
    #[prost(message, repeated, tag = "39")]
    pub library: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, optional, tag = "40")]
    pub r#type: ::core::option::Option<research_element_definition::TypeCode>,
    #[prost(message, optional, tag = "41")]
    pub variable_type: ::core::option::Option<research_element_definition::VariableTypeCode>,
    #[prost(message, repeated, tag = "42")]
    pub characteristic: prost::alloc::vec::Vec<research_element_definition::Characteristic>,
}
/// Nested message and enum types in `ResearchElementDefinition`.
pub mod research_element_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SubjectX {
        #[prost(oneof = "subject_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<subject_x::Choice>,
    }
    /// Nested message and enum types in `SubjectX`.
    pub mod subject_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// population | exposure | outcome
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::research_element_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// dichotomous | continuous | descriptive
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct VariableTypeCode {
        #[prost(enumeration = "super::evidence_variable_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// What defines the members of the research element
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Characteristic {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub definition: ::core::option::Option<characteristic::DefinitionX>,
        /// What code/value pairs define members?
        #[prost(message, repeated, tag = "5")]
        pub usage_context: prost::alloc::vec::Vec<super::UsageContext>,
        /// Whether the characteristic includes or excludes members
        #[prost(message, optional, tag = "6")]
        pub exclude: ::core::option::Option<super::Boolean>,
        /// What unit is the outcome described in?
        #[prost(message, optional, tag = "7")]
        pub unit_of_measure: ::core::option::Option<super::CodeableConcept>,
        /// What time period does the study cover
        #[prost(message, optional, tag = "8")]
        pub study_effective_description: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "9")]
        pub study_effective: ::core::option::Option<characteristic::StudyEffectiveX>,
        /// Observation time from study start
        #[prost(message, optional, tag = "10")]
        pub study_effective_time_from_start: ::core::option::Option<super::Duration>,
        #[prost(message, optional, tag = "11")]
        pub study_effective_group_measure:
            ::core::option::Option<characteristic::StudyEffectiveGroupMeasureCode>,
        /// What time period do participants cover
        #[prost(message, optional, tag = "12")]
        pub participant_effective_description: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "13")]
        pub participant_effective: ::core::option::Option<characteristic::ParticipantEffectiveX>,
        /// Observation time from study start
        #[prost(message, optional, tag = "14")]
        pub participant_effective_time_from_start: ::core::option::Option<super::Duration>,
        #[prost(message, optional, tag = "15")]
        pub participant_effective_group_measure:
            ::core::option::Option<characteristic::ParticipantEffectiveGroupMeasureCode>,
    }
    /// Nested message and enum types in `Characteristic`.
    pub mod characteristic {
        /// What code or expression defines members?
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DefinitionX {
            #[prost(oneof = "definition_x::Choice", tags = "1, 2, 3, 4")]
            pub choice: ::core::option::Option<definition_x::Choice>,
        }
        /// Nested message and enum types in `DefinitionX`.
        pub mod definition_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Canonical(super::super::super::Canonical),
                #[prost(message, tag = "3")]
                Expression(super::super::super::Expression),
                #[prost(message, tag = "4")]
                DataRequirement(super::super::super::DataRequirement),
            }
        }
        /// What time period does the study cover
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct StudyEffectiveX {
            #[prost(oneof = "study_effective_x::Choice", tags = "1, 2, 3, 4")]
            pub choice: ::core::option::Option<study_effective_x::Choice>,
        }
        /// Nested message and enum types in `StudyEffectiveX`.
        pub mod study_effective_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
                #[prost(message, tag = "3")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "4")]
                Timing(super::super::super::Timing),
            }
        }
        /// mean | median | mean-of-mean | mean-of-median | median-of-mean |
        /// median-of-median
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct StudyEffectiveGroupMeasureCode {
            #[prost(enumeration = "super::super::group_measure_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// What time period do participants cover
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ParticipantEffectiveX {
            #[prost(oneof = "participant_effective_x::Choice", tags = "1, 2, 3, 4")]
            pub choice: ::core::option::Option<participant_effective_x::Choice>,
        }
        /// Nested message and enum types in `ParticipantEffectiveX`.
        pub mod participant_effective_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
                #[prost(message, tag = "3")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "4")]
                Timing(super::super::super::Timing),
            }
        }
        /// mean | median | mean-of-mean | mean-of-median | median-of-mean |
        /// median-of-median
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ParticipantEffectiveGroupMeasureCode {
            #[prost(enumeration = "super::super::group_measure_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
}
/// Auto-generated from StructureDefinition for ResearchStudy, last updated
/// 2019-11-01T09:29:23.356+11:00. Investigation to increase healthcare-related
/// patient-independent knowledge. See
/// <http://hl7.org/fhir/StructureDefinition/ResearchStudy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchStudy {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for study
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Name for this study
    #[prost(message, optional, tag = "11")]
    pub title: ::core::option::Option<String>,
    /// Steps followed in executing study
    #[prost(message, repeated, tag = "12")]
    pub protocol: prost::alloc::vec::Vec<Reference>,
    /// Part of larger study
    #[prost(message, repeated, tag = "13")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<research_study::StatusCode>,
    /// treatment | prevention | diagnostic | supportive-care | screening |
    /// health-services-research | basic-science | device-feasibility
    #[prost(message, optional, tag = "15")]
    pub primary_purpose_type: ::core::option::Option<CodeableConcept>,
    /// n-a | early-phase-1 | phase-1 | phase-1-phase-2 | phase-2 | phase-2-phase-3
    /// | phase-3 | phase-4
    #[prost(message, optional, tag = "16")]
    pub phase: ::core::option::Option<CodeableConcept>,
    /// Classifications for the study
    #[prost(message, repeated, tag = "17")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Drugs, devices, etc. under study
    #[prost(message, repeated, tag = "18")]
    pub focus: prost::alloc::vec::Vec<CodeableConcept>,
    /// Condition being studied
    #[prost(message, repeated, tag = "19")]
    pub condition: prost::alloc::vec::Vec<CodeableConcept>,
    /// Contact details for the study
    #[prost(message, repeated, tag = "20")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// References and dependencies
    #[prost(message, repeated, tag = "21")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Used to search for the study
    #[prost(message, repeated, tag = "22")]
    pub keyword: prost::alloc::vec::Vec<CodeableConcept>,
    /// Geographic region(s) for study
    #[prost(message, repeated, tag = "23")]
    pub location: prost::alloc::vec::Vec<CodeableConcept>,
    /// What this is study doing
    #[prost(message, optional, tag = "24")]
    pub description: ::core::option::Option<Markdown>,
    /// Inclusion & exclusion criteria
    #[prost(message, repeated, tag = "25")]
    pub enrollment: prost::alloc::vec::Vec<Reference>,
    /// When the study began and ended
    #[prost(message, optional, tag = "26")]
    pub period: ::core::option::Option<Period>,
    /// Organization that initiates and is legally responsible for the study
    #[prost(message, optional, tag = "27")]
    pub sponsor: ::core::option::Option<Reference>,
    /// Researcher who oversees multiple aspects of the study
    #[prost(message, optional, tag = "28")]
    pub principal_investigator: ::core::option::Option<Reference>,
    /// Facility where study activities are conducted
    #[prost(message, repeated, tag = "29")]
    pub site: prost::alloc::vec::Vec<Reference>,
    /// accrual-goal-met | closed-due-to-toxicity |
    /// closed-due-to-lack-of-study-progress | temporarily-closed-per-study-design
    #[prost(message, optional, tag = "30")]
    pub reason_stopped: ::core::option::Option<CodeableConcept>,
    /// Comments made about the study
    #[prost(message, repeated, tag = "31")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "32")]
    pub arm: prost::alloc::vec::Vec<research_study::Arm>,
    #[prost(message, repeated, tag = "33")]
    pub objective: prost::alloc::vec::Vec<research_study::Objective>,
}
/// Nested message and enum types in `ResearchStudy`.
pub mod research_study {
    /// active | administratively-completed | approved | closed-to-accrual |
    /// closed-to-accrual-and-intervention | completed | disapproved | in-review |
    /// temporarily-closed-to-accrual |
    /// temporarily-closed-to-accrual-and-intervention | withdrawn
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::research_study_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Defined path through the study for a subject
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Arm {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Label for study arm
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Categorization of study arm
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Short explanation of study path
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
    }
    /// A goal for the study
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Objective {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Label for the objective
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// primary | secondary | exploratory
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
    }
}
/// Auto-generated from StructureDefinition for ResearchSubject, last updated
/// 2019-11-01T09:29:23.356+11:00. Physical entity which is the primary unit of
/// interest in the study. See
/// <http://hl7.org/fhir/StructureDefinition/ResearchSubject>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchSubject {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for research subject in a study
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<research_subject::StatusCode>,
    /// Start and end of participation
    #[prost(message, optional, tag = "12")]
    pub period: ::core::option::Option<Period>,
    /// Study subject is part of
    #[prost(message, optional, tag = "13")]
    pub study: ::core::option::Option<Reference>,
    /// Who is part of study
    #[prost(message, optional, tag = "14")]
    pub individual: ::core::option::Option<Reference>,
    /// What path should be followed
    #[prost(message, optional, tag = "15")]
    pub assigned_arm: ::core::option::Option<String>,
    /// What path was followed
    #[prost(message, optional, tag = "16")]
    pub actual_arm: ::core::option::Option<String>,
    /// Agreement to participate in study
    #[prost(message, optional, tag = "17")]
    pub consent: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `ResearchSubject`.
pub mod research_subject {
    /// candidate | eligible | follow-up | ineligible | not-registered | off-study
    /// | on-study | on-study-intervention | on-study-observation |
    /// pending-on-study | potential-candidate | screening | withdrawn
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::research_subject_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for RiskAssessment, last updated
/// 2019-11-01T09:29:23.356+11:00. Potential outcomes for a subject with
/// likelihood. See <http://hl7.org/fhir/StructureDefinition/RiskAssessment>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RiskAssessment {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier for the assessment
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Request fulfilled by this assessment
    #[prost(message, optional, tag = "11")]
    pub based_on: ::core::option::Option<Reference>,
    /// Part of this occurrence
    #[prost(message, optional, tag = "12")]
    pub parent: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<risk_assessment::StatusCode>,
    /// Evaluation mechanism
    #[prost(message, optional, tag = "14")]
    pub method: ::core::option::Option<CodeableConcept>,
    /// Type of assessment
    #[prost(message, optional, tag = "15")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who/what does assessment apply to?
    #[prost(message, optional, tag = "16")]
    pub subject: ::core::option::Option<Reference>,
    /// Where was assessment performed?
    #[prost(message, optional, tag = "17")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "18")]
    pub occurrence: ::core::option::Option<risk_assessment::OccurrenceX>,
    /// Condition assessed
    #[prost(message, optional, tag = "19")]
    pub condition: ::core::option::Option<Reference>,
    /// Who did assessment?
    #[prost(message, optional, tag = "20")]
    pub performer: ::core::option::Option<Reference>,
    /// Why the assessment was necessary?
    #[prost(message, repeated, tag = "21")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why the assessment was necessary?
    #[prost(message, repeated, tag = "22")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Information used in assessment
    #[prost(message, repeated, tag = "23")]
    pub basis: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "24")]
    pub prediction: prost::alloc::vec::Vec<risk_assessment::Prediction>,
    /// How to reduce risk
    #[prost(message, optional, tag = "25")]
    pub mitigation: ::core::option::Option<String>,
    /// Comments on the risk assessment
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `RiskAssessment`.
pub mod risk_assessment {
    /// registered | preliminary | final | amended +
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::observation_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// When was assessment made?
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OccurrenceX {
        #[prost(oneof = "occurrence_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<occurrence_x::Choice>,
    }
    /// Nested message and enum types in `OccurrenceX`.
    pub mod occurrence_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Outcome predicted
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Prediction {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Possible outcome for the subject
        #[prost(message, optional, tag = "4")]
        pub outcome: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub probability: ::core::option::Option<prediction::ProbabilityX>,
        /// Likelihood of specified outcome as a qualitative value
        #[prost(message, optional, tag = "6")]
        pub qualitative_risk: ::core::option::Option<super::CodeableConcept>,
        /// Relative likelihood
        #[prost(message, optional, tag = "7")]
        pub relative_risk: ::core::option::Option<super::Decimal>,
        #[prost(message, optional, tag = "8")]
        pub when: ::core::option::Option<prediction::WhenX>,
        /// Explanation of prediction
        #[prost(message, optional, tag = "9")]
        pub rationale: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Prediction`.
    pub mod prediction {
        /// Likelihood of specified outcome
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ProbabilityX {
            #[prost(oneof = "probability_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<probability_x::Choice>,
        }
        /// Nested message and enum types in `ProbabilityX`.
        pub mod probability_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
            }
        }
        /// Timeframe or age range
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct WhenX {
            #[prost(oneof = "when_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<when_x::Choice>,
        }
        /// Nested message and enum types in `WhenX`.
        pub mod when_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Period(super::super::super::Period),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for RiskEvidenceSynthesis, last
/// updated 2019-11-01T09:29:23.356+11:00. A quantified estimate of risk based on
/// a body of evidence. See
/// <http://hl7.org/fhir/StructureDefinition/RiskEvidenceSynthesis>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RiskEvidenceSynthesis {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this risk evidence synthesis, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the risk evidence synthesis
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the risk evidence synthesis
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this risk evidence synthesis (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this risk evidence synthesis (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<risk_evidence_synthesis::StatusCode>,
    /// Date last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the risk evidence synthesis
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Used for footnotes or explanatory notes
    #[prost(message, repeated, tag = "20")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "21")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for risk evidence synthesis (if applicable)
    #[prost(message, repeated, tag = "22")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "23")]
    pub copyright: ::core::option::Option<Markdown>,
    /// When the risk evidence synthesis was approved by publisher
    #[prost(message, optional, tag = "24")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the risk evidence synthesis was last reviewed
    #[prost(message, optional, tag = "25")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the risk evidence synthesis is expected to be used
    #[prost(message, optional, tag = "26")]
    pub effective_period: ::core::option::Option<Period>,
    /// The category of the EffectEvidenceSynthesis, such as Education, Treatment,
    /// Assessment, etc.
    #[prost(message, repeated, tag = "27")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who authored the content
    #[prost(message, repeated, tag = "28")]
    pub author: prost::alloc::vec::Vec<ContactDetail>,
    /// Who edited the content
    #[prost(message, repeated, tag = "29")]
    pub editor: prost::alloc::vec::Vec<ContactDetail>,
    /// Who reviewed the content
    #[prost(message, repeated, tag = "30")]
    pub reviewer: prost::alloc::vec::Vec<ContactDetail>,
    /// Who endorsed the content
    #[prost(message, repeated, tag = "31")]
    pub endorser: prost::alloc::vec::Vec<ContactDetail>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "32")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Type of synthesis
    #[prost(message, optional, tag = "33")]
    pub synthesis_type: ::core::option::Option<CodeableConcept>,
    /// Type of study
    #[prost(message, optional, tag = "34")]
    pub study_type: ::core::option::Option<CodeableConcept>,
    /// What population?
    #[prost(message, optional, tag = "35")]
    pub population: ::core::option::Option<Reference>,
    /// What exposure?
    #[prost(message, optional, tag = "36")]
    pub exposure: ::core::option::Option<Reference>,
    /// What outcome?
    #[prost(message, optional, tag = "37")]
    pub outcome: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "38")]
    pub sample_size: ::core::option::Option<risk_evidence_synthesis::SampleSize>,
    #[prost(message, optional, tag = "39")]
    pub risk_estimate: ::core::option::Option<risk_evidence_synthesis::RiskEstimate>,
    #[prost(message, repeated, tag = "40")]
    pub certainty: prost::alloc::vec::Vec<risk_evidence_synthesis::Certainty>,
}
/// Nested message and enum types in `RiskEvidenceSynthesis`.
pub mod risk_evidence_synthesis {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// What sample size was involved?
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SampleSize {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Description of sample size
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// How many studies?
        #[prost(message, optional, tag = "5")]
        pub number_of_studies: ::core::option::Option<super::Integer>,
        /// How many participants?
        #[prost(message, optional, tag = "6")]
        pub number_of_participants: ::core::option::Option<super::Integer>,
    }
    /// What was the estimated risk
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RiskEstimate {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Description of risk estimate
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Type of risk estimate
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Point estimate
        #[prost(message, optional, tag = "6")]
        pub value: ::core::option::Option<super::Decimal>,
        /// What unit is the outcome described in?
        #[prost(message, optional, tag = "7")]
        pub unit_of_measure: ::core::option::Option<super::CodeableConcept>,
        /// Sample size for group measured
        #[prost(message, optional, tag = "8")]
        pub denominator_count: ::core::option::Option<super::Integer>,
        /// Number with the outcome
        #[prost(message, optional, tag = "9")]
        pub numerator_count: ::core::option::Option<super::Integer>,
        #[prost(message, repeated, tag = "10")]
        pub precision_estimate: prost::alloc::vec::Vec<risk_estimate::PrecisionEstimate>,
    }
    /// Nested message and enum types in `RiskEstimate`.
    pub mod risk_estimate {
        /// How precise the estimate is
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PrecisionEstimate {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of precision estimate
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Level of confidence interval
            #[prost(message, optional, tag = "5")]
            pub level: ::core::option::Option<super::super::Decimal>,
            /// Lower bound
            #[prost(message, optional, tag = "6")]
            pub from: ::core::option::Option<super::super::Decimal>,
            /// Upper bound
            #[prost(message, optional, tag = "7")]
            pub to: ::core::option::Option<super::super::Decimal>,
        }
    }
    /// How certain is the risk
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Certainty {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Certainty rating
        #[prost(message, repeated, tag = "4")]
        pub rating: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Used for footnotes or explanatory notes
        #[prost(message, repeated, tag = "5")]
        pub note: prost::alloc::vec::Vec<super::Annotation>,
        #[prost(message, repeated, tag = "6")]
        pub certainty_subcomponent: prost::alloc::vec::Vec<certainty::CertaintySubcomponent>,
    }
    /// Nested message and enum types in `Certainty`.
    pub mod certainty {
        /// A component that contributes to the overall certainty
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CertaintySubcomponent {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of subcomponent of certainty rating
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Subcomponent certainty rating
            #[prost(message, repeated, tag = "5")]
            pub rating: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Used for footnotes or explanatory notes
            #[prost(message, repeated, tag = "6")]
            pub note: prost::alloc::vec::Vec<super::super::Annotation>,
        }
    }
}
/// Auto-generated from StructureDefinition for Schedule, last updated
/// 2019-11-01T09:29:23.356+11:00. A container for slots of time that may be
/// available for booking appointments. See
/// <http://hl7.org/fhir/StructureDefinition/Schedule>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Schedule {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this item
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this schedule is in active use
    #[prost(message, optional, tag = "11")]
    pub active: ::core::option::Option<Boolean>,
    /// High-level category
    #[prost(message, repeated, tag = "12")]
    pub service_category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Specific service
    #[prost(message, repeated, tag = "13")]
    pub service_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Type of specialty needed
    #[prost(message, repeated, tag = "14")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// Resource(s) that availability information is being provided for
    #[prost(message, repeated, tag = "15")]
    pub actor: prost::alloc::vec::Vec<Reference>,
    /// Period of time covered by schedule
    #[prost(message, optional, tag = "16")]
    pub planning_horizon: ::core::option::Option<Period>,
    /// Comments on availability
    #[prost(message, optional, tag = "17")]
    pub comment: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for SearchParameter, last updated
/// 2019-11-01T09:29:23.356+11:00. Search parameter for a resource. See
/// <http://hl7.org/fhir/StructureDefinition/SearchParameter>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SearchParameter {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this search parameter, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the search parameter
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this search parameter (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Original definition for the search parameter
    #[prost(message, optional, tag = "13")]
    pub derived_from: ::core::option::Option<Canonical>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<search_parameter::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the search parameter
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for search parameter (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this search parameter is defined
    #[prost(message, optional, tag = "22")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Code used in URL
    #[prost(message, optional, tag = "23")]
    pub code: ::core::option::Option<Code>,
    #[prost(message, repeated, tag = "24")]
    pub base: prost::alloc::vec::Vec<search_parameter::BaseCode>,
    #[prost(message, optional, tag = "25")]
    pub r#type: ::core::option::Option<search_parameter::TypeCode>,
    /// FHIRPath expression that extracts the values
    #[prost(message, optional, tag = "26")]
    pub expression: ::core::option::Option<String>,
    /// XPath that extracts the values
    #[prost(message, optional, tag = "27")]
    pub xpath: ::core::option::Option<String>,
    #[prost(message, optional, tag = "28")]
    pub xpath_usage: ::core::option::Option<search_parameter::XpathUsageCode>,
    #[prost(message, repeated, tag = "29")]
    pub target: prost::alloc::vec::Vec<search_parameter::TargetCode>,
    /// Allow multiple values per parameter (or)
    #[prost(message, optional, tag = "30")]
    pub multiple_or: ::core::option::Option<Boolean>,
    /// Allow multiple parameters (and)
    #[prost(message, optional, tag = "31")]
    pub multiple_and: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "32")]
    pub comparator: prost::alloc::vec::Vec<search_parameter::ComparatorCode>,
    #[prost(message, repeated, tag = "33")]
    pub modifier: prost::alloc::vec::Vec<search_parameter::ModifierCode>,
    /// Chained names supported
    #[prost(message, repeated, tag = "34")]
    pub chain: prost::alloc::vec::Vec<String>,
    #[prost(message, repeated, tag = "35")]
    pub component: prost::alloc::vec::Vec<search_parameter::Component>,
}
/// Nested message and enum types in `SearchParameter`.
pub mod search_parameter {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// The resource type(s) this search parameter applies to
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct BaseCode {
        #[prost(enumeration = "super::resource_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// number | date | string | token | reference | composite | quantity | uri |
    /// special
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::search_param_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// normal | phonetic | nearby | distance | other
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct XpathUsageCode {
        #[prost(enumeration = "super::x_path_usage_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Types of resource (if a resource reference)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TargetCode {
        #[prost(enumeration = "super::resource_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// eq | ne | gt | lt | ge | le | sa | eb | ap
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ComparatorCode {
        #[prost(enumeration = "super::search_comparator_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// missing | exact | contains | not | text | in | not-in | below | above |
    /// type | identifier | ofType
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ModifierCode {
        #[prost(enumeration = "super::search_modifier_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// For Composite resources to define the parts
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Component {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Defines how the part works
        #[prost(message, optional, tag = "4")]
        pub definition: ::core::option::Option<super::Canonical>,
        /// Subexpression relative to main expression
        #[prost(message, optional, tag = "5")]
        pub expression: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for ServiceRequest, last updated
/// 2019-11-01T09:29:23.356+11:00. A request for a service to be performed. See
/// <http://hl7.org/fhir/StructureDefinition/ServiceRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ServiceRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifiers assigned to this order
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates FHIR protocol or definition
    #[prost(message, repeated, tag = "11")]
    pub instantiates_canonical: prost::alloc::vec::Vec<Canonical>,
    /// Instantiates external protocol or definition
    #[prost(message, repeated, tag = "12")]
    pub instantiates_uri: prost::alloc::vec::Vec<Uri>,
    /// What request fulfills
    #[prost(message, repeated, tag = "13")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// What request replaces
    #[prost(message, repeated, tag = "14")]
    pub replaces: prost::alloc::vec::Vec<Reference>,
    /// Composite Request ID
    #[prost(message, optional, tag = "15")]
    pub requisition: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<service_request::StatusCode>,
    #[prost(message, optional, tag = "17")]
    pub intent: ::core::option::Option<service_request::IntentCode>,
    /// Classification of service
    #[prost(message, repeated, tag = "18")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, optional, tag = "19")]
    pub priority: ::core::option::Option<service_request::PriorityCode>,
    /// True if service/procedure should not be performed
    #[prost(message, optional, tag = "20")]
    pub do_not_perform: ::core::option::Option<Boolean>,
    /// What is being requested/ordered
    #[prost(message, optional, tag = "21")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Additional order information
    #[prost(message, repeated, tag = "22")]
    pub order_detail: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, optional, tag = "23")]
    pub quantity: ::core::option::Option<service_request::QuantityX>,
    /// Individual or Entity the service is ordered for
    #[prost(message, optional, tag = "24")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter in which the request was created
    #[prost(message, optional, tag = "25")]
    pub encounter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "26")]
    pub occurrence: ::core::option::Option<service_request::OccurrenceX>,
    #[prost(message, optional, tag = "27")]
    pub as_needed: ::core::option::Option<service_request::AsNeededX>,
    /// Date request signed
    #[prost(message, optional, tag = "28")]
    pub authored_on: ::core::option::Option<DateTime>,
    /// Who/what is requesting service
    #[prost(message, optional, tag = "29")]
    pub requester: ::core::option::Option<Reference>,
    /// Performer role
    #[prost(message, optional, tag = "30")]
    pub performer_type: ::core::option::Option<CodeableConcept>,
    /// Requested performer
    #[prost(message, repeated, tag = "31")]
    pub performer: prost::alloc::vec::Vec<Reference>,
    /// Requested location
    #[prost(message, repeated, tag = "32")]
    pub location_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Requested location
    #[prost(message, repeated, tag = "33")]
    pub location_reference: prost::alloc::vec::Vec<Reference>,
    /// Explanation/Justification for procedure or service
    #[prost(message, repeated, tag = "34")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Explanation/Justification for service or service
    #[prost(message, repeated, tag = "35")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Associated insurance coverage
    #[prost(message, repeated, tag = "36")]
    pub insurance: prost::alloc::vec::Vec<Reference>,
    /// Additional clinical information
    #[prost(message, repeated, tag = "37")]
    pub supporting_info: prost::alloc::vec::Vec<Reference>,
    /// Procedure Samples
    #[prost(message, repeated, tag = "38")]
    pub specimen: prost::alloc::vec::Vec<Reference>,
    /// Location on Body
    #[prost(message, repeated, tag = "39")]
    pub body_site: prost::alloc::vec::Vec<CodeableConcept>,
    /// Comments
    #[prost(message, repeated, tag = "40")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Patient or consumer-oriented instructions
    #[prost(message, optional, tag = "41")]
    pub patient_instruction: ::core::option::Option<String>,
    /// Request provenance
    #[prost(message, repeated, tag = "42")]
    pub relevant_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `ServiceRequest`.
pub mod service_request {
    /// draft | active | on-hold | revoked | completed | entered-in-error | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::request_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// proposal | plan | directive | order | original-order | reflex-order |
    /// filler-order | instance-order | option
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct IntentCode {
        #[prost(enumeration = "super::request_intent_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// routine | urgent | asap | stat
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PriorityCode {
        #[prost(enumeration = "super::request_priority_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Service amount
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct QuantityX {
        #[prost(oneof = "quantity_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<quantity_x::Choice>,
    }
    /// Nested message and enum types in `QuantityX`.
    pub mod quantity_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "2")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "3")]
            Range(super::super::Range),
        }
    }
    /// When service should occur
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OccurrenceX {
        #[prost(oneof = "occurrence_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<occurrence_x::Choice>,
    }
    /// Nested message and enum types in `OccurrenceX`.
    pub mod occurrence_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
        }
    }
    /// Preconditions for service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AsNeededX {
        #[prost(oneof = "as_needed_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<as_needed_x::Choice>,
    }
    /// Nested message and enum types in `AsNeededX`.
    pub mod as_needed_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
}
/// Auto-generated from StructureDefinition for Slot, last updated
/// 2019-11-01T09:29:23.356+11:00. A slot of time on a schedule that may be
/// available for booking appointments. See
/// <http://hl7.org/fhir/StructureDefinition/Slot>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Slot {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this item
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// A broad categorization of the service that is to be performed during this
    /// appointment
    #[prost(message, repeated, tag = "11")]
    pub service_category: prost::alloc::vec::Vec<CodeableConcept>,
    /// The type of appointments that can be booked into this slot (ideally this
    /// would be an identifiable service - which is at a location, rather than the
    /// location itself). If provided then this overrides the value provided on the
    /// availability resource
    #[prost(message, repeated, tag = "12")]
    pub service_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// The specialty of a practitioner that would be required to perform the
    /// service requested in this appointment
    #[prost(message, repeated, tag = "13")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// The style of appointment or patient that may be booked in the slot (not
    /// service type)
    #[prost(message, optional, tag = "14")]
    pub appointment_type: ::core::option::Option<CodeableConcept>,
    /// The schedule resource that this slot defines an interval of status
    /// information
    #[prost(message, optional, tag = "15")]
    pub schedule: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<slot::StatusCode>,
    /// Date/Time that the slot is to begin
    #[prost(message, optional, tag = "17")]
    pub start: ::core::option::Option<Instant>,
    /// Date/Time that the slot is to conclude
    #[prost(message, optional, tag = "18")]
    pub end: ::core::option::Option<Instant>,
    /// This slot has already been overbooked, appointments are unlikely to be
    /// accepted for this time
    #[prost(message, optional, tag = "19")]
    pub overbooked: ::core::option::Option<Boolean>,
    /// Comments on the slot to describe any extended information. Such as custom
    /// constraints on the slot
    #[prost(message, optional, tag = "20")]
    pub comment: ::core::option::Option<String>,
}
/// Nested message and enum types in `Slot`.
pub mod slot {
    /// busy | free | busy-unavailable | busy-tentative | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::slot_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Specimen, last updated
/// 2019-11-01T09:29:23.356+11:00. Sample for analysis. See
/// <http://hl7.org/fhir/StructureDefinition/Specimen>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Specimen {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Identifier assigned by the lab
    #[prost(message, optional, tag = "11")]
    pub accession_identifier: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<specimen::StatusCode>,
    /// Kind of material that forms the specimen
    #[prost(message, optional, tag = "13")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Where the specimen came from. This may be from patient(s), from a location
    /// (e.g., the source of an environmental sample), or a sampling of a substance
    /// or a device
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// The time when specimen was received for processing
    #[prost(message, optional, tag = "15")]
    pub received_time: ::core::option::Option<DateTime>,
    /// Specimen from which this specimen originated
    #[prost(message, repeated, tag = "16")]
    pub parent: prost::alloc::vec::Vec<Reference>,
    /// Why the specimen was collected
    #[prost(message, repeated, tag = "17")]
    pub request: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "18")]
    pub collection: ::core::option::Option<specimen::Collection>,
    #[prost(message, repeated, tag = "19")]
    pub processing: prost::alloc::vec::Vec<specimen::Processing>,
    #[prost(message, repeated, tag = "20")]
    pub container: prost::alloc::vec::Vec<specimen::Container>,
    /// State of the specimen
    #[prost(message, repeated, tag = "21")]
    pub condition: prost::alloc::vec::Vec<CodeableConcept>,
    /// Comments
    #[prost(message, repeated, tag = "22")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `Specimen`.
pub mod specimen {
    /// available | unavailable | unsatisfactory | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::specimen_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Collection details
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Collection {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Who collected the specimen
        #[prost(message, optional, tag = "4")]
        pub collector: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "5")]
        pub collected: ::core::option::Option<collection::CollectedX>,
        /// How long it took to collect specimen
        #[prost(message, optional, tag = "6")]
        pub duration: ::core::option::Option<super::Duration>,
        /// The quantity of specimen collected
        #[prost(message, optional, tag = "7")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Technique used to perform collection
        #[prost(message, optional, tag = "8")]
        pub method: ::core::option::Option<super::CodeableConcept>,
        /// Anatomical collection site
        #[prost(message, optional, tag = "9")]
        pub body_site: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "10")]
        pub fasting_status: ::core::option::Option<collection::FastingStatusX>,
    }
    /// Nested message and enum types in `Collection`.
    pub mod collection {
        /// Collection time
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct CollectedX {
            #[prost(oneof = "collected_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<collected_x::Choice>,
        }
        /// Nested message and enum types in `CollectedX`.
        pub mod collected_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Whether or how long patient abstained from food and/or drink
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct FastingStatusX {
            #[prost(oneof = "fasting_status_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<fasting_status_x::Choice>,
        }
        /// Nested message and enum types in `FastingStatusX`.
        pub mod fasting_status_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Duration(super::super::super::Duration),
            }
        }
    }
    /// Processing and processing step details
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Processing {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Textual description of procedure
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Indicates the treatment step  applied to the specimen
        #[prost(message, optional, tag = "5")]
        pub procedure: ::core::option::Option<super::CodeableConcept>,
        /// Material used in the processing step
        #[prost(message, repeated, tag = "6")]
        pub additive: prost::alloc::vec::Vec<super::Reference>,
        #[prost(message, optional, tag = "7")]
        pub time: ::core::option::Option<processing::TimeX>,
    }
    /// Nested message and enum types in `Processing`.
    pub mod processing {
        /// Date and time of specimen processing
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimeX {
            #[prost(oneof = "time_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<time_x::Choice>,
        }
        /// Nested message and enum types in `TimeX`.
        pub mod time_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
    }
    /// Direct container of specimen (tube/slide, etc.)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Container {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Id for the container
        #[prost(message, repeated, tag = "4")]
        pub identifier: prost::alloc::vec::Vec<super::Identifier>,
        /// Textual description of the container
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        /// Kind of container directly associated with specimen
        #[prost(message, optional, tag = "6")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Container volume or size
        #[prost(message, optional, tag = "7")]
        pub capacity: ::core::option::Option<super::SimpleQuantity>,
        /// Quantity of specimen within container
        #[prost(message, optional, tag = "8")]
        pub specimen_quantity: ::core::option::Option<super::SimpleQuantity>,
        #[prost(message, optional, tag = "9")]
        pub additive: ::core::option::Option<container::AdditiveX>,
    }
    /// Nested message and enum types in `Container`.
    pub mod container {
        /// Additive associated with container
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AdditiveX {
            #[prost(oneof = "additive_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<additive_x::Choice>,
        }
        /// Nested message and enum types in `AdditiveX`.
        pub mod additive_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for SpecimenDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. Kind of specimen. See
/// <http://hl7.org/fhir/StructureDefinition/SpecimenDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecimenDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier of a kind of specimen
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Kind of material to collect
    #[prost(message, optional, tag = "11")]
    pub type_collected: ::core::option::Option<CodeableConcept>,
    /// Patient preparation for collection
    #[prost(message, repeated, tag = "12")]
    pub patient_preparation: prost::alloc::vec::Vec<CodeableConcept>,
    /// Time aspect for collection
    #[prost(message, optional, tag = "13")]
    pub time_aspect: ::core::option::Option<String>,
    /// Specimen collection procedure
    #[prost(message, repeated, tag = "14")]
    pub collection: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "15")]
    pub type_tested: prost::alloc::vec::Vec<specimen_definition::TypeTested>,
}
/// Nested message and enum types in `SpecimenDefinition`.
pub mod specimen_definition {
    /// Specimen in container intended for testing by lab
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeTested {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Primary or secondary specimen
        #[prost(message, optional, tag = "4")]
        pub is_derived: ::core::option::Option<super::Boolean>,
        /// Type of intended specimen
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "6")]
        pub preference: ::core::option::Option<type_tested::PreferenceCode>,
        #[prost(message, optional, tag = "7")]
        pub container: ::core::option::Option<type_tested::Container>,
        /// Specimen requirements
        #[prost(message, optional, tag = "8")]
        pub requirement: ::core::option::Option<super::String>,
        /// Specimen retention time
        #[prost(message, optional, tag = "9")]
        pub retention_time: ::core::option::Option<super::Duration>,
        /// Rejection criterion
        #[prost(message, repeated, tag = "10")]
        pub rejection_criterion: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, repeated, tag = "11")]
        pub handling: prost::alloc::vec::Vec<type_tested::Handling>,
    }
    /// Nested message and enum types in `TypeTested`.
    pub mod type_tested {
        /// preferred | alternate
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PreferenceCode {
            #[prost(
                enumeration = "super::super::specimen_contained_preference_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// The specimen's container
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Container {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Container material
            #[prost(message, optional, tag = "4")]
            pub material: ::core::option::Option<super::super::CodeableConcept>,
            /// Kind of container associated with the kind of specimen
            #[prost(message, optional, tag = "5")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Color of container cap
            #[prost(message, optional, tag = "6")]
            pub cap: ::core::option::Option<super::super::CodeableConcept>,
            /// Container description
            #[prost(message, optional, tag = "7")]
            pub description: ::core::option::Option<super::super::String>,
            /// Container capacity
            #[prost(message, optional, tag = "8")]
            pub capacity: ::core::option::Option<super::super::SimpleQuantity>,
            #[prost(message, optional, tag = "9")]
            pub minimum_volume: ::core::option::Option<container::MinimumVolumeX>,
            #[prost(message, repeated, tag = "10")]
            pub additive: prost::alloc::vec::Vec<container::Additive>,
            /// Specimen container preparation
            #[prost(message, optional, tag = "11")]
            pub preparation: ::core::option::Option<super::super::String>,
        }
        /// Nested message and enum types in `Container`.
        pub mod container {
            /// Minimum volume
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct MinimumVolumeX {
                #[prost(oneof = "minimum_volume_x::Choice", tags = "1, 2")]
                pub choice: ::core::option::Option<minimum_volume_x::Choice>,
            }
            /// Nested message and enum types in `MinimumVolumeX`.
            pub mod minimum_volume_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    Quantity(super::super::super::super::SimpleQuantity),
                    #[prost(message, tag = "2")]
                    StringValue(super::super::super::super::String),
                }
            }
            /// Additive associated with container
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Additive {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                #[prost(message, optional, tag = "4")]
                pub additive: ::core::option::Option<additive::AdditiveX>,
            }
            /// Nested message and enum types in `Additive`.
            pub mod additive {
                /// Additive associated with container
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct AdditiveX {
                    #[prost(oneof = "additive_x::Choice", tags = "1, 2")]
                    pub choice: ::core::option::Option<additive_x::Choice>,
                }
                /// Nested message and enum types in `AdditiveX`.
                pub mod additive_x {
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Oneof)]
                    pub enum Choice {
                        #[prost(message, tag = "1")]
                        CodeableConcept(super::super::super::super::super::CodeableConcept),
                        #[prost(message, tag = "2")]
                        Reference(super::super::super::super::super::Reference),
                    }
                }
            }
        }
        /// Specimen handling before testing
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Handling {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Temperature qualifier
            #[prost(message, optional, tag = "4")]
            pub temperature_qualifier: ::core::option::Option<super::super::CodeableConcept>,
            /// Temperature range
            #[prost(message, optional, tag = "5")]
            pub temperature_range: ::core::option::Option<super::super::Range>,
            /// Maximum preservation time
            #[prost(message, optional, tag = "6")]
            pub max_duration: ::core::option::Option<super::super::Duration>,
            /// Preservation instruction
            #[prost(message, optional, tag = "7")]
            pub instruction: ::core::option::Option<super::super::String>,
        }
    }
}
/// Auto-generated from StructureDefinition for StructureDefinition, last updated
/// 2019-11-01T09:29:23.356+11:00. Structural Definition. See
/// <http://hl7.org/fhir/StructureDefinition/StructureDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this structure definition, represented as a URI
    /// (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the structure definition
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the structure definition
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this structure definition (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this structure definition (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<structure_definition::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "16")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "18")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "19")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the structure definition
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "21")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for structure definition (if applicable)
    #[prost(message, repeated, tag = "22")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this structure definition is defined
    #[prost(message, optional, tag = "23")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "24")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Assist with indexing and finding
    #[prost(message, repeated, tag = "25")]
    pub keyword: prost::alloc::vec::Vec<Coding>,
    #[prost(message, optional, tag = "26")]
    pub fhir_version: ::core::option::Option<structure_definition::FhirVersionCode>,
    #[prost(message, repeated, tag = "27")]
    pub mapping: prost::alloc::vec::Vec<structure_definition::Mapping>,
    #[prost(message, optional, tag = "28")]
    pub kind: ::core::option::Option<structure_definition::KindCode>,
    /// Whether the structure is abstract
    #[prost(message, optional, tag = "29")]
    pub r#abstract: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "30")]
    pub context: prost::alloc::vec::Vec<structure_definition::Context>,
    /// FHIRPath invariants - when the extension can be used
    #[prost(message, repeated, tag = "31")]
    pub context_invariant: prost::alloc::vec::Vec<String>,
    /// Type defined or constrained by this structure
    #[prost(message, optional, tag = "32")]
    pub r#type: ::core::option::Option<Uri>,
    /// Definition that this type is constrained/specialized from
    #[prost(message, optional, tag = "33")]
    pub base_definition: ::core::option::Option<Canonical>,
    #[prost(message, optional, tag = "34")]
    pub derivation: ::core::option::Option<structure_definition::DerivationCode>,
    #[prost(message, optional, tag = "35")]
    pub snapshot: ::core::option::Option<structure_definition::Snapshot>,
    #[prost(message, optional, tag = "36")]
    pub differential: ::core::option::Option<structure_definition::Differential>,
}
/// Nested message and enum types in `StructureDefinition`.
pub mod structure_definition {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// FHIR Version this StructureDefinition targets
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FhirVersionCode {
        #[prost(enumeration = "super::fhir_version_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// External specification that the content is mapped to
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Mapping {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Internal id when this mapping is used
        #[prost(message, optional, tag = "4")]
        pub identity: ::core::option::Option<super::Id>,
        /// Identifies what this mapping refers to
        #[prost(message, optional, tag = "5")]
        pub uri: ::core::option::Option<super::Uri>,
        /// Names what this mapping refers to
        #[prost(message, optional, tag = "6")]
        pub name: ::core::option::Option<super::String>,
        /// Versions, Issues, Scope limitations etc.
        #[prost(message, optional, tag = "7")]
        pub comment: ::core::option::Option<super::String>,
    }
    /// primitive-type | complex-type | resource | logical
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct KindCode {
        #[prost(
            enumeration = "super::structure_definition_kind_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// If an extension, where it can be used in instances
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Context {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<context::TypeCode>,
        /// Where the extension can be used in instances
        #[prost(message, optional, tag = "5")]
        pub expression: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Context`.
    pub mod context {
        /// fhirpath | element | extension
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(
                enumeration = "super::super::extension_context_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// specialization | constraint - How relates to base definition
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DerivationCode {
        #[prost(enumeration = "super::type_derivation_rule_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Snapshot view of the structure
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Snapshot {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Definition of elements in the resource (if no StructureDefinition)
        #[prost(message, repeated, tag = "4")]
        pub element: prost::alloc::vec::Vec<super::ElementDefinition>,
    }
    /// Differential view of the structure
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Differential {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Definition of elements in the resource (if no StructureDefinition)
        #[prost(message, repeated, tag = "4")]
        pub element: prost::alloc::vec::Vec<super::ElementDefinition>,
    }
}
/// Auto-generated from StructureDefinition for StructureMap, last updated
/// 2019-11-01T09:29:23.356+11:00. A Map of relationships between 2 structures
/// that can be used to transform data. See
/// <http://hl7.org/fhir/StructureDefinition/StructureMap>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMap {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this structure map, represented as a URI (globally
    /// unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the structure map
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the structure map
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this structure map (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this structure map (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<structure_map::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "16")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "18")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "19")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the structure map
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "21")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for structure map (if applicable)
    #[prost(message, repeated, tag = "22")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this structure map is defined
    #[prost(message, optional, tag = "23")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "24")]
    pub copyright: ::core::option::Option<Markdown>,
    #[prost(message, repeated, tag = "25")]
    pub structure: prost::alloc::vec::Vec<structure_map::Structure>,
    /// Other maps used by this map (canonical URLs)
    #[prost(message, repeated, tag = "26")]
    pub import: prost::alloc::vec::Vec<Canonical>,
    #[prost(message, repeated, tag = "27")]
    pub group: prost::alloc::vec::Vec<structure_map::Group>,
}
/// Nested message and enum types in `StructureMap`.
pub mod structure_map {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Structure Definition used by this map
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Structure {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Canonical reference to structure definition
        #[prost(message, optional, tag = "4")]
        pub url: ::core::option::Option<super::Canonical>,
        #[prost(message, optional, tag = "5")]
        pub mode: ::core::option::Option<structure::ModeCode>,
        /// Name for type in this map
        #[prost(message, optional, tag = "6")]
        pub alias: ::core::option::Option<super::String>,
        /// Documentation on use of structure
        #[prost(message, optional, tag = "7")]
        pub documentation: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Structure`.
    pub mod structure {
        /// source | queried | target | produced
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ModeCode {
            #[prost(
                enumeration = "super::super::structure_map_model_mode_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// Named sections for reader convenience
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Group {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Human-readable label
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::Id>,
        /// Another group that this group adds rules to
        #[prost(message, optional, tag = "5")]
        pub extends: ::core::option::Option<super::Id>,
        #[prost(message, optional, tag = "6")]
        pub type_mode: ::core::option::Option<group::TypeModeCode>,
        /// Additional description/explanation for group
        #[prost(message, optional, tag = "7")]
        pub documentation: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "8")]
        pub input: prost::alloc::vec::Vec<group::Input>,
        #[prost(message, repeated, tag = "9")]
        pub rule: prost::alloc::vec::Vec<group::Rule>,
    }
    /// Nested message and enum types in `Group`.
    pub mod group {
        /// none | types | type-and-types
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeModeCode {
            #[prost(
                enumeration = "super::super::structure_map_group_type_mode_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Named instance provided when invoking the map
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Input {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Name for this instance of data
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::Id>,
            /// Type for this instance of data
            #[prost(message, optional, tag = "5")]
            pub r#type: ::core::option::Option<super::super::String>,
            #[prost(message, optional, tag = "6")]
            pub mode: ::core::option::Option<input::ModeCode>,
            /// Documentation for this instance of data
            #[prost(message, optional, tag = "7")]
            pub documentation: ::core::option::Option<super::super::String>,
        }
        /// Nested message and enum types in `Input`.
        pub mod input {
            /// source | target
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ModeCode {
                #[prost(
                    enumeration = "super::super::super::structure_map_input_mode_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
        /// Transform Rule from source to target
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Rule {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Name of the rule for internal references
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::Id>,
            #[prost(message, repeated, tag = "5")]
            pub source: prost::alloc::vec::Vec<rule::Source>,
            #[prost(message, repeated, tag = "6")]
            pub target: prost::alloc::vec::Vec<rule::Target>,
            /// Rules contained in this rule
            #[prost(message, repeated, tag = "7")]
            pub rule: prost::alloc::vec::Vec<Rule>,
            #[prost(message, repeated, tag = "8")]
            pub dependent: prost::alloc::vec::Vec<rule::Dependent>,
            /// Documentation for this instance of data
            #[prost(message, optional, tag = "9")]
            pub documentation: ::core::option::Option<super::super::String>,
        }
        /// Nested message and enum types in `Rule`.
        pub mod rule {
            /// Source inputs to the mapping
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Source {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Type or variable this rule applies to
                #[prost(message, optional, tag = "4")]
                pub context: ::core::option::Option<super::super::super::Id>,
                /// Specified minimum cardinality
                #[prost(message, optional, tag = "5")]
                pub min: ::core::option::Option<super::super::super::Integer>,
                /// Specified maximum cardinality (number or *)
                #[prost(message, optional, tag = "6")]
                pub max: ::core::option::Option<super::super::super::String>,
                /// Rule only applies if source has this type
                #[prost(message, optional, tag = "7")]
                pub r#type: ::core::option::Option<super::super::super::String>,
                #[prost(message, optional, tag = "8")]
                pub default_value: ::core::option::Option<source::DefaultValueX>,
                /// Optional field for this source
                #[prost(message, optional, tag = "9")]
                pub element: ::core::option::Option<super::super::super::String>,
                #[prost(message, optional, tag = "10")]
                pub list_mode: ::core::option::Option<source::ListModeCode>,
                /// Named context for field, if a field is specified
                #[prost(message, optional, tag = "11")]
                pub variable: ::core::option::Option<super::super::super::Id>,
                /// FHIRPath expression  - must be true or the rule does not apply
                #[prost(message, optional, tag = "12")]
                pub condition: ::core::option::Option<super::super::super::String>,
                /// FHIRPath expression  - must be true or the mapping engine throws an
                /// error instead of completing
                #[prost(message, optional, tag = "13")]
                pub check: ::core::option::Option<super::super::super::String>,
                /// Message to put in log if source exists (FHIRPath)
                #[prost(message, optional, tag = "14")]
                pub log_message: ::core::option::Option<super::super::super::String>,
            }
            /// Nested message and enum types in `Source`.
            pub mod source {
                /// Default value if no value exists
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct DefaultValueX {
                    #[prost(
                        oneof = "default_value_x::Choice",
                        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50"
                    )]
                    pub choice: ::core::option::Option<default_value_x::Choice>,
                }
                /// Nested message and enum types in `DefaultValueX`.
                pub mod default_value_x {
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Oneof)]
                    pub enum Choice {
                        #[prost(message, tag = "1")]
                        Base64Binary(super::super::super::super::super::Base64Binary),
                        #[prost(message, tag = "2")]
                        Boolean(super::super::super::super::super::Boolean),
                        #[prost(message, tag = "3")]
                        Canonical(super::super::super::super::super::Canonical),
                        #[prost(message, tag = "4")]
                        Code(super::super::super::super::super::Code),
                        #[prost(message, tag = "5")]
                        Date(super::super::super::super::super::Date),
                        #[prost(message, tag = "6")]
                        DateTime(super::super::super::super::super::DateTime),
                        #[prost(message, tag = "7")]
                        Decimal(super::super::super::super::super::Decimal),
                        #[prost(message, tag = "8")]
                        Id(super::super::super::super::super::Id),
                        #[prost(message, tag = "9")]
                        Instant(super::super::super::super::super::Instant),
                        #[prost(message, tag = "10")]
                        Integer(super::super::super::super::super::Integer),
                        #[prost(message, tag = "11")]
                        Markdown(super::super::super::super::super::Markdown),
                        #[prost(message, tag = "12")]
                        Oid(super::super::super::super::super::Oid),
                        #[prost(message, tag = "13")]
                        PositiveInt(super::super::super::super::super::PositiveInt),
                        #[prost(message, tag = "14")]
                        StringValue(super::super::super::super::super::String),
                        #[prost(message, tag = "15")]
                        Time(super::super::super::super::super::Time),
                        #[prost(message, tag = "16")]
                        UnsignedInt(super::super::super::super::super::UnsignedInt),
                        #[prost(message, tag = "17")]
                        Uri(super::super::super::super::super::Uri),
                        #[prost(message, tag = "18")]
                        Url(super::super::super::super::super::Url),
                        #[prost(message, tag = "19")]
                        Uuid(super::super::super::super::super::Uuid),
                        #[prost(message, tag = "20")]
                        Address(super::super::super::super::super::Address),
                        #[prost(message, tag = "21")]
                        Age(super::super::super::super::super::Age),
                        #[prost(message, tag = "22")]
                        Annotation(super::super::super::super::super::Annotation),
                        #[prost(message, tag = "23")]
                        Attachment(super::super::super::super::super::Attachment),
                        #[prost(message, tag = "24")]
                        CodeableConcept(super::super::super::super::super::CodeableConcept),
                        #[prost(message, tag = "25")]
                        Coding(super::super::super::super::super::Coding),
                        #[prost(message, tag = "26")]
                        ContactPoint(super::super::super::super::super::ContactPoint),
                        #[prost(message, tag = "27")]
                        Count(super::super::super::super::super::Count),
                        #[prost(message, tag = "28")]
                        Distance(super::super::super::super::super::Distance),
                        #[prost(message, tag = "29")]
                        Duration(super::super::super::super::super::Duration),
                        #[prost(message, tag = "30")]
                        HumanName(super::super::super::super::super::HumanName),
                        #[prost(message, tag = "31")]
                        Identifier(super::super::super::super::super::Identifier),
                        #[prost(message, tag = "32")]
                        Money(super::super::super::super::super::Money),
                        #[prost(message, tag = "33")]
                        Period(super::super::super::super::super::Period),
                        #[prost(message, tag = "34")]
                        Quantity(super::super::super::super::super::Quantity),
                        #[prost(message, tag = "35")]
                        Range(super::super::super::super::super::Range),
                        #[prost(message, tag = "36")]
                        Ratio(super::super::super::super::super::Ratio),
                        #[prost(message, tag = "37")]
                        Reference(super::super::super::super::super::Reference),
                        #[prost(message, tag = "38")]
                        SampledData(super::super::super::super::super::SampledData),
                        #[prost(message, tag = "39")]
                        Signature(super::super::super::super::super::Signature),
                        #[prost(message, tag = "40")]
                        Timing(super::super::super::super::super::Timing),
                        #[prost(message, tag = "41")]
                        ContactDetail(super::super::super::super::super::ContactDetail),
                        #[prost(message, tag = "42")]
                        Contributor(super::super::super::super::super::Contributor),
                        #[prost(message, tag = "43")]
                        DataRequirement(super::super::super::super::super::DataRequirement),
                        #[prost(message, tag = "44")]
                        Expression(super::super::super::super::super::Expression),
                        #[prost(message, tag = "45")]
                        ParameterDefinition(super::super::super::super::super::ParameterDefinition),
                        #[prost(message, tag = "46")]
                        RelatedArtifact(super::super::super::super::super::RelatedArtifact),
                        #[prost(message, tag = "47")]
                        TriggerDefinition(super::super::super::super::super::TriggerDefinition),
                        #[prost(message, tag = "48")]
                        UsageContext(super::super::super::super::super::UsageContext),
                        #[prost(message, tag = "49")]
                        Dosage(super::super::super::super::super::Dosage),
                        #[prost(message, tag = "50")]
                        Meta(super::super::super::super::super::Meta),
                    }
                }
                /// first | not_first | last | not_last | only_one
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ListModeCode {
                    #[prost(
                        enumeration = "super::super::super::super::structure_map_source_list_mode_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
            }
            /// Content to create because of this mapping rule
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Target {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Type or variable this rule applies to
                #[prost(message, optional, tag = "4")]
                pub context: ::core::option::Option<super::super::super::Id>,
                #[prost(message, optional, tag = "5")]
                pub context_type: ::core::option::Option<target::ContextTypeCode>,
                /// Field to create in the context
                #[prost(message, optional, tag = "6")]
                pub element: ::core::option::Option<super::super::super::String>,
                /// Named context for field, if desired, and a field is specified
                #[prost(message, optional, tag = "7")]
                pub variable: ::core::option::Option<super::super::super::Id>,
                #[prost(message, repeated, tag = "8")]
                pub list_mode: prost::alloc::vec::Vec<target::ListModeCode>,
                /// Internal rule reference for shared list items
                #[prost(message, optional, tag = "9")]
                pub list_rule_id: ::core::option::Option<super::super::super::Id>,
                #[prost(message, optional, tag = "10")]
                pub transform: ::core::option::Option<target::TransformCode>,
                #[prost(message, repeated, tag = "11")]
                pub parameter: prost::alloc::vec::Vec<target::Parameter>,
            }
            /// Nested message and enum types in `Target`.
            pub mod target {
                /// type | variable
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ContextTypeCode {
                    #[prost(
                        enumeration = "super::super::super::super::structure_map_context_type_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// first | share | last | collate
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ListModeCode {
                    #[prost(
                        enumeration = "super::super::super::super::structure_map_target_list_mode_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// create | copy +
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct TransformCode {
                    #[prost(
                        enumeration = "super::super::super::super::structure_map_transform_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// Parameters to the transform
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct Parameter {
                    /// Unique id for inter-element referencing
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored even if unrecognized
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    #[prost(message, optional, tag = "4")]
                    pub value: ::core::option::Option<parameter::ValueX>,
                }
                /// Nested message and enum types in `Parameter`.
                pub mod parameter {
                    /// Parameter value - variable or literal
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Message)]
                    pub struct ValueX {
                        #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5")]
                        pub choice: ::core::option::Option<value_x::Choice>,
                    }
                    /// Nested message and enum types in `ValueX`.
                    pub mod value_x {
                        #[derive(Serialize, Deserialize)]
                        #[serde(rename_all = "camelCase")]
                        #[derive(Clone, PartialEq, prost::Oneof)]
                        pub enum Choice {
                            #[prost(message, tag = "1")]
                            Id(super::super::super::super::super::super::Id),
                            #[prost(message, tag = "2")]
                            StringValue(super::super::super::super::super::super::String),
                            #[prost(message, tag = "3")]
                            Boolean(super::super::super::super::super::super::Boolean),
                            #[prost(message, tag = "4")]
                            Integer(super::super::super::super::super::super::Integer),
                            #[prost(message, tag = "5")]
                            Decimal(super::super::super::super::super::super::Decimal),
                        }
                    }
                }
            }
            /// Which other rules to apply in the context of this rule
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Dependent {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Name of a rule or group to apply
                #[prost(message, optional, tag = "4")]
                pub name: ::core::option::Option<super::super::super::Id>,
                /// Variable to pass to the rule or group
                #[prost(message, repeated, tag = "5")]
                pub variable: prost::alloc::vec::Vec<super::super::super::String>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Subscription, last updated
/// 2019-11-01T09:29:23.356+11:00. Server push subscription criteria. See
/// <http://hl7.org/fhir/StructureDefinition/Subscription>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Subscription {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<subscription::StatusCode>,
    /// Contact details for source (e.g. troubleshooting)
    #[prost(message, repeated, tag = "11")]
    pub contact: prost::alloc::vec::Vec<ContactPoint>,
    /// When to automatically delete the subscription
    #[prost(message, optional, tag = "12")]
    pub end: ::core::option::Option<Instant>,
    /// Description of why this subscription was created
    #[prost(message, optional, tag = "13")]
    pub reason: ::core::option::Option<String>,
    /// Rule for server push
    #[prost(message, optional, tag = "14")]
    pub criteria: ::core::option::Option<String>,
    /// Latest error note
    #[prost(message, optional, tag = "15")]
    pub error: ::core::option::Option<String>,
    #[prost(message, optional, tag = "16")]
    pub channel: ::core::option::Option<subscription::Channel>,
}
/// Nested message and enum types in `Subscription`.
pub mod subscription {
    /// requested | active | error | off
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::subscription_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// The channel on which to report matches to the criteria
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Channel {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<channel::TypeCode>,
        /// Where the channel points to
        #[prost(message, optional, tag = "5")]
        pub endpoint: ::core::option::Option<super::Url>,
        #[prost(message, optional, tag = "6")]
        pub payload: ::core::option::Option<channel::PayloadCode>,
        /// Usage depends on the channel type
        #[prost(message, repeated, tag = "7")]
        pub header: prost::alloc::vec::Vec<super::String>,
    }
    /// Nested message and enum types in `Channel`.
    pub mod channel {
        /// rest-hook | websocket | email | sms | message
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(
                enumeration = "super::super::subscription_channel_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// MIME type to send, or omit for no payload
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct PayloadCode {
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// This valueset is not enumerable, and so is represented as a string.
            #[prost(string, tag = "4")]
            pub value: prost::alloc::string::String,
        }
    }
}
/// Auto-generated from StructureDefinition for Substance, last updated
/// 2019-11-01T09:29:23.356+11:00. A homogeneous material with a definite
/// composition. See <http://hl7.org/fhir/StructureDefinition/Substance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Substance {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<substance::StatusCode>,
    /// What class/type of substance this is
    #[prost(message, repeated, tag = "12")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// What substance this is
    #[prost(message, optional, tag = "13")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Textual description of the substance, comments
    #[prost(message, optional, tag = "14")]
    pub description: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "15")]
    pub instance: prost::alloc::vec::Vec<substance::Instance>,
    #[prost(message, repeated, tag = "16")]
    pub ingredient: prost::alloc::vec::Vec<substance::Ingredient>,
}
/// Nested message and enum types in `Substance`.
pub mod substance {
    /// active | inactive | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::fhir_substance_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// If this describes a specific package/container of the substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Instance {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifier of the package/container
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// When no longer valid to use
        #[prost(message, optional, tag = "5")]
        pub expiry: ::core::option::Option<super::DateTime>,
        /// Amount of substance in the package
        #[prost(message, optional, tag = "6")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
    }
    /// Composition information about the substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Ingredient {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Optional amount (concentration)
        #[prost(message, optional, tag = "4")]
        pub quantity: ::core::option::Option<super::Ratio>,
        #[prost(message, optional, tag = "5")]
        pub substance: ::core::option::Option<ingredient::SubstanceX>,
    }
    /// Nested message and enum types in `Ingredient`.
    pub mod ingredient {
        /// A component of the substance
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SubstanceX {
            #[prost(oneof = "substance_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<substance_x::Choice>,
        }
        /// Nested message and enum types in `SubstanceX`.
        pub mod substance_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for SubstanceNucleicAcid, last
/// updated 2019-11-01T09:29:23.356+11:00. Nucleic acids are defined by three
/// distinct elements: the base, sugar and linkage. Individual substance/moiety
/// IDs will be created for each of these elements. The nucleotide sequence will
/// be always entered in the 5’-3’ direction. See
/// <http://hl7.org/fhir/StructureDefinition/SubstanceNucleicAcid>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubstanceNucleicAcid {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The type of the sequence shall be specified based on a controlled
    /// vocabulary
    #[prost(message, optional, tag = "10")]
    pub sequence_type: ::core::option::Option<CodeableConcept>,
    /// The number of linear sequences of nucleotides linked through phosphodiester
    /// bonds shall be described. Subunits would be strands of nucleic acids that
    /// are tightly associated typically through Watson-Crick base pairing. NOTE:
    /// If not specified in the reference source, the assumption is that there is 1
    /// subunit
    #[prost(message, optional, tag = "11")]
    pub number_of_subunits: ::core::option::Option<Integer>,
    /// The area of hybridisation shall be described if applicable for double
    /// stranded RNA or DNA. The number associated with the subunit followed by the
    /// number associated to the residue shall be specified in increasing order.
    /// The underscore “” shall be used as separator as follows: “Subunitnumber
    /// Residue”
    #[prost(message, optional, tag = "12")]
    pub area_of_hybridisation: ::core::option::Option<String>,
    /// (TBC)
    #[prost(message, optional, tag = "13")]
    pub oligo_nucleotide_type: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "14")]
    pub subunit: prost::alloc::vec::Vec<substance_nucleic_acid::Subunit>,
}
/// Nested message and enum types in `SubstanceNucleicAcid`.
pub mod substance_nucleic_acid {
    /// Subunits are listed in order of decreasing length; sequences of the same
    /// length will be ordered by molecular weight; subunits that have identical
    /// sequences will be repeated multiple times
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Subunit {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Index of linear sequences of nucleic acids in order of decreasing length.
        /// Sequences of the same length will be ordered by molecular weight.
        /// Subunits that have identical sequences will be repeated and have
        /// sequential subscripts
        #[prost(message, optional, tag = "4")]
        pub subunit: ::core::option::Option<super::Integer>,
        /// Actual nucleotide sequence notation from 5' to 3' end using standard
        /// single letter codes. In addition to the base sequence, sugar and type of
        /// phosphate or non-phosphate linkage should also be captured
        #[prost(message, optional, tag = "5")]
        pub sequence: ::core::option::Option<super::String>,
        /// The length of the sequence shall be captured
        #[prost(message, optional, tag = "6")]
        pub length: ::core::option::Option<super::Integer>,
        /// (TBC)
        #[prost(message, optional, tag = "7")]
        pub sequence_attachment: ::core::option::Option<super::Attachment>,
        /// The nucleotide present at the 5’ terminal shall be specified based on a
        /// controlled vocabulary. Since the sequence is represented from the 5' to
        /// the 3' end, the 5’ prime nucleotide is the letter at the first position
        /// in the sequence. A separate representation would be redundant
        #[prost(message, optional, tag = "8")]
        pub five_prime: ::core::option::Option<super::CodeableConcept>,
        /// The nucleotide present at the 3’ terminal shall be specified based on a
        /// controlled vocabulary. Since the sequence is represented from the 5' to
        /// the 3' end, the 5’ prime nucleotide is the letter at the last position in
        /// the sequence. A separate representation would be redundant
        #[prost(message, optional, tag = "9")]
        pub three_prime: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "10")]
        pub linkage: prost::alloc::vec::Vec<subunit::Linkage>,
        #[prost(message, repeated, tag = "11")]
        pub sugar: prost::alloc::vec::Vec<subunit::Sugar>,
    }
    /// Nested message and enum types in `Subunit`.
    pub mod subunit {
        /// The linkages between sugar residues will also be captured
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Linkage {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The entity that links the sugar residues together should also be
            /// captured for nearly all naturally occurring nucleic acid the linkage is
            /// a phosphate group. For many synthetic oligonucleotides phosphorothioate
            /// linkages are often seen. Linkage connectivity is assumed to be 3’-5’.
            /// If the linkage is either 3’-3’ or 5’-5’ this should be specified
            #[prost(message, optional, tag = "4")]
            pub connectivity: ::core::option::Option<super::super::String>,
            /// Each linkage will be registered as a fragment and have an ID
            #[prost(message, optional, tag = "5")]
            pub identifier: ::core::option::Option<super::super::Identifier>,
            /// Each linkage will be registered as a fragment and have at least one
            /// name. A single name shall be assigned to each linkage
            #[prost(message, optional, tag = "6")]
            pub name: ::core::option::Option<super::super::String>,
            /// Residues shall be captured as described in 5.3.6.8.3
            #[prost(message, optional, tag = "7")]
            pub residue_site: ::core::option::Option<super::super::String>,
        }
        /// 5.3.6.8.1 Sugar ID (Mandatory)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Sugar {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The Substance ID of the sugar or sugar-like component that make up the
            /// nucleotide
            #[prost(message, optional, tag = "4")]
            pub identifier: ::core::option::Option<super::super::Identifier>,
            /// The name of the sugar or sugar-like component that make up the
            /// nucleotide
            #[prost(message, optional, tag = "5")]
            pub name: ::core::option::Option<super::super::String>,
            /// The residues that contain a given sugar will be captured. The order of
            /// given residues will be captured in the 5‘-3‘direction consistent with
            /// the base sequences listed above
            #[prost(message, optional, tag = "6")]
            pub residue_site: ::core::option::Option<super::super::String>,
        }
    }
}
/// Auto-generated from StructureDefinition for SubstancePolymer, last updated
/// 2019-11-01T09:29:23.356+11:00. Todo. See
/// <http://hl7.org/fhir/StructureDefinition/SubstancePolymer>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubstancePolymer {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Todo
    #[prost(message, optional, tag = "10")]
    pub class_value: ::core::option::Option<CodeableConcept>,
    /// Todo
    #[prost(message, optional, tag = "11")]
    pub geometry: ::core::option::Option<CodeableConcept>,
    /// Todo
    #[prost(message, repeated, tag = "12")]
    pub copolymer_connectivity: prost::alloc::vec::Vec<CodeableConcept>,
    /// Todo
    #[prost(message, repeated, tag = "13")]
    pub modification: prost::alloc::vec::Vec<String>,
    #[prost(message, repeated, tag = "14")]
    pub monomer_set: prost::alloc::vec::Vec<substance_polymer::MonomerSet>,
    #[prost(message, repeated, tag = "15")]
    pub repeat: prost::alloc::vec::Vec<substance_polymer::Repeat>,
}
/// Nested message and enum types in `SubstancePolymer`.
pub mod substance_polymer {
    /// Todo
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MonomerSet {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Todo
        #[prost(message, optional, tag = "4")]
        pub ratio_type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "5")]
        pub starting_material: prost::alloc::vec::Vec<monomer_set::StartingMaterial>,
    }
    /// Nested message and enum types in `MonomerSet`.
    pub mod monomer_set {
        /// Todo
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct StartingMaterial {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Todo
            #[prost(message, optional, tag = "4")]
            pub material: ::core::option::Option<super::super::CodeableConcept>,
            /// Todo
            #[prost(message, optional, tag = "5")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Todo
            #[prost(message, optional, tag = "6")]
            pub is_defining: ::core::option::Option<super::super::Boolean>,
            /// Todo
            #[prost(message, optional, tag = "7")]
            pub amount: ::core::option::Option<super::super::SubstanceAmount>,
        }
    }
    /// Todo
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Repeat {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Todo
        #[prost(message, optional, tag = "4")]
        pub number_of_units: ::core::option::Option<super::Integer>,
        /// Todo
        #[prost(message, optional, tag = "5")]
        pub average_molecular_formula: ::core::option::Option<super::String>,
        /// Todo
        #[prost(message, optional, tag = "6")]
        pub repeat_unit_amount_type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "7")]
        pub repeat_unit: prost::alloc::vec::Vec<repeat::RepeatUnit>,
    }
    /// Nested message and enum types in `Repeat`.
    pub mod repeat {
        /// Todo
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RepeatUnit {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Todo
            #[prost(message, optional, tag = "4")]
            pub orientation_of_polymerisation:
                ::core::option::Option<super::super::CodeableConcept>,
            /// Todo
            #[prost(message, optional, tag = "5")]
            pub repeat_unit: ::core::option::Option<super::super::String>,
            /// Todo
            #[prost(message, optional, tag = "6")]
            pub amount: ::core::option::Option<super::super::SubstanceAmount>,
            #[prost(message, repeated, tag = "7")]
            pub degree_of_polymerisation:
                prost::alloc::vec::Vec<repeat_unit::DegreeOfPolymerisation>,
            #[prost(message, repeated, tag = "8")]
            pub structural_representation:
                prost::alloc::vec::Vec<repeat_unit::StructuralRepresentation>,
        }
        /// Nested message and enum types in `RepeatUnit`.
        pub mod repeat_unit {
            /// Todo
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct DegreeOfPolymerisation {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Todo
                #[prost(message, optional, tag = "4")]
                pub degree: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Todo
                #[prost(message, optional, tag = "5")]
                pub amount: ::core::option::Option<super::super::super::SubstanceAmount>,
            }
            /// Todo
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct StructuralRepresentation {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Todo
                #[prost(message, optional, tag = "4")]
                pub r#type: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Todo
                #[prost(message, optional, tag = "5")]
                pub representation: ::core::option::Option<super::super::super::String>,
                /// Todo
                #[prost(message, optional, tag = "6")]
                pub attachment: ::core::option::Option<super::super::super::Attachment>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for SubstanceProtein, last updated
/// 2019-11-01T09:29:23.356+11:00. A SubstanceProtein is defined as a single unit
/// of a linear amino acid sequence, or a combination of subunits that are either
/// covalently linked or have a defined invariant stoichiometric relationship.
/// This includes all synthetic, recombinant and purified SubstanceProteins of
/// defined sequence, whether the use is therapeutic or prophylactic. This set of
/// elements will be used to describe albumins, coagulation factors, cytokines,
/// growth factors, peptide/SubstanceProtein hormones, enzymes, toxins, toxoids,
/// recombinant vaccines, and immunomodulators. See
/// <http://hl7.org/fhir/StructureDefinition/SubstanceProtein>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubstanceProtein {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The SubstanceProtein descriptive elements will only be used when a complete
    /// or partial amino acid sequence is available or derivable from a nucleic
    /// acid sequence
    #[prost(message, optional, tag = "10")]
    pub sequence_type: ::core::option::Option<CodeableConcept>,
    /// Number of linear sequences of amino acids linked through peptide bonds. The
    /// number of subunits constituting the SubstanceProtein shall be described. It
    /// is possible that the number of subunits can be variable
    #[prost(message, optional, tag = "11")]
    pub number_of_subunits: ::core::option::Option<Integer>,
    /// The disulphide bond between two cysteine residues either on the same
    /// subunit or on two different subunits shall be described. The position of
    /// the disulfide bonds in the SubstanceProtein shall be listed in increasing
    /// order of subunit number and position within subunit followed by the
    /// abbreviation of the amino acids involved. The disulfide linkage positions
    /// shall actually contain the amino acid Cysteine at the respective positions
    #[prost(message, repeated, tag = "12")]
    pub disulfide_linkage: prost::alloc::vec::Vec<String>,
    #[prost(message, repeated, tag = "13")]
    pub subunit: prost::alloc::vec::Vec<substance_protein::Subunit>,
}
/// Nested message and enum types in `SubstanceProtein`.
pub mod substance_protein {
    /// This subclause refers to the description of each subunit constituting the
    /// SubstanceProtein. A subunit is a linear sequence of amino acids linked
    /// through peptide bonds. The Subunit information shall be provided when the
    /// finished SubstanceProtein is a complex of multiple sequences; subunits are
    /// not used to delineate domains within a single sequence. Subunits are listed
    /// in order of decreasing length; sequences of the same length will be ordered
    /// by decreasing molecular weight; subunits that have identical sequences will
    /// be repeated multiple times
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Subunit {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Index of primary sequences of amino acids linked through peptide bonds in
        /// order of decreasing length. Sequences of the same length will be ordered
        /// by molecular weight. Subunits that have identical sequences will be
        /// repeated and have sequential subscripts
        #[prost(message, optional, tag = "4")]
        pub subunit: ::core::option::Option<super::Integer>,
        /// The sequence information shall be provided enumerating the amino acids
        /// from N- to C-terminal end using standard single-letter amino acid codes.
        /// Uppercase shall be used for L-amino acids and lowercase for D-amino
        /// acids. Transcribed SubstanceProteins will always be described using the
        /// translated sequence; for synthetic peptide containing amino acids that
        /// are not represented with a single letter code an X should be used within
        /// the sequence. The modified amino acids will be distinguished by their
        /// position in the sequence
        #[prost(message, optional, tag = "5")]
        pub sequence: ::core::option::Option<super::String>,
        /// Length of linear sequences of amino acids contained in the subunit
        #[prost(message, optional, tag = "6")]
        pub length: ::core::option::Option<super::Integer>,
        /// The sequence information shall be provided enumerating the amino acids
        /// from N- to C-terminal end using standard single-letter amino acid codes.
        /// Uppercase shall be used for L-amino acids and lowercase for D-amino
        /// acids. Transcribed SubstanceProteins will always be described using the
        /// translated sequence; for synthetic peptide containing amino acids that
        /// are not represented with a single letter code an X should be used within
        /// the sequence. The modified amino acids will be distinguished by their
        /// position in the sequence
        #[prost(message, optional, tag = "7")]
        pub sequence_attachment: ::core::option::Option<super::Attachment>,
        /// Unique identifier for molecular fragment modification based on the ISO
        /// 11238 Substance ID
        #[prost(message, optional, tag = "8")]
        pub n_terminal_modification_id: ::core::option::Option<super::Identifier>,
        /// The name of the fragment modified at the N-terminal of the
        /// SubstanceProtein shall be specified
        #[prost(message, optional, tag = "9")]
        pub n_terminal_modification: ::core::option::Option<super::String>,
        /// Unique identifier for molecular fragment modification based on the ISO
        /// 11238 Substance ID
        #[prost(message, optional, tag = "10")]
        pub c_terminal_modification_id: ::core::option::Option<super::Identifier>,
        /// The modification at the C-terminal shall be specified
        #[prost(message, optional, tag = "11")]
        pub c_terminal_modification: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for SubstanceReferenceInformation,
/// last updated 2019-11-01T09:29:23.356+11:00. Todo. See
/// <http://hl7.org/fhir/StructureDefinition/SubstanceReferenceInformation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubstanceReferenceInformation {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Todo
    #[prost(message, optional, tag = "10")]
    pub comment: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "11")]
    pub gene: prost::alloc::vec::Vec<substance_reference_information::Gene>,
    #[prost(message, repeated, tag = "12")]
    pub gene_element: prost::alloc::vec::Vec<substance_reference_information::GeneElement>,
    #[prost(message, repeated, tag = "13")]
    pub classification: prost::alloc::vec::Vec<substance_reference_information::Classification>,
    #[prost(message, repeated, tag = "14")]
    pub target: prost::alloc::vec::Vec<substance_reference_information::Target>,
}
/// Nested message and enum types in `SubstanceReferenceInformation`.
pub mod substance_reference_information {
    /// Todo
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Gene {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Todo
        #[prost(message, optional, tag = "4")]
        pub gene_sequence_origin: ::core::option::Option<super::CodeableConcept>,
        /// Todo
        #[prost(message, optional, tag = "5")]
        pub gene: ::core::option::Option<super::CodeableConcept>,
        /// Todo
        #[prost(message, repeated, tag = "6")]
        pub source: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Todo
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct GeneElement {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Todo
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Todo
        #[prost(message, optional, tag = "5")]
        pub element: ::core::option::Option<super::Identifier>,
        /// Todo
        #[prost(message, repeated, tag = "6")]
        pub source: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Todo
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Classification {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Todo
        #[prost(message, optional, tag = "4")]
        pub domain: ::core::option::Option<super::CodeableConcept>,
        /// Todo
        #[prost(message, optional, tag = "5")]
        pub classification: ::core::option::Option<super::CodeableConcept>,
        /// Todo
        #[prost(message, repeated, tag = "6")]
        pub subtype: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Todo
        #[prost(message, repeated, tag = "7")]
        pub source: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Todo
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Target {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Todo
        #[prost(message, optional, tag = "4")]
        pub target: ::core::option::Option<super::Identifier>,
        /// Todo
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Todo
        #[prost(message, optional, tag = "6")]
        pub interaction: ::core::option::Option<super::CodeableConcept>,
        /// Todo
        #[prost(message, optional, tag = "7")]
        pub organism: ::core::option::Option<super::CodeableConcept>,
        /// Todo
        #[prost(message, optional, tag = "8")]
        pub organism_type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "9")]
        pub amount: ::core::option::Option<target::AmountX>,
        /// Todo
        #[prost(message, optional, tag = "10")]
        pub amount_type: ::core::option::Option<super::CodeableConcept>,
        /// Todo
        #[prost(message, repeated, tag = "11")]
        pub source: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Nested message and enum types in `Target`.
    pub mod target {
        /// Todo
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AmountX {
            #[prost(oneof = "amount_x::Choice", tags = "1, 2, 3")]
            pub choice: ::core::option::Option<amount_x::Choice>,
        }
        /// Nested message and enum types in `AmountX`.
        pub mod amount_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
                #[prost(message, tag = "3")]
                StringValue(super::super::super::String),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for SubstanceSourceMaterial, last
/// updated 2019-11-01T09:29:23.356+11:00. Source material shall capture
/// information on the taxonomic and anatomical origins as well as the fraction
/// of a material that can result in or can be modified to form a substance. This
/// set of data elements shall be used to define polymer substances isolated from
/// biological matrices. Taxonomic and anatomical origins shall be described
/// using a controlled vocabulary as required. This information is captured for
/// naturally derived polymers ( . starch) and structurally diverse substances.
/// For Organisms belonging to the Kingdom Plantae the Substance level defines
/// the fresh material of a single species or infraspecies, the Herbal Drug and
/// the Herbal preparation. For Herbal preparations, the fraction information
/// will be captured at the Substance information level and additional
/// information for herbal extracts will be captured at the Specified Substance
/// Group 1 information level. See for further explanation the Substance Class:
/// Structurally Diverse and the herbal annex. See
/// <http://hl7.org/fhir/StructureDefinition/SubstanceSourceMaterial>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubstanceSourceMaterial {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// General high level classification of the source material specific to the
    /// origin of the material
    #[prost(message, optional, tag = "10")]
    pub source_material_class: ::core::option::Option<CodeableConcept>,
    /// The type of the source material shall be specified based on a controlled
    /// vocabulary. For vaccines, this subclause refers to the class of infectious
    /// agent
    #[prost(message, optional, tag = "11")]
    pub source_material_type: ::core::option::Option<CodeableConcept>,
    /// The state of the source material when extracted
    #[prost(message, optional, tag = "12")]
    pub source_material_state: ::core::option::Option<CodeableConcept>,
    /// The unique identifier associated with the source material parent organism
    /// shall be specified
    #[prost(message, optional, tag = "13")]
    pub organism_id: ::core::option::Option<Identifier>,
    /// The organism accepted Scientific name shall be provided based on the
    /// organism taxonomy
    #[prost(message, optional, tag = "14")]
    pub organism_name: ::core::option::Option<String>,
    /// The parent of the herbal drug Ginkgo biloba, Leaf is the substance ID of
    /// the substance (fresh) of Ginkgo biloba L. or Ginkgo biloba L. (Whole plant)
    #[prost(message, repeated, tag = "15")]
    pub parent_substance_id: prost::alloc::vec::Vec<Identifier>,
    /// The parent substance of the Herbal Drug, or Herbal preparation
    #[prost(message, repeated, tag = "16")]
    pub parent_substance_name: prost::alloc::vec::Vec<String>,
    /// The country where the plant material is harvested or the countries where
    /// the plasma is sourced from as laid down in accordance with the Plasma
    /// Master File. For “Plasma-derived substances” the attribute country of
    /// origin provides information about the countries used for the manufacturing
    /// of the Cryopoor plama or Crioprecipitate
    #[prost(message, repeated, tag = "17")]
    pub country_of_origin: prost::alloc::vec::Vec<CodeableConcept>,
    /// The place/region where the plant is harvested or the places/regions where
    /// the animal source material has its habitat
    #[prost(message, repeated, tag = "18")]
    pub geographical_location: prost::alloc::vec::Vec<String>,
    /// Stage of life for animals, plants, insects and microorganisms. This
    /// information shall be provided only when the substance is significantly
    /// different in these stages (e.g. foetal bovine serum)
    #[prost(message, optional, tag = "19")]
    pub development_stage: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "20")]
    pub fraction_description:
        prost::alloc::vec::Vec<substance_source_material::FractionDescription>,
    #[prost(message, optional, tag = "21")]
    pub organism: ::core::option::Option<substance_source_material::Organism>,
    #[prost(message, repeated, tag = "22")]
    pub part_description: prost::alloc::vec::Vec<substance_source_material::PartDescription>,
}
/// Nested message and enum types in `SubstanceSourceMaterial`.
pub mod substance_source_material {
    /// Many complex materials are fractions of parts of plants, animals, or
    /// minerals. Fraction elements are often necessary to define both Substances
    /// and Specified Group 1 Substances. For substances derived from Plants,
    /// fraction information will be captured at the Substance information level (
    /// . Oils, Juices and Exudates). Additional information for Extracts, such as
    /// extraction solvent composition, will be captured at the Specified Substance
    /// Group 1 information level. For plasma-derived products fraction information
    /// will be captured at the Substance and the Specified Substance Group 1
    /// levels
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FractionDescription {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// This element is capturing information about the fraction of a plant part,
        /// or human plasma for fractionation
        #[prost(message, optional, tag = "4")]
        pub fraction: ::core::option::Option<super::String>,
        /// The specific type of the material constituting the component. For Herbal
        /// preparations the particulars of the extracts (liquid/dry) is described in
        /// Specified Substance Group 1
        #[prost(message, optional, tag = "5")]
        pub material_type: ::core::option::Option<super::CodeableConcept>,
    }
    /// This subclause describes the organism which the substance is derived from.
    /// For vaccines, the parent organism shall be specified based on these
    /// subclause elements. As an example, full taxonomy will be described for the
    /// Substance Name: ., Leaf
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Organism {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The family of an organism shall be specified
        #[prost(message, optional, tag = "4")]
        pub family: ::core::option::Option<super::CodeableConcept>,
        /// The genus of an organism shall be specified; refers to the Latin epithet
        /// of the genus element of the plant/animal scientific name; it is present
        /// in names for genera, species and infraspecies
        #[prost(message, optional, tag = "5")]
        pub genus: ::core::option::Option<super::CodeableConcept>,
        /// The species of an organism shall be specified; refers to the Latin
        /// epithet of the species of the plant/animal; it is present in names for
        /// species and infraspecies
        #[prost(message, optional, tag = "6")]
        pub species: ::core::option::Option<super::CodeableConcept>,
        /// The Intraspecific type of an organism shall be specified
        #[prost(message, optional, tag = "7")]
        pub intraspecific_type: ::core::option::Option<super::CodeableConcept>,
        /// The intraspecific description of an organism shall be specified based on
        /// a controlled vocabulary. For Influenza Vaccine, the intraspecific
        /// description shall contain the syntax of the antigen in line with the WHO
        /// convention
        #[prost(message, optional, tag = "8")]
        pub intraspecific_description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "9")]
        pub author: prost::alloc::vec::Vec<organism::Author>,
        #[prost(message, optional, tag = "10")]
        pub hybrid: ::core::option::Option<organism::Hybrid>,
        #[prost(message, optional, tag = "11")]
        pub organism_general: ::core::option::Option<organism::OrganismGeneral>,
    }
    /// Nested message and enum types in `Organism`.
    pub mod organism {
        /// 4.9.13.6.1 Author type (Conditional)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Author {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The type of author of an organism species shall be specified. The
            /// parenthetical author of an organism species refers to the first author
            /// who published the plant/animal name (of any rank). The primary author
            /// of an organism species refers to the first author(s), who validly
            /// published the plant/animal name
            #[prost(message, optional, tag = "4")]
            pub author_type: ::core::option::Option<super::super::CodeableConcept>,
            /// The author of an organism species shall be specified. The author year
            /// of an organism shall also be specified when applicable; refers to the
            /// year in which the first author(s) published the infraspecific
            /// plant/animal name (of any rank)
            #[prost(message, optional, tag = "5")]
            pub author_description: ::core::option::Option<super::super::String>,
        }
        /// 4.9.13.8.1 Hybrid species maternal organism ID (Optional)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Hybrid {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The identifier of the maternal species constituting the hybrid organism
            /// shall be specified based on a controlled vocabulary. For plants, the
            /// parents aren’t always known, and it is unlikely that it will be known
            /// which is maternal and which is paternal
            #[prost(message, optional, tag = "4")]
            pub maternal_organism_id: ::core::option::Option<super::super::String>,
            /// The name of the maternal species constituting the hybrid organism shall
            /// be specified. For plants, the parents aren’t always known, and it is
            /// unlikely that it will be known which is maternal and which is paternal
            #[prost(message, optional, tag = "5")]
            pub maternal_organism_name: ::core::option::Option<super::super::String>,
            /// The identifier of the paternal species constituting the hybrid organism
            /// shall be specified based on a controlled vocabulary
            #[prost(message, optional, tag = "6")]
            pub paternal_organism_id: ::core::option::Option<super::super::String>,
            /// The name of the paternal species constituting the hybrid organism shall
            /// be specified
            #[prost(message, optional, tag = "7")]
            pub paternal_organism_name: ::core::option::Option<super::super::String>,
            /// The hybrid type of an organism shall be specified
            #[prost(message, optional, tag = "8")]
            pub hybrid_type: ::core::option::Option<super::super::CodeableConcept>,
        }
        /// 4.9.13.7.1 Kingdom (Conditional)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct OrganismGeneral {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The kingdom of an organism shall be specified
            #[prost(message, optional, tag = "4")]
            pub kingdom: ::core::option::Option<super::super::CodeableConcept>,
            /// The phylum of an organism shall be specified
            #[prost(message, optional, tag = "5")]
            pub phylum: ::core::option::Option<super::super::CodeableConcept>,
            /// The class of an organism shall be specified
            #[prost(message, optional, tag = "6")]
            pub class_value: ::core::option::Option<super::super::CodeableConcept>,
            /// The order of an organism shall be specified,
            #[prost(message, optional, tag = "7")]
            pub order: ::core::option::Option<super::super::CodeableConcept>,
        }
    }
    /// To do
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PartDescription {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Entity of anatomical origin of source material within an organism
        #[prost(message, optional, tag = "4")]
        pub part: ::core::option::Option<super::CodeableConcept>,
        /// The detailed anatomic location when the part can be extracted from
        /// different anatomical locations of the organism. Multiple alternative
        /// locations may apply
        #[prost(message, optional, tag = "5")]
        pub part_location: ::core::option::Option<super::CodeableConcept>,
    }
}
/// Auto-generated from StructureDefinition for SubstanceSpecification, last
/// updated 2019-11-01T09:29:23.356+11:00. The detailed description of a
/// substance, typically at a level beyond what is used for prescribing. See
/// <http://hl7.org/fhir/StructureDefinition/SubstanceSpecification>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubstanceSpecification {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifier by which this substance is known
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// High level categorization, e.g. polymer or nucleic acid
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Status of substance within the catalogue e.g. approved
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<CodeableConcept>,
    /// If the substance applies to only human or veterinary use
    #[prost(message, optional, tag = "13")]
    pub domain: ::core::option::Option<CodeableConcept>,
    /// Textual description of the substance
    #[prost(message, optional, tag = "14")]
    pub description: ::core::option::Option<String>,
    /// Supporting literature
    #[prost(message, repeated, tag = "15")]
    pub source: prost::alloc::vec::Vec<Reference>,
    /// Textual comment about this record of a substance
    #[prost(message, optional, tag = "16")]
    pub comment: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "17")]
    pub moiety: prost::alloc::vec::Vec<substance_specification::Moiety>,
    #[prost(message, repeated, tag = "18")]
    pub property: prost::alloc::vec::Vec<substance_specification::Property>,
    /// General information detailing this substance
    #[prost(message, optional, tag = "19")]
    pub reference_information: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "20")]
    pub structure: ::core::option::Option<substance_specification::Structure>,
    #[prost(message, repeated, tag = "21")]
    pub code: prost::alloc::vec::Vec<substance_specification::CodeType>,
    #[prost(message, repeated, tag = "22")]
    pub name: prost::alloc::vec::Vec<substance_specification::Name>,
    /// The molecular weight or weight range (for proteins, polymers or nucleic
    /// acids)
    #[prost(message, repeated, tag = "23")]
    pub molecular_weight:
        prost::alloc::vec::Vec<substance_specification::structure::isotope::MolecularWeight>,
    #[prost(message, repeated, tag = "24")]
    pub relationship: prost::alloc::vec::Vec<substance_specification::Relationship>,
    /// Data items specific to nucleic acids
    #[prost(message, optional, tag = "25")]
    pub nucleic_acid: ::core::option::Option<Reference>,
    /// Data items specific to polymers
    #[prost(message, optional, tag = "26")]
    pub polymer: ::core::option::Option<Reference>,
    /// Data items specific to proteins
    #[prost(message, optional, tag = "27")]
    pub protein: ::core::option::Option<Reference>,
    /// Material or taxonomic/anatomical source for the substance
    #[prost(message, optional, tag = "28")]
    pub source_material: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `SubstanceSpecification`.
pub mod substance_specification {
    /// Moiety, for structural modifications
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Moiety {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Role that the moiety is playing
        #[prost(message, optional, tag = "4")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Identifier by which this moiety substance is known
        #[prost(message, optional, tag = "5")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Textual name for this moiety substance
        #[prost(message, optional, tag = "6")]
        pub name: ::core::option::Option<super::String>,
        /// Stereochemistry type
        #[prost(message, optional, tag = "7")]
        pub stereochemistry: ::core::option::Option<super::CodeableConcept>,
        /// Optical activity type
        #[prost(message, optional, tag = "8")]
        pub optical_activity: ::core::option::Option<super::CodeableConcept>,
        /// Molecular formula
        #[prost(message, optional, tag = "9")]
        pub molecular_formula: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "10")]
        pub amount: ::core::option::Option<moiety::AmountX>,
    }
    /// Nested message and enum types in `Moiety`.
    pub mod moiety {
        /// Quantitative value for this moiety
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AmountX {
            #[prost(oneof = "amount_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<amount_x::Choice>,
        }
        /// Nested message and enum types in `AmountX`.
        pub mod amount_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "2")]
                StringValue(super::super::super::String),
            }
        }
    }
    /// General specifications for this substance, including how it is related to
    /// other substances
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Property {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// A category for this property, e.g. Physical, Chemical, Enzymatic
        #[prost(message, optional, tag = "4")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Property type e.g. viscosity, pH, isoelectric point
        #[prost(message, optional, tag = "5")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Parameters that were used in the measurement of a property (e.g. for
        /// viscosity: measured at 20C with a pH of 7.1)
        #[prost(message, optional, tag = "6")]
        pub parameters: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "7")]
        pub defining_substance: ::core::option::Option<property::DefiningSubstanceX>,
        #[prost(message, optional, tag = "8")]
        pub amount: ::core::option::Option<property::AmountX>,
    }
    /// Nested message and enum types in `Property`.
    pub mod property {
        /// A substance upon which a defining property depends (e.g. for solubility:
        /// in water, in alcohol)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DefiningSubstanceX {
            #[prost(oneof = "defining_substance_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<defining_substance_x::Choice>,
        }
        /// Nested message and enum types in `DefiningSubstanceX`.
        pub mod defining_substance_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "2")]
                CodeableConcept(super::super::super::CodeableConcept),
            }
        }
        /// Quantitative value for this property
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AmountX {
            #[prost(oneof = "amount_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<amount_x::Choice>,
        }
        /// Nested message and enum types in `AmountX`.
        pub mod amount_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "2")]
                StringValue(super::super::super::String),
            }
        }
    }
    /// Structural information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Structure {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Stereochemistry type
        #[prost(message, optional, tag = "4")]
        pub stereochemistry: ::core::option::Option<super::CodeableConcept>,
        /// Optical activity type
        #[prost(message, optional, tag = "5")]
        pub optical_activity: ::core::option::Option<super::CodeableConcept>,
        /// Molecular formula
        #[prost(message, optional, tag = "6")]
        pub molecular_formula: ::core::option::Option<super::String>,
        /// Specified per moiety according to the Hill system, i.e. first C, then H,
        /// then alphabetical, each moiety separated by a dot
        #[prost(message, optional, tag = "7")]
        pub molecular_formula_by_moiety: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "8")]
        pub isotope: prost::alloc::vec::Vec<structure::Isotope>,
        /// The molecular weight or weight range (for proteins, polymers or nucleic
        /// acids)
        #[prost(message, optional, tag = "9")]
        pub molecular_weight: ::core::option::Option<structure::isotope::MolecularWeight>,
        /// Supporting literature
        #[prost(message, repeated, tag = "10")]
        pub source: prost::alloc::vec::Vec<super::Reference>,
        #[prost(message, repeated, tag = "11")]
        pub representation: prost::alloc::vec::Vec<structure::Representation>,
    }
    /// Nested message and enum types in `Structure`.
    pub mod structure {
        /// Applicable for single substances that contain a radionuclide or a
        /// non-natural isotopic ratio
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Isotope {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Substance identifier for each non-natural or radioisotope
            #[prost(message, optional, tag = "4")]
            pub identifier: ::core::option::Option<super::super::Identifier>,
            /// Substance name for each non-natural or radioisotope
            #[prost(message, optional, tag = "5")]
            pub name: ::core::option::Option<super::super::CodeableConcept>,
            /// The type of isotopic substitution present in a single substance
            #[prost(message, optional, tag = "6")]
            pub substitution: ::core::option::Option<super::super::CodeableConcept>,
            /// Half life - for a non-natural nuclide
            #[prost(message, optional, tag = "7")]
            pub half_life: ::core::option::Option<super::super::Quantity>,
            #[prost(message, optional, tag = "8")]
            pub molecular_weight: ::core::option::Option<isotope::MolecularWeight>,
        }
        /// Nested message and enum types in `Isotope`.
        pub mod isotope {
            /// The molecular weight or weight range (for proteins, polymers or nucleic
            /// acids)
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct MolecularWeight {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// The method by which the molecular weight was determined
                #[prost(message, optional, tag = "4")]
                pub method: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Type of molecular weight such as exact, average (also known as.
                /// number average), weight average
                #[prost(message, optional, tag = "5")]
                pub r#type: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Used to capture quantitative values for a variety of elements. If
                /// only limits are given, the arithmetic mean would be the average. If
                /// only a single definite value for a given element is given, it would
                /// be captured in this field
                #[prost(message, optional, tag = "6")]
                pub amount: ::core::option::Option<super::super::super::Quantity>,
            }
        }
        /// Molecular structural representation
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Representation {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The type of structure (e.g. Full, Partial, Representative)
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// The structural representation as text string in a format e.g. InChI,
            /// SMILES, MOLFILE, CDX
            #[prost(message, optional, tag = "5")]
            pub representation: ::core::option::Option<super::super::String>,
            /// An attached file with the structural representation
            #[prost(message, optional, tag = "6")]
            pub attachment: ::core::option::Option<super::super::Attachment>,
        }
    }
    /// Codes associated with the substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CodeType {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The specific code
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Status of the code assignment
        #[prost(message, optional, tag = "5")]
        pub status: ::core::option::Option<super::CodeableConcept>,
        /// The date at which the code status is changed as part of the terminology
        /// maintenance
        #[prost(message, optional, tag = "6")]
        pub status_date: ::core::option::Option<super::DateTime>,
        /// Any comment can be provided in this field, if necessary
        #[prost(message, optional, tag = "7")]
        pub comment: ::core::option::Option<super::String>,
        /// Supporting literature
        #[prost(message, repeated, tag = "8")]
        pub source: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Names applicable to this substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Name {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The actual name
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Name type
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// The status of the name
        #[prost(message, optional, tag = "6")]
        pub status: ::core::option::Option<super::CodeableConcept>,
        /// If this is the preferred name for this substance
        #[prost(message, optional, tag = "7")]
        pub preferred: ::core::option::Option<super::Boolean>,
        /// Language of the name
        #[prost(message, repeated, tag = "8")]
        pub language: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// The use context of this name for example if there is a different name a
        /// drug active ingredient as opposed to a food colour additive
        #[prost(message, repeated, tag = "9")]
        pub domain: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// The jurisdiction where this name applies
        #[prost(message, repeated, tag = "10")]
        pub jurisdiction: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// A synonym of this name
        #[prost(message, repeated, tag = "11")]
        pub synonym: prost::alloc::vec::Vec<Name>,
        /// A translation for this name
        #[prost(message, repeated, tag = "12")]
        pub translation: prost::alloc::vec::Vec<Name>,
        #[prost(message, repeated, tag = "13")]
        pub official: prost::alloc::vec::Vec<name::Official>,
        /// Supporting literature
        #[prost(message, repeated, tag = "14")]
        pub source: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Nested message and enum types in `Name`.
    pub mod name {
        /// Details of the official nature of this name
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Official {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Which authority uses this official name
            #[prost(message, optional, tag = "4")]
            pub authority: ::core::option::Option<super::super::CodeableConcept>,
            /// The status of the official name
            #[prost(message, optional, tag = "5")]
            pub status: ::core::option::Option<super::super::CodeableConcept>,
            /// Date of official name change
            #[prost(message, optional, tag = "6")]
            pub date: ::core::option::Option<super::super::DateTime>,
        }
    }
    /// A link between this substance and another, with details of the relationship
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Relationship {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub substance: ::core::option::Option<relationship::SubstanceX>,
        /// For example "salt to parent", "active moiety", "starting material"
        #[prost(message, optional, tag = "5")]
        pub relationship: ::core::option::Option<super::CodeableConcept>,
        /// For example where an enzyme strongly bonds with a particular substance,
        /// this is a defining relationship for that enzyme, out of several possible
        /// substance relationships
        #[prost(message, optional, tag = "6")]
        pub is_defining: ::core::option::Option<super::Boolean>,
        #[prost(message, optional, tag = "7")]
        pub amount: ::core::option::Option<relationship::AmountX>,
        /// For use when the numeric
        #[prost(message, optional, tag = "8")]
        pub amount_ratio_low_limit: ::core::option::Option<super::Ratio>,
        /// An operator for the amount, for example "average", "approximately", "less
        /// than"
        #[prost(message, optional, tag = "9")]
        pub amount_type: ::core::option::Option<super::CodeableConcept>,
        /// Supporting literature
        #[prost(message, repeated, tag = "10")]
        pub source: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Nested message and enum types in `Relationship`.
    pub mod relationship {
        /// A pointer to another substance, as a resource or just a representational
        /// code
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SubstanceX {
            #[prost(oneof = "substance_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<substance_x::Choice>,
        }
        /// Nested message and enum types in `SubstanceX`.
        pub mod substance_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "2")]
                CodeableConcept(super::super::super::CodeableConcept),
            }
        }
        /// A numeric factor for the relationship, for instance to express that the
        /// salt of a substance has some percentage of the active substance in
        /// relation to some other
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AmountX {
            #[prost(oneof = "amount_x::Choice", tags = "1, 2, 3, 4")]
            pub choice: ::core::option::Option<amount_x::Choice>,
        }
        /// Nested message and enum types in `AmountX`.
        pub mod amount_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
                #[prost(message, tag = "3")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "4")]
                StringValue(super::super::super::String),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for SupplyDelivery, last updated
/// 2019-11-01T09:29:23.356+11:00. Delivery of bulk Supplies. See
/// <http://hl7.org/fhir/StructureDefinition/SupplyDelivery>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyDelivery {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Fulfills plan, proposal or order
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced event
    #[prost(message, repeated, tag = "12")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<supply_delivery::StatusCode>,
    /// Patient for whom the item is supplied
    #[prost(message, optional, tag = "14")]
    pub patient: ::core::option::Option<Reference>,
    /// Category of dispense event
    #[prost(message, optional, tag = "15")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "16")]
    pub supplied_item: ::core::option::Option<supply_delivery::SuppliedItem>,
    #[prost(message, optional, tag = "17")]
    pub occurrence: ::core::option::Option<supply_delivery::OccurrenceX>,
    /// Dispenser
    #[prost(message, optional, tag = "18")]
    pub supplier: ::core::option::Option<Reference>,
    /// Where the Supply was sent
    #[prost(message, optional, tag = "19")]
    pub destination: ::core::option::Option<Reference>,
    /// Who collected the Supply
    #[prost(message, repeated, tag = "20")]
    pub receiver: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `SupplyDelivery`.
pub mod supply_delivery {
    /// in-progress | completed | abandoned | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::supply_delivery_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// The item that is delivered or supplied
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SuppliedItem {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Amount dispensed
        #[prost(message, optional, tag = "4")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        #[prost(message, optional, tag = "5")]
        pub item: ::core::option::Option<supplied_item::ItemX>,
    }
    /// Nested message and enum types in `SuppliedItem`.
    pub mod supplied_item {
        /// Medication, Substance, or Device supplied
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ItemX {
            #[prost(oneof = "item_x::Choice", tags = "1, 2")]
            pub choice: ::core::option::Option<item_x::Choice>,
        }
        /// Nested message and enum types in `ItemX`.
        pub mod item_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// When event occurred
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OccurrenceX {
        #[prost(oneof = "occurrence_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<occurrence_x::Choice>,
    }
    /// Nested message and enum types in `OccurrenceX`.
    pub mod occurrence_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
        }
    }
}
/// Auto-generated from StructureDefinition for SupplyRequest, last updated
/// 2019-11-01T09:29:23.356+11:00. Request for a medication, substance or device.
/// See <http://hl7.org/fhir/StructureDefinition/SupplyRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for SupplyRequest
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<supply_request::StatusCode>,
    /// The kind of supply (central, non-stock, etc.)
    #[prost(message, optional, tag = "12")]
    pub category: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "13")]
    pub priority: ::core::option::Option<supply_request::PriorityCode>,
    #[prost(message, optional, tag = "14")]
    pub item: ::core::option::Option<supply_request::ItemX>,
    /// The requested amount of the item indicated
    #[prost(message, optional, tag = "15")]
    pub quantity: ::core::option::Option<Quantity>,
    #[prost(message, repeated, tag = "16")]
    pub parameter: prost::alloc::vec::Vec<supply_request::Parameter>,
    #[prost(message, optional, tag = "17")]
    pub occurrence: ::core::option::Option<supply_request::OccurrenceX>,
    /// When the request was made
    #[prost(message, optional, tag = "18")]
    pub authored_on: ::core::option::Option<DateTime>,
    /// Individual making the request
    #[prost(message, optional, tag = "19")]
    pub requester: ::core::option::Option<Reference>,
    /// Who is intended to fulfill the request
    #[prost(message, repeated, tag = "20")]
    pub supplier: prost::alloc::vec::Vec<Reference>,
    /// The reason why the supply item was requested
    #[prost(message, repeated, tag = "21")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// The reason why the supply item was requested
    #[prost(message, repeated, tag = "22")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// The origin of the supply
    #[prost(message, optional, tag = "23")]
    pub deliver_from: ::core::option::Option<Reference>,
    /// The destination of the supply
    #[prost(message, optional, tag = "24")]
    pub deliver_to: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `SupplyRequest`.
pub mod supply_request {
    /// draft | active | suspended +
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::supply_request_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// routine | urgent | asap | stat
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PriorityCode {
        #[prost(enumeration = "super::request_priority_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Medication, Substance, or Device requested to be supplied
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ItemX {
        #[prost(oneof = "item_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<item_x::Choice>,
    }
    /// Nested message and enum types in `ItemX`.
    pub mod item_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Ordered item details
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Parameter {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Item detail
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<parameter::ValueX>,
    }
    /// Nested message and enum types in `Parameter`.
    pub mod parameter {
        /// Value of detail
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4")]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "3")]
                Range(super::super::super::Range),
                #[prost(message, tag = "4")]
                Boolean(super::super::super::Boolean),
            }
        }
    }
    /// When the request should be fulfilled
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OccurrenceX {
        #[prost(oneof = "occurrence_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<occurrence_x::Choice>,
    }
    /// Nested message and enum types in `OccurrenceX`.
    pub mod occurrence_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
        }
    }
}
/// Auto-generated from StructureDefinition for Task, last updated
/// 2019-11-01T09:29:23.356+11:00. A task to be performed. See
/// <http://hl7.org/fhir/StructureDefinition/Task>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Task {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Task Instance Identifier
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Formal definition of task
    #[prost(message, optional, tag = "11")]
    pub instantiates_canonical: ::core::option::Option<Canonical>,
    /// Formal definition of task
    #[prost(message, optional, tag = "12")]
    pub instantiates_uri: ::core::option::Option<Uri>,
    /// Request fulfilled by this task
    #[prost(message, repeated, tag = "13")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Requisition or grouper id
    #[prost(message, optional, tag = "14")]
    pub group_identifier: ::core::option::Option<Identifier>,
    /// Composite task
    #[prost(message, repeated, tag = "15")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "16")]
    pub status: ::core::option::Option<task::StatusCode>,
    /// Reason for current status
    #[prost(message, optional, tag = "17")]
    pub status_reason: ::core::option::Option<CodeableConcept>,
    /// E.g. "Specimen collected", "IV prepped"
    #[prost(message, optional, tag = "18")]
    pub business_status: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "19")]
    pub intent: ::core::option::Option<task::IntentCode>,
    #[prost(message, optional, tag = "20")]
    pub priority: ::core::option::Option<task::PriorityCode>,
    /// Task Type
    #[prost(message, optional, tag = "21")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Human-readable explanation of task
    #[prost(message, optional, tag = "22")]
    pub description: ::core::option::Option<String>,
    /// What task is acting on
    #[prost(message, optional, tag = "23")]
    pub focus: ::core::option::Option<Reference>,
    /// Beneficiary of the Task
    #[prost(message, optional, tag = "24")]
    pub for_value: ::core::option::Option<Reference>,
    /// Healthcare event during which this task originated
    #[prost(message, optional, tag = "25")]
    pub encounter: ::core::option::Option<Reference>,
    /// Start and end time of execution
    #[prost(message, optional, tag = "26")]
    pub execution_period: ::core::option::Option<Period>,
    /// Task Creation Date
    #[prost(message, optional, tag = "27")]
    pub authored_on: ::core::option::Option<DateTime>,
    /// Task Last Modified Date
    #[prost(message, optional, tag = "28")]
    pub last_modified: ::core::option::Option<DateTime>,
    /// Who is asking for task to be done
    #[prost(message, optional, tag = "29")]
    pub requester: ::core::option::Option<Reference>,
    /// Requested performer
    #[prost(message, repeated, tag = "30")]
    pub performer_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Responsible individual
    #[prost(message, optional, tag = "31")]
    pub owner: ::core::option::Option<Reference>,
    /// Where task occurs
    #[prost(message, optional, tag = "32")]
    pub location: ::core::option::Option<Reference>,
    /// Why task is needed
    #[prost(message, optional, tag = "33")]
    pub reason_code: ::core::option::Option<CodeableConcept>,
    /// Why task is needed
    #[prost(message, optional, tag = "34")]
    pub reason_reference: ::core::option::Option<Reference>,
    /// Associated insurance coverage
    #[prost(message, repeated, tag = "35")]
    pub insurance: prost::alloc::vec::Vec<Reference>,
    /// Comments made about the task
    #[prost(message, repeated, tag = "36")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Key events in history of the Task
    #[prost(message, repeated, tag = "37")]
    pub relevant_history: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "38")]
    pub restriction: ::core::option::Option<task::Restriction>,
    #[prost(message, repeated, tag = "39")]
    pub input: prost::alloc::vec::Vec<task::Parameter>,
    #[prost(message, repeated, tag = "40")]
    pub output: prost::alloc::vec::Vec<task::Output>,
}
/// Nested message and enum types in `Task`.
pub mod task {
    /// draft | requested | received | accepted | +
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::task_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// unknown | proposal | plan | order | original-order | reflex-order |
    /// filler-order | instance-order | option
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct IntentCode {
        #[prost(enumeration = "super::task_intent_value_set::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// routine | urgent | asap | stat
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PriorityCode {
        #[prost(enumeration = "super::request_priority_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Constraints on fulfillment tasks
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Restriction {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// How many times to repeat
        #[prost(message, optional, tag = "4")]
        pub repetitions: ::core::option::Option<super::PositiveInt>,
        /// When fulfillment sought
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
        /// For whom is fulfillment sought?
        #[prost(message, repeated, tag = "6")]
        pub recipient: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Information used to perform task
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Parameter {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Label for the input
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<parameter::ValueX>,
    }
    /// Nested message and enum types in `Parameter`.
    pub mod parameter {
        /// Content to use in performing the task
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(
                oneof = "value_x::Choice",
                tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50"
            )]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Base64Binary(super::super::super::Base64Binary),
                #[prost(message, tag = "2")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "3")]
                Canonical(super::super::super::Canonical),
                #[prost(message, tag = "4")]
                Code(super::super::super::Code),
                #[prost(message, tag = "5")]
                Date(super::super::super::Date),
                #[prost(message, tag = "6")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "7")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "8")]
                Id(super::super::super::Id),
                #[prost(message, tag = "9")]
                Instant(super::super::super::Instant),
                #[prost(message, tag = "10")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "11")]
                Markdown(super::super::super::Markdown),
                #[prost(message, tag = "12")]
                Oid(super::super::super::Oid),
                #[prost(message, tag = "13")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "14")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "15")]
                Time(super::super::super::Time),
                #[prost(message, tag = "16")]
                UnsignedInt(super::super::super::UnsignedInt),
                #[prost(message, tag = "17")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "18")]
                Url(super::super::super::Url),
                #[prost(message, tag = "19")]
                Uuid(super::super::super::Uuid),
                #[prost(message, tag = "20")]
                Address(super::super::super::Address),
                #[prost(message, tag = "21")]
                Age(super::super::super::Age),
                #[prost(message, tag = "22")]
                Annotation(super::super::super::Annotation),
                #[prost(message, tag = "23")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "24")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "25")]
                Coding(super::super::super::Coding),
                #[prost(message, tag = "26")]
                ContactPoint(super::super::super::ContactPoint),
                #[prost(message, tag = "27")]
                Count(super::super::super::Count),
                #[prost(message, tag = "28")]
                Distance(super::super::super::Distance),
                #[prost(message, tag = "29")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "30")]
                HumanName(super::super::super::HumanName),
                #[prost(message, tag = "31")]
                Identifier(super::super::super::Identifier),
                #[prost(message, tag = "32")]
                Money(super::super::super::Money),
                #[prost(message, tag = "33")]
                Period(super::super::super::Period),
                #[prost(message, tag = "34")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "35")]
                Range(super::super::super::Range),
                #[prost(message, tag = "36")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "37")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "38")]
                SampledData(super::super::super::SampledData),
                #[prost(message, tag = "39")]
                Signature(super::super::super::Signature),
                #[prost(message, tag = "40")]
                Timing(super::super::super::Timing),
                #[prost(message, tag = "41")]
                ContactDetail(super::super::super::ContactDetail),
                #[prost(message, tag = "42")]
                Contributor(super::super::super::Contributor),
                #[prost(message, tag = "43")]
                DataRequirement(super::super::super::DataRequirement),
                #[prost(message, tag = "44")]
                Expression(super::super::super::Expression),
                #[prost(message, tag = "45")]
                ParameterDefinition(super::super::super::ParameterDefinition),
                #[prost(message, tag = "46")]
                RelatedArtifact(super::super::super::RelatedArtifact),
                #[prost(message, tag = "47")]
                TriggerDefinition(super::super::super::TriggerDefinition),
                #[prost(message, tag = "48")]
                UsageContext(super::super::super::UsageContext),
                #[prost(message, tag = "49")]
                Dosage(super::super::super::Dosage),
                #[prost(message, tag = "50")]
                Meta(super::super::super::Meta),
            }
        }
    }
    /// Information produced as part of task
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Output {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Label for output
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<output::ValueX>,
    }
    /// Nested message and enum types in `Output`.
    pub mod output {
        /// Result of output
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueX {
            #[prost(
                oneof = "value_x::Choice",
                tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50"
            )]
            pub choice: ::core::option::Option<value_x::Choice>,
        }
        /// Nested message and enum types in `ValueX`.
        pub mod value_x {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Choice {
                #[prost(message, tag = "1")]
                Base64Binary(super::super::super::Base64Binary),
                #[prost(message, tag = "2")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "3")]
                Canonical(super::super::super::Canonical),
                #[prost(message, tag = "4")]
                Code(super::super::super::Code),
                #[prost(message, tag = "5")]
                Date(super::super::super::Date),
                #[prost(message, tag = "6")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "7")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "8")]
                Id(super::super::super::Id),
                #[prost(message, tag = "9")]
                Instant(super::super::super::Instant),
                #[prost(message, tag = "10")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "11")]
                Markdown(super::super::super::Markdown),
                #[prost(message, tag = "12")]
                Oid(super::super::super::Oid),
                #[prost(message, tag = "13")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "14")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "15")]
                Time(super::super::super::Time),
                #[prost(message, tag = "16")]
                UnsignedInt(super::super::super::UnsignedInt),
                #[prost(message, tag = "17")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "18")]
                Url(super::super::super::Url),
                #[prost(message, tag = "19")]
                Uuid(super::super::super::Uuid),
                #[prost(message, tag = "20")]
                Address(super::super::super::Address),
                #[prost(message, tag = "21")]
                Age(super::super::super::Age),
                #[prost(message, tag = "22")]
                Annotation(super::super::super::Annotation),
                #[prost(message, tag = "23")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "24")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "25")]
                Coding(super::super::super::Coding),
                #[prost(message, tag = "26")]
                ContactPoint(super::super::super::ContactPoint),
                #[prost(message, tag = "27")]
                Count(super::super::super::Count),
                #[prost(message, tag = "28")]
                Distance(super::super::super::Distance),
                #[prost(message, tag = "29")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "30")]
                HumanName(super::super::super::HumanName),
                #[prost(message, tag = "31")]
                Identifier(super::super::super::Identifier),
                #[prost(message, tag = "32")]
                Money(super::super::super::Money),
                #[prost(message, tag = "33")]
                Period(super::super::super::Period),
                #[prost(message, tag = "34")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "35")]
                Range(super::super::super::Range),
                #[prost(message, tag = "36")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "37")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "38")]
                SampledData(super::super::super::SampledData),
                #[prost(message, tag = "39")]
                Signature(super::super::super::Signature),
                #[prost(message, tag = "40")]
                Timing(super::super::super::Timing),
                #[prost(message, tag = "41")]
                ContactDetail(super::super::super::ContactDetail),
                #[prost(message, tag = "42")]
                Contributor(super::super::super::Contributor),
                #[prost(message, tag = "43")]
                DataRequirement(super::super::super::DataRequirement),
                #[prost(message, tag = "44")]
                Expression(super::super::super::Expression),
                #[prost(message, tag = "45")]
                ParameterDefinition(super::super::super::ParameterDefinition),
                #[prost(message, tag = "46")]
                RelatedArtifact(super::super::super::RelatedArtifact),
                #[prost(message, tag = "47")]
                TriggerDefinition(super::super::super::TriggerDefinition),
                #[prost(message, tag = "48")]
                UsageContext(super::super::super::UsageContext),
                #[prost(message, tag = "49")]
                Dosage(super::super::super::Dosage),
                #[prost(message, tag = "50")]
                Meta(super::super::super::Meta),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for TerminologyCapabilities, last
/// updated 2019-11-01T09:29:23.356+11:00. A statement of system capabilities.
/// See <http://hl7.org/fhir/StructureDefinition/TerminologyCapabilities>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TerminologyCapabilities {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this terminology capabilities, represented as a
    /// URI (globally unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the terminology capabilities
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this terminology capabilities (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this terminology capabilities (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<terminology_capabilities::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the terminology capabilities
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for terminology capabilities (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this terminology capabilities is defined
    #[prost(message, optional, tag = "22")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "23")]
    pub copyright: ::core::option::Option<Markdown>,
    #[prost(message, optional, tag = "24")]
    pub kind: ::core::option::Option<terminology_capabilities::KindCode>,
    #[prost(message, optional, tag = "25")]
    pub software: ::core::option::Option<terminology_capabilities::Software>,
    #[prost(message, optional, tag = "26")]
    pub implementation: ::core::option::Option<terminology_capabilities::Implementation>,
    /// Whether lockedDate is supported
    #[prost(message, optional, tag = "27")]
    pub locked_date: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "28")]
    pub code_system: prost::alloc::vec::Vec<terminology_capabilities::CodeSystem>,
    #[prost(message, optional, tag = "29")]
    pub expansion: ::core::option::Option<terminology_capabilities::Expansion>,
    #[prost(message, optional, tag = "30")]
    pub code_search: ::core::option::Option<terminology_capabilities::CodeSearchCode>,
    #[prost(message, optional, tag = "31")]
    pub validate_code: ::core::option::Option<terminology_capabilities::ValidateCode>,
    #[prost(message, optional, tag = "32")]
    pub translation: ::core::option::Option<terminology_capabilities::Translation>,
    #[prost(message, optional, tag = "33")]
    pub closure: ::core::option::Option<terminology_capabilities::Closure>,
}
/// Nested message and enum types in `TerminologyCapabilities`.
pub mod terminology_capabilities {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// instance | capability | requirements
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct KindCode {
        #[prost(
            enumeration = "super::capability_statement_kind_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Software that is covered by this terminology capability statement
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Software {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// A name the software is known by
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Version covered by this statement
        #[prost(message, optional, tag = "5")]
        pub version: ::core::option::Option<super::String>,
    }
    /// If this describes a specific instance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Implementation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Describes this specific instance
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Base URL for the implementation
        #[prost(message, optional, tag = "5")]
        pub url: ::core::option::Option<super::Url>,
    }
    /// A code system supported by the server
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CodeSystem {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// URI for the Code System
        #[prost(message, optional, tag = "4")]
        pub uri: ::core::option::Option<super::Canonical>,
        #[prost(message, repeated, tag = "5")]
        pub version: prost::alloc::vec::Vec<code_system::Version>,
        /// Whether subsumption is supported
        #[prost(message, optional, tag = "6")]
        pub subsumption: ::core::option::Option<super::Boolean>,
    }
    /// Nested message and enum types in `CodeSystem`.
    pub mod code_system {
        /// Version of Code System supported
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Version {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Version identifier for this version
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::String>,
            /// If this is the default version for this code system
            #[prost(message, optional, tag = "5")]
            pub is_default: ::core::option::Option<super::super::Boolean>,
            /// If compositional grammar is supported
            #[prost(message, optional, tag = "6")]
            pub compositional: ::core::option::Option<super::super::Boolean>,
            /// Language Displays supported
            #[prost(message, repeated, tag = "7")]
            pub language: prost::alloc::vec::Vec<super::super::Code>,
            #[prost(message, repeated, tag = "8")]
            pub filter: prost::alloc::vec::Vec<version::Filter>,
            /// Properties supported for $lookup
            #[prost(message, repeated, tag = "9")]
            pub property: prost::alloc::vec::Vec<super::super::Code>,
        }
        /// Nested message and enum types in `Version`.
        pub mod version {
            /// Filter Properties supported
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Filter {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Code of the property supported
                #[prost(message, optional, tag = "4")]
                pub code: ::core::option::Option<super::super::super::Code>,
                /// Operations supported for the property
                #[prost(message, repeated, tag = "5")]
                pub op: prost::alloc::vec::Vec<super::super::super::Code>,
            }
        }
    }
    /// Information about the \[ValueSet/$expand\](valueset-operation-expand.html)
    /// operation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Expansion {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Whether the server can return nested value sets
        #[prost(message, optional, tag = "4")]
        pub hierarchical: ::core::option::Option<super::Boolean>,
        /// Whether the server supports paging on expansion
        #[prost(message, optional, tag = "5")]
        pub paging: ::core::option::Option<super::Boolean>,
        /// Allow request for incomplete expansions?
        #[prost(message, optional, tag = "6")]
        pub incomplete: ::core::option::Option<super::Boolean>,
        #[prost(message, repeated, tag = "7")]
        pub parameter: prost::alloc::vec::Vec<expansion::Parameter>,
        /// Documentation about text searching works
        #[prost(message, optional, tag = "8")]
        pub text_filter: ::core::option::Option<super::Markdown>,
    }
    /// Nested message and enum types in `Expansion`.
    pub mod expansion {
        /// Supported expansion parameter
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Parameter {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Expansion Parameter name
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::Code>,
            /// Description of support for parameter
            #[prost(message, optional, tag = "5")]
            pub documentation: ::core::option::Option<super::super::String>,
        }
    }
    /// explicit | all
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CodeSearchCode {
        #[prost(enumeration = "super::code_search_support_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Information about the
    /// \[ValueSet/$validate-code\](valueset-operation-validate-code.html) operation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValidateCode {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Whether translations are validated
        #[prost(message, optional, tag = "4")]
        pub translations: ::core::option::Option<super::Boolean>,
    }
    /// Information about the
    /// \[ConceptMap/$translate\](conceptmap-operation-translate.html) operation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Translation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Whether the client must identify the map
        #[prost(message, optional, tag = "4")]
        pub needs_map: ::core::option::Option<super::Boolean>,
    }
    /// Information about the
    /// \[ConceptMap/$closure\](conceptmap-operation-closure.html) operation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Closure {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// If cross-system closure is supported
        #[prost(message, optional, tag = "4")]
        pub translation: ::core::option::Option<super::Boolean>,
    }
}
/// Auto-generated from StructureDefinition for TestReport, last updated
/// 2019-11-01T09:29:23.356+11:00. Describes the results of a TestScript
/// execution. See <http://hl7.org/fhir/StructureDefinition/TestReport>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestReport {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Informal name of the executed TestScript
    #[prost(message, optional, tag = "11")]
    pub name: ::core::option::Option<String>,
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<test_report::StatusCode>,
    /// Reference to the  version-specific TestScript that was executed to produce
    /// this TestReport
    #[prost(message, optional, tag = "13")]
    pub test_script: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "14")]
    pub result: ::core::option::Option<test_report::ResultCode>,
    /// The final score (percentage of tests passed) resulting from the execution
    /// of the TestScript
    #[prost(message, optional, tag = "15")]
    pub score: ::core::option::Option<Decimal>,
    /// Name of the tester producing this report (Organization or individual)
    #[prost(message, optional, tag = "16")]
    pub tester: ::core::option::Option<String>,
    /// When the TestScript was executed and this TestReport was generated
    #[prost(message, optional, tag = "17")]
    pub issued: ::core::option::Option<DateTime>,
    #[prost(message, repeated, tag = "18")]
    pub participant: prost::alloc::vec::Vec<test_report::Participant>,
    #[prost(message, optional, tag = "19")]
    pub setup: ::core::option::Option<test_report::Setup>,
    #[prost(message, repeated, tag = "20")]
    pub test: prost::alloc::vec::Vec<test_report::Test>,
    #[prost(message, optional, tag = "21")]
    pub teardown: ::core::option::Option<test_report::Teardown>,
}
/// Nested message and enum types in `TestReport`.
pub mod test_report {
    /// completed | in-progress | waiting | stopped | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::test_report_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// pass | fail | pending
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ResultCode {
        #[prost(enumeration = "super::test_report_result_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// A participant in the test execution, either the execution engine, a client,
    /// or a server
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<participant::TypeCode>,
        /// The uri of the participant. An absolute URL is preferred
        #[prost(message, optional, tag = "5")]
        pub uri: ::core::option::Option<super::Uri>,
        /// The display name of the participant
        #[prost(message, optional, tag = "6")]
        pub display: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Participant`.
    pub mod participant {
        /// test-engine | client | server
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TypeCode {
            #[prost(
                enumeration = "super::super::test_report_participant_type_code::Value",
                tag = "1"
            )]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
    }
    /// The results of the series of required setup operations before the tests
    /// were executed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Setup {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub action: prost::alloc::vec::Vec<setup::SetupAction>,
    }
    /// Nested message and enum types in `Setup`.
    pub mod setup {
        /// A setup operation or assert that was executed
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SetupAction {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<setup_action::Operation>,
            #[prost(message, optional, tag = "5")]
            pub assert_value: ::core::option::Option<setup_action::Assert>,
        }
        /// Nested message and enum types in `SetupAction`.
        pub mod setup_action {
            /// The operation to perform
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Operation {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                #[prost(message, optional, tag = "4")]
                pub result: ::core::option::Option<operation::ResultCode>,
                /// A message associated with the result
                #[prost(message, optional, tag = "5")]
                pub message: ::core::option::Option<super::super::super::Markdown>,
                /// A link to further details on the result
                #[prost(message, optional, tag = "6")]
                pub detail: ::core::option::Option<super::super::super::Uri>,
            }
            /// Nested message and enum types in `Operation`.
            pub mod operation {
                /// pass | skip | fail | warning | error
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ResultCode {
                    #[prost(
                        enumeration = "super::super::super::super::test_report_action_result_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
            }
            /// The assertion to perform
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Assert {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                #[prost(message, optional, tag = "4")]
                pub result: ::core::option::Option<assert::ResultCode>,
                /// A message associated with the result
                #[prost(message, optional, tag = "5")]
                pub message: ::core::option::Option<super::super::super::Markdown>,
                /// A link to further details on the result
                #[prost(message, optional, tag = "6")]
                pub detail: ::core::option::Option<super::super::super::String>,
            }
            /// Nested message and enum types in `Assert`.
            pub mod assert {
                /// pass | skip | fail | warning | error
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ResultCode {
                    #[prost(
                        enumeration = "super::super::super::super::test_report_action_result_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
            }
        }
    }
    /// A test executed from the test script
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Test {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Tracking/logging name of this test
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Tracking/reporting short description of the test
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "6")]
        pub action: prost::alloc::vec::Vec<test::TestAction>,
    }
    /// Nested message and enum types in `Test`.
    pub mod test {
        /// A test operation or assert that was performed
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TestAction {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The operation performed
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<super::setup::setup_action::Operation>,
            /// The assertion performed
            #[prost(message, optional, tag = "5")]
            pub assert_value: ::core::option::Option<super::setup::setup_action::Assert>,
        }
    }
    /// The results of running the series of required clean up steps
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Teardown {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub action: prost::alloc::vec::Vec<teardown::TeardownAction>,
    }
    /// Nested message and enum types in `Teardown`.
    pub mod teardown {
        /// One or more teardown operations performed
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TeardownAction {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The teardown operation performed
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<super::setup::setup_action::Operation>,
        }
    }
}
/// Auto-generated from StructureDefinition for TestScript, last updated
/// 2019-11-01T09:29:23.356+11:00. Describes a set of tests. See
/// <http://hl7.org/fhir/StructureDefinition/TestScript>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestScript {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this test script, represented as a URI (globally
    /// unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the test script
    #[prost(message, optional, tag = "11")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Business version of the test script
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this test script (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this test script (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<test_script::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "16")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "18")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "19")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the test script
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "21")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for test script (if applicable)
    #[prost(message, repeated, tag = "22")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this test script is defined
    #[prost(message, optional, tag = "23")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "24")]
    pub copyright: ::core::option::Option<Markdown>,
    #[prost(message, repeated, tag = "25")]
    pub origin: prost::alloc::vec::Vec<test_script::Origin>,
    #[prost(message, repeated, tag = "26")]
    pub destination: prost::alloc::vec::Vec<test_script::Destination>,
    #[prost(message, optional, tag = "27")]
    pub metadata: ::core::option::Option<test_script::Metadata>,
    #[prost(message, repeated, tag = "28")]
    pub fixture: prost::alloc::vec::Vec<test_script::Fixture>,
    /// Reference of the validation profile
    #[prost(message, repeated, tag = "29")]
    pub profile: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "30")]
    pub variable: prost::alloc::vec::Vec<test_script::Variable>,
    #[prost(message, optional, tag = "31")]
    pub setup: ::core::option::Option<test_script::Setup>,
    #[prost(message, repeated, tag = "32")]
    pub test: prost::alloc::vec::Vec<test_script::Test>,
    #[prost(message, optional, tag = "33")]
    pub teardown: ::core::option::Option<test_script::Teardown>,
}
/// Nested message and enum types in `TestScript`.
pub mod test_script {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// An abstract server representing a client or sender in a message exchange
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Origin {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The index of the abstract origin server starting at 1
        #[prost(message, optional, tag = "4")]
        pub index: ::core::option::Option<super::Integer>,
        /// FHIR-Client | FHIR-SDC-FormFiller
        #[prost(message, optional, tag = "5")]
        pub profile: ::core::option::Option<super::Coding>,
    }
    /// An abstract server representing a destination or receiver in a message
    /// exchange
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Destination {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The index of the abstract destination server starting at 1
        #[prost(message, optional, tag = "4")]
        pub index: ::core::option::Option<super::Integer>,
        /// FHIR-Server | FHIR-SDC-FormManager | FHIR-SDC-FormReceiver |
        /// FHIR-SDC-FormProcessor
        #[prost(message, optional, tag = "5")]
        pub profile: ::core::option::Option<super::Coding>,
    }
    /// Required capability that is assumed to function correctly on the FHIR
    /// server being tested
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Metadata {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub link: prost::alloc::vec::Vec<metadata::Link>,
        #[prost(message, repeated, tag = "5")]
        pub capability: prost::alloc::vec::Vec<metadata::Capability>,
    }
    /// Nested message and enum types in `Metadata`.
    pub mod metadata {
        /// Links to the FHIR specification
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Link {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// URL to the specification
            #[prost(message, optional, tag = "4")]
            pub url: ::core::option::Option<super::super::Uri>,
            /// Short description
            #[prost(message, optional, tag = "5")]
            pub description: ::core::option::Option<super::super::String>,
        }
        /// Capabilities  that are assumed to function correctly on the FHIR server
        /// being tested
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Capability {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Are the capabilities required?
            #[prost(message, optional, tag = "4")]
            pub required: ::core::option::Option<super::super::Boolean>,
            /// Are the capabilities validated?
            #[prost(message, optional, tag = "5")]
            pub validated: ::core::option::Option<super::super::Boolean>,
            /// The expected capabilities of the server
            #[prost(message, optional, tag = "6")]
            pub description: ::core::option::Option<super::super::String>,
            /// Which origin server these requirements apply to
            #[prost(message, repeated, tag = "7")]
            pub origin: prost::alloc::vec::Vec<super::super::Integer>,
            /// Which server these requirements apply to
            #[prost(message, optional, tag = "8")]
            pub destination: ::core::option::Option<super::super::Integer>,
            /// Links to the FHIR specification
            #[prost(message, repeated, tag = "9")]
            pub link: prost::alloc::vec::Vec<super::super::Uri>,
            /// Required Capability Statement
            #[prost(message, optional, tag = "10")]
            pub capabilities: ::core::option::Option<super::super::Canonical>,
        }
    }
    /// Fixture in the test script - by reference (uri)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Fixture {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Whether or not to implicitly create the fixture during setup
        #[prost(message, optional, tag = "4")]
        pub autocreate: ::core::option::Option<super::Boolean>,
        /// Whether or not to implicitly delete the fixture during teardown
        #[prost(message, optional, tag = "5")]
        pub autodelete: ::core::option::Option<super::Boolean>,
        /// Reference of the resource
        #[prost(message, optional, tag = "6")]
        pub resource: ::core::option::Option<super::Reference>,
    }
    /// Placeholder for evaluated elements
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Variable {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Descriptive name for this variable
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Default, hard-coded, or user-defined value for this variable
        #[prost(message, optional, tag = "5")]
        pub default_value: ::core::option::Option<super::String>,
        /// Natural language description of the variable
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        /// The FHIRPath expression against the fixture body
        #[prost(message, optional, tag = "7")]
        pub expression: ::core::option::Option<super::String>,
        /// HTTP header field name for source
        #[prost(message, optional, tag = "8")]
        pub header_field: ::core::option::Option<super::String>,
        /// Hint help text for default value to enter
        #[prost(message, optional, tag = "9")]
        pub hint: ::core::option::Option<super::String>,
        /// XPath or JSONPath against the fixture body
        #[prost(message, optional, tag = "10")]
        pub path: ::core::option::Option<super::String>,
        /// Fixture Id of source expression or headerField within this variable
        #[prost(message, optional, tag = "11")]
        pub source_id: ::core::option::Option<super::Id>,
    }
    /// A series of required setup operations before tests are executed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Setup {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub action: prost::alloc::vec::Vec<setup::SetupAction>,
    }
    /// Nested message and enum types in `Setup`.
    pub mod setup {
        /// A setup operation or assert to perform
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SetupAction {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<setup_action::Operation>,
            #[prost(message, optional, tag = "5")]
            pub assert_value: ::core::option::Option<setup_action::Assert>,
        }
        /// Nested message and enum types in `SetupAction`.
        pub mod setup_action {
            /// The setup operation to perform
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Operation {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// The operation code type that will be executed
                #[prost(message, optional, tag = "4")]
                pub r#type: ::core::option::Option<super::super::super::Coding>,
                #[prost(message, optional, tag = "5")]
                pub resource: ::core::option::Option<operation::ResourceCode>,
                /// Tracking/logging operation label
                #[prost(message, optional, tag = "6")]
                pub label: ::core::option::Option<super::super::super::String>,
                /// Tracking/reporting operation description
                #[prost(message, optional, tag = "7")]
                pub description: ::core::option::Option<super::super::super::String>,
                #[prost(message, optional, tag = "8")]
                pub accept: ::core::option::Option<operation::AcceptCode>,
                #[prost(message, optional, tag = "9")]
                pub content_type: ::core::option::Option<operation::ContentTypeCode>,
                /// Server responding to the request
                #[prost(message, optional, tag = "10")]
                pub destination: ::core::option::Option<super::super::super::Integer>,
                /// Whether or not to send the request url in encoded format
                #[prost(message, optional, tag = "11")]
                pub encode_request_url: ::core::option::Option<super::super::super::Boolean>,
                #[prost(message, optional, tag = "12")]
                pub method: ::core::option::Option<operation::MethodCode>,
                /// Server initiating the request
                #[prost(message, optional, tag = "13")]
                pub origin: ::core::option::Option<super::super::super::Integer>,
                /// Explicitly defined path parameters
                #[prost(message, optional, tag = "14")]
                pub params: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "15")]
                pub request_header: prost::alloc::vec::Vec<operation::RequestHeader>,
                /// Fixture Id of mapped request
                #[prost(message, optional, tag = "16")]
                pub request_id: ::core::option::Option<super::super::super::Id>,
                /// Fixture Id of mapped response
                #[prost(message, optional, tag = "17")]
                pub response_id: ::core::option::Option<super::super::super::Id>,
                /// Fixture Id of body for PUT and POST requests
                #[prost(message, optional, tag = "18")]
                pub source_id: ::core::option::Option<super::super::super::Id>,
                /// Id of fixture used for extracting the \[id\],  \[type\], and \[vid\] for
                /// GET requests
                #[prost(message, optional, tag = "19")]
                pub target_id: ::core::option::Option<super::super::super::Id>,
                /// Request URL
                #[prost(message, optional, tag = "20")]
                pub url: ::core::option::Option<super::super::super::String>,
            }
            /// Nested message and enum types in `Operation`.
            pub mod operation {
                /// Resource type
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ResourceCode {
                    #[prost(
                        enumeration = "super::super::super::super::fhir_defined_type_value_set::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// Mime type to accept in the payload of the response, with charset etc.
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct AcceptCode {
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// This valueset is not enumerable, and so is represented as a string.
                    #[prost(string, tag = "4")]
                    pub value: prost::alloc::string::String,
                }
                /// Mime type of the request payload contents, with charset etc.
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ContentTypeCode {
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// This valueset is not enumerable, and so is represented as a string.
                    #[prost(string, tag = "4")]
                    pub value: prost::alloc::string::String,
                }
                /// delete | get | options | patch | post | put | head
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct MethodCode {
                    #[prost(
                        enumeration = "super::super::super::super::test_script_request_method_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// Each operation can have one or more header elements
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct RequestHeader {
                    /// Unique id for inter-element referencing
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored even if unrecognized
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// HTTP header field name
                    #[prost(message, optional, tag = "4")]
                    pub field: ::core::option::Option<super::super::super::super::String>,
                    /// HTTP headerfield value
                    #[prost(message, optional, tag = "5")]
                    pub value: ::core::option::Option<super::super::super::super::String>,
                }
            }
            /// The assertion to perform
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Assert {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Tracking/logging assertion label
                #[prost(message, optional, tag = "4")]
                pub label: ::core::option::Option<super::super::super::String>,
                /// Tracking/reporting assertion description
                #[prost(message, optional, tag = "5")]
                pub description: ::core::option::Option<super::super::super::String>,
                #[prost(message, optional, tag = "6")]
                pub direction: ::core::option::Option<assert::DirectionCode>,
                /// Id of the source fixture to be evaluated
                #[prost(message, optional, tag = "7")]
                pub compare_to_source_id: ::core::option::Option<super::super::super::String>,
                /// The FHIRPath expression to evaluate against the source fixture
                #[prost(message, optional, tag = "8")]
                pub compare_to_source_expression:
                    ::core::option::Option<super::super::super::String>,
                /// XPath or JSONPath expression to evaluate against the source fixture
                #[prost(message, optional, tag = "9")]
                pub compare_to_source_path: ::core::option::Option<super::super::super::String>,
                #[prost(message, optional, tag = "10")]
                pub content_type: ::core::option::Option<assert::ContentTypeCode>,
                /// The FHIRPath expression to be evaluated
                #[prost(message, optional, tag = "11")]
                pub expression: ::core::option::Option<super::super::super::String>,
                /// HTTP header field name
                #[prost(message, optional, tag = "12")]
                pub header_field: ::core::option::Option<super::super::super::String>,
                /// Fixture Id of minimum content resource
                #[prost(message, optional, tag = "13")]
                pub minimum_id: ::core::option::Option<super::super::super::String>,
                /// Perform validation on navigation links?
                #[prost(message, optional, tag = "14")]
                pub navigation_links: ::core::option::Option<super::super::super::Boolean>,
                #[prost(message, optional, tag = "15")]
                pub operator: ::core::option::Option<assert::OperatorCode>,
                /// XPath or JSONPath expression
                #[prost(message, optional, tag = "16")]
                pub path: ::core::option::Option<super::super::super::String>,
                #[prost(message, optional, tag = "17")]
                pub request_method: ::core::option::Option<assert::RequestMethodCode>,
                /// Request URL comparison value
                #[prost(message, optional, tag = "18")]
                pub request_url: ::core::option::Option<super::super::super::String>,
                #[prost(message, optional, tag = "19")]
                pub resource: ::core::option::Option<assert::ResourceCode>,
                #[prost(message, optional, tag = "20")]
                pub response: ::core::option::Option<assert::ResponseCode>,
                /// HTTP response code to test
                #[prost(message, optional, tag = "21")]
                pub response_code: ::core::option::Option<super::super::super::String>,
                /// Fixture Id of source expression or headerField
                #[prost(message, optional, tag = "22")]
                pub source_id: ::core::option::Option<super::super::super::Id>,
                /// Profile Id of validation profile reference
                #[prost(message, optional, tag = "23")]
                pub validate_profile_id: ::core::option::Option<super::super::super::Id>,
                /// The value to compare to
                #[prost(message, optional, tag = "24")]
                pub value: ::core::option::Option<super::super::super::String>,
                /// Will this assert produce a warning only on error?
                #[prost(message, optional, tag = "25")]
                pub warning_only: ::core::option::Option<super::super::super::Boolean>,
            }
            /// Nested message and enum types in `Assert`.
            pub mod assert {
                /// response | request
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct DirectionCode {
                    #[prost(
                        enumeration = "super::super::super::super::assertion_direction_type_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// Mime type to compare against the 'Content-Type' header
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ContentTypeCode {
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// This valueset is not enumerable, and so is represented as a string.
                    #[prost(string, tag = "4")]
                    pub value: prost::alloc::string::String,
                }
                /// equals | notEquals | in | notIn | greaterThan | lessThan | empty |
                /// notEmpty | contains | notContains | eval
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct OperatorCode {
                    #[prost(
                        enumeration = "super::super::super::super::assertion_operator_type_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// delete | get | options | patch | post | put | head
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct RequestMethodCode {
                    #[prost(
                        enumeration = "super::super::super::super::test_script_request_method_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// Resource type
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ResourceCode {
                    #[prost(
                        enumeration = "super::super::super::super::fhir_defined_type_value_set::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
                /// okay | created | noContent | notModified | bad | forbidden | notFound
                /// | methodNotAllowed | conflict | gone | preconditionFailed |
                /// unprocessable
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ResponseCode {
                    #[prost(
                        enumeration = "super::super::super::super::assertion_response_types_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
            }
        }
    }
    /// A test in this script
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Test {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Tracking/logging name of this test
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Tracking/reporting short description of the test
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "6")]
        pub action: prost::alloc::vec::Vec<test::TestAction>,
    }
    /// Nested message and enum types in `Test`.
    pub mod test {
        /// A test operation or assert to perform
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TestAction {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The setup operation to perform
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<super::setup::setup_action::Operation>,
            /// The setup assertion to perform
            #[prost(message, optional, tag = "5")]
            pub assert_value: ::core::option::Option<super::setup::setup_action::Assert>,
        }
    }
    /// A series of required clean up steps
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Teardown {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub action: prost::alloc::vec::Vec<teardown::TeardownAction>,
    }
    /// Nested message and enum types in `Teardown`.
    pub mod teardown {
        /// One or more teardown operations to perform
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TeardownAction {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The teardown operation to perform
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<super::setup::setup_action::Operation>,
        }
    }
}
/// Auto-generated from StructureDefinition for ValueSet, last updated
/// 2019-11-01T09:29:23.356+11:00. A set of codes drawn from one or more code
/// systems. See <http://hl7.org/fhir/StructureDefinition/ValueSet>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSet {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Canonical identifier for this value set, represented as a URI (globally
    /// unique)
    #[prost(message, optional, tag = "10")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the value set (business identifier)
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the value set
    #[prost(message, optional, tag = "12")]
    pub version: ::core::option::Option<String>,
    /// Name for this value set (computer friendly)
    #[prost(message, optional, tag = "13")]
    pub name: ::core::option::Option<String>,
    /// Name for this value set (human friendly)
    #[prost(message, optional, tag = "14")]
    pub title: ::core::option::Option<String>,
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<value_set::StatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "16")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date last changed
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "18")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "19")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the value set
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<Markdown>,
    /// The context that the content is intended to support
    #[prost(message, repeated, tag = "21")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for value set (if applicable)
    #[prost(message, repeated, tag = "22")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Indicates whether or not any change to the content logical definition may
    /// occur
    #[prost(message, optional, tag = "23")]
    pub immutable: ::core::option::Option<Boolean>,
    /// Why this value set is defined
    #[prost(message, optional, tag = "24")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "25")]
    pub copyright: ::core::option::Option<Markdown>,
    #[prost(message, optional, tag = "26")]
    pub compose: ::core::option::Option<value_set::Compose>,
    #[prost(message, optional, tag = "27")]
    pub expansion: ::core::option::Option<value_set::Expansion>,
}
/// Nested message and enum types in `ValueSet`.
pub mod value_set {
    /// draft | active | retired | unknown
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::publication_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Content logical definition of the value set (CLD)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Compose {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Fixed date for references with no specified version (transitive)
        #[prost(message, optional, tag = "4")]
        pub locked_date: ::core::option::Option<super::Date>,
        /// Whether inactive codes are in the value set
        #[prost(message, optional, tag = "5")]
        pub inactive: ::core::option::Option<super::Boolean>,
        #[prost(message, repeated, tag = "6")]
        pub include: prost::alloc::vec::Vec<compose::ConceptSet>,
        /// Explicitly exclude codes from a code system or other value sets
        #[prost(message, repeated, tag = "7")]
        pub exclude: prost::alloc::vec::Vec<compose::ConceptSet>,
    }
    /// Nested message and enum types in `Compose`.
    pub mod compose {
        /// Include one or more codes from a code system or other value set(s)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ConceptSet {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The system the codes come from
            #[prost(message, optional, tag = "4")]
            pub system: ::core::option::Option<super::super::Uri>,
            /// Specific version of the code system referred to
            #[prost(message, optional, tag = "5")]
            pub version: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "6")]
            pub concept: prost::alloc::vec::Vec<concept_set::ConceptReference>,
            #[prost(message, repeated, tag = "7")]
            pub filter: prost::alloc::vec::Vec<concept_set::Filter>,
            /// Select the contents included in this value set
            #[prost(message, repeated, tag = "8")]
            pub value_set: prost::alloc::vec::Vec<super::super::Canonical>,
        }
        /// Nested message and enum types in `ConceptSet`.
        pub mod concept_set {
            /// A concept defined in the system
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ConceptReference {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Code or expression from system
                #[prost(message, optional, tag = "4")]
                pub code: ::core::option::Option<super::super::super::Code>,
                /// Text to display for this code for this value set in this valueset
                #[prost(message, optional, tag = "5")]
                pub display: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "6")]
                pub designation: prost::alloc::vec::Vec<concept_reference::Designation>,
            }
            /// Nested message and enum types in `ConceptReference`.
            pub mod concept_reference {
                /// Additional representations for this concept
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct Designation {
                    /// Unique id for inter-element referencing
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored even if unrecognized
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Human language of the designation
                    #[prost(message, optional, tag = "4")]
                    pub language: ::core::option::Option<super::super::super::super::Code>,
                    /// Types of uses of designations
                    #[prost(message, optional, tag = "5")]
                    pub r#use: ::core::option::Option<super::super::super::super::Coding>,
                    /// The text value for this designation
                    #[prost(message, optional, tag = "6")]
                    pub value: ::core::option::Option<super::super::super::super::String>,
                }
            }
            /// Select codes/concepts by their properties (including relationships)
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Filter {
                /// Unique id for inter-element referencing
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored even if unrecognized
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// A property/filter defined by the code system
                #[prost(message, optional, tag = "4")]
                pub property: ::core::option::Option<super::super::super::Code>,
                #[prost(message, optional, tag = "5")]
                pub op: ::core::option::Option<filter::OpCode>,
                /// Code from the system, or regex criteria, or boolean value for exists
                #[prost(message, optional, tag = "6")]
                pub value: ::core::option::Option<super::super::super::String>,
            }
            /// Nested message and enum types in `Filter`.
            pub mod filter {
                /// = | is-a | descendent-of | is-not-a | regex | in | not-in |
                /// generalizes | exists
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct OpCode {
                    #[prost(
                        enumeration = "super::super::super::super::filter_operator_code::Value",
                        tag = "1"
                    )]
                    pub value: i32,
                    #[prost(message, optional, tag = "2")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    #[prost(message, repeated, tag = "3")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                }
            }
        }
    }
    /// Used when the value set is "expanded"
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Expansion {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifies the value set expansion (business identifier)
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Uri>,
        /// Time ValueSet expansion happened
        #[prost(message, optional, tag = "5")]
        pub timestamp: ::core::option::Option<super::DateTime>,
        /// Total number of codes in the expansion
        #[prost(message, optional, tag = "6")]
        pub total: ::core::option::Option<super::Integer>,
        /// Offset at which this resource starts
        #[prost(message, optional, tag = "7")]
        pub offset: ::core::option::Option<super::Integer>,
        #[prost(message, repeated, tag = "8")]
        pub parameter: prost::alloc::vec::Vec<expansion::Parameter>,
        #[prost(message, repeated, tag = "9")]
        pub contains: prost::alloc::vec::Vec<expansion::Contains>,
    }
    /// Nested message and enum types in `Expansion`.
    pub mod expansion {
        /// Parameter that controlled the expansion process
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Parameter {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Name as assigned by the client or server
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::String>,
            #[prost(message, optional, tag = "5")]
            pub value: ::core::option::Option<parameter::ValueX>,
        }
        /// Nested message and enum types in `Parameter`.
        pub mod parameter {
            /// Value of the named parameter
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ValueX {
                #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5, 6, 7")]
                pub choice: ::core::option::Option<value_x::Choice>,
            }
            /// Nested message and enum types in `ValueX`.
            pub mod value_x {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Choice {
                    #[prost(message, tag = "1")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "2")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "3")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "4")]
                    Decimal(super::super::super::super::Decimal),
                    #[prost(message, tag = "5")]
                    Uri(super::super::super::super::Uri),
                    #[prost(message, tag = "6")]
                    Code(super::super::super::super::Code),
                    #[prost(message, tag = "7")]
                    DateTime(super::super::super::super::DateTime),
                }
            }
        }
        /// Codes in the value set
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Contains {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// System value for the code
            #[prost(message, optional, tag = "4")]
            pub system: ::core::option::Option<super::super::Uri>,
            /// If user cannot select this entry
            #[prost(message, optional, tag = "5")]
            pub r#abstract: ::core::option::Option<super::super::Boolean>,
            /// If concept is inactive in the code system
            #[prost(message, optional, tag = "6")]
            pub inactive: ::core::option::Option<super::super::Boolean>,
            /// Version in which this code/display is defined
            #[prost(message, optional, tag = "7")]
            pub version: ::core::option::Option<super::super::String>,
            /// Code - if blank, this is not a selectable code
            #[prost(message, optional, tag = "8")]
            pub code: ::core::option::Option<super::super::Code>,
            /// User display for the concept
            #[prost(message, optional, tag = "9")]
            pub display: ::core::option::Option<super::super::String>,
            /// Additional representations for this item
            #[prost(message, repeated, tag = "10")]
            pub designation:
                prost::alloc::vec::Vec<super::compose::concept_set::concept_reference::Designation>,
            /// Codes contained under this entry
            #[prost(message, repeated, tag = "11")]
            pub contains: prost::alloc::vec::Vec<Contains>,
        }
    }
}
/// Auto-generated from StructureDefinition for VerificationResult, last updated
/// 2019-11-01T09:29:23.356+11:00. Describes validation requirements, source(s),
/// status and dates for one or more elements. See
/// <http://hl7.org/fhir/StructureDefinition/VerificationResult>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct VerificationResult {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// A resource that was validated
    #[prost(message, repeated, tag = "10")]
    pub target: prost::alloc::vec::Vec<Reference>,
    /// The fhirpath location(s) within the resource that was validated
    #[prost(message, repeated, tag = "11")]
    pub target_location: prost::alloc::vec::Vec<String>,
    /// none | initial | periodic
    #[prost(message, optional, tag = "12")]
    pub need: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<verification_result::StatusCode>,
    /// When the validation status was updated
    #[prost(message, optional, tag = "14")]
    pub status_date: ::core::option::Option<DateTime>,
    /// nothing | primary | multiple
    #[prost(message, optional, tag = "15")]
    pub validation_type: ::core::option::Option<CodeableConcept>,
    /// The primary process by which the target is validated (edit check; value
    /// set; primary source; multiple sources; standalone; in context)
    #[prost(message, repeated, tag = "16")]
    pub validation_process: prost::alloc::vec::Vec<CodeableConcept>,
    /// Frequency of revalidation
    #[prost(message, optional, tag = "17")]
    pub frequency: ::core::option::Option<Timing>,
    /// The date/time validation was last completed (including failed validations)
    #[prost(message, optional, tag = "18")]
    pub last_performed: ::core::option::Option<DateTime>,
    /// The date when target is next validated, if appropriate
    #[prost(message, optional, tag = "19")]
    pub next_scheduled: ::core::option::Option<Date>,
    /// fatal | warn | rec-only | none
    #[prost(message, optional, tag = "20")]
    pub failure_action: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "21")]
    pub primary_source: prost::alloc::vec::Vec<verification_result::PrimarySource>,
    #[prost(message, optional, tag = "22")]
    pub attestation: ::core::option::Option<verification_result::Attestation>,
    #[prost(message, repeated, tag = "23")]
    pub validator: prost::alloc::vec::Vec<verification_result::Validator>,
}
/// Nested message and enum types in `VerificationResult`.
pub mod verification_result {
    /// attested | validated | in-process | req-revalid | val-fail | reval-fail
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Information about the primary source(s) involved in validation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct PrimarySource {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to the primary source
        #[prost(message, optional, tag = "4")]
        pub who: ::core::option::Option<super::Reference>,
        /// Type of primary source (License Board; Primary Education; Continuing
        /// Education; Postal Service; Relationship owner; Registration Authority;
        /// legal source; issuing source; authoritative source)
        #[prost(message, repeated, tag = "5")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Method for exchanging information with the primary source
        #[prost(message, repeated, tag = "6")]
        pub communication_method: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// successful | failed | unknown
        #[prost(message, optional, tag = "7")]
        pub validation_status: ::core::option::Option<super::CodeableConcept>,
        /// When the target was validated against the primary source
        #[prost(message, optional, tag = "8")]
        pub validation_date: ::core::option::Option<super::DateTime>,
        /// yes | no | undetermined
        #[prost(message, optional, tag = "9")]
        pub can_push_updates: ::core::option::Option<super::CodeableConcept>,
        /// specific | any | source
        #[prost(message, repeated, tag = "10")]
        pub push_type_available: prost::alloc::vec::Vec<super::CodeableConcept>,
    }
    /// Information about the entity attesting to information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Attestation {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The individual or organization attesting to information
        #[prost(message, optional, tag = "4")]
        pub who: ::core::option::Option<super::Reference>,
        /// When the who is asserting on behalf of another (organization or
        /// individual)
        #[prost(message, optional, tag = "5")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
        /// The method by which attested information was submitted/retrieved
        #[prost(message, optional, tag = "6")]
        pub communication_method: ::core::option::Option<super::CodeableConcept>,
        /// The date the information was attested to
        #[prost(message, optional, tag = "7")]
        pub date: ::core::option::Option<super::Date>,
        /// A digital identity certificate associated with the attestation source
        #[prost(message, optional, tag = "8")]
        pub source_identity_certificate: ::core::option::Option<super::String>,
        /// A digital identity certificate associated with the proxy entity
        /// submitting attested information on behalf of the attestation source
        #[prost(message, optional, tag = "9")]
        pub proxy_identity_certificate: ::core::option::Option<super::String>,
        /// Proxy signature
        #[prost(message, optional, tag = "10")]
        pub proxy_signature: ::core::option::Option<super::Signature>,
        /// Attester signature
        #[prost(message, optional, tag = "11")]
        pub source_signature: ::core::option::Option<super::Signature>,
    }
    /// Information about the entity validating information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Validator {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to the organization validating information
        #[prost(message, optional, tag = "4")]
        pub organization: ::core::option::Option<super::Reference>,
        /// A digital identity certificate associated with the validator
        #[prost(message, optional, tag = "5")]
        pub identity_certificate: ::core::option::Option<super::String>,
        /// Validator signature
        #[prost(message, optional, tag = "6")]
        pub attestation_signature: ::core::option::Option<super::Signature>,
    }
}
/// Auto-generated from StructureDefinition for VisionPrescription, last updated
/// 2019-11-01T09:29:23.356+11:00. Prescription for vision correction products
/// for a patient. See <http://hl7.org/fhir/StructureDefinition/VisionPrescription>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct VisionPrescription {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<::prost_wkt_types::Any>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "8")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "9")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for vision prescription
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<vision_prescription::StatusCode>,
    /// Response creation date
    #[prost(message, optional, tag = "12")]
    pub created: ::core::option::Option<DateTime>,
    /// Who prescription is for
    #[prost(message, optional, tag = "13")]
    pub patient: ::core::option::Option<Reference>,
    /// Created during encounter / admission / stay
    #[prost(message, optional, tag = "14")]
    pub encounter: ::core::option::Option<Reference>,
    /// When prescription was authorized
    #[prost(message, optional, tag = "15")]
    pub date_written: ::core::option::Option<DateTime>,
    /// Who authorized the vision prescription
    #[prost(message, optional, tag = "16")]
    pub prescriber: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "17")]
    pub lens_specification: prost::alloc::vec::Vec<vision_prescription::LensSpecification>,
}
/// Nested message and enum types in `VisionPrescription`.
pub mod vision_prescription {
    /// active | cancelled | draft | entered-in-error
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(
            enumeration = "super::financial_resource_status_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Vision lens authorization
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct LensSpecification {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Product to be supplied
        #[prost(message, optional, tag = "4")]
        pub product: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub eye: ::core::option::Option<lens_specification::EyeCode>,
        /// Power of the lens
        #[prost(message, optional, tag = "6")]
        pub sphere: ::core::option::Option<super::Decimal>,
        /// Lens power for astigmatism
        #[prost(message, optional, tag = "7")]
        pub cylinder: ::core::option::Option<super::Decimal>,
        /// Lens meridian which contain no power for astigmatism
        #[prost(message, optional, tag = "8")]
        pub axis: ::core::option::Option<super::Integer>,
        #[prost(message, repeated, tag = "9")]
        pub prism: prost::alloc::vec::Vec<lens_specification::Prism>,
        /// Added power for multifocal levels
        #[prost(message, optional, tag = "10")]
        pub add: ::core::option::Option<super::Decimal>,
        /// Contact lens power
        #[prost(message, optional, tag = "11")]
        pub power: ::core::option::Option<super::Decimal>,
        /// Contact lens back curvature
        #[prost(message, optional, tag = "12")]
        pub back_curve: ::core::option::Option<super::Decimal>,
        /// Contact lens diameter
        #[prost(message, optional, tag = "13")]
        pub diameter: ::core::option::Option<super::Decimal>,
        /// Lens wear duration
        #[prost(message, optional, tag = "14")]
        pub duration: ::core::option::Option<super::SimpleQuantity>,
        /// Color required
        #[prost(message, optional, tag = "15")]
        pub color: ::core::option::Option<super::String>,
        /// Brand required
        #[prost(message, optional, tag = "16")]
        pub brand: ::core::option::Option<super::String>,
        /// Notes for coatings
        #[prost(message, repeated, tag = "17")]
        pub note: prost::alloc::vec::Vec<super::Annotation>,
    }
    /// Nested message and enum types in `LensSpecification`.
    pub mod lens_specification {
        /// right | left
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct EyeCode {
            #[prost(enumeration = "super::super::vision_eyes_code::Value", tag = "1")]
            pub value: i32,
            #[prost(message, optional, tag = "2")]
            pub id: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "3")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
        }
        /// Eye alignment compensation
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Prism {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Amount of adjustment
            #[prost(message, optional, tag = "4")]
            pub amount: ::core::option::Option<super::super::Decimal>,
            #[prost(message, optional, tag = "5")]
            pub base: ::core::option::Option<prism::BaseCode>,
        }
        /// Nested message and enum types in `Prism`.
        pub mod prism {
            /// up | down | in | out
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct BaseCode {
                #[prost(
                    enumeration = "super::super::super::vision_base_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Bundle, last updated
/// 2019-11-01T09:29:23.356+11:00. Contains a collection of resources. See
/// <http://hl7.org/fhir/StructureDefinition/Bundle>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Bundle {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<Code>,
    /// Persistent identifier for the bundle
    #[prost(message, optional, tag = "5")]
    pub identifier: ::core::option::Option<Identifier>,
    #[prost(message, optional, tag = "6")]
    pub r#type: ::core::option::Option<bundle::TypeCode>,
    /// When the bundle was assembled
    #[prost(message, optional, tag = "7")]
    pub timestamp: ::core::option::Option<Instant>,
    /// If search, the total number of matches
    #[prost(message, optional, tag = "8")]
    pub total: ::core::option::Option<UnsignedInt>,
    #[prost(message, repeated, tag = "9")]
    pub link: prost::alloc::vec::Vec<bundle::Link>,
    #[prost(message, repeated, tag = "10")]
    pub entry: prost::alloc::vec::Vec<bundle::Entry>,
    /// Digital Signature
    #[prost(message, optional, tag = "11")]
    pub signature: ::core::option::Option<Signature>,
}
/// Nested message and enum types in `Bundle`.
pub mod bundle {
    /// document | message | transaction | transaction-response | batch |
    /// batch-response | history | searchset | collection
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeCode {
        #[prost(enumeration = "super::bundle_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// Links related to this Bundle
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Link {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// See
        /// <http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1>
        #[prost(message, optional, tag = "4")]
        pub relation: ::core::option::Option<super::String>,
        /// Reference details for the link
        #[prost(message, optional, tag = "5")]
        pub url: ::core::option::Option<super::Uri>,
    }
    /// Entry in the bundle - will have a resource or information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Entry {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored even if unrecognized
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Links related to this entry
        #[prost(message, repeated, tag = "4")]
        pub link: prost::alloc::vec::Vec<Link>,
        /// URI for resource (Absolute URL server address or URI for UUID/OID)
        #[prost(message, optional, tag = "5")]
        pub full_url: ::core::option::Option<super::Uri>,
        /// A resource in the bundle
        #[prost(message, optional, tag = "6")]
        pub resource: ::core::option::Option<super::ContainedResource>,
        #[prost(message, optional, tag = "7")]
        pub search: ::core::option::Option<entry::Search>,
        #[prost(message, optional, tag = "8")]
        pub request: ::core::option::Option<entry::Request>,
        #[prost(message, optional, tag = "9")]
        pub response: ::core::option::Option<entry::Response>,
    }
    /// Nested message and enum types in `Entry`.
    pub mod entry {
        /// Search related information
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Search {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub mode: ::core::option::Option<search::ModeCode>,
            /// Search ranking (between 0 and 1)
            #[prost(message, optional, tag = "5")]
            pub score: ::core::option::Option<super::super::Decimal>,
        }
        /// Nested message and enum types in `Search`.
        pub mod search {
            /// match | include | outcome - why this is in the result set
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ModeCode {
                #[prost(
                    enumeration = "super::super::super::search_entry_mode_code::Value",
                    tag = "1"
                )]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
        /// Additional execution information (transaction/batch/history)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Request {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub method: ::core::option::Option<request::MethodCode>,
            /// URL for HTTP equivalent of this entry
            #[prost(message, optional, tag = "5")]
            pub url: ::core::option::Option<super::super::Uri>,
            /// For managing cache currency
            #[prost(message, optional, tag = "6")]
            pub if_none_match: ::core::option::Option<super::super::String>,
            /// For managing cache currency
            #[prost(message, optional, tag = "7")]
            pub if_modified_since: ::core::option::Option<super::super::Instant>,
            /// For managing update contention
            #[prost(message, optional, tag = "8")]
            pub if_match: ::core::option::Option<super::super::String>,
            /// For conditional creates
            #[prost(message, optional, tag = "9")]
            pub if_none_exist: ::core::option::Option<super::super::String>,
        }
        /// Nested message and enum types in `Request`.
        pub mod request {
            /// GET | HEAD | POST | PUT | DELETE | PATCH
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct MethodCode {
                #[prost(enumeration = "super::super::super::http_verb_code::Value", tag = "1")]
                pub value: i32,
                #[prost(message, optional, tag = "2")]
                pub id: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "3")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
            }
        }
        /// Results of execution (transaction/batch/history)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Response {
            /// Unique id for inter-element referencing
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored even if unrecognized
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Status response code (text optional)
            #[prost(message, optional, tag = "4")]
            pub status: ::core::option::Option<super::super::String>,
            /// The location (if the operation returns a location)
            #[prost(message, optional, tag = "5")]
            pub location: ::core::option::Option<super::super::Uri>,
            /// The Etag for the resource (if relevant)
            #[prost(message, optional, tag = "6")]
            pub etag: ::core::option::Option<super::super::String>,
            /// Server's date time modified
            #[prost(message, optional, tag = "7")]
            pub last_modified: ::core::option::Option<super::super::Instant>,
            /// OperationOutcome with hints and warnings (for batch/transaction)
            #[prost(message, optional, tag = "8")]
            pub outcome: ::core::option::Option<super::super::ContainedResource>,
        }
    }
}
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContainedResource {
    #[prost(
        oneof = "contained_resource::OneofResource",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146"
    )]
    pub oneof_resource: ::core::option::Option<contained_resource::OneofResource>,
}
/// Nested message and enum types in `ContainedResource`.
pub mod contained_resource {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Oneof)]
    pub enum OneofResource {
        #[prost(message, tag = "1")]
        Account(super::Account),
        #[prost(message, tag = "2")]
        ActivityDefinition(super::ActivityDefinition),
        #[prost(message, tag = "3")]
        AdverseEvent(super::AdverseEvent),
        #[prost(message, tag = "4")]
        AllergyIntolerance(super::AllergyIntolerance),
        #[prost(message, tag = "5")]
        Appointment(super::Appointment),
        #[prost(message, tag = "6")]
        AppointmentResponse(super::AppointmentResponse),
        #[prost(message, tag = "7")]
        AuditEvent(super::AuditEvent),
        #[prost(message, tag = "8")]
        Basic(super::Basic),
        #[prost(message, tag = "9")]
        Binary(super::Binary),
        #[prost(message, tag = "10")]
        BiologicallyDerivedProduct(super::BiologicallyDerivedProduct),
        #[prost(message, tag = "11")]
        BodyStructure(super::BodyStructure),
        #[prost(message, tag = "12")]
        Bundle(super::Bundle),
        #[prost(message, tag = "13")]
        CapabilityStatement(super::CapabilityStatement),
        #[prost(message, tag = "14")]
        CarePlan(super::CarePlan),
        #[prost(message, tag = "15")]
        CareTeam(super::CareTeam),
        #[prost(message, tag = "16")]
        CatalogEntry(super::CatalogEntry),
        #[prost(message, tag = "17")]
        ChargeItem(super::ChargeItem),
        #[prost(message, tag = "18")]
        ChargeItemDefinition(super::ChargeItemDefinition),
        #[prost(message, tag = "19")]
        Claim(super::Claim),
        #[prost(message, tag = "20")]
        ClaimResponse(super::ClaimResponse),
        #[prost(message, tag = "21")]
        ClinicalImpression(super::ClinicalImpression),
        #[prost(message, tag = "22")]
        CodeSystem(super::CodeSystem),
        #[prost(message, tag = "23")]
        Communication(super::Communication),
        #[prost(message, tag = "24")]
        CommunicationRequest(super::CommunicationRequest),
        #[prost(message, tag = "25")]
        CompartmentDefinition(super::CompartmentDefinition),
        #[prost(message, tag = "26")]
        Composition(super::Composition),
        #[prost(message, tag = "27")]
        ConceptMap(super::ConceptMap),
        #[prost(message, tag = "28")]
        Condition(super::Condition),
        #[prost(message, tag = "29")]
        Consent(super::Consent),
        #[prost(message, tag = "30")]
        Contract(super::Contract),
        #[prost(message, tag = "31")]
        Coverage(super::Coverage),
        #[prost(message, tag = "32")]
        CoverageEligibilityRequest(super::CoverageEligibilityRequest),
        #[prost(message, tag = "33")]
        CoverageEligibilityResponse(super::CoverageEligibilityResponse),
        #[prost(message, tag = "34")]
        DetectedIssue(super::DetectedIssue),
        #[prost(message, tag = "35")]
        Device(super::Device),
        #[prost(message, tag = "36")]
        DeviceDefinition(super::DeviceDefinition),
        #[prost(message, tag = "37")]
        DeviceMetric(super::DeviceMetric),
        #[prost(message, tag = "38")]
        DeviceRequest(super::DeviceRequest),
        #[prost(message, tag = "39")]
        DeviceUseStatement(super::DeviceUseStatement),
        #[prost(message, tag = "40")]
        DiagnosticReport(super::DiagnosticReport),
        #[prost(message, tag = "41")]
        DocumentManifest(super::DocumentManifest),
        #[prost(message, tag = "42")]
        DocumentReference(super::DocumentReference),
        #[prost(message, tag = "43")]
        EffectEvidenceSynthesis(super::EffectEvidenceSynthesis),
        #[prost(message, tag = "44")]
        Encounter(super::Encounter),
        #[prost(message, tag = "45")]
        Endpoint(super::Endpoint),
        #[prost(message, tag = "46")]
        EnrollmentRequest(super::EnrollmentRequest),
        #[prost(message, tag = "47")]
        EnrollmentResponse(super::EnrollmentResponse),
        #[prost(message, tag = "48")]
        EpisodeOfCare(super::EpisodeOfCare),
        #[prost(message, tag = "49")]
        EventDefinition(super::EventDefinition),
        #[prost(message, tag = "50")]
        Evidence(super::Evidence),
        #[prost(message, tag = "51")]
        EvidenceVariable(super::EvidenceVariable),
        #[prost(message, tag = "52")]
        ExampleScenario(super::ExampleScenario),
        #[prost(message, tag = "53")]
        ExplanationOfBenefit(super::ExplanationOfBenefit),
        #[prost(message, tag = "54")]
        FamilyMemberHistory(super::FamilyMemberHistory),
        #[prost(message, tag = "55")]
        Flag(super::Flag),
        #[prost(message, tag = "56")]
        Goal(super::Goal),
        #[prost(message, tag = "57")]
        GraphDefinition(super::GraphDefinition),
        #[prost(message, tag = "58")]
        Group(super::Group),
        #[prost(message, tag = "59")]
        GuidanceResponse(super::GuidanceResponse),
        #[prost(message, tag = "60")]
        HealthcareService(super::HealthcareService),
        #[prost(message, tag = "61")]
        ImagingStudy(super::ImagingStudy),
        #[prost(message, tag = "62")]
        Immunization(super::Immunization),
        #[prost(message, tag = "63")]
        ImmunizationEvaluation(super::ImmunizationEvaluation),
        #[prost(message, tag = "64")]
        ImmunizationRecommendation(super::ImmunizationRecommendation),
        #[prost(message, tag = "65")]
        ImplementationGuide(super::ImplementationGuide),
        #[prost(message, tag = "66")]
        InsurancePlan(super::InsurancePlan),
        #[prost(message, tag = "67")]
        Invoice(super::Invoice),
        #[prost(message, tag = "68")]
        Library(super::Library),
        #[prost(message, tag = "69")]
        Linkage(super::Linkage),
        #[prost(message, tag = "70")]
        List(super::List),
        #[prost(message, tag = "71")]
        Location(super::Location),
        #[prost(message, tag = "72")]
        Measure(super::Measure),
        #[prost(message, tag = "73")]
        MeasureReport(super::MeasureReport),
        #[prost(message, tag = "74")]
        Media(super::Media),
        #[prost(message, tag = "75")]
        Medication(super::Medication),
        #[prost(message, tag = "76")]
        MedicationAdministration(super::MedicationAdministration),
        #[prost(message, tag = "77")]
        MedicationDispense(super::MedicationDispense),
        #[prost(message, tag = "78")]
        MedicationKnowledge(super::MedicationKnowledge),
        #[prost(message, tag = "79")]
        MedicationRequest(super::MedicationRequest),
        #[prost(message, tag = "80")]
        MedicationStatement(super::MedicationStatement),
        #[prost(message, tag = "81")]
        MedicinalProduct(super::MedicinalProduct),
        #[prost(message, tag = "82")]
        MedicinalProductAuthorization(super::MedicinalProductAuthorization),
        #[prost(message, tag = "83")]
        MedicinalProductContraindication(super::MedicinalProductContraindication),
        #[prost(message, tag = "84")]
        MedicinalProductIndication(super::MedicinalProductIndication),
        #[prost(message, tag = "85")]
        MedicinalProductIngredient(super::MedicinalProductIngredient),
        #[prost(message, tag = "86")]
        MedicinalProductInteraction(super::MedicinalProductInteraction),
        #[prost(message, tag = "87")]
        MedicinalProductManufactured(super::MedicinalProductManufactured),
        #[prost(message, tag = "88")]
        MedicinalProductPackaged(super::MedicinalProductPackaged),
        #[prost(message, tag = "89")]
        MedicinalProductPharmaceutical(super::MedicinalProductPharmaceutical),
        #[prost(message, tag = "90")]
        MedicinalProductUndesirableEffect(super::MedicinalProductUndesirableEffect),
        #[prost(message, tag = "91")]
        MessageDefinition(super::MessageDefinition),
        #[prost(message, tag = "92")]
        MessageHeader(super::MessageHeader),
        #[prost(message, tag = "93")]
        MolecularSequence(super::MolecularSequence),
        #[prost(message, tag = "94")]
        NamingSystem(super::NamingSystem),
        #[prost(message, tag = "95")]
        NutritionOrder(super::NutritionOrder),
        #[prost(message, tag = "96")]
        Observation(super::Observation),
        #[prost(message, tag = "97")]
        ObservationDefinition(super::ObservationDefinition),
        #[prost(message, tag = "98")]
        OperationDefinition(super::OperationDefinition),
        #[prost(message, tag = "99")]
        OperationOutcome(super::OperationOutcome),
        #[prost(message, tag = "100")]
        Organization(super::Organization),
        #[prost(message, tag = "101")]
        OrganizationAffiliation(super::OrganizationAffiliation),
        #[prost(message, tag = "102")]
        Parameters(super::Parameters),
        #[prost(message, tag = "103")]
        Patient(super::Patient),
        #[prost(message, tag = "104")]
        PaymentNotice(super::PaymentNotice),
        #[prost(message, tag = "105")]
        PaymentReconciliation(super::PaymentReconciliation),
        #[prost(message, tag = "106")]
        Person(super::Person),
        #[prost(message, tag = "107")]
        PlanDefinition(super::PlanDefinition),
        #[prost(message, tag = "108")]
        Practitioner(super::Practitioner),
        #[prost(message, tag = "109")]
        PractitionerRole(super::PractitionerRole),
        #[prost(message, tag = "110")]
        Procedure(super::Procedure),
        #[prost(message, tag = "111")]
        Provenance(super::Provenance),
        #[prost(message, tag = "112")]
        Questionnaire(super::Questionnaire),
        #[prost(message, tag = "113")]
        QuestionnaireResponse(super::QuestionnaireResponse),
        #[prost(message, tag = "114")]
        RelatedPerson(super::RelatedPerson),
        #[prost(message, tag = "115")]
        RequestGroup(super::RequestGroup),
        #[prost(message, tag = "116")]
        ResearchDefinition(super::ResearchDefinition),
        #[prost(message, tag = "117")]
        ResearchElementDefinition(super::ResearchElementDefinition),
        #[prost(message, tag = "118")]
        ResearchStudy(super::ResearchStudy),
        #[prost(message, tag = "119")]
        ResearchSubject(super::ResearchSubject),
        #[prost(message, tag = "120")]
        RiskAssessment(super::RiskAssessment),
        #[prost(message, tag = "121")]
        RiskEvidenceSynthesis(super::RiskEvidenceSynthesis),
        #[prost(message, tag = "122")]
        Schedule(super::Schedule),
        #[prost(message, tag = "123")]
        SearchParameter(super::SearchParameter),
        #[prost(message, tag = "124")]
        ServiceRequest(super::ServiceRequest),
        #[prost(message, tag = "125")]
        Slot(super::Slot),
        #[prost(message, tag = "126")]
        Specimen(super::Specimen),
        #[prost(message, tag = "127")]
        SpecimenDefinition(super::SpecimenDefinition),
        #[prost(message, tag = "128")]
        StructureDefinition(super::StructureDefinition),
        #[prost(message, tag = "129")]
        StructureMap(super::StructureMap),
        #[prost(message, tag = "130")]
        Subscription(super::Subscription),
        #[prost(message, tag = "131")]
        Substance(super::Substance),
        #[prost(message, tag = "132")]
        SubstanceNucleicAcid(super::SubstanceNucleicAcid),
        #[prost(message, tag = "133")]
        SubstancePolymer(super::SubstancePolymer),
        #[prost(message, tag = "134")]
        SubstanceProtein(super::SubstanceProtein),
        #[prost(message, tag = "135")]
        SubstanceReferenceInformation(super::SubstanceReferenceInformation),
        #[prost(message, tag = "136")]
        SubstanceSourceMaterial(super::SubstanceSourceMaterial),
        #[prost(message, tag = "137")]
        SubstanceSpecification(super::SubstanceSpecification),
        #[prost(message, tag = "138")]
        SupplyDelivery(super::SupplyDelivery),
        #[prost(message, tag = "139")]
        SupplyRequest(super::SupplyRequest),
        #[prost(message, tag = "140")]
        Task(super::Task),
        #[prost(message, tag = "141")]
        TerminologyCapabilities(super::TerminologyCapabilities),
        #[prost(message, tag = "142")]
        TestReport(super::TestReport),
        #[prost(message, tag = "143")]
        TestScript(super::TestScript),
        #[prost(message, tag = "144")]
        ValueSet(super::ValueSet),
        #[prost(message, tag = "145")]
        VerificationResult(super::VerificationResult),
        #[prost(message, tag = "146")]
        VisionPrescription(super::VisionPrescription),
    }
}
/// Auto-generated from StructureDefinition for AD-use.
/// BAD | CONF | HP | HV | DIR | PUB | PHYS | PST.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-AD-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdUse {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<address_ad_use::ValueCode>,
}
/// Nested message and enum types in `AddressADUse`.
pub mod address_ad_use {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::postal_address_use_value_set::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for ADXP-additionalLocator.
/// additionalLocator.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-additionalLocator>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpAdditionalLocator {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-buildingNumberSuffix.
/// buildingNumberSuffix.
/// See
/// <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-buildingNumberSuffix>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpBuildingNumberSuffix {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-careOf.
/// careOf.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-careOf>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpCareOf {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-censusTract.
/// censusTract.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-censusTract>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpCensusTract {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-delimiter.
/// delimiter.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-delimiter>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpDelimiter {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-deliveryAddressLine.
/// deliveryAddressLine.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-deliveryAddressLine>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpDeliveryAddressLine {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-deliveryInstallationArea.
/// deliveryInstallationArea.
/// See
/// <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-deliveryInstallationArea>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpDeliveryInstallationArea {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for
/// ADXP-deliveryInstallationQualifier. deliveryInstallationQualifier. See
/// <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-deliveryInstallationQualifier>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpDeliveryInstallationQualifier {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-deliveryInstallationType.
/// deliveryInstallationType.
/// See
/// <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-deliveryInstallationType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpDeliveryInstallationType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-deliveryMode.
/// deliveryMode.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-deliveryMode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpDeliveryMode {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-deliveryModeIdentifier.
/// deliveryModeIdentifier.
/// See
/// <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-deliveryModeIdentifier>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpDeliveryModeIdentifier {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-direction.
/// direction.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-direction>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpDirection {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-houseNumber.
/// houseNumber.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-houseNumber>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpHouseNumber {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-houseNumberNumeric.
/// houseNumberNumeric.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-houseNumberNumeric>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpHouseNumberNumeric {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-postBox.
/// postBox.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-postBox>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpPostBox {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-precinct.
/// precinct.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-precinct>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpPrecinct {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-streetAddressLine.
/// streetAddressLine.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-streetAddressLine>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpStreetAddressLine {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-streetName.
/// streetName.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-streetName>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpStreetName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-streetNameBase.
/// streetNameBase.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-streetNameBase>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpStreetNameBase {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-streetNameType.
/// streetNameType.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-streetNameType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpStreetNameType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-unitID.
/// unitID.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-unitID>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpUnitId {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ADXP-unitType.
/// unitType.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-ADXP-unitType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressAdxpUnitType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for Geolocation.
/// The absolute geographic location.
/// See <http://hl7.org/fhir/StructureDefinition/geolocation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressGeolocation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Latitude with WGS84 datum
    #[prost(message, optional, tag = "4")]
    pub latitude: ::core::option::Option<Decimal>,
    /// Longitude with WGS84 datum
    #[prost(message, optional, tag = "5")]
    pub longitude: ::core::option::Option<Decimal>,
}
/// Auto-generated from StructureDefinition for administration.
/// Actual medication record, if known.
/// See <http://hl7.org/fhir/StructureDefinition/openEHR-administration>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceAdministration {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for assertedDate.
/// Date the allergy or intolerance was first asserted.
/// See <http://hl7.org/fhir/StructureDefinition/allergyintolerance-assertedDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceAssertedDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date_time: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for careplan.
/// Clinical Management Details.
/// See <http://hl7.org/fhir/StructureDefinition/openEHR-careplan>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceCareplan {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for certainty.
/// Certainty that the substance was the cause of the manifestation.
/// See <http://hl7.org/fhir/StructureDefinition/allergyintolerance-certainty>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceCertainty {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for duration.
/// How long Manifestations persisted.
/// See <http://hl7.org/fhir/StructureDefinition/allergyintolerance-duration>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceDuration {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_duration: ::core::option::Option<Duration>,
}
/// Auto-generated from StructureDefinition for exposureDate.
/// Date(/time) of first exposure to Substance.
/// See <http://hl7.org/fhir/StructureDefinition/openEHR-exposureDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceExposureDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date_time: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for exposureDescription.
/// Text description about exposure to the Substance.
/// See <http://hl7.org/fhir/StructureDefinition/openEHR-exposureDescription>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceExposureDescription {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for exposureDuration.
/// Amount of time individual was exposed to Substance.
/// See <http://hl7.org/fhir/StructureDefinition/openEHR-exposureDuration>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceExposureDuration {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_duration: ::core::option::Option<Duration>,
}
/// Auto-generated from StructureDefinition for location.
/// Body site of manifestations.
/// See <http://hl7.org/fhir/StructureDefinition/openEHR-location>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceLocation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for management.
/// Clinical Management Description.
/// See <http://hl7.org/fhir/StructureDefinition/openEHR-management>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceManagement {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for reasonRefuted.
/// Explanation associated with refuted status.
/// See <http://hl7.org/fhir/StructureDefinition/allergyintolerance-reasonRefuted>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceReasonRefuted {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for resolutionAge.
/// Age that the allergy or intolerance resolved.
/// See <http://hl7.org/fhir/StructureDefinition/allergyintolerance-resolutionAge>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceResolutionAge {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_age: ::core::option::Option<Age>,
}
/// Auto-generated from StructureDefinition for substanceExposureRisk.
/// Exposure risk of adverse reaction (allergy or intolerance) to the specified
/// substance/product. See
/// <http://hl7.org/fhir/StructureDefinition/allergyintolerance-substanceExposureRisk>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceSubstanceExposureRisk {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Substance (or pharmaceutical product)
    #[prost(message, optional, tag = "4")]
    pub substance: ::core::option::Option<CodeableConcept>,
    /// known-reaction-risk | no-known-reaction-risk
    #[prost(message, optional, tag = "5")]
    pub exposure_risk: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for test.
/// Observations that confirm or refute.
/// See <http://hl7.org/fhir/StructureDefinition/openEHR-test>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceTest {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for animalSpecies.
/// The Species of the Service Animal.
/// See <http://hl7.org/fhir/StructureDefinition/practitioner-animalSpecies>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AnimalSpecies {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for approachBodyStructure.
/// The access point or points used for this procedure.
/// See <http://hl7.org/fhir/StructureDefinition/procedure-approachBodyStructure>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ApproachBodyStructure {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for approvalDate.
/// When resource approved by publisher.
/// See <http://hl7.org/fhir/StructureDefinition/resource-approvalDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ApprovalDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date: ::core::option::Option<Date>,
}
/// Auto-generated from StructureDefinition for citation.
/// Bibliographic citation for the resource.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-citation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AttachmentCitation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for qualityOfEvidence.
/// The quality of the evidence.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-qualityOfEvidence>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AttachmentQualityOfEvidence {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for strengthOfRecommendation.
/// The strength of the recommendation.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-strengthOfRecommendation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AttachmentStrengthOfRecommendation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for Accession.
/// Accession Number.
/// See <http://hl7.org/fhir/StructureDefinition/auditevent-Accession>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventAccession {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_identifier: ::core::option::Option<Identifier>,
}
/// Auto-generated from StructureDefinition for Anonymized.
/// Anonymized state.
/// See <http://hl7.org/fhir/StructureDefinition/auditevent-Anonymized>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventAnonymized {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for Encrypted.
/// Encrypted state.
/// See <http://hl7.org/fhir/StructureDefinition/auditevent-Encrypted>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventEncrypted {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for Instance.
/// SOP Instance UID value.
/// See <http://hl7.org/fhir/StructureDefinition/auditevent-Instance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventInstance {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_identifier: ::core::option::Option<Identifier>,
}
/// Auto-generated from StructureDefinition for MPPS.
/// MPPS instance UID.
/// See <http://hl7.org/fhir/StructureDefinition/auditevent-MPPS>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventMpps {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_identifier: ::core::option::Option<Identifier>,
}
/// Auto-generated from StructureDefinition for NumberOfInstances.
/// Number of SOP Instances referred to by this entity.
/// See <http://hl7.org/fhir/StructureDefinition/auditevent-NumberOfInstances>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventNumberOfInstances {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for ParticipantObjectContainsStudy.
/// Contains Study.
/// See
/// <http://hl7.org/fhir/StructureDefinition/auditevent-ParticipantObjectContainsStudy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventParticipantObjectContainsStudy {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_identifier: ::core::option::Option<Identifier>,
}
/// Auto-generated from StructureDefinition for SOPClass.
/// UIDs of SOP classes referred to.
/// See <http://hl7.org/fhir/StructureDefinition/auditevent-SOPClass>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventSopClass {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for encounterClass.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-encounterClass>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicEncounterClass {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for encounterType.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-encounterType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicEncounterType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for initiatingOrganization.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-initiatingOrganization>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicInitiatingOrganization {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for initiatingPerson.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-initiatingPerson>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicInitiatingPerson {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for receivingOrganization.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-receivingOrganization>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicReceivingOrganization {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for receivingPerson.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-receivingPerson>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicReceivingPerson {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for recipientLanguage.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-recipientLanguage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicRecipientLanguage {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for recipientType.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-recipientType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicRecipientType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for systemUserLanguage.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-systemUserLanguage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicSystemUserLanguage {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for systemUserTaskContext.
/// The task the system user is performing.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-systemUserTaskContext>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicSystemUserTaskContext {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for systemUserType.
/// The type of user initiating the request.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-systemUserType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicSystemUserType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for bodyPosition.
/// The body position during the observation.
/// See <http://hl7.org/fhir/StructureDefinition/observation-bodyPosition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BodyPosition {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for BodyStructure Reference.
/// Target anatomic location or structure.
/// See <http://hl7.org/fhir/StructureDefinition/bodySite>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BodyStructureReference {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for http-response-header.
/// HTTP header returned by the interaction.
/// See <http://hl7.org/fhir/StructureDefinition/http-response-header>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BundleHttpResponseHeader {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for location-distance.
/// The distance this resource is from a provided location (geocode point).
/// See <http://hl7.org/fhir/StructureDefinition/location-distance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BundleLocationDistance {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_distance: ::core::option::Option<Distance>,
}
/// Auto-generated from StructureDefinition for match-grade.
/// How likely this resource is to be a match.
/// See <http://hl7.org/fhir/StructureDefinition/match-grade>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BundleMatchGrade {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<bundle_match_grade::ValueCode>,
}
/// Nested message and enum types in `BundleMatchGrade`.
pub mod bundle_match_grade {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::match_grade_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for calculatedValue.
/// A calculated value.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-calculatedValue>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CalculatedValue {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for Display Name.
/// Display name for canonical reference.
/// See <http://hl7.org/fhir/StructureDefinition/display>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CanonicalDisplayName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for capabilities.
/// Server Capabilities.
/// See <http://fhir-registry.smarthealthit.org/StructureDefinition/capabilities>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatementCapabilities {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<capability_statement_capabilities::ValueCode>,
}
/// Nested message and enum types in `CapabilityStatementCapabilities`.
pub mod capability_statement_capabilities {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::smart_capabilities_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for expectation.
/// SHALL | SHOULD | MAY |SHOULD-NOT.
/// See <http://hl7.org/fhir/StructureDefinition/capabilitystatement-expectation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatementExpectation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<capability_statement_expectation::ValueCode>,
}
/// Nested message and enum types in `CapabilityStatementExpectation`.
pub mod capability_statement_expectation {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::conformance_expectation_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for oauth-uris.
/// Automated discovery of OAuth2 endpoints.
/// See <http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatementOauthUris {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// OAuth2 "authorize" endpoint
    #[prost(message, optional, tag = "4")]
    pub authorize: ::core::option::Option<Uri>,
    /// OAuth2 "token" endpoint
    #[prost(message, optional, tag = "5")]
    pub token: ::core::option::Option<Uri>,
    /// OAuth2 dynamic registration endpoint
    #[prost(message, optional, tag = "6")]
    pub register: ::core::option::Option<Uri>,
    /// User-facing authorization management entry point
    #[prost(message, optional, tag = "7")]
    pub manage: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for prohibited.
/// Functionality not allowed.
/// See <http://hl7.org/fhir/StructureDefinition/capabilitystatement-prohibited>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatementProhibited {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for search-parameter-combination.
/// An allowable parameter combination.
/// See
/// <http://hl7.org/fhir/StructureDefinition/capabilitystatement-search-parameter-combination>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatementSearchParameterCombination {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// A required search parameter name
    #[prost(message, repeated, tag = "4")]
    pub required: prost::alloc::vec::Vec<String>,
    /// An optional search parameter name
    #[prost(message, repeated, tag = "5")]
    pub optional: prost::alloc::vec::Vec<String>,
}
/// Auto-generated from StructureDefinition for supported-system.
/// Code system not defined in a value set.
/// See
/// <http://hl7.org/fhir/StructureDefinition/capabilitystatement-supported-system>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatementSupportedSystem {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for websocket.
/// Where server websocket end point is found.
/// See <http://hl7.org/fhir/StructureDefinition/capabilitystatement-websocket>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatementWebsocket {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for activity-title.
/// Label for activity.
/// See <http://hl7.org/fhir/StructureDefinition/careplan-activity-title>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CarePlanActivityTitle {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for alternate.
/// Additional code for the concept.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-alternate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemAlternate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Code that represents the concept
    #[prost(message, optional, tag = "4")]
    pub code: ::core::option::Option<Code>,
    /// Expected use of the code
    #[prost(message, optional, tag = "5")]
    pub r#use: ::core::option::Option<Coding>,
}
/// Auto-generated from StructureDefinition for author.
/// User or Org actually involved in creating the value set content.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-author>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemAuthor {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for concept-comments.
/// Comment about the use of this code in this context.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-concept-comments>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemConceptComments {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for conceptOrder.
/// Appearance order for user selection.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-conceptOrder>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemConceptOrder {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for effectiveDate.
/// When the value set version becomes Active and is available for use.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-effectiveDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemEffectiveDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date: ::core::option::Option<Date>,
}
/// Auto-generated from StructureDefinition for expirationDate.
/// When the value set version should no longer be used.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-expirationDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemExpirationDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date: ::core::option::Option<Date>,
}
/// Auto-generated from StructureDefinition for history.
/// What has happened over time.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-history>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemHistory {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// The name of this set of history entries
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "5")]
    pub revision: prost::alloc::vec::Vec<code_system_history::Revision>,
}
/// Nested message and enum types in `CodeSystemHistory`.
pub mod code_system_history {
    /// Audit of all changes for a history entry
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Revision {
        /// Unique id for inter-element referencing
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Date the change was made
        #[prost(message, optional, tag = "4")]
        pub date: ::core::option::Option<super::DateTime>,
        /// Version marker after the change was made
        #[prost(message, optional, tag = "5")]
        pub id_slice: ::core::option::Option<super::String>,
        /// Who made the change
        #[prost(message, optional, tag = "6")]
        pub author: ::core::option::Option<super::String>,
        /// Information about the change
        #[prost(message, optional, tag = "7")]
        pub notes: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for keyWord.
/// Descriptors and key terms for search.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-keyWord>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemKeyWord {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for label.
/// E.g. "(a)", "1.", etc.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-label>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemLabel {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for map.
/// A concept map relevant to interpret this value set.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-map>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemMap {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for otherName.
/// Alternative names.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-otherName>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemOtherName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Human readable, short and specific
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<String>,
    /// Which name is preferred for this language
    #[prost(message, optional, tag = "5")]
    pub preferred: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for replacedby.
/// A code that replaces this.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-replacedby>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemReplacedby {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_coding: ::core::option::Option<Coding>,
}
/// Auto-generated from StructureDefinition for sourceReference.
/// Where did this content come from.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-sourceReference>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemSourceReference {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for trusted-expansion.
/// Reference to a trusted expansion.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-trusted-expansion>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemTrustedExpansion {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for usage.
/// Who has used and how?.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-usage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemUsage {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// A consumer of or client for the value set
    #[prost(message, optional, tag = "4")]
    pub user: ::core::option::Option<String>,
    /// Implementation/project/standard that uses value set
    #[prost(message, optional, tag = "5")]
    pub r#use: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for warning.
/// Extra warning about the correct use of the value set.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-warning>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemWarning {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_markdown: ::core::option::Option<Markdown>,
}
/// Auto-generated from StructureDefinition for workflowStatus.
/// Indicates the state of development of the value set.
/// See <http://hl7.org/fhir/StructureDefinition/codesystem-workflowStatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemWorkflowStatus {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for sctdescid.
/// SNOMED CT Description ID.
/// See <http://hl7.org/fhir/StructureDefinition/coding-sctdescid>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodingSctdescid {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_id: ::core::option::Option<Id>,
}
/// Auto-generated from StructureDefinition for media.
/// Attached media.
/// See <http://hl7.org/fhir/StructureDefinition/communication-media>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CommunicationMedia {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_attachment: ::core::option::Option<Attachment>,
}
/// Auto-generated from StructureDefinition for initiatingLocation.
/// Location where the CommunicationRequest was initiated.
/// See
/// <http://hl7.org/fhir/StructureDefinition/communicationrequest-initiatingLocation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CommunicationRequestInitiatingLocation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for otherConfidentiality.
/// Additional confidentiality codes.
/// See
/// <http://hl7.org/fhir/StructureDefinition/composition-clinicaldocument-otherConfidentiality>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompositionOtherConfidentiality {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_coding: ::core::option::Option<Coding>,
}
/// Auto-generated from StructureDefinition for section-subject.
/// Section has a different subject that it's container.
/// See <http://hl7.org/fhir/StructureDefinition/composition-section-subject>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompositionSectionSubject {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ValidityPeriod.
/// Validity Period.
/// See <http://hl7.org/fhir/StructureDefinition/cqm-ValidityPeriod>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompositionValidityPeriod {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date_time: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for versionNumber.
/// Version-specific identifier for composition.
/// See
/// <http://hl7.org/fhir/StructureDefinition/composition-clinicaldocument-versionNumber>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompositionVersionNumber {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for bidirectional.
/// Whether the map can be interpreted in reverse.
/// See <http://hl7.org/fhir/StructureDefinition/concept-bidirectional>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConceptMapBidirectional {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for assertedDate.
/// Date the condition was first asserted.
/// See <http://hl7.org/fhir/StructureDefinition/condition-assertedDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionAssertedDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date_time: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for basedOn.
/// Fulfills plan, proposal or order.
/// See <http://hl7.org/fhir/StructureDefinition/event-basedOn>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionBasedOn {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for dueTo.
/// Causes for this Condition.
/// See <http://hl7.org/fhir/StructureDefinition/condition-dueTo>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionDueTo {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<condition_due_to::ValueX>,
}
/// Nested message and enum types in `ConditionDueTo`.
pub mod condition_due_to {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for occurredFollowing.
/// Precedent for this Condition.
/// See <http://hl7.org/fhir/StructureDefinition/condition-occurredFollowing>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionOccurredFollowing {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<condition_occurred_following::ValueX>,
}
/// Nested message and enum types in `ConditionOccurredFollowing`.
pub mod condition_occurred_following {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for outcome.
/// A consequence of the Condition.
/// See <http://hl7.org/fhir/StructureDefinition/condition-outcome>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionOutcome {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for related.
/// Conditions associated with this condition.
/// See <http://hl7.org/fhir/StructureDefinition/condition-related>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionRelated {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for ruledOut.
/// Conditions ruled out for this condition.
/// See <http://hl7.org/fhir/StructureDefinition/condition-ruledOut>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionRuledOut {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for location.
/// A location specific constraint.
/// See <http://hl7.org/fhir/StructureDefinition/consent-location>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConsentLocation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for NotificationEndpoint.
/// Notification Endpoint.
/// See <http://hl7.org/fhir/StructureDefinition/consent-NotificationEndpoint>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConsentNotificationEndpoint {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for Transcriber.
/// Transcribed consent.
/// See <http://hl7.org/fhir/StructureDefinition/consent-Transcriber>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConsentTranscriber {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Witness.
/// Witness to Consent.
/// See <http://hl7.org/fhir/StructureDefinition/consent-Witness>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConsentWitness {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for area.
/// Area/zone/city code.
/// See <http://hl7.org/fhir/StructureDefinition/contactpoint-area>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPointArea {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for country.
/// Country code as defined by the ITU.
/// See <http://hl7.org/fhir/StructureDefinition/contactpoint-country>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPointCountry {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for extension.
/// Number within private network.
/// See <http://hl7.org/fhir/StructureDefinition/contactpoint-extension>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPointExtension {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for local.
/// Local number that must always be dialled.
/// See <http://hl7.org/fhir/StructureDefinition/contactpoint-local>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPointLocal {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for TEL-address.
/// RFC 3966 compliant telephone or fax number.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-TEL-address>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPointTelAddress {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_url: ::core::option::Option<Url>,
}
/// Auto-generated from StructureDefinition for expression.
/// An dynamic expression.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-expression>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CqfExpression {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_expression: ::core::option::Option<Expression>,
}
/// Auto-generated from StructureDefinition for library.
/// A library containing logic used by the artifact.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-library>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CqfLibrary {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for Data Absent Reason.
/// unknown | asked | temp | notasked | masked | unsupported | astext | error.
/// See <http://hl7.org/fhir/StructureDefinition/data-absent-reason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DataAbsentReason {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<data_absent_reason::ValueCode>,
}
/// Nested message and enum types in `DataAbsentReason`.
pub mod data_absent_reason {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::data_absent_reason_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Timezone Offset.
/// Timezone offset, for dates (no timezone in date).
/// See <http://hl7.org/fhir/StructureDefinition/tz-offset>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DateTimezoneOffset {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for daysOfCycle.
/// Days on which the action should be performed.
/// See <http://hl7.org/fhir/StructureDefinition/timing-daysOfCycle>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DaysOfCycle {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// What day to perform
    #[prost(message, repeated, tag = "4")]
    pub day: prost::alloc::vec::Vec<Integer>,
}
/// Auto-generated from StructureDefinition for precision.
/// Explicit precision (number of significant decimal places).
/// See <http://hl7.org/fhir/StructureDefinition/quantity-precision>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DecimalPrecision {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for Design Note.
/// Design comments.
/// See <http://hl7.org/fhir/StructureDefinition/designNote>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DesignNote {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_markdown: ::core::option::Option<Markdown>,
}
/// Auto-generated from StructureDefinition for implantStatus.
/// Implant Status.
/// See <http://hl7.org/fhir/StructureDefinition/device-implantStatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceImplantStatus {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<device_implant_status::ValueCode>,
}
/// Nested message and enum types in `DeviceImplantStatus`.
pub mod device_implant_status {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::implant_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for patientInstruction.
/// Patient Friendly Insructions.
/// See <http://hl7.org/fhir/StructureDefinition/devicerequest-patientInstruction>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceRequestPatientInstruction {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Language
    #[prost(message, optional, tag = "4")]
    pub lang: ::core::option::Option<Code>,
    /// Text
    #[prost(message, optional, tag = "5")]
    pub content: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for addendumOf.
/// Additional or Supplement Content.
/// See <http://hl7.org/fhir/StructureDefinition/diagnosticReport-addendumOf>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportAddendumOf {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for allele-database.
/// Allele Database.
/// See
/// <http://hl7.org/fhir/StructureDefinition/hla-genotyping-results-allele-database>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportAlleleDatabase {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for Analysis.
/// Analysis.
/// See <http://hl7.org/fhir/StructureDefinition/DiagnosticReport-geneticsAnalysis>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportAnalysis {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Analysis type
    #[prost(message, optional, tag = "4")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Analysis interpretation
    #[prost(message, optional, tag = "5")]
    pub interpretation: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for AssessedCondition.
/// AssessedCondition.
/// See
/// <http://hl7.org/fhir/StructureDefinition/DiagnosticReport-geneticsAssessedCondition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportAssessedCondition {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for extends.
/// Related reports.
/// See <http://hl7.org/fhir/StructureDefinition/diagnosticReport-extends>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportExtends {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for FamilyMemberHistory.
/// FamilyHistory.
/// See
/// <http://hl7.org/fhir/StructureDefinition/DiagnosticReport-geneticsFamilyMemberHistory>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportFamilyMemberHistory {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for glstring.
/// glstring.
/// See <http://hl7.org/fhir/StructureDefinition/hla-genotyping-results-glstring>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportGlstring {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// glstring.url
    #[prost(message, optional, tag = "4")]
    pub url: ::core::option::Option<Uri>,
    /// glstring.text
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for haploid.
/// haploid.
/// See <http://hl7.org/fhir/StructureDefinition/hla-genotyping-results-haploid>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportHaploid {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// haploid-locus
    #[prost(message, optional, tag = "4")]
    pub locus: ::core::option::Option<CodeableConcept>,
    /// haploid-type
    #[prost(message, optional, tag = "5")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// haploid-method
    #[prost(message, optional, tag = "6")]
    pub method: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for Item.
/// The items the orderer requested.
/// See <http://hl7.org/fhir/StructureDefinition/servicerequest-geneticsItem>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportItem {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Code to indicate the item (test, panel or sequence variant) being ordered
    #[prost(message, optional, tag = "4")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Indicate the genetic variant ordered to be tested
    #[prost(message, optional, tag = "5")]
    pub genetics_observation: ::core::option::Option<Reference>,
    /// If this item relates to specific specimens
    #[prost(message, optional, tag = "6")]
    pub specimen: ::core::option::Option<Reference>,
    /// proposed | draft | planned | requested | received | accepted | in-progress
    /// | review | completed | cancelled | suspended | rejected | failed
    #[prost(message, optional, tag = "7")]
    pub status: ::core::option::Option<Code>,
}
/// Auto-generated from StructureDefinition for locationPerformed.
/// Location Performed.
/// See
/// <http://hl7.org/fhir/StructureDefinition/diagnosticReport-locationPerformed>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportLocationPerformed {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for method.
/// The platform, methodology and software applied at the time of the
/// genotyping.
/// See <http://hl7.org/fhir/StructureDefinition/hla-genotyping-results-method>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportMethod {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for References.
/// Additional bibliographic reference information.
/// See
/// <http://hl7.org/fhir/StructureDefinition/DiagnosticReport-geneticsReferences>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportReferences {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Reference description
    #[prost(message, optional, tag = "4")]
    pub description: ::core::option::Option<String>,
    /// Reference URI
    #[prost(message, repeated, tag = "5")]
    pub reference: prost::alloc::vec::Vec<Uri>,
    /// Reference type
    #[prost(message, optional, tag = "6")]
    pub r#type: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for replaces.
/// Replacement for another report.
/// See <http://hl7.org/fhir/StructureDefinition/diagnosticReport-replaces>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportReplaces {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for summaryOf.
/// Summary Of Other Reports.
/// See <http://hl7.org/fhir/StructureDefinition/diagnosticReport-summaryOf>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportSummaryOf {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for directedBy.
/// Who has decision-making authority.
/// See <http://hl7.org/fhir/StructureDefinition/procedure-directedBy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DirectedBy {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<directed_by::ValueX>,
}
/// Nested message and enum types in `DirectedBy`.
pub mod directed_by {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for effectivePeriod.
/// The effective date range for the resource.
/// See <http://hl7.org/fhir/StructureDefinition/resource-effectivePeriod>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EffectivePeriod {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_period: ::core::option::Option<Period>,
}
/// Auto-generated from StructureDefinition for allowedUnits.
/// Units to use for measured value.
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-allowedUnits>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionAllowedUnits {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<element_definition_allowed_units::ValueX>,
}
/// Nested message and enum types in `ElementDefinitionAllowedUnits`.
pub mod element_definition_allowed_units {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Canonical(super::super::Canonical),
        }
    }
}
/// Auto-generated from StructureDefinition for bestpractice.
/// Mark a warning invariant as 'best practice'.
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-bestpractice>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionBestpractice {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<element_definition_bestpractice::ValueX>,
}
/// Nested message and enum types in `ElementDefinitionBestpractice`.
pub mod element_definition_bestpractice {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
}
/// Auto-generated from StructureDefinition for bestpractice-explanation.
/// Explains why an invariant is labelled as best practice.
/// See
/// <http://hl7.org/fhir/StructureDefinition/elementdefinition-bestpractice-explanation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionBestpracticeExplanation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_markdown: ::core::option::Option<Markdown>,
}
/// Auto-generated from StructureDefinition for bindingName.
/// Suggested Name for code generation.
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-bindingName>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionBindingName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for display-hint.
/// Hinting information for the narrative generator.
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-display-hint>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionDisplayHint {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for equivalence.
/// equivalent | equal | wider | subsumes | narrower | specializes | inexact |
/// unmatched | disjoint. See
/// <http://hl7.org/fhir/StructureDefinition/elementdefinition-equivalence>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionEquivalence {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<element_definition_equivalence::ValueCode>,
}
/// Nested message and enum types in `ElementDefinitionEquivalence`.
pub mod element_definition_equivalence {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::concept_map_equivalence_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for explicit-type-name.
/// Advisory - name of Type for implementations.
/// See
/// <http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionExplicitTypeName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for fhir-type.
/// FHIR type for value property - when a simple system type.
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-fhir-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionFhirType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_url: ::core::option::Option<Url>,
}
/// Auto-generated from StructureDefinition for hierarchy.
/// Whether a circular reference is allowed to (transitively) point back to the
/// same instance. See
/// <http://hl7.org/fhir/StructureDefinition/structuredefinition-hierarchy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionHierarchy {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for identifier.
/// External Identifier associated with this element.
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-identifier>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionIdentifier {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_identifier: ::core::option::Option<Identifier>,
}
/// Auto-generated from StructureDefinition for inheritedExtensibleValueSet.
/// An extensible Value Set specified in a parent profile.
/// See
/// <http://hl7.org/fhir/StructureDefinition/elementdefinition-inheritedExtensibleValueSet>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionInheritedExtensibleValueSet {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<element_definition_inherited_extensible_value_set::ValueX>,
}
/// Nested message and enum types in `ElementDefinitionInheritedExtensibleValueSet`.
pub mod element_definition_inherited_extensible_value_set {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Canonical(super::super::Canonical),
        }
    }
}
/// Auto-generated from StructureDefinition for isCommonBinding.
/// Whether used on multiple resources.
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-isCommonBinding>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionIsCommonBinding {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for maxValueSet.
/// Maximum Value Set (when strength = extensible).
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-maxValueSet>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionMaxValueSet {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<element_definition_max_value_set::ValueX>,
}
/// Nested message and enum types in `ElementDefinitionMaxValueSet`.
pub mod element_definition_max_value_set {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Canonical(super::super::Canonical),
        }
    }
}
/// Auto-generated from StructureDefinition for minValueSet.
/// Minimum Value Set (what system must support).
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-minValueSet>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionMinValueSet {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<element_definition_min_value_set::ValueX>,
}
/// Nested message and enum types in `ElementDefinitionMinValueSet`.
pub mod element_definition_min_value_set {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Canonical(super::super::Canonical),
        }
    }
}
/// Auto-generated from StructureDefinition for objectClass.
/// Object Class.
/// See <http://hl7.org/fhir/StructureDefinition/11179-objectClass>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionObjectClass {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_coding: ::core::option::Option<Coding>,
}
/// Auto-generated from StructureDefinition for objectClassProperty.
/// Object Class Property.
/// See <http://hl7.org/fhir/StructureDefinition/11179-objectClassProperty>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionObjectClassProperty {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_coding: ::core::option::Option<Coding>,
}
/// Auto-generated from StructureDefinition for profile-element.
/// Specific element for profile (for backbone elements).
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-profile-element>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionProfileElement {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for question.
/// Prompt for element phrased as question.
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-question>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionQuestion {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for selector.
/// FHIRPath that defines the selection criteria for a slice.
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-selector>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionSelector {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for translatable.
/// Whether translations apply to this element.
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-translatable>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinitionTranslatable {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for associatedEncounter.
/// Associated Encounter.
/// See <http://hl7.org/fhir/StructureDefinition/encounter-associatedEncounter>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EncounterAssociatedEncounter {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for modeOfArrival.
/// The method of arrival of the patient into the facility.
/// See <http://hl7.org/fhir/StructureDefinition/encounter-modeOfArrival>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EncounterModeOfArrival {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_coding: ::core::option::Option<Coding>,
}
/// Auto-generated from StructureDefinition for reasonCancelled.
/// Explanation for cancellation.
/// See <http://hl7.org/fhir/StructureDefinition/encounter-reasonCancelled>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EncounterReasonCancelled {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for entryFormat.
/// User prompt for format.
/// See <http://hl7.org/fhir/StructureDefinition/entryFormat>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EntryFormat {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for episodeOfCare.
/// Associated Encounter episode of care.
/// See <http://hl7.org/fhir/StructureDefinition/workflow-episodeOfCare>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EpisodeOfCareExtension {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for eventHistory.
/// Events of interest in the resource lifecycle.
/// See <http://hl7.org/fhir/StructureDefinition/event-eventHistory>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EventHistory {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for abatement.
/// When (or if) the family member's condition resolved.
/// See <http://hl7.org/fhir/StructureDefinition/familymemberhistory-abatement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyMemberHistoryAbatement {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<family_member_history_abatement::ValueX>,
}
/// Nested message and enum types in `FamilyMemberHistoryAbatement`.
pub mod family_member_history_abatement {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2, 3")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            Age(super::super::Age),
            #[prost(message, tag = "3")]
            Boolean(super::super::Boolean),
        }
    }
}
/// Auto-generated from StructureDefinition for observation.
/// Genetic markers, ethnicity, etc.
/// See
/// <http://hl7.org/fhir/StructureDefinition/family-member-history-genetics-observation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyMemberHistoryObservation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for parent.
/// Mother(s) & Father(s) - genetic & other.
/// See
/// <http://hl7.org/fhir/StructureDefinition/family-member-history-genetics-parent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyMemberHistoryParent {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// mother | father | adoptive mother | etc.
    #[prost(message, optional, tag = "4")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Link to parent relative(s)
    #[prost(message, optional, tag = "5")]
    pub reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for patient-record.
/// Link to patient record.
/// See
/// <http://hl7.org/fhir/StructureDefinition/familymemberhistory-patient-record>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyMemberHistoryPatientRecord {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for severity.
/// The seriousness of the family member condition.
/// See <http://hl7.org/fhir/StructureDefinition/familymemberhistory-severity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyMemberHistorySeverity {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for sibling.
/// natural brother(s) & natural sister(s) - genetic & other.
/// See
/// <http://hl7.org/fhir/StructureDefinition/family-member-history-genetics-sibling>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyMemberHistorySibling {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// sibling | brother | sister | etc.
    #[prost(message, optional, tag = "4")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Link to sibling relative(s)
    #[prost(message, optional, tag = "5")]
    pub reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for type.
/// Purpose of the family member history.
/// See <http://hl7.org/fhir/StructureDefinition/familymemberhistory-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyMemberHistoryType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for detail.
/// Resource with details for flag.
/// See <http://hl7.org/fhir/StructureDefinition/flag-detail>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FlagDetail {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for priority.
/// An alarm code.
/// See <http://hl7.org/fhir/StructureDefinition/flag-priority>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FlagPriority {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for fmm.
/// FMM Level.
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-fmm>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Fmm {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for acceptance.
/// Individual acceptance of goal.
/// See <http://hl7.org/fhir/StructureDefinition/goal-acceptance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalAcceptance {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Individual whose acceptance is reflected
    #[prost(message, optional, tag = "4")]
    pub individual: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "5")]
    pub status: ::core::option::Option<goal_acceptance::StatusCode>,
    /// Priority of goal for individual
    #[prost(message, optional, tag = "6")]
    pub priority: ::core::option::Option<CodeableConcept>,
}
/// Nested message and enum types in `GoalAcceptance`.
pub mod goal_acceptance {
    /// agree | disagree | pending
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusCode {
        #[prost(enumeration = "super::goal_acceptance_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for reasonRejected.
/// The reason the goal was not accepted.
/// See <http://hl7.org/fhir/StructureDefinition/goal-reasonRejected>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalReasonRejected {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for relationship.
/// Goals related to this Goal.
/// See <http://hl7.org/fhir/StructureDefinition/goal-relationship>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalRelationship {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// predecessor | successor | replacement | other
    #[prost(message, optional, tag = "4")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Related goal
    #[prost(message, optional, tag = "5")]
    pub target: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Human Language.
/// Human Language for the item.
/// See <http://hl7.org/fhir/StructureDefinition/language>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanLanguage {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<Code>,
}
/// Auto-generated from StructureDefinition for assembly-order.
/// Preferred display order of name parts.
/// See <http://hl7.org/fhir/StructureDefinition/humanname-assembly-order>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameAssemblyOrder {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<human_name_assembly_order::ValueCode>,
}
/// Nested message and enum types in `HumanNameAssemblyOrder`.
pub mod human_name_assembly_order {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(
            enumeration = "super::human_name_assembly_order_value_set::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for EN-qualifier.
/// LS | AC | NB | PR | HON | BR | AD | SP | MID | CL | IN | VV.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-EN-qualifier>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameEnQualifier {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<human_name_en_qualifier::ValueCode>,
}
/// Nested message and enum types in `HumanNameENQualifier`.
pub mod human_name_en_qualifier {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(
            enumeration = "super::entity_name_part_qualifier_value_set::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for EN-representation.
/// ABC | IDE | SYL.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-EN-representation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameEnRepresentation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<human_name_en_representation::ValueCode>,
}
/// Nested message and enum types in `HumanNameENRepresentation`.
pub mod human_name_en_representation {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(
            enumeration = "super::name_representation_use_value_set::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for EN-use.
/// A | ANON | I | P | R | C | M | ABC | IDE | SYL | OLD | DN | OR | PHON | SRCH
/// | T. See <http://hl7.org/fhir/StructureDefinition/iso21090-EN-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameEnUse {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<human_name_en_use::ValueCode>,
}
/// Nested message and enum types in `HumanNameENUse`.
pub mod human_name_en_use {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::v3_entity_name_use_r2_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for fathers-family.
/// Portion of family name derived from father.
/// See <http://hl7.org/fhir/StructureDefinition/humanname-fathers-family>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameFathersFamily {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for mothers-family.
/// Portion of family name derived from mother.
/// See <http://hl7.org/fhir/StructureDefinition/humanname-mothers-family>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameMothersFamily {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for own-name.
/// Portion derived from person's own surname.
/// See <http://hl7.org/fhir/StructureDefinition/humanname-own-name>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameOwnName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for own-prefix.
/// Voorvoegsel derived from person's own surname.
/// See <http://hl7.org/fhir/StructureDefinition/humanname-own-prefix>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameOwnPrefix {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for partner-name.
/// Portion derived from person's partner's surname.
/// See <http://hl7.org/fhir/StructureDefinition/humanname-partner-name>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNamePartnerName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for partner-prefix.
/// Voorvoegsel derived from person's partner's surname.
/// See <http://hl7.org/fhir/StructureDefinition/humanname-partner-prefix>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNamePartnerPrefix {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for validDate.
/// External Identifier associated with this element.
/// See <http://hl7.org/fhir/StructureDefinition/identifier-validDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct IdentifierValidDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date_time: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for initialValue.
/// An initial value expression.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-initialValue>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct InitialValue {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for instantiatesCanonical.
/// FHIR protocol or definition.
/// See <http://hl7.org/fhir/StructureDefinition/workflow-instantiatesCanonical>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct InstantiatesCanonical {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for instantiatesUri.
/// External protocol or definition.
/// See <http://hl7.org/fhir/StructureDefinition/workflow-instantiatesUri>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct InstantiatesUri {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for lastReviewDate.
/// Last review date for the resource.
/// See <http://hl7.org/fhir/StructureDefinition/resource-lastReviewDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LastReviewDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date: ::core::option::Option<Date>,
}
/// Auto-generated from StructureDefinition for changeBase.
/// Base List for changes.
/// See <http://hl7.org/fhir/StructureDefinition/list-changeBase>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ListChangeBase {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for boundary-geojson.
/// A boundary shape that represents the outside edge of the location (in GeoJSON
/// format). See
/// <http://hl7.org/fhir/StructureDefinition/location-boundary-geojson>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LocationBoundaryGeojson {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_attachment: ::core::option::Option<Attachment>,
}
/// Auto-generated from StructureDefinition for location.
/// Where event occurred.
/// See <http://hl7.org/fhir/StructureDefinition/event-location>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LocationExtension {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for maxDecimalPlaces.
/// Maximum digits after decimal.
/// See <http://hl7.org/fhir/StructureDefinition/maxDecimalPlaces>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MaxDecimalPlaces {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for maxSize.
/// Max size in MB.
/// See <http://hl7.org/fhir/StructureDefinition/maxSize>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MaxSize {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_decimal: ::core::option::Option<Decimal>,
}
/// Auto-generated from StructureDefinition for measureInfo.
/// Measure criteria for the resource.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-measureInfo>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureInfo {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// The measure being calculated
    #[prost(message, optional, tag = "4")]
    pub measure: ::core::option::Option<Canonical>,
    /// The group identifier
    #[prost(message, optional, tag = "5")]
    pub group_id: ::core::option::Option<String>,
    /// The population identifier
    #[prost(message, optional, tag = "6")]
    pub population_id: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for messageheader-response-request.
/// messageheader initiator requests a response.
/// See <http://hl7.org/fhir/StructureDefinition/messageheader-response-request>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageHeaderMessageheaderResponseRequest {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code:
        ::core::option::Option<message_header_messageheader_response_request::ValueCode>,
}
/// Nested message and enum types in `MessageHeaderMessageheaderResponseRequest`.
pub mod message_header_messageheader_response_request {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(
            enumeration = "super::messageheader_response_request_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for mimeType.
/// Type of attachment.
/// See <http://hl7.org/fhir/StructureDefinition/mimeType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MimeType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<mime_type::ValueCode>,
}
/// Nested message and enum types in `MimeType`.
pub mod mime_type {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// This valueset is not enumerable, and so is represented as a string.
        #[prost(string, tag = "4")]
        pub value: prost::alloc::string::String,
    }
}
/// Auto-generated from StructureDefinition for minLength.
/// At least this many characters.
/// See <http://hl7.org/fhir/StructureDefinition/minLength>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MinLength {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for namespace.
/// specify namespace other than <http://hl7.org/fhir.>
/// See <http://hl7.org/fhir/StructureDefinition/elementdefinition-namespace>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Namespace {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for Narrative Link.
/// Narrative Link.
/// See <http://hl7.org/fhir/StructureDefinition/narrativeLink>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NarrativeLink {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_url: ::core::option::Option<Url>,
}
/// Auto-generated from StructureDefinition for nullFlavor.
/// NI | OTH | NINF | PINF | UNK | ASKU | NAV | NASK | TRC | MSK | NA | QS.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-nullFlavor>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NullFlavor {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<null_flavor::ValueCode>,
}
/// Nested message and enum types in `NullFlavor`.
pub mod null_flavor {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::v3_null_flavor_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for adaptiveFeedingDevice.
/// Adaptive Feeding Device.
/// See
/// <http://hl7.org/fhir/StructureDefinition/nutritionorder-adaptiveFeedingDevice>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NutritionOrderAdaptiveFeedingDevice {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for doNotPerform.
/// true if request is prohibiting action.
/// See <http://hl7.org/fhir/StructureDefinition/request-doNotPerform>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NutritionOrderDoNotPerform {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for insurance.
/// Associated insurance coverage.
/// See <http://hl7.org/fhir/StructureDefinition/request-insurance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NutritionOrderInsurance {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for replaces.
/// Request(s) replaced by this request.
/// See <http://hl7.org/fhir/StructureDefinition/request-replaces>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NutritionOrderReplaces {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Allele.
/// Allele.
/// See <http://hl7.org/fhir/StructureDefinition/observation-geneticsAllele>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationAllele {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Name of allele
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<CodeableConcept>,
    /// The level of occurrence of a single DNA sequence variant within a set of
    /// chromosomes: Heteroplasmic / Homoplasmic / Homozygous / Heterozygous /
    /// Hemizygous
    #[prost(message, optional, tag = "5")]
    pub state: ::core::option::Option<CodeableConcept>,
    /// Allele frequency
    #[prost(message, optional, tag = "6")]
    pub frequency: ::core::option::Option<Decimal>,
}
/// Auto-generated from StructureDefinition for AminoAcidChange.
/// AminoAcidChange.
/// See
/// <http://hl7.org/fhir/StructureDefinition/observation-geneticsAminoAcidChange>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationAminoAcidChange {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// HGVS nomenclature for observed Amino Acid Change
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<CodeableConcept>,
    /// Amino Acid Change Type
    #[prost(message, optional, tag = "5")]
    pub r#type: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for Ancestry.
/// Ancestry.
/// See <http://hl7.org/fhir/StructureDefinition/observation-geneticsAncestry>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationAncestry {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Ancestry name
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<CodeableConcept>,
    /// Ancestry percentage
    #[prost(message, optional, tag = "5")]
    pub percentage: ::core::option::Option<Decimal>,
    /// Source of ancestry report
    #[prost(message, optional, tag = "6")]
    pub source: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for CopyNumberEvent.
/// Copy number variation.
/// See
/// <http://hl7.org/fhir/StructureDefinition/observation-geneticsCopyNumberEvent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationCopyNumberEvent {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for DNARegionName.
/// DNA region name.
/// See <http://hl7.org/fhir/StructureDefinition/observation-geneticsDNARegionName>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationDnaRegionName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for delta.
/// Qualitative change or trend in the measurement.
/// See <http://hl7.org/fhir/StructureDefinition/observation-delta>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationDelta {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for deviceCode.
/// A code representing the the type of device used for this observation.  Should
/// only be used if not implicit in the code found in `Observation.code`. See
/// <http://hl7.org/fhir/StructureDefinition/observation-deviceCode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationDeviceCode {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for focusCode.
/// Focus Code.
/// See <http://hl7.org/fhir/StructureDefinition/observation-focusCode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationFocusCode {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for gatewayDevice.
/// Gateway Device.
/// See <http://hl7.org/fhir/StructureDefinition/observation-gatewayDevice>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationGatewayDevice {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Gene.
/// HGNC gene symbol.
/// See <http://hl7.org/fhir/StructureDefinition/observation-geneticsGene>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationGene {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for GenomicSourceClass.
/// Genomic source class.
/// See
/// <http://hl7.org/fhir/StructureDefinition/observation-geneticsGenomicSourceClass>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationGenomicSourceClass {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for Interpretation.
/// Clinical interpretations for variant.
/// See
/// <http://hl7.org/fhir/StructureDefinition/observation-geneticsInterpretation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationInterpretation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for PhaseSet.
/// Phase set.
/// See <http://hl7.org/fhir/StructureDefinition/observation-geneticsPhaseSet>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationPhaseSet {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Phase set ID
    #[prost(message, optional, tag = "4")]
    pub id_slice: ::core::option::Option<Uri>,
    /// Phase set sequence
    #[prost(message, repeated, tag = "5")]
    pub molecular_sequence: prost::alloc::vec::Vec<Reference>,
}
/// Auto-generated from StructureDefinition for precondition.
/// Other Observations needed to aid in  the interpretation of the source
/// observation. See
/// <http://hl7.org/fhir/StructureDefinition/observation-precondition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationPrecondition {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for reagent.
/// Reference to reagents used to generate this observation.
/// See <http://hl7.org/fhir/StructureDefinition/observation-reagent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationReagent {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for replaces.
/// Replaces referenced Observation.
/// See <http://hl7.org/fhir/StructureDefinition/observation-replaces>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationReplaces {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for secondaryFinding.
/// Secondary findings are genetic test results that provide information about
/// variants in a gene unrelated to the primary purpose for the testing, most
/// often discovered when [Whole Exome Sequencing
/// (WES)](<https://en.wikipedia.org/wiki/Exome_sequencing>) or [Whole Genome
/// Sequencing (WGS)](<https://en.wikipedia.org/wiki/Whole_genome_sequencing>) is
/// performed. This extension should be used to denote when a genetic finding is
/// being shared as a secondary finding, and ideally refer to a corresponding
/// guideline or policy statement.
///
/// For more detail, please see:
/// <https://ghr.nlm.nih.gov/primer/testing/secondaryfindings.>
/// See <http://hl7.org/fhir/StructureDefinition/observation-secondaryFinding>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationSecondaryFinding {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for sequelTo.
/// Sequel to referenced Observation.
/// See <http://hl7.org/fhir/StructureDefinition/observation-sequelTo>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationSequelTo {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for specimenCode.
/// A code representing the the type of specimen used for this observation.
/// Should only be used if not implicit in the code found in `Observation.code`.
/// See <http://hl7.org/fhir/StructureDefinition/observation-specimenCode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationSpecimenCode {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for timeOffset.
/// Time Offset for interlacing.
/// See <http://hl7.org/fhir/StructureDefinition/observation-timeOffset>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationTimeOffset {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for Variant.
/// Variant.
/// See <http://hl7.org/fhir/StructureDefinition/observation-geneticsVariant>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationVariant {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// HGVS nomenclature for observed DNA sequence variant
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<CodeableConcept>,
    /// DNA sequence variant ID
    #[prost(message, optional, tag = "5")]
    pub id_slice: ::core::option::Option<CodeableConcept>,
    /// DNA sequence variant type
    #[prost(message, optional, tag = "6")]
    pub r#type: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for allowed-type.
/// Which types are allowed for a parameter, when the base type is Abstract.
/// See <http://hl7.org/fhir/StructureDefinition/operationdefinition-allowed-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationDefinitionAllowedType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for profile.
/// Profiles (StructureDefinition or IG) - one must apply.
/// See <http://hl7.org/fhir/StructureDefinition/operationdefinition-profile>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationDefinitionProfile {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for authority.
/// Reference to where the rule is defined.
/// See <http://hl7.org/fhir/StructureDefinition/operationoutcome-authority>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationOutcomeAuthority {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for detectedIssue.
/// Reference to a contra-indication that is the basis for this error.
/// See <http://hl7.org/fhir/StructureDefinition/operationoutcome-detectedIssue>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationOutcomeDetectedIssue {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for issue-source.
/// Source of a validation message.
/// See <http://hl7.org/fhir/StructureDefinition/operationoutcome-issue-source>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationOutcomeIssueSource {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for Ordinal Value.
/// Assigned Ordinal Value.
/// See <http://hl7.org/fhir/StructureDefinition/ordinalValue>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OrdinalValue {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_decimal: ::core::option::Option<Decimal>,
}
/// Auto-generated from StructureDefinition for primaryInd.
/// Indicator of primary specialty.
/// See
/// <http://hl7.org/fhir/StructureDefinition/organizationaffiliation-primaryInd>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OrganizationAffiliationPrimaryInd {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for period.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/organization-period>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OrganizationPeriod {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_period: ::core::option::Option<Period>,
}
/// Auto-generated from StructureDefinition for preferredContact.
/// Extension.
/// See <http://hl7.org/fhir/StructureDefinition/organization-preferredContact>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OrganizationPreferredContact {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for Original Text.
/// Original Text that represents the data as seen/selected/uttered originally.
/// See <http://hl7.org/fhir/StructureDefinition/originalText>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OriginalText {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for fullUrl.
/// fullUrl for resource.
/// See <http://hl7.org/fhir/StructureDefinition/parameters-fullUrl>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ParametersFullUrl {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for partOf.
/// Part of referenced event.
/// See <http://hl7.org/fhir/StructureDefinition/event-partOf>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PartOf {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for adoptionInfo.
/// The adoption status of the patient.
/// See <http://hl7.org/fhir/StructureDefinition/patient-adoptionInfo>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientAdoptionInfo {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for animal.
/// This patient is known to be an animal (non-human).
/// See <http://hl7.org/fhir/StructureDefinition/patient-animal>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientAnimal {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// The animal species.  E.g. Dog, Cow.
    #[prost(message, optional, tag = "4")]
    pub species: ::core::option::Option<CodeableConcept>,
    /// The animal breed.  E.g. Poodle, Angus.
    #[prost(message, optional, tag = "5")]
    pub breed: ::core::option::Option<CodeableConcept>,
    /// The status of the animal's reproductive parts.  E.g. Neutered, Intact.
    #[prost(message, optional, tag = "6")]
    pub gender_status: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for birthPlace.
/// Place of Birth for patient.
/// See <http://hl7.org/fhir/StructureDefinition/patient-birthPlace>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientBirthPlace {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_address: ::core::option::Option<Address>,
}
/// Auto-generated from StructureDefinition for birthTime.
/// Time of day of birth.
/// See <http://hl7.org/fhir/StructureDefinition/patient-birthTime>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientBirthTime {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date_time: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for cadavericDonor.
/// Post-mortem donor status.
/// See <http://hl7.org/fhir/StructureDefinition/patient-cadavericDonor>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientCadavericDonor {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for citizenship.
/// Nation(s) where the patient claims citizenship.
/// See <http://hl7.org/fhir/StructureDefinition/patient-citizenship>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientCitizenship {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Nation code of citizenship
    #[prost(message, optional, tag = "4")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Time period of citizenship
    #[prost(message, optional, tag = "5")]
    pub period: ::core::option::Option<Period>,
}
/// Auto-generated from StructureDefinition for congregation.
/// A group of place of religious practice.
/// See <http://hl7.org/fhir/StructureDefinition/patient-congregation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientCongregation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for disability.
/// Condition(s) limiting movement, senses, or activities.
/// See <http://hl7.org/fhir/StructureDefinition/patient-disability>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientDisability {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for genderIdentity.
/// The patient's gender identity.
/// See <http://hl7.org/fhir/StructureDefinition/patient-genderIdentity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientGenderIdentity {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for importance.
/// Special status given the patient.
/// See <http://hl7.org/fhir/StructureDefinition/patient-importance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientImportance {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for interpreterRequired.
/// Whether the patient needs an interpreter.
/// See <http://hl7.org/fhir/StructureDefinition/patient-interpreterRequired>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientInterpreterRequired {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for mothersMaidenName.
/// Mother's Maiden name.
/// See <http://hl7.org/fhir/StructureDefinition/patient-mothersMaidenName>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientMothersMaidenName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for nationality.
/// Nationality.
/// See <http://hl7.org/fhir/StructureDefinition/patient-nationality>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientNationality {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Nationality Code
    #[prost(message, optional, tag = "4")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Nationality Period
    #[prost(message, optional, tag = "5")]
    pub period: ::core::option::Option<Period>,
}
/// Auto-generated from StructureDefinition for preferenceType.
/// The type of the patient's preferred language.
/// See <http://hl7.org/fhir/StructureDefinition/patient-preferenceType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientPreferenceType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_coding: ::core::option::Option<Coding>,
}
/// Auto-generated from StructureDefinition for proficiency.
/// Proficiency level of the communication.
/// See <http://hl7.org/fhir/StructureDefinition/patient-proficiency>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientProficiency {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// The proficiency level of the communication
    #[prost(message, optional, tag = "4")]
    pub level: ::core::option::Option<Coding>,
    /// The proficiency type of the communication
    #[prost(message, repeated, tag = "5")]
    pub r#type: prost::alloc::vec::Vec<Coding>,
}
/// Auto-generated from StructureDefinition for relatedPerson.
/// This contact may have further details in this RelatedPerson.
/// See <http://hl7.org/fhir/StructureDefinition/patient-relatedPerson>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientRelatedPerson {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for religion.
/// The patient's professed religious affiliations.
/// See <http://hl7.org/fhir/StructureDefinition/patient-religion>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PatientReligion {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for performerFunction.
/// Type of performance.
/// See <http://hl7.org/fhir/StructureDefinition/event-performerFunction>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PerformerFunction {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for permitted-value-conceptmap.
/// Mapping from permitted to transmitted.
/// See <http://hl7.org/fhir/StructureDefinition/11179-permitted-value-conceptmap>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PermittedValueConceptmap {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for permitted-value-valueset.
/// Permitted values.
/// See <http://hl7.org/fhir/StructureDefinition/11179-permitted-value-valueset>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PermittedValueValueset {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for cdsHooksEndpoint.
/// Surface this ECA Rule here.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-cdsHooksEndpoint>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PlanDefinitionCdsHooksEndpoint {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for primaryInd.
/// Indicator of primary specialty.
/// See <http://hl7.org/fhir/StructureDefinition/practitionerrole-primaryInd>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PractitionerRolePrimaryInd {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for preferred.
/// Preferred.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-preferred>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Preferred {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for causedBy.
/// Related item that caused this procedure.
/// See <http://hl7.org/fhir/StructureDefinition/procedure-causedBy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProcedureCausedBy {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for incisionDateTime.
/// The first incision time.
/// See <http://hl7.org/fhir/StructureDefinition/procedure-incisionDateTime>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProcedureIncisionDateTime {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date_time: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for method.
/// The method used to perform the procedure.
/// See <http://hl7.org/fhir/StructureDefinition/procedure-method>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProcedureMethod {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for progressStatus.
/// A details procedure progress.
/// See <http://hl7.org/fhir/StructureDefinition/procedure-progressStatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProcedureProgressStatus {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for schedule.
/// Schedule followed.
/// See <http://hl7.org/fhir/StructureDefinition/procedure-schedule>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProcedureSchedule {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_timing: ::core::option::Option<Timing>,
}
/// Auto-generated from StructureDefinition for PQ-translation.
/// Same quantity with different units.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-PQ-translation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuantityPqTranslation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_quantity: ::core::option::Option<Quantity>,
}
/// Auto-generated from StructureDefinition for uncertainty.
/// Standard Deviation (same units as the quantity).
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-uncertainty>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuantityUncertainty {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_decimal: ::core::option::Option<Decimal>,
}
/// Auto-generated from StructureDefinition for uncertaintyType.
/// Probability Distribution Type for uncertainty.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-uncertaintyType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuantityUncertaintyType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<quantity_uncertainty_type::ValueCode>,
}
/// Nested message and enum types in `QuantityUncertaintyType`.
pub mod quantity_uncertainty_type {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(
            enumeration = "super::probability_distribution_type_value_set::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for baseType.
/// Base Type for answer.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-baseType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireBaseType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<questionnaire_base_type::ValueCode>,
}
/// Nested message and enum types in `QuestionnaireBaseType`.
pub mod questionnaire_base_type {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::data_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for choiceOrientation.
/// horizontal | vertical.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireChoiceOrientation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<questionnaire_choice_orientation::ValueCode>,
}
/// Nested message and enum types in `QuestionnaireChoiceOrientation`.
pub mod questionnaire_choice_orientation {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::choice_list_orientation_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for constraint.
/// Constraint.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-constraint>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireConstraint {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier
    #[prost(message, optional, tag = "4")]
    pub key: ::core::option::Option<Id>,
    /// Why needed
    #[prost(message, optional, tag = "5")]
    pub requirements: ::core::option::Option<String>,
    #[prost(message, optional, tag = "6")]
    pub severity: ::core::option::Option<questionnaire_constraint::SeverityCode>,
    /// Formal rule
    #[prost(message, optional, tag = "7")]
    pub expression: ::core::option::Option<String>,
    /// Human-readable rule
    #[prost(message, optional, tag = "8")]
    pub human: ::core::option::Option<String>,
    /// Relative path to elements
    #[prost(message, repeated, tag = "9")]
    pub location: prost::alloc::vec::Vec<String>,
}
/// Nested message and enum types in `QuestionnaireConstraint`.
pub mod questionnaire_constraint {
    /// error|warning
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SeverityCode {
        #[prost(enumeration = "super::constraint_severity_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for displayCategory.
/// Purpose of rendered text.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-displayCategory>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireDisplayCategory {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for fhirType.
/// The underlying FHIR data type.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-fhirType>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireFhirType {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for hidden.
/// Don't display to user.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-hidden>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireHidden {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for itemControl.
/// E.g. Fly-over, Table, Checkbox, Combo-box, Lookup, etc.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireItemControl {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for maxOccurs.
/// Maximum repetitions.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireMaxOccurs {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for maxValue.
/// Must be <= this value.
/// See <http://hl7.org/fhir/StructureDefinition/maxValue>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireMaxValue {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<questionnaire_max_value::ValueX>,
}
/// Nested message and enum types in `QuestionnaireMaxValue`.
pub mod questionnaire_max_value {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5, 6")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "3")]
            Time(super::super::Time),
            #[prost(message, tag = "4")]
            Instant(super::super::Instant),
            #[prost(message, tag = "5")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "6")]
            Integer(super::super::Integer),
        }
    }
}
/// Auto-generated from StructureDefinition for minOccurs.
/// Minimum repetitions.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireMinOccurs {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for minValue.
/// Must be >= this value.
/// See <http://hl7.org/fhir/StructureDefinition/minValue>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireMinValue {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<questionnaire_min_value::ValueX>,
}
/// Nested message and enum types in `QuestionnaireMinValue`.
pub mod questionnaire_min_value {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2, 3, 4, 5")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "3")]
            Time(super::super::Time),
            #[prost(message, tag = "4")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "5")]
            Integer(super::super::Integer),
        }
    }
}
/// Auto-generated from StructureDefinition for optionExclusive.
/// Option is exclusive.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-optionExclusive>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireOptionExclusive {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for optionPrefix.
/// E.g. "(a)", "1.", etc.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-optionPrefix>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireOptionPrefix {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for referenceFilter.
/// Filter to apply when looking up references.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-referenceFilter>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireReferenceFilter {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for referenceProfile.
/// Allowed profile for reference.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-referenceProfile>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireReferenceProfile {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for referenceResource.
/// Allowed resource for reference.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-referenceResource>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireReferenceResource {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<questionnaire_reference_resource::ValueCode>,
}
/// Nested message and enum types in `QuestionnaireReferenceResource`.
pub mod questionnaire_reference_resource {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::resource_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for author.
/// Who answered question/group.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaireresponse-author>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireResponseAuthor {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for completionMode.
/// E.g. Verbal, written, electronic.
/// See
/// <http://hl7.org/fhir/StructureDefinition/questionnaireresponse-completionMode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireResponseCompletionMode {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for reason.
/// Why response was created.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaireresponse-reason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireResponseReason {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for reviewer.
/// Who verified completion of form?.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaireresponse-reviewer>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireResponseReviewer {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for signature.
/// A signature attesting to the content.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaireresponse-signature>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireResponseSignature {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_signature: ::core::option::Option<Signature>,
}
/// Auto-generated from StructureDefinition for signatureRequired.
/// Is signature needed?.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-signatureRequired>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireSignatureRequired {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for sliderStepValue.
/// Increment value for slider.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-sliderStepValue>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireSliderStepValue {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for supportLink.
/// Supporting information.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-supportLink>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireSupportLink {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for unit.
/// Unit for numeric answer.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-unit>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireUnit {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_coding: ::core::option::Option<Coding>,
}
/// Auto-generated from StructureDefinition for unitOption.
/// Unit choice.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-unitOption>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireUnitOption {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_coding: ::core::option::Option<Coding>,
}
/// Auto-generated from StructureDefinition for unitValueSet.
/// Unit choices.
/// See <http://hl7.org/fhir/StructureDefinition/questionnaire-unitValueSet>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireUnitValueSet {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for usageMode.
/// capture | display | display-non-empty | capture-display |
/// capture-display-non-empty. See
/// <http://hl7.org/fhir/StructureDefinition/questionnaire-usageMode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireUsageMode {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<questionnaire_usage_mode::ValueCode>,
}
/// Nested message and enum types in `QuestionnaireUsageMode`.
pub mod questionnaire_usage_mode {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(
            enumeration = "super::questionnaire_item_usage_mode_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for Variable.
/// Variable for processing.
/// See <http://hl7.org/fhir/StructureDefinition/variable>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireVariable {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_expression: ::core::option::Option<Expression>,
}
/// Auto-generated from StructureDefinition for reasonCode.
/// Why was event performed?.
/// See <http://hl7.org/fhir/StructureDefinition/workflow-reasonCode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReasonCode {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for reasonReference.
/// Why was event performed?.
/// See <http://hl7.org/fhir/StructureDefinition/workflow-reasonReference>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReasonReference {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for regex.
/// Regular expression pattern.
/// See <http://hl7.org/fhir/StructureDefinition/regex>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Regex {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for relatedArtifact.
/// Documentation relevant to the 'parent' resource.
/// See <http://hl7.org/fhir/StructureDefinition/workflow-relatedArtifact>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RelatedArtifactExtension {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_related_artifact: ::core::option::Option<RelatedArtifact>,
}
/// Auto-generated from StructureDefinition for Relative Date Criteria.
/// Relative Date Criteria.
/// See <http://hl7.org/fhir/StructureDefinition/relative-date>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RelativeDateCriteria {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "4")]
    pub event: ::core::option::Option<relative_date_criteria::EventX>,
    #[prost(message, optional, tag = "5")]
    pub relationship: ::core::option::Option<relative_date_criteria::RelationshipCode>,
    /// Duration after the event
    #[prost(message, optional, tag = "6")]
    pub offset: ::core::option::Option<Duration>,
}
/// Nested message and enum types in `RelativeDateCriteria`.
pub mod relative_date_criteria {
    /// Event that the date is relative to
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EventX {
        #[prost(oneof = "event_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<event_x::Choice>,
    }
    /// Nested message and enum types in `EventX`.
    pub mod event_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Reference(super::super::Reference),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// before-start | before | before-end | concurrent-with-start | concurrent |
    /// concurrent-with-end | after-start | after | after-end
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelationshipCode {
        #[prost(enumeration = "super::action_relationship_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for relativeDateTime.
/// A date/time that is specified relative to another event.
/// See <http://hl7.org/fhir/StructureDefinition/cqf-relativeDateTime>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RelativeDateTime {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Relative to what event
    #[prost(message, optional, tag = "4")]
    pub target: ::core::option::Option<Reference>,
    /// Relative to which element on the event
    #[prost(message, optional, tag = "5")]
    pub target_path: ::core::option::Option<String>,
    #[prost(message, optional, tag = "6")]
    pub relationship: ::core::option::Option<relative_date_time::RelationshipCode>,
    #[prost(message, optional, tag = "7")]
    pub offset: ::core::option::Option<relative_date_time::OffsetX>,
}
/// Nested message and enum types in `RelativeDateTime`.
pub mod relative_date_time {
    /// before-start | before | before-end | concurrent-with-start | concurrent |
    /// concurrent-with-end | after-start | after | after-end
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelationshipCode {
        #[prost(enumeration = "super::action_relationship_type_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
    /// How long
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OffsetX {
        #[prost(oneof = "offset_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<offset_x::Choice>,
    }
    /// Nested message and enum types in `OffsetX`.
    pub mod offset_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Duration(super::super::Duration),
            #[prost(message, tag = "2")]
            Range(super::super::Range),
        }
    }
}
/// Auto-generated from StructureDefinition for relevantHistory.
/// Key events in history of request.
/// See <http://hl7.org/fhir/StructureDefinition/request-relevantHistory>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RelevantHistory {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Rendered Value.
/// What should be displayed to human (if default is not appropriate).
/// See <http://hl7.org/fhir/StructureDefinition/rendered-value>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RenderedValue {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for replaces.
/// References a resource that this resource replaces.
/// See <http://hl7.org/fhir/StructureDefinition/replaces>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Replaces {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for researchStudy.
/// Associated research study.
/// See <http://hl7.org/fhir/StructureDefinition/workflow-researchStudy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchStudyExtension {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for pertainsToGoal.
/// Pertains to goal.
/// See <http://hl7.org/fhir/StructureDefinition/resource-pertainsToGoal>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResourcePertainsToGoal {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for risk.
/// Risk.
/// See <http://hl7.org/fhir/StructureDefinition/diagnosticReport-risk>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Risk {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for performerOrder.
/// Performer Order.
/// See <http://hl7.org/fhir/StructureDefinition/request-performerOrder>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ServiceRequestPerformerOrder {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for precondition.
/// The condition or state of the patient for this test.
/// See <http://hl7.org/fhir/StructureDefinition/servicerequest-precondition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ServiceRequestPrecondition {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for questionnaireRequest.
/// Questionnaire to be ordered.
/// See
/// <http://hl7.org/fhir/StructureDefinition/servicerequest-questionnaireRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ServiceRequestQuestionnaireRequest {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for special-status.
/// Special note about status for implementers.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-special-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecialStatus {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for collectionPriority.
/// Urgency for collection.
/// See <http://hl7.org/fhir/StructureDefinition/specimen-collectionPriority>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecimenCollectionPriority {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for isDryWeight.
/// Whether quantity is a dry weight.
/// See <http://hl7.org/fhir/StructureDefinition/specimen-isDryWeight>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecimenIsDryWeight {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for processingTime.
/// Time of processing.
/// See <http://hl7.org/fhir/StructureDefinition/specimen-processingTime>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecimenProcessingTime {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<specimen_processing_time::ValueX>,
}
/// Nested message and enum types in `SpecimenProcessingTime`.
pub mod specimen_processing_time {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(oneof = "value_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Period(super::super::Period),
            #[prost(message, tag = "2")]
            Duration(super::super::Duration),
        }
    }
}
/// Auto-generated from StructureDefinition for sequenceNumber.
/// The sequence number of the sample.
/// See <http://hl7.org/fhir/StructureDefinition/specimen-sequenceNumber>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecimenSequenceNumber {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for specialHandling.
/// Special handling of the specimen.
/// See <http://hl7.org/fhir/StructureDefinition/specimen-specialHandling>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecimenSpecialHandling {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for standards-status.
/// HL7 Ballot/Standards status of artifact.
/// See
/// <http://hl7.org/fhir/StructureDefinition/structuredefinition-standards-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StandardsStatus {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<standards_status::ValueCode>,
}
/// Nested message and enum types in `StandardsStatus`.
pub mod standards_status {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::standards_status_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for statusReason.
/// Reason for current status.
/// See <http://hl7.org/fhir/StructureDefinition/event-statusReason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StatusReason {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for statusReason.
/// Reason for current status.
/// See <http://hl7.org/fhir/StructureDefinition/request-statusReason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StatusReasonExtension {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_codeable_concept: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for markdown.
/// String equivalent with markdown.
/// See <http://hl7.org/fhir/StructureDefinition/rendering-markdown>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StringMarkdown {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_markdown: ::core::option::Option<Markdown>,
}
/// Auto-generated from StructureDefinition for SC-coding.
/// code for string.
/// See <http://hl7.org/fhir/StructureDefinition/iso21090-SC-coding>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StringScCoding {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_coding: ::core::option::Option<Coding>,
}
/// Auto-generated from StructureDefinition for xhtml.
/// String equivalent with html markup.
/// See <http://hl7.org/fhir/StructureDefinition/rendering-xhtml>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StringXhtml {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for ancestor.
/// StructureDefinition this is derived from.
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-ancestor>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionAncestor {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for applicable-version.
/// Another Version this applies to.
/// See
/// <http://hl7.org/fhir/StructureDefinition/structuredefinition-applicable-version>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionApplicableVersion {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<structure_definition_applicable_version::ValueCode>,
}
/// Nested message and enum types in `StructureDefinitionApplicableVersion`.
pub mod structure_definition_applicable_version {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::fhir_version_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for category.
/// Category from official resource list.
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionCategory {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for codegen-super.
/// Use a different base when generating code.
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-codegen-super>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionCodegenSuper {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for dependencies.
/// Dependent Profiles - must be valid against these too.
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-dependencies>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionDependencies {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for fmm-no-warnings.
/// FMM Level (if no warnings).
/// See
/// <http://hl7.org/fhir/StructureDefinition/structuredefinition-fmm-no-warnings>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionFmmNoWarnings {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for normative-version.
/// If normative, which was the first normative version.
/// See
/// <http://hl7.org/fhir/StructureDefinition/structuredefinition-normative-version>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionNormativeVersion {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<structure_definition_normative_version::ValueCode>,
}
/// Nested message and enum types in `StructureDefinitionNormativeVersion`.
pub mod structure_definition_normative_version {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::fhir_version_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for security-category.
/// Security Categorization for Resource.
/// See
/// <http://hl7.org/fhir/StructureDefinition/structuredefinition-security-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionSecurityCategory {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<structure_definition_security_category::ValueCode>,
}
/// Nested message and enum types in `StructureDefinitionSecurityCategory`.
pub mod structure_definition_security_category {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(
            enumeration = "super::resource_security_category_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for summary.
/// Additional text for the summary presentation.
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-summary>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionSummary {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_markdown: ::core::option::Option<Markdown>,
}
/// Auto-generated from StructureDefinition for table-name.
/// Show mappings in the summary table with this name.
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-table-name>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionTableName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for template-status.
/// Template Status Code (more authoring statuses).
/// See
/// <http://hl7.org/fhir/StructureDefinition/structuredefinition-template-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionTemplateStatus {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<structure_definition_template_status::ValueCode>,
}
/// Nested message and enum types in `StructureDefinitionTemplateStatus`.
pub mod structure_definition_template_status {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(
            enumeration = "super::template_status_code_value_set::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for xml-no-order.
/// Whether elements can come in any order (XML).
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-xml-no-order>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionXmlNoOrder {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for style.
/// Html style value.
/// See <http://hl7.org/fhir/StructureDefinition/rendering-style>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Style {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for styleSensitive.
/// Are styles important for processing?.
/// See <http://hl7.org/fhir/StructureDefinition/rendering-styleSensitive>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StyleSensitive {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for supportingInfo.
/// Other information that may be relevant to this event.
/// See <http://hl7.org/fhir/StructureDefinition/workflow-supportingInfo>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupportingInfo {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for targetBodyStructure.
/// The target point for this procedure.
/// See <http://hl7.org/fhir/StructureDefinition/procedure-targetBodyStructure>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TargetBodyStructure {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for candidateList.
/// List of possible owners of Task.
/// See <http://hl7.org/fhir/StructureDefinition/task-candidateList>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TaskCandidateList {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for replaces.
/// Task(s) replaced by this Task.
/// See <http://hl7.org/fhir/StructureDefinition/task-replaces>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TaskReplaces {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_reference: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Timezone Code.
/// IANA Timezone Code per BCP 175.
/// See <http://hl7.org/fhir/StructureDefinition/tz-code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TimezoneCode {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<timezone_code::ValueCode>,
}
/// Nested message and enum types in `TimezoneCode`.
pub mod timezone_code {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// This valueset is not enumerable, and so is represented as a string.
        #[prost(string, tag = "4")]
        pub value: prost::alloc::string::String,
    }
}
/// Auto-generated from StructureDefinition for dayOfMonth.
/// Day of Month for schedule.
/// See <http://hl7.org/fhir/StructureDefinition/timing-dayOfMonth>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TimingDayOfMonth {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_positive_int: ::core::option::Option<PositiveInt>,
}
/// Auto-generated from StructureDefinition for exact.
/// Whether specified times must be followed as closely as possible.
/// See <http://hl7.org/fhir/StructureDefinition/timing-exact>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TimingExact {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for Translation.
/// Language Translation (Localization).
/// See <http://hl7.org/fhir/StructureDefinition/translation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Translation {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Code for Language
    #[prost(message, optional, tag = "4")]
    pub lang: ::core::option::Option<Code>,
    #[prost(message, optional, tag = "5")]
    pub content: ::core::option::Option<translation::ContentX>,
}
/// Nested message and enum types in `Translation`.
pub mod translation {
    /// Content in other Language
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ContentX {
        #[prost(oneof = "content_x::Choice", tags = "1, 2")]
        pub choice: ::core::option::Option<content_x::Choice>,
    }
    /// Nested message and enum types in `ContentX`.
    pub mod content_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            StringValue(super::super::String),
            #[prost(message, tag = "2")]
            Markdown(super::super::Markdown),
        }
    }
}
/// Auto-generated from StructureDefinition for group.
/// The group which this usage context is part of.
/// See <http://hl7.org/fhir/StructureDefinition/usagecontext-group>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UsageContextGroup {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for activityStatusDate.
/// Date when the activity status is in effect.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-activityStatusDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetActivityStatusDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date: ::core::option::Option<Date>,
}
/// Auto-generated from StructureDefinition for author.
/// Entity/entities that create and may modify the Value Set.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-author>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetAuthor {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_contact_detail: ::core::option::Option<ContactDetail>,
}
/// Auto-generated from StructureDefinition for authoritativeSource.
/// Reference to the current trusted source of the ValueSet resource (metadata
/// and definition). See
/// <http://hl7.org/fhir/StructureDefinition/valueset-authoritativeSource>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetAuthoritativeSource {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for caseSensitive.
/// If code is case sensitive.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-caseSensitive>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetCaseSensitive {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for concept-comments.
/// Comment about the use of this code in this context.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-concept-comments>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetConceptComments {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for concept-definition.
/// A definition for this code.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-concept-definition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetConceptDefinition {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for conceptOrder.
/// Appearance order for user selection.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-conceptOrder>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetConceptOrder {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_integer: ::core::option::Option<Integer>,
}
/// Auto-generated from StructureDefinition for deprecated.
/// The concept should not be used.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-deprecated>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetDeprecated {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for effectiveDate.
/// When the value set version becomes Active and is available for use.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-effectiveDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetEffectiveDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date_time: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for expand-group.
/// Defines a hierarchy structure (when in UI mode).
/// See <http://hl7.org/fhir/StructureDefinition/valueset-expand-group>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetExpandGroup {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Underlying code from the system
    #[prost(message, optional, tag = "4")]
    pub code: ::core::option::Option<Code>,
    /// Display for the group
    #[prost(message, optional, tag = "5")]
    pub display: ::core::option::Option<String>,
    /// Codes or other groups in this group
    #[prost(message, repeated, tag = "6")]
    pub member: prost::alloc::vec::Vec<Code>,
}
/// Auto-generated from StructureDefinition for expand-rules.
/// all-codes | ungrouped | groups-only.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-expand-rules>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetExpandRules {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<value_set_expand_rules::ValueCode>,
}
/// Nested message and enum types in `ValueSetExpandRules`.
pub mod value_set_expand_rules {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(
            enumeration = "super::expansion_processing_rule_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for expansionSource.
/// ValueSet definition used to generate this expansion (logical URL).
/// See <http://hl7.org/fhir/StructureDefinition/valueset-expansionSource>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetExpansionSource {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for expirationDate.
/// When the value set version should no longer be used.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-expirationDate>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetExpirationDate {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_date: ::core::option::Option<Date>,
}
/// Auto-generated from StructureDefinition for expression.
/// An alternative computable expression of the value set content.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-expression>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetExpression {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_expression: ::core::option::Option<Expression>,
}
/// Auto-generated from StructureDefinition for extensible.
/// Intended to be used with an extensible binding (e.g. 'open').
/// See <http://hl7.org/fhir/StructureDefinition/valueset-extensible>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetExtensible {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for keyWord.
/// Descriptors and key terms for search.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-keyWord>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetKeyWord {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for label.
/// E.g. "(a)", "1.", etc.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-label>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetLabel {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for map.
/// A concept map relevant to interpret this value set.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-map>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetMap {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for otherName.
/// Alternative names.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-otherName>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetOtherName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Human readable, short and specific
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<String>,
    /// Which name is preferred for this language
    #[prost(message, optional, tag = "5")]
    pub preferred: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for parameterSource.
/// Declares the source of the parameter.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-parameterSource>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetParameterSource {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<value_set_parameter_source::ValueCode>,
}
/// Nested message and enum types in `ValueSetParameterSource`.
pub mod value_set_parameter_source {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(
            enumeration = "super::expansion_parameter_source_code::Value",
            tag = "1"
        )]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
/// Auto-generated from StructureDefinition for reference.
/// Url of Value set the code was chosen from.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-reference>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetReference {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for rules-text.
/// An alternative non-computable expression of the value set content.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-rules-text>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetRulesText {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_markdown: ::core::option::Option<Markdown>,
}
/// Auto-generated from StructureDefinition for sourceReference.
/// Where did this content come from.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-sourceReference>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetSourceReference {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for steward.
/// Entity responsible for Value Set.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-steward>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetSteward {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_contact_detail: ::core::option::Option<ContactDetail>,
}
/// Auto-generated from StructureDefinition for supplement.
/// Declares dependency on a particular supplment.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-supplement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetSupplement {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for system.
/// Code system resource.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-system>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetSystem {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_canonical: ::core::option::Option<Canonical>,
}
/// Auto-generated from StructureDefinition for systemName.
/// Code system name.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-systemName>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetSystemName {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for systemRef.
/// Where to find code system.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-systemRef>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetSystemRef {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for toocostly.
/// The expansion is incomplete because the full expansion is too large.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-toocostly>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetToocostly {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for trusted-expansion.
/// Reference to a trusted expansion.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-trusted-expansion>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetTrustedExpansion {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_uri: ::core::option::Option<Uri>,
}
/// Auto-generated from StructureDefinition for unclosed.
/// The expansion is incomplete (perhaps because of post-coordination).
/// See <http://hl7.org/fhir/StructureDefinition/valueset-unclosed>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetUnclosed {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_boolean: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for usage.
/// Who has used and how?.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-usage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetUsage {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// A consumer of or client for the value set
    #[prost(message, optional, tag = "4")]
    pub user: ::core::option::Option<String>,
    /// Implementation/project/standard that uses value set
    #[prost(message, optional, tag = "5")]
    pub r#use: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for warning.
/// Extra warning about the correct use of the value set.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-warning>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetWarning {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_markdown: ::core::option::Option<Markdown>,
}
/// Auto-generated from StructureDefinition for workflowStatus.
/// Indicates the state of development of the value set.
/// See <http://hl7.org/fhir/StructureDefinition/valueset-workflowStatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSetWorkflowStatus {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Value of extension
    #[prost(message, optional, tag = "3")]
    pub value_string: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for wg.
/// Owning Work Group.
/// See <http://hl7.org/fhir/StructureDefinition/structuredefinition-wg>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Wg {
    /// Unique id for inter-element referencing
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    #[prost(message, optional, tag = "3")]
    pub value_code: ::core::option::Option<wg::ValueCode>,
}
/// Nested message and enum types in `Wg`.
pub mod wg {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueCode {
        #[prost(enumeration = "super::hl7_workgroup_code::Value", tag = "1")]
        pub value: i32,
        #[prost(message, optional, tag = "2")]
        pub id: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "3")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
    }
}
