/// Auto-generated from StructureDefinition for base64Binary, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type base64Binary. See
/// <http://hl7.org/fhir/StructureDefinition/base64Binary>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Base64Binary {
    /// Primitive value for base64Binary
    #[prost(bytes = "vec", tag = "1")]
    pub value: prost::alloc::vec::Vec<u8>,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for boolean, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type boolean. See
/// <http://hl7.org/fhir/StructureDefinition/boolean>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Boolean {
    /// Primitive value for boolean
    #[prost(bool, tag = "1")]
    pub value: bool,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for code, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type code. See
/// <http://hl7.org/fhir/StructureDefinition/code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Code {
    /// Primitive value for code
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for date, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type date. See
/// <http://hl7.org/fhir/StructureDefinition/date>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Date {
    /// Primitive value for date
    #[prost(int64, tag = "1")]
    pub value_us: i64,
    #[prost(string, tag = "2")]
    pub timezone: prost::alloc::string::String,
    #[prost(enumeration = "date::Precision", tag = "3")]
    pub precision: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "4")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "5")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `Date`.
pub mod date {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Precision {
        Unspecified = 0,
        Year = 1,
        Month = 2,
        Day = 3,
    }
}
/// Auto-generated from StructureDefinition for dateTime, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type dateTime. See
/// <http://hl7.org/fhir/StructureDefinition/dateTime>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DateTime {
    /// Primitive value for dateTime
    #[prost(int64, tag = "1")]
    pub value_us: i64,
    #[prost(string, tag = "2")]
    pub timezone: prost::alloc::string::String,
    #[prost(enumeration = "date_time::Precision", tag = "3")]
    pub precision: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "4")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "5")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DateTime`.
pub mod date_time {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Precision {
        Unspecified = 0,
        Year = 1,
        Month = 2,
        Day = 3,
        Second = 4,
        Millisecond = 5,
        Microsecond = 6,
    }
}
/// Auto-generated from StructureDefinition for decimal, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type decimal. See
/// <http://hl7.org/fhir/StructureDefinition/decimal>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Decimal {
    /// Primitive value for decimal
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for id, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type id. See
/// <http://hl7.org/fhir/StructureDefinition/id>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Id {
    /// Primitive value for id
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for instant, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type instant. See
/// <http://hl7.org/fhir/StructureDefinition/instant>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Instant {
    /// Primitive value for instant
    #[prost(int64, tag = "1")]
    pub value_us: i64,
    #[prost(string, tag = "2")]
    pub timezone: prost::alloc::string::String,
    #[prost(enumeration = "instant::Precision", tag = "3")]
    pub precision: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "4")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "5")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `Instant`.
pub mod instant {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Precision {
        Unspecified = 0,
        Second = 1,
        Millisecond = 2,
        Microsecond = 3,
    }
}
/// Auto-generated from StructureDefinition for integer, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type integer. See
/// <http://hl7.org/fhir/StructureDefinition/integer>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Integer {
    /// Primitive value for integer
    #[prost(sint32, tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for markdown, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type markdown. See
/// <http://hl7.org/fhir/StructureDefinition/markdown>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Markdown {
    /// Primitive value for markdown
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for oid, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type oid. See
/// <http://hl7.org/fhir/StructureDefinition/oid>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Oid {
    /// Primitive value for oid
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for positiveInt, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type positiveInt. See
/// <http://hl7.org/fhir/StructureDefinition/positiveInt>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PositiveInt {
    /// Primitive value for positiveInt
    #[prost(uint32, tag = "1")]
    pub value: u32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for string, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type string. See
/// <http://hl7.org/fhir/StructureDefinition/string>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct String {
    /// Primitive value for string
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, boxed, tag = "2")]
    pub id: ::core::option::Option<prost::alloc::boxed::Box<String>>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for time, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type time. See
/// <http://hl7.org/fhir/StructureDefinition/time>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Time {
    /// Primitive value for time
    #[prost(int64, tag = "1")]
    pub value_us: i64,
    #[prost(enumeration = "time::Precision", tag = "2")]
    pub precision: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "3")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "4")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `Time`.
pub mod time {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Precision {
        Unspecified = 0,
        Second = 1,
        Millisecond = 2,
        Microsecond = 3,
    }
}
/// Auto-generated from StructureDefinition for unsignedInt, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type unsignedInt. See
/// <http://hl7.org/fhir/StructureDefinition/unsignedInt>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UnsignedInt {
    /// Primitive value for unsignedInt
    #[prost(uint32, tag = "1")]
    pub value: u32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for uri, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type uri. See
/// <http://hl7.org/fhir/StructureDefinition/uri>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Uri {
    /// Primitive value for uri
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for uuid, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type uuid. See
/// <http://hl7.org/fhir/StructureDefinition/uuid>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Uuid {
    /// Primitive value for uuid
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for xhtml, last updated
/// 2017-04-19T07:44:43.294+10:00. Primitive Type xhtml. See
/// <http://hl7.org/fhir/StructureDefinition/xhtml>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Xhtml {
    /// Actual xhtml
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for Address, last updated
/// 2017-04-19T07:44:43.294+10:00. An address expressed using postal conventions
/// (as opposed to GPS or other location definition formats). See
/// <http://hl7.org/fhir/StructureDefinition/Address>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Address {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// home | work | temp | old - purpose of this address
    #[prost(message, optional, tag = "3")]
    pub r#use: ::core::option::Option<AddressUseCode>,
    /// postal | physical | both
    #[prost(message, optional, tag = "4")]
    pub r#type: ::core::option::Option<AddressTypeCode>,
    /// Text representation of the address
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<String>,
    /// Street name, number, direction & P.O. Box etc.
    #[prost(message, repeated, tag = "6")]
    pub line: prost::alloc::vec::Vec<String>,
    /// Name of city, town etc.
    #[prost(message, optional, tag = "7")]
    pub city: ::core::option::Option<String>,
    /// District name (aka county)
    #[prost(message, optional, tag = "8")]
    pub district: ::core::option::Option<String>,
    /// Sub-unit of country (abbreviations ok)
    #[prost(message, optional, tag = "9")]
    pub state: ::core::option::Option<String>,
    /// Postal code for area
    #[prost(message, optional, tag = "10")]
    pub postal_code: ::core::option::Option<String>,
    /// Country (e.g. can be ISO 3166 2 or 3 letter code)
    #[prost(message, optional, tag = "11")]
    pub country: ::core::option::Option<String>,
    /// Time period when address was/is in use
    #[prost(message, optional, tag = "12")]
    pub period: ::core::option::Option<Period>,
}
/// Auto-generated from StructureDefinition for Age, last updated
/// 2017-04-19T07:44:43.294+10:00. A duration of time during which an organism
/// (or a process) has existed. See <http://hl7.org/fhir/StructureDefinition/Age>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Age {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    /// < | <= | >= | > - how to understand the value
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<QuantityComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Auto-generated from StructureDefinition for Annotation, last updated
/// 2017-04-19T07:44:43.294+10:00. Text node with attribution. See
/// <http://hl7.org/fhir/StructureDefinition/Annotation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Annotation {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, optional, tag = "3")]
    pub author: ::core::option::Option<annotation::Author>,
    /// When the annotation was made
    #[prost(message, optional, tag = "4")]
    pub time: ::core::option::Option<DateTime>,
    /// The annotation  - text content
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<String>,
}
/// Nested message and enum types in `Annotation`.
pub mod annotation {
    /// Individual responsible for the annotation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Author {
        #[prost(oneof = "author::Author", tags = "1, 2")]
        pub author: ::core::option::Option<author::Author>,
    }
    /// Nested message and enum types in `Author`.
    pub mod author {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Author {
            #[prost(message, tag = "1")]
            Reference(super::super::Reference),
            #[prost(message, tag = "2")]
            StringValue(super::super::String),
        }
    }
}
/// Auto-generated from StructureDefinition for Attachment, last updated
/// 2017-04-19T07:44:43.294+10:00. Content in a format defined elsewhere. See
/// <http://hl7.org/fhir/StructureDefinition/Attachment>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Attachment {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Mime type of the content, with charset etc.
    #[prost(message, optional, tag = "3")]
    pub content_type: ::core::option::Option<MimeTypeCode>,
    /// Human language of the content (BCP-47)
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Data inline, base64ed
    #[prost(message, optional, tag = "5")]
    pub data: ::core::option::Option<Base64Binary>,
    /// Uri where the data can be found
    #[prost(message, optional, tag = "6")]
    pub url: ::core::option::Option<Uri>,
    /// Number of bytes of content (if url provided)
    #[prost(message, optional, tag = "7")]
    pub size: ::core::option::Option<UnsignedInt>,
    /// Hash of the data (sha-1, base64ed)
    #[prost(message, optional, tag = "8")]
    pub hash: ::core::option::Option<Base64Binary>,
    /// Label to display in place of the data
    #[prost(message, optional, tag = "9")]
    pub title: ::core::option::Option<String>,
    /// Date attachment was first created
    #[prost(message, optional, tag = "10")]
    pub creation: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for CodeableConcept, last updated
/// 2017-04-19T07:44:43.294+10:00. Concept - reference to a terminology or just
/// text. See <http://hl7.org/fhir/StructureDefinition/CodeableConcept>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeableConcept {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Code defined by a terminology system
    #[prost(message, repeated, tag = "3")]
    pub coding: prost::alloc::vec::Vec<Coding>,
    /// Plain text representation of the concept
    #[prost(message, optional, tag = "4")]
    pub text: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for Coding, last updated
/// 2017-04-19T07:44:43.294+10:00. A reference to a code defined by a terminology
/// system. See <http://hl7.org/fhir/StructureDefinition/Coding>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Coding {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Identity of the terminology system
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<Uri>,
    /// Version of the system - if relevant
    #[prost(message, optional, tag = "4")]
    pub version: ::core::option::Option<String>,
    /// Symbol in syntax defined by the system
    #[prost(message, optional, tag = "5")]
    pub code: ::core::option::Option<Code>,
    /// Representation defined by the system
    #[prost(message, optional, tag = "6")]
    pub display: ::core::option::Option<String>,
    /// If this coding was chosen directly by the user
    #[prost(message, optional, tag = "7")]
    pub user_selected: ::core::option::Option<Boolean>,
}
/// Auto-generated from StructureDefinition for ContactPoint, last updated
/// 2017-04-19T07:44:43.294+10:00. Details of a Technology mediated contact point
/// (phone, fax, email, etc.). See
/// <http://hl7.org/fhir/StructureDefinition/ContactPoint>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPoint {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// phone | fax | email | pager | url | sms | other
    #[prost(message, optional, tag = "3")]
    pub system: ::core::option::Option<ContactPointSystemCode>,
    /// The actual contact point details
    #[prost(message, optional, tag = "4")]
    pub value: ::core::option::Option<String>,
    /// home | work | temp | old | mobile - purpose of this contact point
    #[prost(message, optional, tag = "5")]
    pub r#use: ::core::option::Option<ContactPointUseCode>,
    /// Specify preferred order of use (1 = highest)
    #[prost(message, optional, tag = "6")]
    pub rank: ::core::option::Option<PositiveInt>,
    /// Time period when the contact point was/is in use
    #[prost(message, optional, tag = "7")]
    pub period: ::core::option::Option<Period>,
}
/// Auto-generated from StructureDefinition for Count, last updated
/// 2017-04-19T07:44:43.294+10:00. A measured or measurable amount. See
/// <http://hl7.org/fhir/StructureDefinition/Count>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Count {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    /// < | <= | >= | > - how to understand the value
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<QuantityComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Auto-generated from StructureDefinition for Distance, last updated
/// 2017-04-19T07:44:43.294+10:00. A length - a value with a unit that is a
/// physical distance. See <http://hl7.org/fhir/StructureDefinition/Distance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Distance {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    /// < | <= | >= | > - how to understand the value
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<QuantityComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Auto-generated from StructureDefinition for Dosage, last updated
/// 2017-04-19T07:44:43.294+10:00. How the medication is/was taken or should be
/// taken. See <http://hl7.org/fhir/StructureDefinition/Dosage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Dosage {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// The order of the dosage instructions
    #[prost(message, optional, tag = "3")]
    pub sequence: ::core::option::Option<Integer>,
    /// Free text dosage instructions e.g. SIG
    #[prost(message, optional, tag = "4")]
    pub text: ::core::option::Option<String>,
    /// Supplemental instruction - e.g. "with meals"
    #[prost(message, repeated, tag = "5")]
    pub additional_instruction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Patient or consumer oriented instructions
    #[prost(message, optional, tag = "6")]
    pub patient_instruction: ::core::option::Option<String>,
    /// When medication should be administered
    #[prost(message, optional, tag = "7")]
    pub timing: ::core::option::Option<Timing>,
    #[prost(message, optional, tag = "8")]
    pub as_needed: ::core::option::Option<dosage::AsNeeded>,
    /// Body site to administer to
    #[prost(message, optional, tag = "9")]
    pub site: ::core::option::Option<CodeableConcept>,
    /// How drug should enter body
    #[prost(message, optional, tag = "10")]
    pub route: ::core::option::Option<CodeableConcept>,
    /// Technique for administering medication
    #[prost(message, optional, tag = "11")]
    pub method: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "12")]
    pub dose: ::core::option::Option<dosage::Dose>,
    /// Upper limit on medication per unit of time
    #[prost(message, optional, tag = "13")]
    pub max_dose_per_period: ::core::option::Option<Ratio>,
    /// Upper limit on medication per administration
    #[prost(message, optional, tag = "14")]
    pub max_dose_per_administration: ::core::option::Option<SimpleQuantity>,
    /// Upper limit on medication per lifetime of the patient
    #[prost(message, optional, tag = "15")]
    pub max_dose_per_lifetime: ::core::option::Option<SimpleQuantity>,
    #[prost(message, optional, tag = "16")]
    pub rate: ::core::option::Option<dosage::Rate>,
}
/// Nested message and enum types in `Dosage`.
pub mod dosage {
    /// Take "as needed" (for x)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AsNeeded {
        #[prost(oneof = "as_needed::AsNeeded", tags = "1, 2")]
        pub as_needed: ::core::option::Option<as_needed::AsNeeded>,
    }
    /// Nested message and enum types in `AsNeeded`.
    pub mod as_needed {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum AsNeeded {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// Amount of medication per dose
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Dose {
        #[prost(oneof = "dose::Dose", tags = "1, 2")]
        pub dose: ::core::option::Option<dose::Dose>,
    }
    /// Nested message and enum types in `Dose`.
    pub mod dose {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Dose {
            #[prost(message, tag = "1")]
            Range(super::super::Range),
            #[prost(message, tag = "2")]
            Quantity(super::super::SimpleQuantity),
        }
    }
    /// Amount of medication per unit of time
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Rate {
        #[prost(oneof = "rate::Rate", tags = "1, 2, 3")]
        pub rate: ::core::option::Option<rate::Rate>,
    }
    /// Nested message and enum types in `Rate`.
    pub mod rate {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Rate {
            #[prost(message, tag = "1")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "2")]
            Range(super::super::Range),
            #[prost(message, tag = "3")]
            Quantity(super::super::SimpleQuantity),
        }
    }
}
/// Auto-generated from StructureDefinition for Duration, last updated
/// 2017-04-19T07:44:43.294+10:00. A length of time. See
/// <http://hl7.org/fhir/StructureDefinition/Duration>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Duration {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    /// < | <= | >= | > - how to understand the value
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<QuantityComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Auto-generated from StructureDefinition for HumanName, last updated
/// 2017-04-19T07:44:43.294+10:00. Name of a human - parts and usage. See
/// <http://hl7.org/fhir/StructureDefinition/HumanName>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanName {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// usual | official | temp | nickname | anonymous | old | maiden
    #[prost(message, optional, tag = "3")]
    pub r#use: ::core::option::Option<NameUseCode>,
    /// Text representation of the full name
    #[prost(message, optional, tag = "4")]
    pub text: ::core::option::Option<String>,
    /// Family name (often called 'Surname')
    #[prost(message, optional, tag = "5")]
    pub family: ::core::option::Option<String>,
    /// Given names (not always 'first'). Includes middle names
    #[prost(message, repeated, tag = "6")]
    pub given: prost::alloc::vec::Vec<String>,
    /// Parts that come before the name
    #[prost(message, repeated, tag = "7")]
    pub prefix: prost::alloc::vec::Vec<String>,
    /// Parts that come after the name
    #[prost(message, repeated, tag = "8")]
    pub suffix: prost::alloc::vec::Vec<String>,
    /// Time period when name was/is in use
    #[prost(message, optional, tag = "9")]
    pub period: ::core::option::Option<Period>,
}
/// Auto-generated from StructureDefinition for Identifier, last updated
/// 2017-04-19T07:44:43.294+10:00. An identifier intended for computation. See
/// <http://hl7.org/fhir/StructureDefinition/Identifier>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Identifier {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// usual | official | temp | secondary (If known)
    #[prost(message, optional, tag = "3")]
    pub r#use: ::core::option::Option<IdentifierUseCode>,
    /// Description of identifier
    #[prost(message, optional, tag = "4")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// The namespace for the identifier value
    #[prost(message, optional, tag = "5")]
    pub system: ::core::option::Option<Uri>,
    /// The value that is unique
    #[prost(message, optional, tag = "6")]
    pub value: ::core::option::Option<String>,
    /// Time period when id is/was valid for use
    #[prost(message, optional, tag = "7")]
    pub period: ::core::option::Option<Period>,
    /// Organization that issued id (may be just text)
    #[prost(message, optional, boxed, tag = "8")]
    pub assigner: ::core::option::Option<prost::alloc::boxed::Box<Reference>>,
}
/// Auto-generated from StructureDefinition for Meta, last updated
/// 2017-04-19T07:44:43.294+10:00. Metadata about a resource. See
/// <http://hl7.org/fhir/StructureDefinition/Meta>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Meta {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Version specific identifier
    #[prost(message, optional, tag = "3")]
    pub version_id: ::core::option::Option<Id>,
    /// When the resource version last changed
    #[prost(message, optional, tag = "4")]
    pub last_updated: ::core::option::Option<Instant>,
    /// Profiles this resource claims to conform to
    #[prost(message, repeated, tag = "5")]
    pub profile: prost::alloc::vec::Vec<Uri>,
    /// Security Labels applied to this resource
    #[prost(message, repeated, tag = "6")]
    pub security: prost::alloc::vec::Vec<Coding>,
    /// Tags applied to this resource
    #[prost(message, repeated, tag = "7")]
    pub tag: prost::alloc::vec::Vec<Coding>,
}
/// Auto-generated from StructureDefinition for Money, last updated
/// 2017-04-19T07:44:43.294+10:00. An amount of economic utility in some
/// recognized currency. See <http://hl7.org/fhir/StructureDefinition/Money>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Money {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    /// < | <= | >= | > - how to understand the value
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<QuantityComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Auto-generated from StructureDefinition for Period, last updated
/// 2017-04-19T07:44:43.294+10:00. Time range defined by start and end date/time.
/// See <http://hl7.org/fhir/StructureDefinition/Period>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Period {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Starting time with inclusive boundary
    #[prost(message, optional, tag = "3")]
    pub start: ::core::option::Option<DateTime>,
    /// End time with inclusive boundary, if not ongoing
    #[prost(message, optional, tag = "4")]
    pub end: ::core::option::Option<DateTime>,
}
/// Auto-generated from StructureDefinition for Quantity, last updated
/// 2017-04-19T07:44:43.294+10:00. A measured or measurable amount. See
/// <http://hl7.org/fhir/StructureDefinition/Quantity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Quantity {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    /// < | <= | >= | > - how to understand the value
    #[prost(message, optional, tag = "4")]
    pub comparator: ::core::option::Option<QuantityComparatorCode>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Auto-generated from StructureDefinition for Range, last updated
/// 2017-04-19T07:44:43.294+10:00. Set of values bounded by low and high. See
/// <http://hl7.org/fhir/StructureDefinition/Range>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Range {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Low limit
    #[prost(message, optional, tag = "3")]
    pub low: ::core::option::Option<SimpleQuantity>,
    /// High limit
    #[prost(message, optional, tag = "4")]
    pub high: ::core::option::Option<SimpleQuantity>,
}
/// Auto-generated from StructureDefinition for Ratio, last updated
/// 2017-04-19T07:44:43.294+10:00. A ratio of two Quantity values - a numerator
/// and a denominator. See <http://hl7.org/fhir/StructureDefinition/Ratio>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Ratio {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerator value
    #[prost(message, optional, tag = "3")]
    pub numerator: ::core::option::Option<Quantity>,
    /// Denominator value
    #[prost(message, optional, tag = "4")]
    pub denominator: ::core::option::Option<Quantity>,
}
/// Auto-generated from StructureDefinition for SampledData, last updated
/// 2017-04-19T07:44:43.294+10:00. A series of measurements taken by a device.
/// See <http://hl7.org/fhir/StructureDefinition/SampledData>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SampledData {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Zero value and units
    #[prost(message, optional, tag = "3")]
    pub origin: ::core::option::Option<SimpleQuantity>,
    /// Number of milliseconds between samples
    #[prost(message, optional, tag = "4")]
    pub period: ::core::option::Option<Decimal>,
    /// Multiply data by this before adding to origin
    #[prost(message, optional, tag = "5")]
    pub factor: ::core::option::Option<Decimal>,
    /// Lower limit of detection
    #[prost(message, optional, tag = "6")]
    pub lower_limit: ::core::option::Option<Decimal>,
    /// Upper limit of detection
    #[prost(message, optional, tag = "7")]
    pub upper_limit: ::core::option::Option<Decimal>,
    /// Number of sample points at each time point
    #[prost(message, optional, tag = "8")]
    pub dimensions: ::core::option::Option<PositiveInt>,
    /// Decimal values with spaces, or "E" | "U" | "L"
    #[prost(message, optional, tag = "9")]
    pub data: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for Signature, last updated
/// 2017-04-19T07:44:43.294+10:00. A digital Signature - XML DigSig, JWT,
/// Graphical image of signature, etc. See
/// <http://hl7.org/fhir/StructureDefinition/Signature>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Signature {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Indication of the reason the entity signed the object(s)
    #[prost(message, repeated, tag = "3")]
    pub r#type: prost::alloc::vec::Vec<Coding>,
    /// When the signature was created
    #[prost(message, optional, tag = "4")]
    pub when: ::core::option::Option<Instant>,
    #[prost(message, optional, tag = "5")]
    pub who: ::core::option::Option<signature::Who>,
    #[prost(message, optional, tag = "6")]
    pub on_behalf_of: ::core::option::Option<signature::OnBehalfOf>,
    /// The technical format of the signature
    #[prost(message, optional, tag = "7")]
    pub content_type: ::core::option::Option<MimeTypeCode>,
    /// The actual signature content (XML DigSig. JWT, picture, etc.)
    #[prost(message, optional, tag = "8")]
    pub blob: ::core::option::Option<Base64Binary>,
}
/// Nested message and enum types in `Signature`.
pub mod signature {
    /// Who signed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Who {
        #[prost(oneof = "who::Who", tags = "1, 2")]
        pub who: ::core::option::Option<who::Who>,
    }
    /// Nested message and enum types in `Who`.
    pub mod who {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Who {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// The party represented
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OnBehalfOf {
        #[prost(oneof = "on_behalf_of::OnBehalfOf", tags = "1, 2")]
        pub on_behalf_of: ::core::option::Option<on_behalf_of::OnBehalfOf>,
    }
    /// Nested message and enum types in `OnBehalfOf`.
    pub mod on_behalf_of {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum OnBehalfOf {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for SimpleQuantity, last updated
/// 2017-04-19T07:44:43.294+10:00. A fixed quantity (no comparator). See
/// <http://hl7.org/fhir/StructureDefinition/SimpleQuantity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SimpleQuantity {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Numerical value (with implicit precision)
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Decimal>,
    /// Unit representation
    #[prost(message, optional, tag = "5")]
    pub unit: ::core::option::Option<String>,
    /// System that defines coded unit form
    #[prost(message, optional, tag = "6")]
    pub system: ::core::option::Option<Uri>,
    /// Coded form of the unit
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<Code>,
}
/// Auto-generated from StructureDefinition for Timing, last updated
/// 2017-04-19T07:44:43.294+10:00. A timing schedule that specifies an event that
/// may occur multiple times. See <http://hl7.org/fhir/StructureDefinition/Timing>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Timing {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// When the event occurs
    #[prost(message, repeated, tag = "3")]
    pub event: prost::alloc::vec::Vec<DateTime>,
    #[prost(message, optional, tag = "4")]
    pub repeat: ::core::option::Option<timing::Repeat>,
    /// BID | TID | QID | AM | PM | QD | QOD | Q4H | Q6H +
    #[prost(message, optional, tag = "5")]
    pub code: ::core::option::Option<CodeableConcept>,
}
/// Nested message and enum types in `Timing`.
pub mod timing {
    /// When the event is to occur
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Repeat {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "3")]
        pub bounds: ::core::option::Option<repeat::Bounds>,
        /// Number of times to repeat
        #[prost(message, optional, tag = "4")]
        pub count: ::core::option::Option<super::Integer>,
        /// Maximum number of times to repeat
        #[prost(message, optional, tag = "5")]
        pub count_max: ::core::option::Option<super::Integer>,
        /// How long when it happens
        #[prost(message, optional, tag = "6")]
        pub duration: ::core::option::Option<super::Decimal>,
        /// How long when it happens (Max)
        #[prost(message, optional, tag = "7")]
        pub duration_max: ::core::option::Option<super::Decimal>,
        /// s | min | h | d | wk | mo | a - unit of time (UCUM)
        #[prost(message, optional, tag = "8")]
        pub duration_unit: ::core::option::Option<super::UnitsOfTimeCode>,
        /// Event occurs frequency times per period
        #[prost(message, optional, tag = "9")]
        pub frequency: ::core::option::Option<super::Integer>,
        /// Event occurs up to frequencyMax times per period
        #[prost(message, optional, tag = "10")]
        pub frequency_max: ::core::option::Option<super::Integer>,
        /// Event occurs frequency times per period
        #[prost(message, optional, tag = "11")]
        pub period: ::core::option::Option<super::Decimal>,
        /// Upper limit of period (3-4 hours)
        #[prost(message, optional, tag = "12")]
        pub period_max: ::core::option::Option<super::Decimal>,
        /// s | min | h | d | wk | mo | a - unit of time (UCUM)
        #[prost(message, optional, tag = "13")]
        pub period_unit: ::core::option::Option<super::UnitsOfTimeCode>,
        /// mon | tue | wed | thu | fri | sat | sun
        #[prost(message, repeated, tag = "14")]
        pub day_of_week: prost::alloc::vec::Vec<super::DaysOfWeekCode>,
        /// Time of day for action
        #[prost(message, repeated, tag = "15")]
        pub time_of_day: prost::alloc::vec::Vec<super::Time>,
        /// Regular life events the event is tied to
        #[prost(message, repeated, tag = "16")]
        pub when: prost::alloc::vec::Vec<super::EventTimingCode>,
        /// Minutes from event (before or after)
        #[prost(message, optional, tag = "17")]
        pub offset: ::core::option::Option<super::UnsignedInt>,
    }
    /// Nested message and enum types in `Repeat`.
    pub mod repeat {
        /// Length/Range of lengths, or (Start and/or end) limits
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Bounds {
            #[prost(oneof = "bounds::Bounds", tags = "1, 2, 3")]
            pub bounds: ::core::option::Option<bounds::Bounds>,
        }
        /// Nested message and enum types in `Bounds`.
        pub mod bounds {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Bounds {
                #[prost(message, tag = "1")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
                #[prost(message, tag = "3")]
                Period(super::super::super::Period),
            }
        }
    }
}
// End of auto-generated messages.

/// Optional Extensions Element
/// See <https://www.hl7.org/fhir/datatypes.html#Extension>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Extension {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// identifies the meaning of the extension
    #[prost(message, optional, tag = "2")]
    pub url: ::core::option::Option<Uri>,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<extension::ValueX>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "4")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `Extension`.
pub mod extension {
    /// Value of extension
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValueX {
        #[prost(
            oneof = "value_x::Choice",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
        )]
        pub choice: ::core::option::Option<value_x::Choice>,
    }
    /// Nested message and enum types in `ValueX`.
    pub mod value_x {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Choice {
            #[prost(message, tag = "1")]
            Base64Binary(super::super::Base64Binary),
            #[prost(message, tag = "2")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "3")]
            Code(super::super::Code),
            #[prost(message, tag = "4")]
            Date(super::super::Date),
            #[prost(message, tag = "5")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "6")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "7")]
            Id(super::super::Id),
            #[prost(message, tag = "8")]
            Instant(super::super::Instant),
            #[prost(message, tag = "9")]
            Integer(super::super::Integer),
            #[prost(message, tag = "10")]
            Markdown(super::super::Markdown),
            #[prost(message, tag = "11")]
            Oid(super::super::Oid),
            #[prost(message, tag = "12")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "13")]
            StringValue(super::super::String),
            #[prost(message, tag = "14")]
            Time(super::super::Time),
            #[prost(message, tag = "15")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "16")]
            Uri(super::super::Uri),
            #[prost(message, tag = "17")]
            Address(super::super::Address),
            #[prost(message, tag = "18")]
            Age(super::super::Age),
            #[prost(message, tag = "19")]
            Annotation(super::super::Annotation),
            #[prost(message, tag = "20")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "21")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "22")]
            Coding(super::super::Coding),
            #[prost(message, tag = "23")]
            ContactPoint(super::super::ContactPoint),
            #[prost(message, tag = "24")]
            Count(super::super::Count),
            #[prost(message, tag = "25")]
            Distance(super::super::Distance),
            #[prost(message, tag = "26")]
            Duration(super::super::Duration),
            #[prost(message, tag = "27")]
            HumanName(super::super::HumanName),
            #[prost(message, tag = "28")]
            Identifier(super::super::Identifier),
            #[prost(message, tag = "29")]
            Money(super::super::Money),
            #[prost(message, tag = "30")]
            Period(super::super::Period),
            #[prost(message, tag = "31")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "32")]
            Range(super::super::Range),
            #[prost(message, tag = "33")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "34")]
            Reference(super::super::Reference),
            #[prost(message, tag = "35")]
            SampledData(super::super::SampledData),
            #[prost(message, tag = "36")]
            Signature(super::super::Signature),
            #[prost(message, tag = "37")]
            Timing(super::super::Timing),
            #[prost(message, tag = "38")]
            Meta(super::super::Meta),
        }
    }
}
// Specializations of Coding that make it nicer to have slices within
// CodeableConcepts.
// TODO: generate in ProtoGenerator from profiles on Coding.

/// Specialization of Coding that drops the system field.
/// Fields that use this message must be annotated with
/// fhir_inlined_coding_system.
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodingWithFixedSystem {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Version of the system - if relevant
    #[prost(message, optional, tag = "4")]
    pub version: ::core::option::Option<String>,
    /// Symbol in syntax defined by the system
    #[prost(message, optional, tag = "5")]
    pub code: ::core::option::Option<Code>,
    /// Representation defined by the system
    #[prost(message, optional, tag = "6")]
    pub display: ::core::option::Option<String>,
    /// If this coding was chosen directly by the user
    #[prost(message, optional, tag = "7")]
    pub user_selected: ::core::option::Option<Boolean>,
}
/// Specialization of Coding that drops the system and code fields.
/// Fields that use this message must be annotated with
/// fhir_inlined_coding_system and fhir_inlined_coding_code.
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodingWithFixedCode {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Version of the system - if relevant
    #[prost(message, optional, tag = "4")]
    pub version: ::core::option::Option<String>,
    /// Representation defined by the system
    #[prost(message, optional, tag = "6")]
    pub display: ::core::option::Option<String>,
    /// If this coding was chosen directly by the user
    #[prost(message, optional, tag = "7")]
    pub user_selected: ::core::option::Option<Boolean>,
}
/// A reference from one resource to another
/// See <https://www.hl7.org/fhir/datatypes.html#Reference>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Reference {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Logical reference, when literal reference is not known
    #[prost(message, optional, boxed, tag = "122")]
    pub identifier: ::core::option::Option<prost::alloc::boxed::Box<Identifier>>,
    /// Text alternative for the resource
    #[prost(message, optional, tag = "123")]
    pub display: ::core::option::Option<String>,
    /// Literal reference, Relative, internal or absolute URL
    #[prost(
        oneof = "reference::Reference",
        tags = "3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121"
    )]
    pub reference: ::core::option::Option<reference::Reference>,
}
/// Nested message and enum types in `Reference`.
pub mod reference {
    /// Literal reference, Relative, internal or absolute URL
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Oneof)]
    pub enum Reference {
        /// Absolute URIs are untyped.
        #[prost(message, tag = "3")]
        Uri(super::String),
        /// Fragments (internal references) are untyped, and represented here
        /// without the leading '#'.
        #[prost(message, tag = "4")]
        Fragment(super::String),
        /// Typed relative urls are represented here.
        #[prost(message, tag = "5")]
        AccountId(super::ReferenceId),
        #[prost(message, tag = "6")]
        ActivityDefinitionId(super::ReferenceId),
        #[prost(message, tag = "7")]
        AdverseEventId(super::ReferenceId),
        #[prost(message, tag = "8")]
        AllergyIntoleranceId(super::ReferenceId),
        #[prost(message, tag = "9")]
        AppointmentId(super::ReferenceId),
        #[prost(message, tag = "10")]
        AppointmentResponseId(super::ReferenceId),
        #[prost(message, tag = "11")]
        AuditEventId(super::ReferenceId),
        #[prost(message, tag = "12")]
        BasicId(super::ReferenceId),
        #[prost(message, tag = "13")]
        BinaryId(super::ReferenceId),
        #[prost(message, tag = "14")]
        BodySiteId(super::ReferenceId),
        #[prost(message, tag = "15")]
        BundleId(super::ReferenceId),
        #[prost(message, tag = "16")]
        CapabilityStatementId(super::ReferenceId),
        #[prost(message, tag = "17")]
        CarePlanId(super::ReferenceId),
        #[prost(message, tag = "18")]
        CareTeamId(super::ReferenceId),
        #[prost(message, tag = "19")]
        ChargeItemId(super::ReferenceId),
        #[prost(message, tag = "20")]
        ClaimId(super::ReferenceId),
        #[prost(message, tag = "21")]
        ClaimResponseId(super::ReferenceId),
        #[prost(message, tag = "22")]
        ClinicalImpressionId(super::ReferenceId),
        #[prost(message, tag = "23")]
        CodeSystemId(super::ReferenceId),
        #[prost(message, tag = "24")]
        CommunicationId(super::ReferenceId),
        #[prost(message, tag = "25")]
        CommunicationRequestId(super::ReferenceId),
        #[prost(message, tag = "26")]
        CompartmentDefinitionId(super::ReferenceId),
        #[prost(message, tag = "27")]
        CompositionId(super::ReferenceId),
        #[prost(message, tag = "28")]
        ConceptMapId(super::ReferenceId),
        #[prost(message, tag = "29")]
        ConditionId(super::ReferenceId),
        #[prost(message, tag = "30")]
        ConsentId(super::ReferenceId),
        #[prost(message, tag = "31")]
        ContractId(super::ReferenceId),
        #[prost(message, tag = "32")]
        CoverageId(super::ReferenceId),
        #[prost(message, tag = "33")]
        DataElementId(super::ReferenceId),
        #[prost(message, tag = "34")]
        DetectedIssueId(super::ReferenceId),
        #[prost(message, tag = "35")]
        DeviceId(super::ReferenceId),
        #[prost(message, tag = "36")]
        DeviceComponentId(super::ReferenceId),
        #[prost(message, tag = "37")]
        DeviceMetricId(super::ReferenceId),
        #[prost(message, tag = "38")]
        DeviceRequestId(super::ReferenceId),
        #[prost(message, tag = "39")]
        DeviceUseStatementId(super::ReferenceId),
        #[prost(message, tag = "40")]
        DiagnosticReportId(super::ReferenceId),
        #[prost(message, tag = "41")]
        DocumentManifestId(super::ReferenceId),
        #[prost(message, tag = "42")]
        DocumentReferenceId(super::ReferenceId),
        #[prost(message, tag = "43")]
        EligibilityRequestId(super::ReferenceId),
        #[prost(message, tag = "44")]
        EligibilityResponseId(super::ReferenceId),
        #[prost(message, tag = "45")]
        EncounterId(super::ReferenceId),
        #[prost(message, tag = "46")]
        EndpointId(super::ReferenceId),
        #[prost(message, tag = "47")]
        EnrollmentRequestId(super::ReferenceId),
        #[prost(message, tag = "48")]
        EnrollmentResponseId(super::ReferenceId),
        #[prost(message, tag = "49")]
        EpisodeOfCareId(super::ReferenceId),
        #[prost(message, tag = "50")]
        ExpansionProfileId(super::ReferenceId),
        #[prost(message, tag = "51")]
        ExplanationOfBenefitId(super::ReferenceId),
        #[prost(message, tag = "52")]
        FamilyMemberHistoryId(super::ReferenceId),
        #[prost(message, tag = "53")]
        FlagId(super::ReferenceId),
        #[prost(message, tag = "54")]
        GoalId(super::ReferenceId),
        #[prost(message, tag = "55")]
        GraphDefinitionId(super::ReferenceId),
        #[prost(message, tag = "56")]
        GroupId(super::ReferenceId),
        #[prost(message, tag = "57")]
        GuidanceResponseId(super::ReferenceId),
        #[prost(message, tag = "58")]
        HealthcareServiceId(super::ReferenceId),
        #[prost(message, tag = "59")]
        ImagingManifestId(super::ReferenceId),
        #[prost(message, tag = "60")]
        ImagingStudyId(super::ReferenceId),
        #[prost(message, tag = "61")]
        ImmunizationId(super::ReferenceId),
        #[prost(message, tag = "62")]
        ImmunizationRecommendationId(super::ReferenceId),
        #[prost(message, tag = "63")]
        ImplementationGuideId(super::ReferenceId),
        #[prost(message, tag = "64")]
        LibraryId(super::ReferenceId),
        #[prost(message, tag = "65")]
        LinkageId(super::ReferenceId),
        #[prost(message, tag = "66")]
        ListId(super::ReferenceId),
        #[prost(message, tag = "67")]
        LocationId(super::ReferenceId),
        #[prost(message, tag = "68")]
        MeasureId(super::ReferenceId),
        #[prost(message, tag = "69")]
        MeasureReportId(super::ReferenceId),
        #[prost(message, tag = "70")]
        MediaId(super::ReferenceId),
        #[prost(message, tag = "71")]
        MedicationId(super::ReferenceId),
        #[prost(message, tag = "72")]
        MedicationAdministrationId(super::ReferenceId),
        #[prost(message, tag = "73")]
        MedicationDispenseId(super::ReferenceId),
        #[prost(message, tag = "74")]
        MedicationRequestId(super::ReferenceId),
        #[prost(message, tag = "75")]
        MedicationStatementId(super::ReferenceId),
        #[prost(message, tag = "76")]
        MessageDefinitionId(super::ReferenceId),
        #[prost(message, tag = "77")]
        MessageHeaderId(super::ReferenceId),
        #[prost(message, tag = "78")]
        NamingSystemId(super::ReferenceId),
        #[prost(message, tag = "79")]
        NutritionOrderId(super::ReferenceId),
        #[prost(message, tag = "80")]
        ObservationId(super::ReferenceId),
        #[prost(message, tag = "81")]
        OperationDefinitionId(super::ReferenceId),
        #[prost(message, tag = "82")]
        OperationOutcomeId(super::ReferenceId),
        #[prost(message, tag = "83")]
        OrganizationId(super::ReferenceId),
        #[prost(message, tag = "84")]
        ParametersId(super::ReferenceId),
        #[prost(message, tag = "85")]
        PatientId(super::ReferenceId),
        #[prost(message, tag = "86")]
        PaymentNoticeId(super::ReferenceId),
        #[prost(message, tag = "87")]
        PaymentReconciliationId(super::ReferenceId),
        #[prost(message, tag = "88")]
        PersonId(super::ReferenceId),
        #[prost(message, tag = "89")]
        PlanDefinitionId(super::ReferenceId),
        #[prost(message, tag = "90")]
        PractitionerId(super::ReferenceId),
        #[prost(message, tag = "91")]
        PractitionerRoleId(super::ReferenceId),
        #[prost(message, tag = "92")]
        ProcedureId(super::ReferenceId),
        #[prost(message, tag = "93")]
        ProcedureRequestId(super::ReferenceId),
        #[prost(message, tag = "94")]
        ProcessRequestId(super::ReferenceId),
        #[prost(message, tag = "95")]
        ProcessResponseId(super::ReferenceId),
        #[prost(message, tag = "96")]
        ProvenanceId(super::ReferenceId),
        #[prost(message, tag = "97")]
        QuestionnaireId(super::ReferenceId),
        #[prost(message, tag = "98")]
        QuestionnaireResponseId(super::ReferenceId),
        #[prost(message, tag = "99")]
        ReferralRequestId(super::ReferenceId),
        #[prost(message, tag = "100")]
        RelatedPersonId(super::ReferenceId),
        #[prost(message, tag = "101")]
        RequestGroupId(super::ReferenceId),
        #[prost(message, tag = "102")]
        ResearchStudyId(super::ReferenceId),
        #[prost(message, tag = "103")]
        ResearchSubjectId(super::ReferenceId),
        #[prost(message, tag = "104")]
        RiskAssessmentId(super::ReferenceId),
        #[prost(message, tag = "105")]
        ScheduleId(super::ReferenceId),
        #[prost(message, tag = "106")]
        SearchParameterId(super::ReferenceId),
        #[prost(message, tag = "107")]
        SequenceId(super::ReferenceId),
        #[prost(message, tag = "108")]
        ServiceDefinitionId(super::ReferenceId),
        #[prost(message, tag = "109")]
        SlotId(super::ReferenceId),
        #[prost(message, tag = "110")]
        SpecimenId(super::ReferenceId),
        #[prost(message, tag = "111")]
        StructureDefinitionId(super::ReferenceId),
        #[prost(message, tag = "112")]
        StructureMapId(super::ReferenceId),
        #[prost(message, tag = "113")]
        SubscriptionId(super::ReferenceId),
        #[prost(message, tag = "114")]
        SubstanceId(super::ReferenceId),
        #[prost(message, tag = "115")]
        SupplyDeliveryId(super::ReferenceId),
        #[prost(message, tag = "116")]
        SupplyRequestId(super::ReferenceId),
        #[prost(message, tag = "117")]
        TaskId(super::ReferenceId),
        #[prost(message, tag = "118")]
        TestReportId(super::ReferenceId),
        #[prost(message, tag = "119")]
        TestScriptId(super::ReferenceId),
        #[prost(message, tag = "120")]
        ValueSetId(super::ReferenceId),
        #[prost(message, tag = "121")]
        VisionPrescriptionId(super::ReferenceId),
    }
}
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReferenceId {
    /// Primitive value for id
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// History version, if present.
    #[prost(message, optional, tag = "2")]
    pub history: ::core::option::Option<Id>,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "3")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "4")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
// Code specializations with required valueset bindings, used by messages
// defined in this file. The majority of the code specializations are defined
// in other files, but these need to be here for technical reasons.

/// The type of an address (physical / postal)
/// See <http://hl7.org/fhir/ValueSet/address-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressTypeCode {
    #[prost(enumeration = "address_type_code::Value", tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AddressTypeCode`.
pub mod address_type_code {
    /// Primitive value for code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Postal = 1,
        Physical = 2,
        Both = 3,
    }
}
/// The use of an address
/// See <http://hl7.org/fhir/ValueSet/address-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AddressUseCode {
    #[prost(enumeration = "address_use_code::Value", tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AddressUseCode`.
pub mod address_use_code {
    /// Primitive value for code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Home = 1,
        Work = 2,
        Temp = 3,
        Old = 4,
    }
}
/// Telecommunications form for contact point
/// See <http://hl7.org/fhir/ValueSet/contact-point-system>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPointSystemCode {
    #[prost(enumeration = "contact_point_system_code::Value", tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ContactPointSystemCode`.
pub mod contact_point_system_code {
    /// Primitive value for code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Phone = 1,
        Fax = 2,
        Email = 3,
        Pager = 4,
        Url = 5,
        Sms = 6,
        Other = 7,
    }
}
/// Use of contact point
/// See <http://hl7.org/fhir/ValueSet/contact-point-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactPointUseCode {
    #[prost(enumeration = "contact_point_use_code::Value", tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ContactPointUseCode`.
pub mod contact_point_use_code {
    /// Primitive value for code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Home = 1,
        Work = 2,
        Temp = 3,
        Old = 4,
        Mobile = 5,
    }
}
/// The days of the week.
/// See <http://hl7.org/fhir/ValueSet/days-of-week>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DaysOfWeekCode {
    #[prost(enumeration = "days_of_week_code::Value", tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DaysOfWeekCode`.
pub mod days_of_week_code {
    /// Primitive value for code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Mon = 1,
        Tue = 2,
        Wed = 3,
        Thu = 4,
        Fri = 5,
        Sat = 6,
        Sun = 7,
    }
}
/// Real world event relating to the schedule.
/// See <http://hl7.org/fhir/ValueSet/event-timing>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EventTimingCode {
    #[prost(enumeration = "event_timing_code::Value", tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EventTimingCode`.
pub mod event_timing_code {
    /// Primitive value for code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Morn = 1,
        Aft = 2,
        Eve = 3,
        Night = 4,
        Phs = 5,
        Hs = 6,
        Wake = 7,
        C = 8,
        Cm = 9,
        Cd = 10,
        Cv = 11,
        Ac = 12,
        Acm = 13,
        Acd = 14,
        Acv = 15,
        Pc = 16,
        Pcm = 17,
        Pcd = 18,
        Pcv = 19,
    }
}
/// Identifies the purpose for this identifier, if known .
/// See <http://hl7.org/fhir/ValueSet/identifier-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct IdentifierUseCode {
    #[prost(enumeration = "identifier_use_code::Value", tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `IdentifierUseCode`.
pub mod identifier_use_code {
    /// Primitive value for code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Usual = 1,
        Official = 2,
        Temp = 3,
        Secondary = 4,
    }
}
/// This value set includes all possible codes from BCP-47
/// (<http://tools.ietf.org/html/bcp47>)
/// See <http://hl7.org/fhir/ValueSet/all-languages>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllLanguageCode {
    /// Primitive value for code
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// This value set includes common codes from BCP-47
/// (<http://tools.ietf.org/html/bcp47>)
/// See <http://hl7.org/fhir/ValueSet/languages>
/// Note: For historical reasons, this does not use an enum to represent value.
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LanguageCode {
    /// Primitive value for code
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Any valid MimeType.
/// See <http://www.rfc-editor.org/bcp/bcp13.txt>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MimeTypeCode {
    /// Primitive value for code
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// The use of a human name
/// See <http://hl7.org/fhir/ValueSet/name-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NameUseCode {
    #[prost(enumeration = "name_use_code::Value", tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `NameUseCode`.
pub mod name_use_code {
    /// Primitive value for code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Usual = 1,
        Official = 2,
        Temp = 3,
        Nickname = 4,
        Anonymous = 5,
        Old = 6,
        Maiden = 7,
    }
}
/// How the Quantity should be understood and represented.
/// See <http://hl7.org/fhir/ValueSet/quantity-comparator>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuantityComparatorCode {
    #[prost(enumeration = "quantity_comparator_code::Value", tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `QuantityComparatorCode`.
pub mod quantity_comparator_code {
    /// Primitive value for code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Lt = 1,
        Le = 2,
        Ge = 3,
        Gt = 4,
    }
}
/// A unit of time (units from UCUM). See
/// <http://hl7.org/fhir/ValueSet/units-of-time>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UnitsOfTimeCode {
    #[prost(enumeration = "units_of_time_code::Value", tag = "1")]
    pub value: i32,
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `UnitsOfTimeCode`.
pub mod units_of_time_code {
    /// Primitive value for code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        S = 1,
        Min = 2,
        H = 3,
        D = 4,
        Wk = 5,
        Mo = 6,
        A = 7,
    }
}
/// A type defined by FHIR that is an abstract type
/// See <http://hl7.org/fhir/ValueSet/abstract-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AbstractTypeCode {
    #[prost(enumeration = "abstract_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AbstractTypeCode`.
pub mod abstract_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Type = 1,
        Any = 2,
    }
}
/// How resource references can be aggregated.
/// See <http://hl7.org/fhir/ValueSet/resource-aggregation-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AggregationModeCode {
    #[prost(enumeration = "aggregation_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AggregationModeCode`.
pub mod aggregation_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Contained = 1,
        Referenced = 2,
        Bundled = 3,
    }
}
/// Indication of the degree of conformance expectations associated with a
/// binding. See <http://hl7.org/fhir/ValueSet/binding-strength>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BindingStrengthCode {
    #[prost(enumeration = "binding_strength_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `BindingStrengthCode`.
pub mod binding_strength_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Required = 1,
        Extensible = 2,
        Preferred = 3,
        Example = 4,
    }
}
/// SHALL applications comply with this constraint?
/// See <http://hl7.org/fhir/ValueSet/constraint-severity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConstraintSeverityCode {
    #[prost(enumeration = "constraint_severity_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConstraintSeverityCode`.
pub mod constraint_severity_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Error = 1,
        Warning = 2,
    }
}
/// How slices are interpreted when evaluating an instance.
/// See <http://hl7.org/fhir/ValueSet/resource-slicing-rules>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SlicingRulesCode {
    #[prost(enumeration = "slicing_rules_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SlicingRulesCode`.
pub mod slicing_rules_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Closed = 1,
        Open = 2,
        OpenAtEnd = 3,
    }
}
/// How an element value is interpreted when discrimination is evaluated
/// See <http://hl7.org/fhir/ValueSet/discriminator-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiscriminatorTypeCode {
    #[prost(enumeration = "discriminator_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DiscriminatorTypeCode`.
pub mod discriminator_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Value = 1,
        Exists = 2,
        Pattern = 3,
        Type = 4,
        Profile = 5,
    }
}
/// How a property is represented when serialized.
/// See <http://hl7.org/fhir/ValueSet/property-representation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PropertyRepresentationCode {
    #[prost(enumeration = "property_representation_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `PropertyRepresentationCode`.
pub mod property_representation_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        XmlAttr = 1,
        XmlText = 2,
        TypeAttr = 3,
        CdaText = 4,
        Xhtml = 5,
    }
}
/// Whether a reference needs to be version specific or version independent, or
/// whether either can be used See
/// <http://hl7.org/fhir/ValueSet/reference-version-rules>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReferenceVersionRulesCode {
    #[prost(enumeration = "reference_version_rules_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ReferenceVersionRulesCode`.
pub mod reference_version_rules_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Either = 1,
        Independent = 2,
        Specific = 3,
    }
}
/// Indicates whether the account is available to be used.
/// See <http://hl7.org/fhir/ValueSet/account-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AccountStatusCode {
    #[prost(enumeration = "account_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AccountStatusCode`.
pub mod account_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
    }
}
/// Defines behavior for an action or a group for how many times that item may
/// be repeated See <http://hl7.org/fhir/ValueSet/action-cardinality-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionCardinalityBehaviorCode {
    #[prost(enumeration = "action_cardinality_behavior_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActionCardinalityBehaviorCode`.
pub mod action_cardinality_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Single = 1,
        Multiple = 2,
    }
}
/// Defines the kinds of conditions that can appear on actions
/// See <http://hl7.org/fhir/ValueSet/action-condition-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionConditionKindCode {
    #[prost(enumeration = "action_condition_kind_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActionConditionKindCode`.
pub mod action_condition_kind_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Applicability = 1,
        Start = 2,
        Stop = 3,
    }
}
/// Defines organization behavior of a group
/// See <http://hl7.org/fhir/ValueSet/action-grouping-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionGroupingBehaviorCode {
    #[prost(enumeration = "action_grouping_behavior_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActionGroupingBehaviorCode`.
pub mod action_grouping_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        VisualGroup = 1,
        LogicalGroup = 2,
        SentenceGroup = 3,
    }
}
/// List of allowable action which this resource can request.
/// See <http://hl7.org/fhir/ValueSet/actionlist>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionListCode {
    #[prost(enumeration = "action_list_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActionListCode`.
pub mod action_list_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Cancel = 1,
        Poll = 2,
        Reprocess = 3,
        Status = 4,
    }
}
/// The type of participant for the action
/// See <http://hl7.org/fhir/ValueSet/action-participant-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionParticipantTypeCode {
    #[prost(enumeration = "action_participant_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActionParticipantTypeCode`.
pub mod action_participant_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Patient = 1,
        Practitioner = 2,
        RelatedPerson = 3,
    }
}
/// Defines selection frequency behavior for an action or group
/// See <http://hl7.org/fhir/ValueSet/action-precheck-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionPrecheckBehaviorCode {
    #[prost(enumeration = "action_precheck_behavior_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActionPrecheckBehaviorCode`.
pub mod action_precheck_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Yes = 1,
        No = 2,
    }
}
/// Defines the types of relationships between actions
/// See <http://hl7.org/fhir/ValueSet/action-relationship-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionRelationshipTypeCode {
    #[prost(enumeration = "action_relationship_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActionRelationshipTypeCode`.
pub mod action_relationship_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        BeforeStart = 1,
        Before = 2,
        BeforeEnd = 3,
        ConcurrentWithStart = 4,
        Concurrent = 5,
        ConcurrentWithEnd = 6,
        AfterStart = 7,
        After = 8,
        AfterEnd = 9,
    }
}
/// Defines requiredness behavior for selecting an action or an action group
/// See <http://hl7.org/fhir/ValueSet/action-required-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionRequiredBehaviorCode {
    #[prost(enumeration = "action_required_behavior_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActionRequiredBehaviorCode`.
pub mod action_required_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Must = 1,
        Could = 2,
        MustUnlessDocumented = 3,
    }
}
/// Defines selection behavior of a group
/// See <http://hl7.org/fhir/ValueSet/action-selection-behavior>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionSelectionBehaviorCode {
    #[prost(enumeration = "action_selection_behavior_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActionSelectionBehaviorCode`.
pub mod action_selection_behavior_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Any = 1,
        All = 2,
        AllOrNone = 3,
        ExactlyOne = 4,
        AtMostOne = 5,
        OneOrMore = 6,
    }
}
/// The type of action to be performed
/// See <http://hl7.org/fhir/ValueSet/action-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActionTypeCode {
    #[prost(enumeration = "action_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActionTypeCode`.
pub mod action_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Create = 1,
        Update = 2,
        Remove = 3,
        FireEvent = 4,
    }
}
/// High-level categorization of the type of activity
/// See <http://hl7.org/fhir/ValueSet/activity-definition-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActivityDefinitionCategoryCode {
    #[prost(enumeration = "activity_definition_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ActivityDefinitionCategoryCode`.
pub mod activity_definition_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Treatment = 1,
        Education = 2,
        Assessment = 3,
    }
}
/// The gender of a person used for administrative purposes.
/// See <http://hl7.org/fhir/ValueSet/administrative-gender>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdministrativeGenderCode {
    #[prost(enumeration = "administrative_gender_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AdministrativeGenderCode`.
pub mod administrative_gender_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Male = 1,
        Female = 2,
        Other = 3,
        Unknown = 4,
    }
}
/// Overall categorization of the event, e.g. real or potential
/// See <http://hl7.org/fhir/ValueSet/adverse-event-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEventCategoryCode {
    #[prost(enumeration = "adverse_event_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AdverseEventCategoryCode`.
pub mod adverse_event_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ae = 1,
        Pae = 2,
    }
}
/// TODO
/// See <http://hl7.org/fhir/ValueSet/adverse-event-causality-assess>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEventCausalityAssessmentCode {
    #[prost(
        enumeration = "adverse_event_causality_assessment_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AdverseEventCausalityAssessmentCode`.
pub mod adverse_event_causality_assessment_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Assess1 = 1,
        Assess2 = 2,
    }
}
/// TODO
/// See <http://hl7.org/fhir/ValueSet/adverse-event-causality>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEventCausalityCode {
    #[prost(enumeration = "adverse_event_causality_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AdverseEventCausalityCode`.
pub mod adverse_event_causality_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Causality1 = 1,
        Causality2 = 2,
    }
}
/// TODO
/// See <http://hl7.org/fhir/ValueSet/adverse-event-causality-method>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEventCausalityMethodCode {
    #[prost(enumeration = "adverse_event_causality_method_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AdverseEventCausalityMethodCode`.
pub mod adverse_event_causality_method_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Method1 = 1,
        Method2 = 2,
    }
}
/// TODO
/// See <http://hl7.org/fhir/ValueSet/adverse-event-causality-result>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEventCausalityResultCode {
    #[prost(enumeration = "adverse_event_causality_result_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AdverseEventCausalityResultCode`.
pub mod adverse_event_causality_result_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Result1 = 1,
        Result2 = 2,
    }
}
/// TODO (and should this be required?)
/// See <http://hl7.org/fhir/ValueSet/adverse-event-outcome>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEventOutcomeCode {
    #[prost(enumeration = "adverse_event_outcome_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AdverseEventOutcomeCode`.
pub mod adverse_event_outcome_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Resolved = 1,
        Recovering = 2,
        Ongoing = 3,
        Resolvedwithsequelae = 4,
        Fatal = 5,
        Unknown = 6,
    }
}
/// Overall seriousness of this event for the patient
/// See <http://hl7.org/fhir/ValueSet/adverse-event-seriousness>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEventSeriousnessCode {
    #[prost(enumeration = "adverse_event_seriousness_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AdverseEventSeriousnessCode`.
pub mod adverse_event_seriousness_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Mild = 1,
        Moderate = 2,
        Severe = 3,
    }
}
/// The risk of an adverse reaction (allergy or intolerance) for this patient
/// upon exposure to the substance (including pharmaceutical products). See
/// <http://hl7.org/fhir/ValueSet/allerg-intol-substance-exp-risk>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceSubstanceExposureRiskCode {
    #[prost(
        enumeration = "allergy_intolerance_substance_exposure_risk_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AllergyIntoleranceSubstanceExposureRiskCode`.
pub mod allergy_intolerance_substance_exposure_risk_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        KnownReactionRisk = 1,
        NoKnownReactionRisk = 2,
    }
}
/// The clinical status of the allergy or intolerance.
/// See <http://hl7.org/fhir/ValueSet/allergy-clinical-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceClinicalStatusCode {
    #[prost(
        enumeration = "allergy_intolerance_clinical_status_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AllergyIntoleranceClinicalStatusCode`.
pub mod allergy_intolerance_clinical_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        Resolved = 3,
    }
}
/// Category of an identified substance.
/// See <http://hl7.org/fhir/ValueSet/allergy-intolerance-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceCategoryCode {
    #[prost(enumeration = "allergy_intolerance_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AllergyIntoleranceCategoryCode`.
pub mod allergy_intolerance_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Food = 1,
        Medication = 2,
        Environment = 3,
        Biologic = 4,
    }
}
/// Estimate of the potential clinical harm, or seriousness, of a reaction to
/// an identified substance. See
/// <http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceCriticalityCode {
    #[prost(enumeration = "allergy_intolerance_criticality_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AllergyIntoleranceCriticalityCode`.
pub mod allergy_intolerance_criticality_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Low = 1,
        High = 2,
        UnableToAssess = 3,
    }
}
/// Identification of the underlying physiological mechanism for a Reaction
/// Risk. See <http://hl7.org/fhir/ValueSet/allergy-intolerance-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceTypeCode {
    #[prost(enumeration = "allergy_intolerance_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AllergyIntoleranceTypeCode`.
pub mod allergy_intolerance_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Allergy = 1,
        Intolerance = 2,
    }
}
/// Assertion about certainty associated with a propensity, or potential risk,
/// of a reaction to the identified substance. See
/// <http://hl7.org/fhir/ValueSet/allergy-verification-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceVerificationStatusCode {
    #[prost(
        enumeration = "allergy_intolerance_verification_status_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AllergyIntoleranceVerificationStatusCode`.
pub mod allergy_intolerance_verification_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unconfirmed = 1,
        Confirmed = 2,
        Refuted = 3,
        EnteredInError = 4,
    }
}
/// This example value set defines a set of codes that can be used to indicate
/// the current state of the animal's reproductive organs. See
/// <http://hl7.org/fhir/ValueSet/animal-genderstatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GenderStatusCode {
    #[prost(enumeration = "gender_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GenderStatusCode`.
pub mod gender_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Neutered = 1,
        Intact = 2,
        Unknown = 3,
    }
}
/// The free/busy status of an appointment.
/// See <http://hl7.org/fhir/ValueSet/appointmentstatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AppointmentStatusCode {
    #[prost(enumeration = "appointment_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AppointmentStatusCode`.
pub mod appointment_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposed = 1,
        Pending = 2,
        Booked = 3,
        Arrived = 4,
        Fulfilled = 5,
        Cancelled = 6,
        Noshow = 7,
        EnteredInError = 8,
    }
}
/// The type of direction to use for assertion.
/// See <http://hl7.org/fhir/ValueSet/assert-direction-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AssertionDirectionTypeCode {
    #[prost(enumeration = "assertion_direction_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AssertionDirectionTypeCode`.
pub mod assertion_direction_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Response = 1,
        Request = 2,
    }
}
/// The type of operator to use for assertion.
/// See <http://hl7.org/fhir/ValueSet/assert-operator-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AssertionOperatorTypeCode {
    #[prost(enumeration = "assertion_operator_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AssertionOperatorTypeCode`.
pub mod assertion_operator_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Equals = 1,
        Notequals = 2,
        In = 3,
        Notin = 4,
        Greaterthan = 5,
        Lessthan = 6,
        Empty = 7,
        Notempty = 8,
        Contains = 9,
        Notcontains = 10,
        Eval = 11,
    }
}
/// The type of response code to use for assertion.
/// See <http://hl7.org/fhir/ValueSet/assert-response-code-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AssertionResponseTypesCode {
    #[prost(enumeration = "assertion_response_types_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AssertionResponseTypesCode`.
pub mod assertion_response_types_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Okay = 1,
        Created = 2,
        Nocontent = 3,
        Notmodified = 4,
        Bad = 5,
        Forbidden = 6,
        Notfound = 7,
        Methodnotallowed = 8,
        Conflict = 9,
        Gone = 10,
        Preconditionfailed = 11,
        Unprocessable = 12,
    }
}
/// Indicator for type of action performed during the event that generated the
/// event See <http://hl7.org/fhir/ValueSet/audit-event-action>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventActionCode {
    #[prost(enumeration = "audit_event_action_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AuditEventActionCode`.
pub mod audit_event_action_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        C = 1,
        R = 2,
        U = 3,
        D = 4,
        E = 5,
    }
}
/// Indicates whether the event succeeded or failed
/// See <http://hl7.org/fhir/ValueSet/audit-event-outcome>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventOutcomeCode {
    #[prost(enumeration = "audit_event_outcome_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AuditEventOutcomeCode`.
pub mod audit_event_outcome_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Success = 1,
        MinorFailure = 2,
        SeriousFailure = 3,
        MajorFailure = 4,
    }
}
/// This value set defines codes for resources not yet supported by (or which
/// will never be supported by) FHIR.  Many of the codes listed here will
/// eventually be turned into official resources.  However, there is no
/// guarantee that any particular resource will be created nor that the scope
/// will be exactly as defined by the codes presented here.  Codes in this set
/// will be deprecated if/when formal resources are defined that encompass
/// these concepts. See <http://hl7.org/fhir/ValueSet/basic-resource-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BasicResourceTypesCode {
    #[prost(enumeration = "basic_resource_types_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `BasicResourceTypesCode`.
pub mod basic_resource_types_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Consent = 1,
        Referral = 2,
        Advevent = 3,
        Aptmtreq = 4,
        Transfer = 5,
        Diet = 6,
        Adminact = 7,
        Exposure = 8,
        Investigation = 9,
        Account = 10,
        Invoice = 11,
        Adjudicat = 12,
        Predetreq = 13,
        Predetermine = 14,
        Study = 15,
        Protocol = 16,
    }
}
/// Indicates the purpose of a bundle - how it was intended to be used.
/// See <http://hl7.org/fhir/ValueSet/bundle-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BundleTypeCode {
    #[prost(enumeration = "bundle_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `BundleTypeCode`.
pub mod bundle_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Document = 1,
        Message = 2,
        Transaction = 3,
        TransactionResponse = 4,
        Batch = 5,
        BatchResponse = 6,
        History = 7,
        Searchset = 8,
        Collection = 9,
    }
}
/// How a capability statement is intended to be used.
/// See <http://hl7.org/fhir/ValueSet/capability-statement-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatementKindCode {
    #[prost(enumeration = "capability_statement_kind_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CapabilityStatementKindCode`.
pub mod capability_statement_kind_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Instance = 1,
        Capability = 2,
        Requirements = 3,
    }
}
/// High-level categorization of the type of activity in a care plan.
/// See <http://hl7.org/fhir/ValueSet/care-plan-activity-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CarePlanActivityCategoryCode {
    #[prost(enumeration = "care_plan_activity_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CarePlanActivityCategoryCode`.
pub mod care_plan_activity_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Diet = 1,
        Drug = 2,
        Encounter = 3,
        Observation = 4,
        Procedure = 5,
        Supply = 6,
        Other = 7,
    }
}
/// Indicates where the activity is at in its overall life cycle.
/// See <http://hl7.org/fhir/ValueSet/care-plan-activity-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CarePlanActivityStatusCode {
    #[prost(enumeration = "care_plan_activity_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CarePlanActivityStatusCode`.
pub mod care_plan_activity_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotStarted = 1,
        Scheduled = 2,
        InProgress = 3,
        OnHold = 4,
        Completed = 5,
        Cancelled = 6,
        Unknown = 7,
    }
}
/// Codes indicating the degree of authority/intentionality associated with a
/// care plan See <http://hl7.org/fhir/ValueSet/care-plan-intent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CarePlanIntentCode {
    #[prost(enumeration = "care_plan_intent_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CarePlanIntentCode`.
pub mod care_plan_intent_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposal = 1,
        Plan = 2,
        Order = 3,
        Option = 4,
    }
}
/// Indicates whether the plan is currently being acted upon, represents future
/// intentions or is now a historical record. See
/// <http://hl7.org/fhir/ValueSet/care-plan-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CarePlanStatusCode {
    #[prost(enumeration = "care_plan_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CarePlanStatusCode`.
pub mod care_plan_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Active = 2,
        Suspended = 3,
        Completed = 4,
        EnteredInError = 5,
        Cancelled = 6,
        Unknown = 7,
    }
}
/// Indicates the type of care team.
/// See <http://hl7.org/fhir/ValueSet/care-team-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CareTeamCategoryCode {
    #[prost(enumeration = "care_team_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CareTeamCategoryCode`.
pub mod care_team_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Event = 1,
        Encounter = 2,
        Episode = 3,
        Longitudinal = 4,
        Condition = 5,
        ClinicalResearch = 6,
    }
}
/// Indicates the status of the care team.
/// See <http://hl7.org/fhir/ValueSet/care-team-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CareTeamStatusCode {
    #[prost(enumeration = "care_team_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CareTeamStatusCode`.
pub mod care_team_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposed = 1,
        Active = 2,
        Suspended = 3,
        Inactive = 4,
        EnteredInError = 5,
    }
}
/// Codes identifying the stage lifecycle stage of a ChargeItem
/// See <http://hl7.org/fhir/ValueSet/chargeitem-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ChargeItemStatusCode {
    #[prost(enumeration = "charge_item_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ChargeItemStatusCode`.
pub mod charge_item_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Planned = 1,
        Billable = 2,
        NotBillable = 3,
        Aborted = 4,
        Billed = 5,
        EnteredInError = 6,
        Unknown = 7,
    }
}
/// Direction in which lists of question options should be displayed
/// See <http://hl7.org/fhir/ValueSet/choice-list-orientation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ChoiceListOrientationCode {
    #[prost(enumeration = "choice_list_orientation_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ChoiceListOrientationCode`.
pub mod choice_list_orientation_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Horizontal = 1,
        Vertical = 2,
    }
}
/// Complete, proposed, exploratory, other
/// See <http://hl7.org/fhir/ValueSet/claim-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UseCode {
    #[prost(enumeration = "use_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `UseCode`.
pub mod use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Complete = 1,
        Proposed = 2,
        Exploratory = 3,
        Other = 4,
    }
}
/// Identifies whether a useContext represents a context or classification for
/// the element See <http://hl7.org/fhir/ValueSet/classification-or-context>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ClassificationOrContextCode {
    #[prost(enumeration = "classification_or_context_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ClassificationOrContextCode`.
pub mod classification_or_context_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Classification = 1,
        Context = 2,
    }
}
/// The workflow state of a clinical impression.
/// See <http://hl7.org/fhir/ValueSet/clinical-impression-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ClinicalImpressionStatusCode {
    #[prost(enumeration = "clinical_impression_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ClinicalImpressionStatusCode`.
pub mod clinical_impression_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Completed = 2,
        EnteredInError = 3,
    }
}
/// How much of the content of the code system - the concepts and codes it
/// defines - are represented in a code system resource See
/// <http://hl7.org/fhir/ValueSet/codesystem-content-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemContentModeCode {
    #[prost(enumeration = "code_system_content_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CodeSystemContentModeCode`.
pub mod code_system_content_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotPresent = 1,
        Example = 2,
        Fragment = 3,
        Complete = 4,
    }
}
/// The meaning of the hierarchy of concepts in a code system
/// See <http://hl7.org/fhir/ValueSet/codesystem-hierarchy-meaning>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystemHierarchyMeaningCode {
    #[prost(enumeration = "code_system_hierarchy_meaning_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CodeSystemHierarchyMeaningCode`.
pub mod code_system_hierarchy_meaning_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        GroupedBy = 1,
        IsA = 2,
        PartOf = 3,
        ClassifiedWith = 4,
    }
}
/// Common Tag Codes defined by FHIR project
/// See <http://hl7.org/fhir/ValueSet/common-tags>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CommonTagsCode {
    #[prost(enumeration = "common_tags_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CommonTagsCode`.
pub mod common_tags_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Actionable = 1,
    }
}
/// Codes for general categories of communications such as alerts, instruction,
/// etc. See <http://hl7.org/fhir/ValueSet/communication-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CommunicationCategoryCode {
    #[prost(enumeration = "communication_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CommunicationCategoryCode`.
pub mod communication_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Alert = 1,
        Notification = 2,
        Reminder = 3,
        Instruction = 4,
    }
}
/// Codes for the reason why a communication was not done.
/// See <http://hl7.org/fhir/ValueSet/communication-not-done-reason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CommunicationNotDoneReasonCode {
    #[prost(enumeration = "communication_not_done_reason_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CommunicationNotDoneReasonCode`.
pub mod communication_not_done_reason_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unknown = 1,
        SystemError = 2,
        InvalidPhoneNumber = 3,
        RecipientUnavailable = 4,
        FamilyObjection = 5,
        PatientObjection = 6,
    }
}
/// Which compartment a compartment definition describes
/// See <http://hl7.org/fhir/ValueSet/compartment-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompartmentTypeCode {
    #[prost(enumeration = "compartment_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CompartmentTypeCode`.
pub mod compartment_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Patient = 1,
        Encounter = 2,
        Relatedperson = 3,
        Practitioner = 4,
        Device = 5,
    }
}
/// The composite scoring method of the measure
/// See <http://hl7.org/fhir/ValueSet/composite-measure-scoring>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompositeMeasureScoringCode {
    #[prost(enumeration = "composite_measure_scoring_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CompositeMeasureScoringCode`.
pub mod composite_measure_scoring_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Opportunity = 1,
        AllOrNothing = 2,
        Linear = 3,
        Weighted = 4,
    }
}
/// The way in which a person authenticated a composition.
/// See <http://hl7.org/fhir/ValueSet/composition-attestation-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompositionAttestationModeCode {
    #[prost(enumeration = "composition_attestation_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CompositionAttestationModeCode`.
pub mod composition_attestation_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Personal = 1,
        Professional = 2,
        Legal = 3,
        Official = 4,
    }
}
/// The workflow/clinical status of the composition.
/// See <http://hl7.org/fhir/ValueSet/composition-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompositionStatusCode {
    #[prost(enumeration = "composition_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CompositionStatusCode`.
pub mod composition_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Preliminary = 1,
        Final = 2,
        Amended = 3,
        EnteredInError = 4,
    }
}
/// The degree of equivalence between concepts.
/// See <http://hl7.org/fhir/ValueSet/concept-map-equivalence>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConceptMapEquivalenceCode {
    #[prost(enumeration = "concept_map_equivalence_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConceptMapEquivalenceCode`.
pub mod concept_map_equivalence_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Relatedto = 1,
        Equivalent = 2,
        Equal = 3,
        Wider = 4,
        Subsumes = 5,
        Narrower = 6,
        Specializes = 7,
        Inexact = 8,
        Unmatched = 9,
        Disjoint = 10,
    }
}
/// Defines which action to take if there is no match in the group.
/// See <http://hl7.org/fhir/ValueSet/conceptmap-unmapped-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConceptMapGroupUnmappedModeCode {
    #[prost(enumeration = "concept_map_group_unmapped_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConceptMapGroupUnmappedModeCode`.
pub mod concept_map_group_unmapped_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Provided = 1,
        Fixed = 2,
        OtherMap = 3,
    }
}
/// The type of a property value
/// See <http://hl7.org/fhir/ValueSet/concept-property-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PropertyTypeCode {
    #[prost(enumeration = "property_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `PropertyTypeCode`.
pub mod property_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Code = 1,
        Coding = 2,
        String = 3,
        Integer = 4,
        Boolean = 5,
        Datetime = 6,
    }
}
/// A code that indicates how the server supports conditional delete.
/// See <http://hl7.org/fhir/ValueSet/conditional-delete-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionalDeleteStatusCode {
    #[prost(enumeration = "conditional_delete_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConditionalDeleteStatusCode`.
pub mod conditional_delete_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotSupported = 1,
        Single = 2,
        Multiple = 3,
    }
}
/// A code that indicates how the server supports conditional read.
/// See <http://hl7.org/fhir/ValueSet/conditional-read-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionalReadStatusCode {
    #[prost(enumeration = "conditional_read_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConditionalReadStatusCode`.
pub mod conditional_read_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotSupported = 1,
        ModifiedSince = 2,
        NotMatch = 3,
        FullSupport = 4,
    }
}
/// Preferred value set for Condition Categories.
/// See <http://hl7.org/fhir/ValueSet/condition-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionCategoryCodesCode {
    #[prost(enumeration = "condition_category_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConditionCategoryCodesCode`.
pub mod condition_category_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        ProblemListItem = 1,
        EncounterDiagnosis = 2,
    }
}
/// Preferred value set for Condition Clinical Status.
/// See <http://hl7.org/fhir/ValueSet/condition-clinical>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionClinicalStatusCodesCode {
    #[prost(enumeration = "condition_clinical_status_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConditionClinicalStatusCodesCode`.
pub mod condition_clinical_status_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Recurrence = 2,
        Inactive = 3,
        Remission = 4,
        Resolved = 5,
    }
}
/// Enumeration indicating whether the condition is currently active, inactive,
/// or has been resolved. See <http://hl7.org/fhir/ValueSet/condition-state>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionStateCode {
    #[prost(enumeration = "condition_state_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConditionStateCode`.
pub mod condition_state_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        Resolved = 3,
    }
}
/// The verification status to support or decline the clinical status of the
/// condition or diagnosis. See
/// <http://hl7.org/fhir/ValueSet/condition-ver-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConditionVerificationStatusCode {
    #[prost(enumeration = "condition_verification_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConditionVerificationStatusCode`.
pub mod condition_verification_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Provisional = 1,
        Differential = 2,
        Confirmed = 3,
        Refuted = 4,
        EnteredInError = 5,
        Unknown = 6,
    }
}
/// Indicates the degree of adherence to a specified behavior or capability
/// expected for a system to be deemed conformant with a specification. See
/// <http://hl7.org/fhir/ValueSet/conformance-expectation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConformanceExpectationCode {
    #[prost(enumeration = "conformance_expectation_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConformanceExpectationCode`.
pub mod conformance_expectation_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Shall = 1,
        Should = 2,
        May = 3,
        ShouldNot = 4,
    }
}
/// How a resource reference is interpreted when testing consent restrictions
/// See <http://hl7.org/fhir/ValueSet/consent-data-meaning>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConsentDataMeaningCode {
    #[prost(enumeration = "consent_data_meaning_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConsentDataMeaningCode`.
pub mod consent_data_meaning_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Instance = 1,
        Related = 2,
        Dependents = 3,
        Authoredby = 4,
    }
}
/// How an exception statement is applied, such as adding additional consent or
/// removing consent See <http://hl7.org/fhir/ValueSet/consent-except-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConsentExceptTypeCode {
    #[prost(enumeration = "consent_except_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConsentExceptTypeCode`.
pub mod consent_except_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Deny = 1,
        Permit = 2,
    }
}
/// Indicates the state of the consent
/// See <http://hl7.org/fhir/ValueSet/consent-state-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConsentStateCode {
    #[prost(enumeration = "consent_state_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConsentStateCode`.
pub mod consent_state_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Proposed = 2,
        Active = 3,
        Rejected = 4,
        Inactive = 5,
        EnteredInError = 6,
    }
}
/// This example value set defines a set of codes that can be used to indicate
/// the purpose for which you would contact a contact party. See
/// <http://hl7.org/fhir/ValueSet/contactentity-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactEntityTypeCode {
    #[prost(enumeration = "contact_entity_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ContactEntityTypeCode`.
pub mod contact_entity_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Bill = 1,
        Admin = 2,
        Hr = 3,
        Payor = 4,
        Patinf = 5,
        Press = 6,
    }
}
/// The content or mime type.
/// See <http://hl7.org/fhir/ValueSet/content-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContentTypeCode {
    #[prost(enumeration = "content_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ContentTypeCode`.
pub mod content_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Xml = 1,
        Json = 2,
        Ttl = 3,
        None = 4,
    }
}
/// This value set contract specific codes for status.
/// See <http://hl7.org/fhir/ValueSet/contract-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContractResourceStatusCode {
    #[prost(enumeration = "contract_resource_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ContractResourceStatusCode`.
pub mod contract_resource_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Amended = 1,
        Appended = 2,
        Cancelled = 3,
        Disputed = 4,
        EnteredInError = 5,
        Executable = 6,
        Executed = 7,
        Negotiable = 8,
        Offered = 9,
        Policy = 10,
        Rejected = 11,
        Renewed = 12,
        Revoked = 13,
        Resolved = 14,
        Terminated = 15,
    }
}
/// The type of contributor
/// See <http://hl7.org/fhir/ValueSet/contributor-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContributorTypeCode {
    #[prost(enumeration = "contributor_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ContributorTypeCode`.
pub mod contributor_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Author = 1,
        Editor = 2,
        Reviewer = 3,
        Endorser = 4,
    }
}
/// Copy Number Event
/// See <http://hl7.org/fhir/ValueSet/copy-number-event>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CopyNumberEventCode {
    #[prost(enumeration = "copy_number_event_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `CopyNumberEventCode`.
pub mod copy_number_event_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Amp = 1,
        Del = 2,
        Lof = 3,
    }
}
/// Used to specify why the normally expected content of the data element is
/// missing. See <http://hl7.org/fhir/ValueSet/data-absent-reason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DataAbsentReasonCode {
    #[prost(enumeration = "data_absent_reason_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DataAbsentReasonCode`.
pub mod data_absent_reason_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unknown = 1,
        Asked = 2,
        Temp = 3,
        NotAsked = 4,
        Masked = 5,
        Unsupported = 6,
        Astext = 7,
        Error = 8,
        NotANumber = 9,
        NotPerformed = 10,
    }
}
/// Indicates the degree of precision of the data element definition.
/// See <http://hl7.org/fhir/ValueSet/dataelement-stringency>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DataElementStringencyCode {
    #[prost(enumeration = "data_element_stringency_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DataElementStringencyCode`.
pub mod data_element_stringency_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Comparable = 1,
        FullySpecified = 2,
        Equivalent = 3,
        Convertable = 4,
        Scaleable = 5,
        Flexible = 6,
    }
}
/// The type of trigger
/// See <http://hl7.org/fhir/ValueSet/trigger-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TriggerTypeCode {
    #[prost(enumeration = "trigger_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TriggerTypeCode`.
pub mod trigger_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NamedEvent = 1,
        Periodic = 2,
        DataAdded = 3,
        DataModified = 4,
        DataRemoved = 5,
        DataAccessed = 6,
        DataAccessEnded = 7,
    }
}
/// The type of an element - one of the FHIR data types.
/// See <http://hl7.org/fhir/ValueSet/data-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DataTypeCode {
    #[prost(enumeration = "data_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DataTypeCode`.
pub mod data_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Address = 1,
        Age = 2,
        Annotation = 3,
        Attachment = 4,
        BackboneElement = 5,
        CodeableConcept = 6,
        Coding = 7,
        ContactDetail = 8,
        ContactPoint = 9,
        Contributor = 10,
        Count = 11,
        DataRequirement = 12,
        Distance = 13,
        Dosage = 14,
        Duration = 15,
        Element = 16,
        ElementDefinition = 17,
        Extension = 18,
        HumanName = 19,
        Identifier = 20,
        Meta = 21,
        Money = 22,
        Narrative = 23,
        ParameterDefinition = 24,
        Period = 25,
        Quantity = 26,
        Range = 27,
        Ratio = 28,
        Reference = 29,
        RelatedArtifact = 30,
        SampledData = 31,
        Signature = 32,
        SimpleQuantity = 33,
        Timing = 34,
        TriggerDefinition = 35,
        UsageContext = 36,
        Base64Binary = 37,
        Boolean = 38,
        Code = 39,
        Date = 40,
        DateTime = 41,
        Decimal = 42,
        Id = 43,
        Instant = 44,
        Integer = 45,
        Markdown = 46,
        Oid = 47,
        PositiveInt = 48,
        String = 49,
        Time = 50,
        UnsignedInt = 51,
        Uri = 52,
        Uuid = 53,
        Xhtml = 54,
    }
}
/// Either an abstract type, a resource or a data type.
/// See <http://hl7.org/fhir/ValueSet/all-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirAllTypesCode {
    #[prost(enumeration = "fhir_all_types_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FHIRAllTypesCode`.
pub mod fhir_all_types_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Address = 1,
        Age = 2,
        Annotation = 3,
        Attachment = 4,
        BackboneElement = 5,
        CodeableConcept = 6,
        Coding = 7,
        ContactDetail = 8,
        ContactPoint = 9,
        Contributor = 10,
        Count = 11,
        DataRequirement = 12,
        Distance = 13,
        Dosage = 14,
        Duration = 15,
        Element = 16,
        ElementDefinition = 17,
        Extension = 18,
        HumanName = 19,
        Identifier = 20,
        Meta = 21,
        Money = 22,
        Narrative = 23,
        ParameterDefinition = 24,
        Period = 25,
        Quantity = 26,
        Range = 27,
        Ratio = 28,
        Reference = 29,
        RelatedArtifact = 30,
        SampledData = 31,
        Signature = 32,
        SimpleQuantity = 33,
        Timing = 34,
        TriggerDefinition = 35,
        UsageContext = 36,
        Base64Binary = 37,
        Boolean = 38,
        Code = 39,
        Date = 40,
        DateTime = 41,
        Decimal = 42,
        Id = 43,
        Instant = 44,
        Integer = 45,
        Markdown = 46,
        Oid = 47,
        PositiveInt = 48,
        String = 49,
        Time = 50,
        UnsignedInt = 51,
        Uri = 52,
        Uuid = 53,
        Xhtml = 54,
        Account = 55,
        ActivityDefinition = 56,
        AdverseEvent = 57,
        AllergyIntolerance = 58,
        Appointment = 59,
        AppointmentResponse = 60,
        AuditEvent = 61,
        Basic = 62,
        Binary = 63,
        BodySite = 64,
        Bundle = 65,
        CapabilityStatement = 66,
        CarePlan = 67,
        CareTeam = 68,
        ChargeItem = 69,
        Claim = 70,
        ClaimResponse = 71,
        ClinicalImpression = 72,
        CodeSystem = 73,
        Communication = 74,
        CommunicationRequest = 75,
        CompartmentDefinition = 76,
        Composition = 77,
        ConceptMap = 78,
        Condition = 79,
        Consent = 80,
        Contract = 81,
        Coverage = 82,
        DataElement = 83,
        DetectedIssue = 84,
        Device = 85,
        DeviceComponent = 86,
        DeviceMetric = 87,
        DeviceRequest = 88,
        DeviceUseStatement = 89,
        DiagnosticReport = 90,
        DocumentManifest = 91,
        DocumentReference = 92,
        DomainResource = 93,
        EligibilityRequest = 94,
        EligibilityResponse = 95,
        Encounter = 96,
        Endpoint = 97,
        EnrollmentRequest = 98,
        EnrollmentResponse = 99,
        EpisodeOfCare = 100,
        ExpansionProfile = 101,
        ExplanationOfBenefit = 102,
        FamilyMemberHistory = 103,
        Flag = 104,
        Goal = 105,
        GraphDefinition = 106,
        Group = 107,
        GuidanceResponse = 108,
        HealthcareService = 109,
        ImagingManifest = 110,
        ImagingStudy = 111,
        Immunization = 112,
        ImmunizationRecommendation = 113,
        ImplementationGuide = 114,
        Library = 115,
        Linkage = 116,
        List = 117,
        Location = 118,
        Measure = 119,
        MeasureReport = 120,
        Media = 121,
        Medication = 122,
        MedicationAdministration = 123,
        MedicationDispense = 124,
        MedicationRequest = 125,
        MedicationStatement = 126,
        MessageDefinition = 127,
        MessageHeader = 128,
        NamingSystem = 129,
        NutritionOrder = 130,
        Observation = 131,
        OperationDefinition = 132,
        OperationOutcome = 133,
        Organization = 134,
        Parameters = 135,
        Patient = 136,
        PaymentNotice = 137,
        PaymentReconciliation = 138,
        Person = 139,
        PlanDefinition = 140,
        Practitioner = 141,
        PractitionerRole = 142,
        Procedure = 143,
        ProcedureRequest = 144,
        ProcessRequest = 145,
        ProcessResponse = 146,
        Provenance = 147,
        Questionnaire = 148,
        QuestionnaireResponse = 149,
        ReferralRequest = 150,
        RelatedPerson = 151,
        RequestGroup = 152,
        ResearchStudy = 153,
        ResearchSubject = 154,
        Resource = 155,
        RiskAssessment = 156,
        Schedule = 157,
        SearchParameter = 158,
        Sequence = 159,
        ServiceDefinition = 160,
        Slot = 161,
        Specimen = 162,
        StructureDefinition = 163,
        StructureMap = 164,
        Subscription = 165,
        Substance = 166,
        SupplyDelivery = 167,
        SupplyRequest = 168,
        Task = 169,
        TestReport = 170,
        TestScript = 171,
        Set = 172,
        VisionPrescription = 173,
        Type = 174,
        Any = 175,
    }
}
/// Either a resource or a data type.
/// See <http://hl7.org/fhir/ValueSet/defined-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirDefinedTypeCode {
    #[prost(enumeration = "fhir_defined_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FHIRDefinedTypeCode`.
pub mod fhir_defined_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Address = 1,
        Age = 2,
        Annotation = 3,
        Attachment = 4,
        BackboneElement = 5,
        CodeableConcept = 6,
        Coding = 7,
        ContactDetail = 8,
        ContactPoint = 9,
        Contributor = 10,
        Count = 11,
        DataRequirement = 12,
        Distance = 13,
        Dosage = 14,
        Duration = 15,
        Element = 16,
        ElementDefinition = 17,
        Extension = 18,
        HumanName = 19,
        Identifier = 20,
        Meta = 21,
        Money = 22,
        Narrative = 23,
        ParameterDefinition = 24,
        Period = 25,
        Quantity = 26,
        Range = 27,
        Ratio = 28,
        Reference = 29,
        RelatedArtifact = 30,
        SampledData = 31,
        Signature = 32,
        SimpleQuantity = 33,
        Timing = 34,
        TriggerDefinition = 35,
        UsageContext = 36,
        Base64Binary = 37,
        Boolean = 38,
        Code = 39,
        Date = 40,
        DateTime = 41,
        Decimal = 42,
        Id = 43,
        Instant = 44,
        Integer = 45,
        Markdown = 46,
        Oid = 47,
        PositiveInt = 48,
        String = 49,
        Time = 50,
        UnsignedInt = 51,
        Uri = 52,
        Uuid = 53,
        Xhtml = 54,
        Account = 55,
        ActivityDefinition = 56,
        AdverseEvent = 57,
        AllergyIntolerance = 58,
        Appointment = 59,
        AppointmentResponse = 60,
        AuditEvent = 61,
        Basic = 62,
        Binary = 63,
        BodySite = 64,
        Bundle = 65,
        CapabilityStatement = 66,
        CarePlan = 67,
        CareTeam = 68,
        ChargeItem = 69,
        Claim = 70,
        ClaimResponse = 71,
        ClinicalImpression = 72,
        CodeSystem = 73,
        Communication = 74,
        CommunicationRequest = 75,
        CompartmentDefinition = 76,
        Composition = 77,
        ConceptMap = 78,
        Condition = 79,
        Consent = 80,
        Contract = 81,
        Coverage = 82,
        DataElement = 83,
        DetectedIssue = 84,
        Device = 85,
        DeviceComponent = 86,
        DeviceMetric = 87,
        DeviceRequest = 88,
        DeviceUseStatement = 89,
        DiagnosticReport = 90,
        DocumentManifest = 91,
        DocumentReference = 92,
        DomainResource = 93,
        EligibilityRequest = 94,
        EligibilityResponse = 95,
        Encounter = 96,
        Endpoint = 97,
        EnrollmentRequest = 98,
        EnrollmentResponse = 99,
        EpisodeOfCare = 100,
        ExpansionProfile = 101,
        ExplanationOfBenefit = 102,
        FamilyMemberHistory = 103,
        Flag = 104,
        Goal = 105,
        GraphDefinition = 106,
        Group = 107,
        GuidanceResponse = 108,
        HealthcareService = 109,
        ImagingManifest = 110,
        ImagingStudy = 111,
        Immunization = 112,
        ImmunizationRecommendation = 113,
        ImplementationGuide = 114,
        Library = 115,
        Linkage = 116,
        List = 117,
        Location = 118,
        Measure = 119,
        MeasureReport = 120,
        Media = 121,
        Medication = 122,
        MedicationAdministration = 123,
        MedicationDispense = 124,
        MedicationRequest = 125,
        MedicationStatement = 126,
        MessageDefinition = 127,
        MessageHeader = 128,
        NamingSystem = 129,
        NutritionOrder = 130,
        Observation = 131,
        OperationDefinition = 132,
        OperationOutcome = 133,
        Organization = 134,
        Parameters = 135,
        Patient = 136,
        PaymentNotice = 137,
        PaymentReconciliation = 138,
        Person = 139,
        PlanDefinition = 140,
        Practitioner = 141,
        PractitionerRole = 142,
        Procedure = 143,
        ProcedureRequest = 144,
        ProcessRequest = 145,
        ProcessResponse = 146,
        Provenance = 147,
        Questionnaire = 148,
        QuestionnaireResponse = 149,
        ReferralRequest = 150,
        RelatedPerson = 151,
        RequestGroup = 152,
        ResearchStudy = 153,
        ResearchSubject = 154,
        Resource = 155,
        RiskAssessment = 156,
        Schedule = 157,
        SearchParameter = 158,
        Sequence = 159,
        ServiceDefinition = 160,
        Slot = 161,
        Specimen = 162,
        StructureDefinition = 163,
        StructureMap = 164,
        Subscription = 165,
        Substance = 166,
        SupplyDelivery = 167,
        SupplyRequest = 168,
        Task = 169,
        TestReport = 170,
        TestScript = 171,
        Set = 172,
        VisionPrescription = 173,
    }
}
/// Either a resource or a data type, extended to allow arbitrary other codes
/// representing FHIR resources. See <http://hl7.org/fhir/ValueSet/defined-types>
/// Due to
/// <https://gforge.hl7.org/gf/project/fhir/tracker/?action=TrackerItemEdit&tracker_item_id=15559>
/// there are two value sets with valueset url:
/// <http://hl7.org/fhir/ValueSet/defined-types.>
/// Fragment added here to disambiguate.
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirDefinedTypeExtCode {
    #[prost(string, tag = "1")]
    pub value: prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Codes identifying the lifecycle stage of a definition
/// See <http://hl7.org/fhir/ValueSet/definition-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DefinitionStatusCode {
    #[prost(enumeration = "definition_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DefinitionStatusCode`.
pub mod definition_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Active = 2,
        Withdrawn = 3,
        Unknown = 4,
    }
}
/// High-level categorization of the definition, used for searching, sorting,
/// and filtering See <http://hl7.org/fhir/ValueSet/definition-topic>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DefinitionTopicCode {
    #[prost(enumeration = "definition_topic_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DefinitionTopicCode`.
pub mod definition_topic_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Treatment = 1,
        Education = 2,
        Assessment = 3,
    }
}
/// Indicates the potential degree of impact of the identified issue on the
/// patient. See <http://hl7.org/fhir/ValueSet/detectedissue-severity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DetectedIssueSeverityCode {
    #[prost(enumeration = "detected_issue_severity_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DetectedIssueSeverityCode`.
pub mod detected_issue_severity_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        High = 1,
        Moderate = 2,
        Low = 3,
    }
}
/// A coded concept indicating the current status of a the Device Usage
/// See <http://hl7.org/fhir/ValueSet/device-statement-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceUseStatementStatusCode {
    #[prost(enumeration = "device_use_statement_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DeviceUseStatementStatusCode`.
pub mod device_use_statement_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Completed = 2,
        EnteredInError = 3,
        Intended = 4,
        Stopped = 5,
        OnHold = 6,
    }
}
/// The availability status of the device.
/// See <http://hl7.org/fhir/ValueSet/device-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirDeviceStatusCode {
    #[prost(enumeration = "fhir_device_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FHIRDeviceStatusCode`.
pub mod fhir_device_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
        Unknown = 4,
    }
}
/// This value set defines a set of codes that can be used to express the role
/// of a diagnosis on the Encounter or EpisodeOfCare record. See
/// <http://hl7.org/fhir/ValueSet/diagnosis-role>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosisRoleCode {
    #[prost(enumeration = "diagnosis_role_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DiagnosisRoleCode`.
pub mod diagnosis_role_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ad = 1,
        Dd = 2,
        Cc = 3,
        Cm = 4,
        PreOp = 5,
        PostOp = 6,
        Billing = 7,
    }
}
/// The status of the diagnostic report as a whole.
/// See <http://hl7.org/fhir/ValueSet/diagnostic-report-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReportStatusCode {
    #[prost(enumeration = "diagnostic_report_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DiagnosticReportStatusCode`.
pub mod diagnostic_report_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Registered = 1,
        Partial = 2,
        Preliminary = 3,
        Final = 4,
        Amended = 5,
        Corrected = 6,
        Appended = 7,
        Cancelled = 8,
        EnteredInError = 9,
        Unknown = 10,
    }
}
/// Whether the media is a photo, video, or audio
/// See <http://hl7.org/fhir/ValueSet/digital-media-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DigitalMediaTypeCode {
    #[prost(enumeration = "digital_media_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DigitalMediaTypeCode`.
pub mod digital_media_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Photo = 1,
        Video = 2,
        Audio = 3,
    }
}
/// Whether the application produces or consumes documents.
/// See <http://hl7.org/fhir/ValueSet/document-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DocumentModeCode {
    #[prost(enumeration = "document_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DocumentModeCode`.
pub mod document_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Producer = 1,
        Consumer = 2,
    }
}
/// The status of the document reference.
/// See <http://hl7.org/fhir/ValueSet/document-reference-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DocumentReferenceStatusCode {
    #[prost(enumeration = "document_reference_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DocumentReferenceStatusCode`.
pub mod document_reference_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Current = 1,
        Superseded = 2,
        EnteredInError = 3,
    }
}
/// The type of relationship between documents.
/// See <http://hl7.org/fhir/ValueSet/document-relationship-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DocumentRelationshipTypeCode {
    #[prost(enumeration = "document_relationship_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DocumentRelationshipTypeCode`.
pub mod document_relationship_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Replaces = 1,
        Transforms = 2,
        Signs = 3,
        Appends = 4,
    }
}
/// This value set defines a set of codes that can be used to indicate from
/// where the patient came in. See
/// <http://hl7.org/fhir/ValueSet/encounter-admit-source>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdmitSourceCode {
    #[prost(enumeration = "admit_source_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AdmitSourceCode`.
pub mod admit_source_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        HospTrans = 1,
        Emd = 2,
        Outp = 3,
        Born = 4,
        Gp = 5,
        Mp = 6,
        Nursing = 7,
        Psych = 8,
        Rehab = 9,
        Other = 10,
    }
}
/// This value set defines a set of codes that can be used to indicate dietary
/// preferences or restrictions a patient may have. See
/// <http://hl7.org/fhir/ValueSet/encounter-diet>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DietCode {
    #[prost(enumeration = "diet_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DietCode`.
pub mod diet_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Vegetarian = 1,
        DairyFree = 2,
        NutFree = 3,
        GlutenFree = 4,
        Vegan = 5,
        Halal = 6,
        Kosher = 7,
    }
}
/// This value set defines a set of codes that can be used to where the patient
/// left the hospital. See
/// <http://hl7.org/fhir/ValueSet/encounter-discharge-disposition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DischargeDispositionCode {
    #[prost(enumeration = "discharge_disposition_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DischargeDispositionCode`.
pub mod discharge_disposition_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Home = 1,
        OtherHcf = 2,
        Hosp = 3,
        Long = 4,
        Aadvice = 5,
        Exp = 6,
        Psy = 7,
        Rehab = 8,
        Snf = 9,
        Oth = 10,
    }
}
/// The status of the location.
/// See <http://hl7.org/fhir/ValueSet/encounter-location-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EncounterLocationStatusCode {
    #[prost(enumeration = "encounter_location_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EncounterLocationStatusCode`.
pub mod encounter_location_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Planned = 1,
        Active = 2,
        Reserved = 3,
        Completed = 4,
    }
}
/// This value set defines a set of codes that can be used to indicate the
/// kinds of special arrangements in place for a patients visit. See
/// <http://hl7.org/fhir/ValueSet/encounter-special-arrangements>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecialArrangementsCode {
    #[prost(enumeration = "special_arrangements_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SpecialArrangementsCode`.
pub mod special_arrangements_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Wheel = 1,
        AddBed = 2,
        Int = 3,
        Att = 4,
        Dog = 5,
    }
}
/// Current state of the encounter
/// See <http://hl7.org/fhir/ValueSet/encounter-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EncounterStatusCode {
    #[prost(enumeration = "encounter_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EncounterStatusCode`.
pub mod encounter_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Planned = 1,
        Arrived = 2,
        Triaged = 3,
        InProgress = 4,
        Onleave = 5,
        Finished = 6,
        Cancelled = 7,
        EnteredInError = 8,
        Unknown = 9,
    }
}
/// This example value set defines a set of codes that can be used to indicate
/// the type of encounter: a specific code indicating type of service provided.
/// See <http://hl7.org/fhir/ValueSet/encounter-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EncounterTypeCode {
    #[prost(enumeration = "encounter_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EncounterTypeCode`.
pub mod encounter_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Adms = 1,
        BdBmClin = 2,
        Ccs60 = 3,
        Oki = 4,
    }
}
/// The status of the endpoint
/// See <http://hl7.org/fhir/ValueSet/endpoint-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EndpointStatusCode {
    #[prost(enumeration = "endpoint_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EndpointStatusCode`.
pub mod endpoint_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Suspended = 2,
        Error = 3,
        Off = 4,
        EnteredInError = 5,
        Test = 6,
    }
}
/// A set of codes each of which specifies a certain subcategory of the name part
/// in addition to the main name part type See
/// <http://hl7.org/fhir/ValueSet/name-part-qualifier>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EntityNamePartQualifierCode {
    #[prost(enumeration = "entity_name_part_qualifier_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EntityNamePartQualifierCode`.
pub mod entity_name_part_qualifier_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ls = 1,
        Ac = 2,
        Nb = 3,
        Pr = 4,
        Hon = 5,
        Br = 6,
        Ad = 7,
        Sp = 8,
        Mid = 9,
        Cl = 10,
        In = 11,
    }
}
/// EnteralFormulaAdditiveType: Codes for the type of modular component such as
/// protein, carbohydrate or fiber to be provided in addition to or mixed with
/// the base formula. This value set is provided as a suggestive example. See
/// <http://hl7.org/fhir/ValueSet/entformula-additive>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EnteralFormulaAdditiveTypeCodeCode {
    #[prost(
        enumeration = "enteral_formula_additive_type_code_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EnteralFormulaAdditiveTypeCodeCode`.
pub mod enteral_formula_additive_type_code_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Lipid = 1,
        Protein = 2,
        Carbohydrate = 3,
        Fiber = 4,
        Water = 5,
    }
}
/// The status of the episode of care.
/// See <http://hl7.org/fhir/ValueSet/episode-of-care-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EpisodeOfCareStatusCode {
    #[prost(enumeration = "episode_of_care_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EpisodeOfCareStatusCode`.
pub mod episode_of_care_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Planned = 1,
        Waitlist = 2,
        Active = 3,
        Onhold = 4,
        Finished = 5,
        Cancelled = 6,
        EnteredInError = 7,
    }
}
/// This example value set defines a set of codes that can be used to express
/// the usage type of an EpisodeOfCare record. See
/// <http://hl7.org/fhir/ValueSet/episodeofcare-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EpisodeOfCareTypeCode {
    #[prost(enumeration = "episode_of_care_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EpisodeOfCareTypeCode`.
pub mod episode_of_care_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Hacc = 1,
        Pac = 2,
        Diab = 3,
        Da = 4,
        Cacp = 5,
    }
}
/// The mode of a message capability statement.
/// See <http://hl7.org/fhir/ValueSet/event-capability-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EventCapabilityModeCode {
    #[prost(enumeration = "event_capability_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EventCapabilityModeCode`.
pub mod event_capability_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Sender = 1,
        Receiver = 2,
    }
}
/// Codes identifying the stage lifecycle stage of a event
/// See <http://hl7.org/fhir/ValueSet/event-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EventStatusCode {
    #[prost(enumeration = "event_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `EventStatusCode`.
pub mod event_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Preparation = 1,
        InProgress = 2,
        Suspended = 3,
        Aborted = 4,
        Completed = 5,
        EnteredInError = 6,
        Unknown = 7,
    }
}
/// The type of Claim payee Resource
/// See <http://hl7.org/fhir/ValueSet/ex-payee-resource-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ClaimPayeeResourceTypeCode {
    #[prost(enumeration = "claim_payee_resource_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ClaimPayeeResourceTypeCode`.
pub mod claim_payee_resource_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Organization = 1,
        Patient = 2,
        Practitioner = 3,
        Relatedperson = 4,
    }
}
/// A code specifying the state of the resource instance.
/// See <http://hl7.org/fhir/ValueSet/explanationofbenefit-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExplanationOfBenefitStatusCode {
    #[prost(enumeration = "explanation_of_benefit_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ExplanationOfBenefitStatusCode`.
pub mod explanation_of_benefit_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Cancelled = 2,
        Draft = 3,
        EnteredInError = 4,
    }
}
/// How an extension context is interpreted.
/// See <http://hl7.org/fhir/ValueSet/extension-context>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExtensionContextCode {
    #[prost(enumeration = "extension_context_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ExtensionContextCode`.
pub mod extension_context_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Resource = 1,
        Datatype = 2,
        Extension = 3,
    }
}
/// The kind of operation to perform as a part of a property based filter.
/// See <http://hl7.org/fhir/ValueSet/filter-operator>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FilterOperatorCode {
    #[prost(enumeration = "filter_operator_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FilterOperatorCode`.
pub mod filter_operator_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Equals = 1,
        IsA = 2,
        DescendentOf = 3,
        IsNotA = 4,
        Regex = 5,
        In = 6,
        NotIn = 7,
        Generalizes = 8,
        Exists = 9,
    }
}
/// Example list of general categories for flagged issues. (Not complete or
/// necessarily appropriate.) See <http://hl7.org/fhir/ValueSet/flag-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FlagCategoryCode {
    #[prost(enumeration = "flag_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FlagCategoryCode`.
pub mod flag_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Diet = 1,
        Drug = 2,
        Lab = 3,
        Admin = 4,
        Contact = 5,
    }
}
/// This value set is provided as an exemplar. The value set is driven by IHE
/// Table B.8-4: Abnormal Flags, Alert Priority. See
/// <http://hl7.org/fhir/ValueSet/flag-priority>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FlagPriorityCodesCode {
    #[prost(enumeration = "flag_priority_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FlagPriorityCodesCode`.
pub mod flag_priority_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Pn = 1,
        Pl = 2,
        Pm = 3,
        Ph = 4,
    }
}
/// Indicates whether this flag is active and needs to be displayed to a user,
/// or whether it is no longer needed or entered in error. See
/// <http://hl7.org/fhir/ValueSet/flag-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FlagStatusCode {
    #[prost(enumeration = "flag_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FlagStatusCode`.
pub mod flag_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
    }
}
/// This value set includes Status codes.
/// See <http://hl7.org/fhir/ValueSet/fm-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FinancialResourceStatusCode {
    #[prost(enumeration = "financial_resource_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FinancialResourceStatusCode`.
pub mod financial_resource_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Cancelled = 2,
        Draft = 3,
        EnteredInError = 4,
    }
}
/// Codes indicating whether the goal has been accepted by a stakeholder
/// See <http://hl7.org/fhir/ValueSet/goal-acceptance-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalAcceptanceStatusCode {
    #[prost(enumeration = "goal_acceptance_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GoalAcceptanceStatusCode`.
pub mod goal_acceptance_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Agree = 1,
        Disagree = 2,
        Pending = 3,
    }
}
/// Example codes for grouping goals for filtering or presentation.
/// See <http://hl7.org/fhir/ValueSet/goal-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalCategoryCode {
    #[prost(enumeration = "goal_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GoalCategoryCode`.
pub mod goal_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Dietary = 1,
        Safety = 2,
        Behavioral = 3,
        Nursing = 4,
        Physiotherapy = 5,
    }
}
/// Indicates the level of importance associated with reaching or sustaining a
/// goal. See <http://hl7.org/fhir/ValueSet/goal-priority>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalPriorityCode {
    #[prost(enumeration = "goal_priority_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GoalPriorityCode`.
pub mod goal_priority_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        HighPriority = 1,
        MediumPriority = 2,
        LowPriority = 3,
    }
}
/// Types of relationships between two goals
/// See <http://hl7.org/fhir/ValueSet/goal-relationship-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalRelationshipTypeCode {
    #[prost(enumeration = "goal_relationship_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GoalRelationshipTypeCode`.
pub mod goal_relationship_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Predecessor = 1,
        Successor = 2,
        Replacement = 3,
        Milestone = 4,
        Other = 5,
    }
}
/// Indicates whether the goal has been met and is still being targeted
/// See <http://hl7.org/fhir/ValueSet/goal-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalStatusCode {
    #[prost(enumeration = "goal_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GoalStatusCode`.
pub mod goal_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposed = 1,
        Accepted = 2,
        Planned = 3,
        InProgress = 4,
        OnTarget = 5,
        AheadOfTarget = 6,
        BehindTarget = 7,
        Sustaining = 8,
        Achieved = 9,
        OnHold = 10,
        Cancelled = 11,
        EnteredInError = 12,
        Rejected = 13,
    }
}
/// Example codes indicating the reason for a current status.  Note that these
/// are in no way complete and may not even be appropriate for some uses. See
/// <http://hl7.org/fhir/ValueSet/goal-status-reason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GoalStatusReasonCode {
    #[prost(enumeration = "goal_status_reason_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GoalStatusReasonCode`.
pub mod goal_status_reason_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Surgery = 1,
        LifeEvent = 2,
        Replaced = 3,
        PatientRequest = 4,
        TempNotAttainable = 5,
        PermanentNotAttainable = 6,
        FinancialBarrier = 7,
        LackOfTransportation = 8,
        LackOfSocialSupport = 9,
    }
}
/// How a compartment must be linked
/// See <http://hl7.org/fhir/ValueSet/graph-compartment-rule>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GraphCompartmentRuleCode {
    #[prost(enumeration = "graph_compartment_rule_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GraphCompartmentRuleCode`.
pub mod graph_compartment_rule_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Identical = 1,
        Matching = 2,
        Different = 3,
        Custom = 4,
    }
}
/// Types of resources that are part of group
/// See <http://hl7.org/fhir/ValueSet/group-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GroupTypeCode {
    #[prost(enumeration = "group_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GroupTypeCode`.
pub mod group_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Person = 1,
        Animal = 2,
        Practitioner = 3,
        Device = 4,
        Medication = 5,
        Substance = 6,
    }
}
/// The status of a guidance response
/// See <http://hl7.org/fhir/ValueSet/guidance-response-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GuidanceResponseStatusCode {
    #[prost(enumeration = "guidance_response_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GuidanceResponseStatusCode`.
pub mod guidance_response_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Success = 1,
        DataRequested = 2,
        DataRequired = 3,
        InProgress = 4,
        Failure = 5,
        EnteredInError = 6,
    }
}
/// How a dependency is represented when the guide is published.
/// See <http://hl7.org/fhir/ValueSet/guide-dependency-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GuideDependencyTypeCode {
    #[prost(enumeration = "guide_dependency_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GuideDependencyTypeCode`.
pub mod guide_dependency_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Reference = 1,
        Inclusion = 2,
    }
}
/// The kind of an included page.
/// See <http://hl7.org/fhir/ValueSet/guide-page-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GuidePageKindCode {
    #[prost(enumeration = "guide_page_kind_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `GuidePageKindCode`.
pub mod guide_page_kind_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Page = 1,
        Example = 2,
        List = 3,
        Include = 4,
        Directory = 5,
        Dictionary = 6,
        Toc = 7,
        Resource = 8,
    }
}
/// Codes describing the reason why a family member history was not done.
/// See <http://hl7.org/fhir/ValueSet/history-not-done-reason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyHistoryNotDoneReasonCode {
    #[prost(enumeration = "family_history_not_done_reason_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FamilyHistoryNotDoneReasonCode`.
pub mod family_history_not_done_reason_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        SubjectUnknown = 1,
        Withheld = 2,
        UnableToObtain = 3,
        Deferred = 4,
    }
}
/// A code that identifies the status of the family history record.
/// See <http://hl7.org/fhir/ValueSet/history-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyHistoryStatusCode {
    #[prost(enumeration = "family_history_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FamilyHistoryStatusCode`.
pub mod family_history_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Partial = 1,
        Completed = 2,
        EnteredInError = 3,
        HealthUnknown = 4,
    }
}
/// An HL7 administrative unit that owns artifacts in the FHIR specification
/// See <http://hl7.org/fhir/ValueSet/hl7-work-group>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Hl7WorkgroupCode {
    #[prost(enumeration = "hl7_workgroup_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `HL7WorkgroupCode`.
pub mod hl7_workgroup_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Cbcc = 1,
        Cds = 2,
        Cqi = 3,
        Cg = 4,
        Dev = 5,
        Ehr = 6,
        Fhir = 7,
        Fm = 8,
        Hsi = 9,
        Ii = 10,
        Inm = 11,
        Its = 12,
        Oo = 13,
        Pa = 14,
        Pc = 15,
        Pher = 16,
        Phx = 17,
        Rcrim = 18,
        Sd = 19,
        Sec = 20,
        Us = 21,
        Vocab = 22,
        Aid = 23,
    }
}
/// The allowable request method or HTTP operation codes.
/// See <http://hl7.org/fhir/ValueSet/http-operations>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestScriptRequestMethodCodeCode {
    #[prost(enumeration = "test_script_request_method_code_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TestScriptRequestMethodCodeCode`.
pub mod test_script_request_method_code_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Delete = 1,
        Get = 2,
        Options = 3,
        Patch = 4,
        Post = 5,
        Put = 6,
    }
}
/// HTTP verbs (in the HTTP command line).
/// See <http://hl7.org/fhir/ValueSet/http-verb>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HttpVerbCode {
    #[prost(enumeration = "http_verb_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `HTTPVerbCode`.
pub mod http_verb_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Get = 1,
        Post = 2,
        Put = 3,
        Delete = 4,
    }
}
/// The level of confidence that this link represents the same actual person,
/// based on NIST Authentication Levels. See
/// <http://hl7.org/fhir/ValueSet/identity-assuranceLevel>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct IdentityAssuranceLevelCode {
    #[prost(enumeration = "identity_assurance_level_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `IdentityAssuranceLevelCode`.
pub mod identity_assurance_level_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Level1 = 1,
        Level2 = 2,
        Level3 = 3,
        Level4 = 4,
    }
}
/// The value set to instantiate this attribute should be drawn from a
/// terminologically robust code system that consists of or contains concepts
/// to support describing the source of the data when the report of the
/// immunization event is not based on information from the person, entity or
/// organization who administered the vaccine. This value set is provided as a
/// suggestive example. See <http://hl7.org/fhir/ValueSet/immunization-origin>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImmunizationOriginCodesCode {
    #[prost(enumeration = "immunization_origin_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ImmunizationOriginCodesCode`.
pub mod immunization_origin_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Provider = 1,
        Record = 2,
        Recall = 3,
        School = 4,
    }
}
/// The value set to instantiate this attribute should be drawn from a
/// terminologically robust code system that consists of or contains concepts
/// to support the definition of dates relevant to recommendations for future
/// doses of vaccines. This value set is provided as a suggestive example. See
/// <http://hl7.org/fhir/ValueSet/immunization-recommendation-date-criterion>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImmunizationRecommendationDateCriterionCodesCode {
    #[prost(
        enumeration = "immunization_recommendation_date_criterion_codes_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ImmunizationRecommendationDateCriterionCodesCode`.
pub mod immunization_recommendation_date_criterion_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Due = 1,
        Recommended = 2,
        Earliest = 3,
        Overdue = 4,
        Latest = 5,
    }
}
/// The value set to instantiate this attribute should be drawn from a
/// terminologically robust code system that consists of or contains concepts
/// to support describing the status of the patient towards perceived immunity
/// against a vaccine preventable disease. This value set is provided as a
/// suggestive example. See
/// <http://hl7.org/fhir/ValueSet/immunization-recommendation-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImmunizationRecommendationStatusCodesCode {
    #[prost(
        enumeration = "immunization_recommendation_status_codes_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ImmunizationRecommendationStatusCodesCode`.
pub mod immunization_recommendation_status_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Due = 1,
        Overdue = 2,
    }
}
/// The value set to instantiate this attribute should be drawn from a
/// terminologically robust code system that consists of or contains concepts
/// to support describing the current status of the administered dose of
/// vaccine. See <http://hl7.org/fhir/ValueSet/immunization-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImmunizationStatusCodesCode {
    #[prost(enumeration = "immunization_status_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ImmunizationStatusCodesCode`.
pub mod immunization_status_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Completed = 1,
        EnteredInError = 2,
    }
}
/// A set codes that define the functional status of an implanted device.
/// See <http://hl7.org/fhir/ValueSet/implant-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImplantStatusCode {
    #[prost(enumeration = "implant_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ImplantStatusCode`.
pub mod implant_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Functional = 1,
        NonFunctional = 2,
        Disabled = 3,
        Unknown = 4,
    }
}
/// Availability of the resource
/// See <http://hl7.org/fhir/ValueSet/instance-availability>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct InstanceAvailabilityCode {
    #[prost(enumeration = "instance_availability_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `InstanceAvailabilityCode`.
pub mod instance_availability_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Online = 1,
        Offline = 2,
        Nearline = 3,
        Unavailable = 4,
    }
}
/// How the issue affects the success of the action.
/// See <http://hl7.org/fhir/ValueSet/issue-severity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct IssueSeverityCode {
    #[prost(enumeration = "issue_severity_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `IssueSeverityCode`.
pub mod issue_severity_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Fatal = 1,
        Error = 2,
        Warning = 3,
        Information = 4,
    }
}
/// A code that describes the type of issue.
/// See <http://hl7.org/fhir/ValueSet/issue-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct IssueTypeCode {
    #[prost(enumeration = "issue_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `IssueTypeCode`.
pub mod issue_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Invalid = 1,
        Structure = 2,
        Required = 3,
        Value = 4,
        Invariant = 5,
        Security = 6,
        Login = 7,
        Unknown = 8,
        Expired = 9,
        Forbidden = 10,
        Suppressed = 11,
        Processing = 12,
        NotSupported = 13,
        Duplicate = 14,
        NotFound = 15,
        TooLong = 16,
        CodeInvalid = 17,
        Extension = 18,
        TooCostly = 19,
        BusinessRule = 20,
        Conflict = 21,
        Incomplete = 22,
        Transient = 23,
        LockError = 24,
        NoStore = 25,
        Exception = 26,
        Timeout = 27,
        Throttled = 28,
        Informational = 29,
    }
}
/// Distinguishes groups from questions and display text and indicates data
/// type for questions See <http://hl7.org/fhir/ValueSet/item-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireItemTypeCode {
    #[prost(enumeration = "questionnaire_item_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `QuestionnaireItemTypeCode`.
pub mod questionnaire_item_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Group = 1,
        Display = 2,
        Question = 3,
        Boolean = 4,
        Decimal = 5,
        Integer = 6,
        Date = 7,
        DateTime = 8,
        Time = 9,
        String = 10,
        Text = 11,
        Url = 12,
        Choice = 13,
        OpenChoice = 14,
        Attachment = 15,
        Reference = 16,
        Quantity = 17,
    }
}
/// The type of knowledge asset this library contains
/// See <http://hl7.org/fhir/ValueSet/library-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LibraryTypeCode {
    #[prost(enumeration = "library_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `LibraryTypeCode`.
pub mod library_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        LogicLibrary = 1,
        ModelDefinition = 2,
        AssetCollection = 3,
        ModuleDefinition = 4,
    }
}
/// Used to distinguish different roles a resource can play within a set of
/// linked resources See <http://hl7.org/fhir/ValueSet/linkage-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LinkageTypeCode {
    #[prost(enumeration = "linkage_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `LinkageTypeCode`.
pub mod linkage_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Source = 1,
        Alternate = 2,
        Historical = 3,
    }
}
/// The type of link between this patient resource and another patient
/// resource. See <http://hl7.org/fhir/ValueSet/link-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LinkTypeCode {
    #[prost(enumeration = "link_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `LinkTypeCode`.
pub mod link_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        ReplacedBy = 1,
        Replaces = 2,
        Refer = 3,
        Seealso = 4,
    }
}
/// General reasons for a list to be empty. Reasons are either related to a
/// summary list (i.e. problem or medication list) or to a workflow related
/// list (i.e. consultation list). See
/// <http://hl7.org/fhir/ValueSet/list-empty-reason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ListEmptyReasonsCode {
    #[prost(enumeration = "list_empty_reasons_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ListEmptyReasonsCode`.
pub mod list_empty_reasons_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Nilknown = 1,
        Notasked = 2,
        Withheld = 3,
        Unavailable = 4,
        Notstarted = 5,
        Closed = 6,
    }
}
/// Example use codes for the List resource - typical kinds of use.
/// See <http://hl7.org/fhir/ValueSet/list-example-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExampleUseCodesforListCode {
    #[prost(enumeration = "example_use_codesfor_list_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ExampleUseCodesforListCode`.
pub mod example_use_codesfor_list_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Alerts = 1,
        Adverserxns = 2,
        Allergies = 3,
        Medications = 4,
        Problems = 5,
        Worklist = 6,
        Waiting = 7,
        Protocols = 8,
        Plans = 9,
    }
}
/// The processing mode that applies to this list
/// See <http://hl7.org/fhir/ValueSet/list-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ListModeCode {
    #[prost(enumeration = "list_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ListModeCode`.
pub mod list_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Working = 1,
        Snapshot = 2,
        Changes = 3,
    }
}
/// Base values for the order of the items in a list resource.
/// See <http://hl7.org/fhir/ValueSet/list-order>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ListOrderCodesCode {
    #[prost(enumeration = "list_order_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ListOrderCodesCode`.
pub mod list_order_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        User = 1,
        System = 2,
        EventDate = 3,
        EntryDate = 4,
        Priority = 5,
        Alphabetic = 6,
        Category = 7,
        Patient = 8,
    }
}
/// The current state of the list
/// See <http://hl7.org/fhir/ValueSet/list-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ListStatusCode {
    #[prost(enumeration = "list_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ListStatusCode`.
pub mod list_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Current = 1,
        Retired = 2,
        EnteredInError = 3,
    }
}
/// Indicates whether a resource instance represents a specific location or a
/// class of locations. See <http://hl7.org/fhir/ValueSet/location-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LocationModeCode {
    #[prost(enumeration = "location_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `LocationModeCode`.
pub mod location_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Instance = 1,
        Kind = 2,
    }
}
/// This example value set defines a set of codes that can be used to indicate
/// the physical form of the Location. See
/// <http://hl7.org/fhir/ValueSet/location-physical-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LocationTypeCode {
    #[prost(enumeration = "location_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `LocationTypeCode`.
pub mod location_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Si = 1,
        Bu = 2,
        Wi = 3,
        Wa = 4,
        Lvl = 5,
        Co = 6,
        Ro = 7,
        Bd = 8,
        Ve = 9,
        Ho = 10,
        Ca = 11,
        Rd = 12,
        Area = 13,
        Jdn = 14,
    }
}
/// Indicates whether the location is still in use.
/// See <http://hl7.org/fhir/ValueSet/location-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct LocationStatusCode {
    #[prost(enumeration = "location_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `LocationStatusCode`.
pub mod location_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Suspended = 2,
        Inactive = 3,
    }
}
/// Codes specifying the type of probability distribution.
/// See <http://hl7.org/fhir/ValueSet/probability-distribution-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProbabilityDistributionTypeCode {
    #[prost(enumeration = "probability_distribution_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ProbabilityDistributionTypeCode`.
pub mod probability_distribution_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        B = 1,
        E = 2,
        F = 3,
        G = 4,
        Ln = 5,
        N = 6,
        T = 7,
        U = 8,
        X2 = 9,
    }
}
/// How to interpret the context
/// See <http://hl7.org/fhir/ValueSet/map-context-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapContextTypeCode {
    #[prost(enumeration = "structure_map_context_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `StructureMapContextTypeCode`.
pub mod structure_map_context_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Type = 1,
        Variable = 2,
    }
}
/// If this is the default rule set to apply for the source type, or this
/// combination of types See <http://hl7.org/fhir/ValueSet/map-group-type-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapGroupTypeModeCode {
    #[prost(enumeration = "structure_map_group_type_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `StructureMapGroupTypeModeCode`.
pub mod structure_map_group_type_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        None = 1,
        Types = 2,
        TypeAndTypes = 3,
    }
}
/// Mode for this instance of data
/// See <http://hl7.org/fhir/ValueSet/map-input-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapInputModeCode {
    #[prost(enumeration = "structure_map_input_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `StructureMapInputModeCode`.
pub mod structure_map_input_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Source = 1,
        Target = 2,
    }
}
/// How the referenced structure is used in this mapping
/// See <http://hl7.org/fhir/ValueSet/map-model-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapModelModeCode {
    #[prost(enumeration = "structure_map_model_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `StructureMapModelModeCode`.
pub mod structure_map_model_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Source = 1,
        Queried = 2,
        Target = 3,
        Produced = 4,
    }
}
/// If field is a list, how to manage the source
/// See <http://hl7.org/fhir/ValueSet/map-source-list-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapSourceListModeCode {
    #[prost(enumeration = "structure_map_source_list_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `StructureMapSourceListModeCode`.
pub mod structure_map_source_list_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        First = 1,
        NotFirst = 2,
        Last = 3,
        NotLast = 4,
        OnlyOne = 5,
    }
}
/// If field is a list, how to manage the production
/// See <http://hl7.org/fhir/ValueSet/map-target-list-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapTargetListModeCode {
    #[prost(enumeration = "structure_map_target_list_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `StructureMapTargetListModeCode`.
pub mod structure_map_target_list_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        First = 1,
        Share = 2,
        Last = 3,
        Collate = 4,
    }
}
/// How data is copied/created
/// See <http://hl7.org/fhir/ValueSet/map-transform>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMapTransformCode {
    #[prost(enumeration = "structure_map_transform_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `StructureMapTransformCode`.
pub mod structure_map_transform_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Create = 1,
        Copy = 2,
        Truncate = 3,
        Escape = 4,
        Cast = 5,
        Append = 6,
        Translate = 7,
        Reference = 8,
        DateOp = 9,
        Uuid = 10,
        Pointer = 11,
        Evaluate = 12,
        Cc = 13,
        C = 14,
        Qty = 15,
        Id = 16,
        Cp = 17,
    }
}
/// A Master Patient Index (MPI) assessment of whether a candidate patient
/// record is a match or not. See <http://hl7.org/fhir/ValueSet/match-grade>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MatchGradeCode {
    #[prost(enumeration = "match_grade_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MatchGradeCode`.
pub mod match_grade_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Certain = 1,
        Probable = 2,
        Possible = 3,
        CertainlyNot = 4,
    }
}
/// The intended usage for supplemental data elements in the measure
/// See <http://hl7.org/fhir/ValueSet/measure-data-usage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureDataUsageCode {
    #[prost(enumeration = "measure_data_usage_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MeasureDataUsageCode`.
pub mod measure_data_usage_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        SupplementalData = 1,
        RiskAdjustmentFactor = 2,
    }
}
/// Different measurement principle supported by the device.
/// See <http://hl7.org/fhir/ValueSet/measurement-principle>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasmntPrincipleCode {
    #[prost(enumeration = "measmnt_principle_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MeasmntPrincipleCode`.
pub mod measmnt_principle_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Other = 1,
        Chemical = 2,
        Electrical = 3,
        Impedance = 4,
        Nuclear = 5,
        Optical = 6,
        Thermal = 7,
        Biological = 8,
        Mechanical = 9,
        Acoustical = 10,
        Manual = 11,
    }
}
/// The type of population
/// See <http://hl7.org/fhir/ValueSet/measure-population>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasurePopulationTypeCode {
    #[prost(enumeration = "measure_population_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MeasurePopulationTypeCode`.
pub mod measure_population_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        InitialPopulation = 1,
        Numerator = 2,
        NumeratorExclusion = 3,
        Denominator = 4,
        DenominatorExclusion = 5,
        DenominatorException = 6,
        MeasurePopulation = 7,
        MeasurePopulationExclusion = 8,
        MeasureObservation = 9,
    }
}
/// The status of the measure report
/// See <http://hl7.org/fhir/ValueSet/measure-report-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureReportStatusCode {
    #[prost(enumeration = "measure_report_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MeasureReportStatusCode`.
pub mod measure_report_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Complete = 1,
        Pending = 2,
        Error = 3,
    }
}
/// The type of the measure report
/// See <http://hl7.org/fhir/ValueSet/measure-report-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureReportTypeCode {
    #[prost(enumeration = "measure_report_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MeasureReportTypeCode`.
pub mod measure_report_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Individual = 1,
        PatientList = 2,
        Summary = 3,
    }
}
/// The scoring type of the measure
/// See <http://hl7.org/fhir/ValueSet/measure-scoring>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureScoringCode {
    #[prost(enumeration = "measure_scoring_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MeasureScoringCode`.
pub mod measure_scoring_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proportion = 1,
        Ratio = 2,
        ContinuousVariable = 3,
        Cohort = 4,
    }
}
/// The type of measure (includes codes from 2.16.840.1.113883.1.11.20368)
/// See <http://hl7.org/fhir/ValueSet/measure-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureTypeCode {
    #[prost(enumeration = "measure_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MeasureTypeCode`.
pub mod measure_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Process = 1,
        Outcome = 2,
        Structure = 3,
        PatientReportedOutcome = 4,
        Composite = 5,
    }
}
/// A coded concept describing where the medication administered is expected to
/// occur See <http://hl7.org/fhir/ValueSet/medication-admin-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationAdministrationCategoryCode {
    #[prost(
        enumeration = "medication_administration_category_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationAdministrationCategoryCode`.
pub mod medication_administration_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Inpatient = 1,
        Outpatient = 2,
        Community = 3,
    }
}
/// A set of codes indicating the current status of a MedicationAdministration.
/// See <http://hl7.org/fhir/ValueSet/medication-admin-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationAdministrationStatusCode {
    #[prost(
        enumeration = "medication_administration_status_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationAdministrationStatusCode`.
pub mod medication_administration_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        InProgress = 1,
        OnHold = 2,
        Completed = 3,
        EnteredInError = 4,
        Stopped = 5,
        Unknown = 6,
    }
}
/// A code describing where the dispensed medication is expected to be consumed
/// or administered See
/// <http://hl7.org/fhir/ValueSet/medication-dispense-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationDispenseCategoryCode {
    #[prost(enumeration = "medication_dispense_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationDispenseCategoryCode`.
pub mod medication_dispense_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Inpatient = 1,
        Outpatient = 2,
        Community = 3,
    }
}
/// A coded concept specifying the state of the dispense event.
/// See <http://hl7.org/fhir/ValueSet/medication-dispense-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationDispenseStatusCode {
    #[prost(enumeration = "medication_dispense_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationDispenseStatusCode`.
pub mod medication_dispense_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Preparation = 1,
        InProgress = 2,
        OnHold = 3,
        Completed = 4,
        EnteredInError = 5,
        Stopped = 6,
    }
}
/// A coded concept defining the kind of container a medication package is
/// packaged in See <http://hl7.org/fhir/ValueSet/medication-package-form>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationContainerCode {
    #[prost(enumeration = "medication_container_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationContainerCode`.
pub mod medication_container_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ampoule = 1,
        Bottle = 2,
        Box = 3,
        Cartridge = 4,
        Container = 5,
        Tube = 6,
        Unitdose = 7,
        Vial = 8,
    }
}
/// A coded concept identifying where the medication ordered is expected to be
/// consumed or administered See
/// <http://hl7.org/fhir/ValueSet/medication-request-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationRequestCategoryCode {
    #[prost(enumeration = "medication_request_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationRequestCategoryCode`.
pub mod medication_request_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Inpatient = 1,
        Outpatient = 2,
        Community = 3,
    }
}
/// The kind of medication order
/// See <http://hl7.org/fhir/ValueSet/medication-request-intent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationRequestIntentCode {
    #[prost(enumeration = "medication_request_intent_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationRequestIntentCode`.
pub mod medication_request_intent_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposal = 1,
        Plan = 2,
        Order = 3,
        InstanceOrder = 4,
    }
}
/// Identifies the level of importance to be assigned to actioning the request
/// See <http://hl7.org/fhir/ValueSet/medication-request-priority>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationRequestPriorityCode {
    #[prost(enumeration = "medication_request_priority_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationRequestPriorityCode`.
pub mod medication_request_priority_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Routine = 1,
        Urgent = 2,
        Stat = 3,
        Asap = 4,
    }
}
/// A coded concept specifying the state of the prescribing event. Describes
/// the lifecycle of the prescription See
/// <http://hl7.org/fhir/ValueSet/medication-request-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationRequestStatusCode {
    #[prost(enumeration = "medication_request_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationRequestStatusCode`.
pub mod medication_request_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        OnHold = 2,
        Cancelled = 3,
        Completed = 4,
        EnteredInError = 5,
        Stopped = 6,
        Draft = 7,
        Unknown = 8,
    }
}
/// A coded concept identifying where the medication included in the
/// medicationstatement is expected to be consumed or administered See
/// <http://hl7.org/fhir/ValueSet/medication-statement-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationStatementCategoryCode {
    #[prost(enumeration = "medication_statement_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationStatementCategoryCode`.
pub mod medication_statement_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Inpatient = 1,
        Outpatient = 2,
        Community = 3,
        Patientspecified = 4,
    }
}
/// A coded concept indicating the current status of a MedicationStatement.
/// See <http://hl7.org/fhir/ValueSet/medication-statement-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationStatementStatusCode {
    #[prost(enumeration = "medication_statement_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationStatementStatusCode`.
pub mod medication_statement_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Completed = 2,
        EnteredInError = 3,
        Intended = 4,
        Stopped = 5,
        OnHold = 6,
    }
}
/// A coded concept identifying level of certainty if patient has taken or has
/// not taken the medication See
/// <http://hl7.org/fhir/ValueSet/medication-statement-taken>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationStatementTakenCode {
    #[prost(enumeration = "medication_statement_taken_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationStatementTakenCode`.
pub mod medication_statement_taken_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Y = 1,
        N = 2,
        Unk = 3,
        Na = 4,
    }
}
/// A coded concept defining if the medication is in active use
/// See <http://hl7.org/fhir/ValueSet/medication-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationStatusCode {
    #[prost(enumeration = "medication_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MedicationStatusCode`.
pub mod medication_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
    }
}
/// One of the message events defined as part of FHIR.
/// See <http://hl7.org/fhir/ValueSet/message-events>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageEventCode {
    #[prost(enumeration = "message_event_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MessageEventCode`.
pub mod message_event_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        CodeSystemExpand = 1,
        MedicationAdministrationComplete = 2,
        MedicationAdministrationNullification = 3,
        MedicationAdministrationRecording = 4,
        MedicationAdministrationUpdate = 5,
        AdminNotify = 6,
        CommunicationRequest = 7,
        DiagnosticreportProvide = 8,
        ObservationProvide = 9,
        PatientLink = 10,
        PatientUnlink = 11,
        ValuesetExpand = 12,
    }
}
/// One of the message events defined as part of FHIR.
/// See <http://hl7.org/fhir/ValueSet/messageheader-response-request>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageHeaderResponseRequestCode {
    #[prost(enumeration = "message_header_response_request_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MessageHeaderResponseRequestCode`.
pub mod message_header_response_request_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Always = 1,
        OnError = 2,
        Never = 3,
        OnSuccess = 4,
    }
}
/// Example Message Reasons. These are the set of codes that might be used an
/// updating an encounter using admin-update. See
/// <http://hl7.org/fhir/ValueSet/message-reason-encounter>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExampleMessageReasonCodesCode {
    #[prost(enumeration = "example_message_reason_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ExampleMessageReasonCodesCode`.
pub mod example_message_reason_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Admit = 1,
        Discharge = 2,
        Absent = 3,
        Return = 4,
        Moved = 5,
        Edit = 6,
    }
}
/// The impact of the content of a message.
/// See <http://hl7.org/fhir/ValueSet/message-significance-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageSignificanceCategoryCode {
    #[prost(enumeration = "message_significance_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MessageSignificanceCategoryCode`.
pub mod message_significance_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Consequence = 1,
        Currency = 2,
        Notification = 3,
    }
}
/// The protocol used for message transport.
/// See <http://hl7.org/fhir/ValueSet/message-transport>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageTransportCode {
    #[prost(enumeration = "message_transport_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MessageTransportCode`.
pub mod message_transport_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Http = 1,
        Ftp = 2,
        Mllp = 3,
    }
}
/// Describes the state of a metric calibration.
/// See <http://hl7.org/fhir/ValueSet/metric-calibration-state>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetricCalibrationStateCode {
    #[prost(enumeration = "device_metric_calibration_state_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DeviceMetricCalibrationStateCode`.
pub mod device_metric_calibration_state_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotCalibrated = 1,
        CalibrationRequired = 2,
        Calibrated = 3,
        Unspecified = 4,
    }
}
/// Describes the type of a metric calibration.
/// See <http://hl7.org/fhir/ValueSet/metric-calibration-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetricCalibrationTypeCode {
    #[prost(enumeration = "device_metric_calibration_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DeviceMetricCalibrationTypeCode`.
pub mod device_metric_calibration_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unspecified = 1,
        Offset = 2,
        Gain = 3,
        TwoPoint = 4,
    }
}
/// Describes the category of the metric.
/// See <http://hl7.org/fhir/ValueSet/metric-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetricCategoryCode {
    #[prost(enumeration = "device_metric_category_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DeviceMetricCategoryCode`.
pub mod device_metric_category_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Measurement = 1,
        Setting = 2,
        Calculation = 3,
        Unspecified = 4,
    }
}
/// Describes the typical color of representation.
/// See <http://hl7.org/fhir/ValueSet/metric-color>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetricColorCode {
    #[prost(enumeration = "device_metric_color_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DeviceMetricColorCode`.
pub mod device_metric_color_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Black = 1,
        Red = 2,
        Green = 3,
        Yellow = 4,
        Blue = 5,
        Magenta = 6,
        Cyan = 7,
        White = 8,
    }
}
/// Describes the operational status of the DeviceMetric.
/// See <http://hl7.org/fhir/ValueSet/metric-operational-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetricOperationalStatusCode {
    #[prost(
        enumeration = "device_metric_operational_status_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DeviceMetricOperationalStatusCode`.
pub mod device_metric_operational_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        On = 1,
        Off = 2,
        Standby = 3,
        EnteredInError = 4,
    }
}
/// A code that represents the preferred display order of the components of a
/// human name See <http://hl7.org/fhir/ValueSet/name-assembly-order>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HumanNameAssemblyOrderCode {
    #[prost(enumeration = "human_name_assembly_order_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `HumanNameAssemblyOrderCode`.
pub mod human_name_assembly_order_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Nl1 = 1,
        Nl2 = 2,
        Nl3 = 3,
        Nl4 = 4,
    }
}
/// A set of codes for each different representation of a name.
/// See <http://hl7.org/fhir/ValueSet/name-v3-representation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NameRepresentationUseCode {
    #[prost(enumeration = "name_representation_use_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `NameRepresentationUseCode`.
pub mod name_representation_use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Abc = 1,
        Ide = 2,
        Syl = 3,
    }
}
/// Identifies the style of unique identifier used to identify a namespace.
/// See <http://hl7.org/fhir/ValueSet/namingsystem-identifier-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NamingSystemIdentifierTypeCode {
    #[prost(enumeration = "naming_system_identifier_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `NamingSystemIdentifierTypeCode`.
pub mod naming_system_identifier_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Oid = 1,
        Uuid = 2,
        Uri = 3,
        Other = 4,
    }
}
/// Identifies the purpose of the naming system.
/// See <http://hl7.org/fhir/ValueSet/namingsystem-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NamingSystemTypeCode {
    #[prost(enumeration = "naming_system_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `NamingSystemTypeCode`.
pub mod naming_system_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Codesystem = 1,
        Identifier = 2,
        Root = 3,
    }
}
/// The type of network access point of this agent in the audit event
/// See <http://hl7.org/fhir/ValueSet/network-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEventAgentNetworkTypeCode {
    #[prost(enumeration = "audit_event_agent_network_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AuditEventAgentNetworkTypeCode`.
pub mod audit_event_agent_network_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        MachineName = 1,
        IpAddress = 2,
        TelephoneNumber = 3,
        EmailAddress = 4,
        Uri = 5,
    }
}
/// The presentation types of notes.
/// See <http://hl7.org/fhir/ValueSet/note-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NoteTypeCode {
    #[prost(enumeration = "note_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `NoteTypeCode`.
pub mod note_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Display = 1,
        Print = 2,
        Printoper = 3,
    }
}
/// A collection of codes specifying why a valid value is not present.
/// See <http://hl7.org/fhir/ValueSet/v3-NullFlavor>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NullFlavorCode {
    #[prost(enumeration = "null_flavor_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `NullFlavorCode`.
pub mod null_flavor_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ni = 1,
        Inv = 2,
        Der = 3,
        Oth = 4,
        Ninf = 5,
        Pinf = 6,
        Unc = 7,
        Msk = 8,
        Na = 9,
        Unk = 10,
        Asku = 11,
        Nav = 12,
        Nask = 13,
        Navu = 14,
        Qs = 15,
        Trc = 16,
        Np = 17,
    }
}
/// Codes specifying the state of the request. Describes the lifecycle of the
/// nutrition order. See <http://hl7.org/fhir/ValueSet/nutrition-request-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NutritionOrderStatusCode {
    #[prost(enumeration = "nutrition_order_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `NutritionOrderStatusCode`.
pub mod nutrition_order_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposed = 1,
        Draft = 2,
        Planned = 3,
        Requested = 4,
        Active = 5,
        OnHold = 6,
        Completed = 7,
        Cancelled = 8,
        EnteredInError = 9,
    }
}
/// Observation Category codes.
/// See <http://hl7.org/fhir/ValueSet/observation-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationCategoryCodesCode {
    #[prost(enumeration = "observation_category_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ObservationCategoryCodesCode`.
pub mod observation_category_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        SocialHistory = 1,
        VitalSigns = 2,
        Imaging = 3,
        Laboratory = 4,
        Procedure = 5,
        Survey = 6,
        Exam = 7,
        Therapy = 8,
    }
}
/// Codes specifying how two observations are related.
/// See <http://hl7.org/fhir/ValueSet/observation-relationshiptypes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationRelationshipTypeCode {
    #[prost(enumeration = "observation_relationship_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ObservationRelationshipTypeCode`.
pub mod observation_relationship_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        HasMember = 1,
        DerivedFrom = 2,
        SequelTo = 3,
        Replaces = 4,
        QualifiedBy = 5,
        InterferedBy = 6,
    }
}
/// The statistical operation parameter -\
/// See <http://hl7.org/fhir/ValueSet/observation-statistics>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StatisticsCodeCode {
    #[prost(enumeration = "statistics_code_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `StatisticsCodeCode`.
pub mod statistics_code_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Average = 1,
        Maximum = 2,
        Minimum = 3,
        Count = 4,
        Totalcount = 5,
        Median = 6,
        StdDev = 7,
        Sum = 8,
        Variance = 9,
        TwentyPercent = 10,
        EightyPercent = 11,
        FourLower = 12,
        FourUpper = 13,
        FourDev = 14,
        FiveOne = 15,
        FiveTwo = 16,
        FiveThree = 17,
        FiveFour = 18,
        Skew = 19,
        Kurtosis = 20,
        Regression = 21,
    }
}
/// Codes providing the status of an observation.
/// See <http://hl7.org/fhir/ValueSet/observation-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationStatusCode {
    #[prost(enumeration = "observation_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ObservationStatusCode`.
pub mod observation_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Registered = 1,
        Preliminary = 2,
        Final = 3,
        Amended = 4,
        Corrected = 5,
        Cancelled = 6,
        EnteredInError = 7,
        Unknown = 8,
    }
}
/// Codes representing the current status of the device - on, off, suspended,
/// etc. See <http://hl7.org/fhir/ValueSet/operational-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceComponentOperationalStatusCode {
    #[prost(
        enumeration = "device_component_operational_status_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DeviceComponentOperationalStatusCode`.
pub mod device_component_operational_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Off = 1,
        On = 2,
        NotReady = 3,
        Standby = 4,
        TransducDiscon = 5,
        HwDiscon = 6,
        EnteredInError = 7,
    }
}
/// Whether an operation is a normal operation or a query.
/// See <http://hl7.org/fhir/ValueSet/operation-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationKindCode {
    #[prost(enumeration = "operation_kind_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `OperationKindCode`.
pub mod operation_kind_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Operation = 1,
        Query = 2,
    }
}
/// Operation Outcome codes used by FHIR test servers (see Implementation file
/// translations.xml) See <http://hl7.org/fhir/ValueSet/operation-outcome>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationOutcomeCodesCode {
    #[prost(enumeration = "operation_outcome_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `OperationOutcomeCodesCode`.
pub mod operation_outcome_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        MsgAuthRequired = 1,
        MsgBadFormat = 2,
        MsgBadSyntax = 3,
        MsgCantParseContent = 4,
        MsgCantParseRoot = 5,
        MsgCreated = 6,
        MsgDateFormat = 7,
        MsgDeleted = 8,
        MsgDeletedDone = 9,
        MsgDeletedId = 10,
        MsgDuplicateId = 11,
        MsgErrorParsing = 12,
        MsgIdInvalid = 13,
        MsgIdTooLong = 14,
        MsgInvalidId = 15,
        MsgJsonObject = 16,
        MsgLocalFail = 17,
        MsgNoMatch = 18,
        MsgNoExist = 19,
        MsgNoModule = 20,
        MsgNoSummary = 21,
        MsgOpNotAllowed = 22,
        MsgParamChained = 23,
        MsgParamNoRepeat = 24,
        MsgParamUnknown = 25,
        MsgParamInvalid = 26,
        MsgParamModifierInvalid = 27,
        MsgResourceExampleProtected = 28,
        MsgResourceIdFail = 29,
        MsgResourceNotAllowed = 30,
        MsgResourceRequired = 31,
        MsgResourceIdMismatch = 32,
        MsgResourceIdMissing = 33,
        MsgResourceTypeMismatch = 34,
        MsgSortUnknown = 35,
        MsgTransactionDuplicateId = 36,
        MsgTransactionMissingId = 37,
        MsgUnhandledNodeType = 38,
        MsgUnknownContent = 39,
        MsgUnknownOperation = 40,
        MsgUnknownType = 41,
        MsgUpdated = 42,
        MsgVersionAware = 43,
        MsgVersionAwareConflict = 44,
        MsgVersionAwareUrl = 45,
        MsgWrongNs = 46,
        SearchMultiple = 47,
        UpdateMultipleMatches = 48,
        DeleteMultipleMatches = 49,
        SearchNone = 50,
    }
}
/// The status of a resource narrative
/// See <http://hl7.org/fhir/ValueSet/narrative-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NarrativeStatusCode {
    #[prost(enumeration = "narrative_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `NarrativeStatusCode`.
pub mod narrative_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Generated = 1,
        Extensions = 2,
        Additional = 3,
        Empty = 4,
    }
}
/// Whether an operation parameter is an input or an output parameter.
/// See <http://hl7.org/fhir/ValueSet/operation-parameter-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationParameterUseCode {
    #[prost(enumeration = "operation_parameter_use_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `OperationParameterUseCode`.
pub mod operation_parameter_use_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        In = 1,
        Out = 2,
    }
}
/// This example value set defines a set of codes that can be used to indicate
/// a type of organization. See <http://hl7.org/fhir/ValueSet/organization-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OrganizationTypeCode {
    #[prost(enumeration = "organization_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `OrganizationTypeCode`.
pub mod organization_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Prov = 1,
        Dept = 2,
        Team = 3,
        Govt = 4,
        Ins = 5,
        Edu = 6,
        Reli = 7,
        Crs = 8,
        Cg = 9,
        Bus = 10,
        Other = 11,
    }
}
/// Codes identifying groupings of parameters; e.g. Cardiovascular.
/// See <http://hl7.org/fhir/ValueSet/parameter-group>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceComponentParameterGroupCode {
    #[prost(
        enumeration = "device_component_parameter_group_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DeviceComponentParameterGroupCode`.
pub mod device_component_parameter_group_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Haemodynamic = 1,
        Ecg = 2,
        Respiratory = 3,
        Ventilation = 4,
        Neurological = 5,
        DrugDelivery = 6,
        FluidChemistry = 7,
        BloodChemistry = 8,
        Miscellaneous = 9,
    }
}
/// Is the Participant required to attend the appointment.
/// See <http://hl7.org/fhir/ValueSet/participantrequired>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ParticipantRequiredCode {
    #[prost(enumeration = "participant_required_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ParticipantRequiredCode`.
pub mod participant_required_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Required = 1,
        Optional = 2,
        InformationOnly = 3,
    }
}
/// The Participation status of an appointment.
/// See <http://hl7.org/fhir/ValueSet/participationstatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ParticipationStatusCode {
    #[prost(enumeration = "participation_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ParticipationStatusCode`.
pub mod participation_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Accepted = 1,
        Declined = 2,
        Tentative = 3,
        NeedsAction = 4,
    }
}
/// The type of PlanDefinition
/// See <http://hl7.org/fhir/ValueSet/plan-definition-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PlanDefinitionTypeCode {
    #[prost(enumeration = "plan_definition_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `PlanDefinitionTypeCode`.
pub mod plan_definition_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        OrderSet = 1,
        Protocol = 2,
        EcaRule = 3,
    }
}
/// The type of PostalAddressUse
/// See <http://hl7.org/fhir/ValueSet/postal-address-use>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PostalAddressUseTypeCode {
    #[prost(enumeration = "postal_address_use_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `PostalAddressUseTypeCode`.
pub mod postal_address_use_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        BadAddress = 1,
        ConfidentialAddress = 2,
        PrimaryHome = 3,
        VacationHome = 4,
        Direct = 5,
        Public = 6,
        PhysicalVisitAddress = 7,
        PostalAddress = 8,
    }
}
/// This example value set defines a set of codes that can be used to indicate
/// the role of a Practitioner. See
/// <http://hl7.org/fhir/ValueSet/practitioner-role>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PractitionerRoleCode {
    #[prost(enumeration = "practitioner_role_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `PractitionerRoleCode`.
pub mod practitioner_role_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Doctor = 1,
        Nurse = 2,
        Pharmacist = 3,
        Researcher = 4,
        Teacher = 5,
        Ict = 6,
    }
}
/// This example value set defines a set of codes that can be used to indicate
/// the specialty of a Practitioner. See
/// <http://hl7.org/fhir/ValueSet/practitioner-specialty>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PractitionerSpecialtyCode {
    #[prost(enumeration = "practitioner_specialty_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `PractitionerSpecialtyCode`.
pub mod practitioner_specialty_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Cardio = 1,
        Dent = 2,
        Dietary = 3,
        Midw = 4,
        Sysarch = 5,
    }
}
/// This value set is provided as an example. The value set to instantiate this
/// attribute should be drawn from a robust terminology code system that
/// consists of or contains concepts to support the procedure performance
/// process. See <http://hl7.org/fhir/ValueSet/procedure-progress-status-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProcedureProgressStatusCodesCode {
    #[prost(enumeration = "procedure_progress_status_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ProcedureProgressStatusCodesCode`.
pub mod procedure_progress_status_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        InOperatingRoom = 1,
        Prepared = 2,
        AnesthesiaInduced = 3,
        OpenIncision = 4,
        ClosedIncision = 5,
        InRecoveryRoom = 6,
    }
}
/// How an entity was used in an activity.
/// See <http://hl7.org/fhir/ValueSet/provenance-entity-role>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProvenanceEntityRoleCode {
    #[prost(enumeration = "provenance_entity_role_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ProvenanceEntityRoleCode`.
pub mod provenance_entity_role_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Derivation = 1,
        Revision = 2,
        Quotation = 3,
        Source = 4,
        Removal = 5,
    }
}
/// The lifecycle status of a Value Set or Concept Map.
/// See <http://hl7.org/fhir/ValueSet/publication-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PublicationStatusCode {
    #[prost(enumeration = "publication_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `PublicationStatusCode`.
pub mod publication_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Active = 2,
        Retired = 3,
        Unknown = 4,
    }
}
/// Type for quality report
/// See <http://hl7.org/fhir/ValueSet/quality-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QualityTypeCode {
    #[prost(enumeration = "quality_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `QualityTypeCode`.
pub mod quality_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Indel = 1,
        Snp = 2,
        Unknown = 3,
    }
}
/// Flags an element as having unlimited repetitions
/// See <http://hl7.org/fhir/ValueSet/question-max-occurs>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MaxOccursCode {
    #[prost(enumeration = "max_occurs_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `MaxOccursCode`.
pub mod max_occurs_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Max = 1,
    }
}
/// Lifecycle status of the questionnaire response.
/// See <http://hl7.org/fhir/ValueSet/questionnaire-answers-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireResponseStatusCode {
    #[prost(enumeration = "questionnaire_response_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `QuestionnaireResponseStatusCode`.
pub mod questionnaire_response_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        InProgress = 1,
        Completed = 2,
        Amended = 3,
        EnteredInError = 4,
        Stopped = 5,
    }
}
/// Codes defining the purpose of a Questionnaire item of type 'text'.
/// See <http://hl7.org/fhir/ValueSet/questionnaire-display-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireTextCategoriesCode {
    #[prost(enumeration = "questionnaire_text_categories_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `QuestionnaireTextCategoriesCode`.
pub mod questionnaire_text_categories_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Instructions = 1,
        Security = 2,
    }
}
/// Starter set of user interface control/display mechanisms that might be used
/// when rendering an item in a questionnaire. See
/// <http://hl7.org/fhir/ValueSet/questionnaire-item-control>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireItemUiControlCodesCode {
    #[prost(
        enumeration = "questionnaire_item_ui_control_codes_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `QuestionnaireItemUIControlCodesCode`.
pub mod questionnaire_item_ui_control_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        List = 1,
        Table = 2,
        Header = 3,
        Footer = 4,
        Inline = 5,
        Prompt = 6,
        Unit = 7,
        Lower = 8,
        Upper = 9,
        Flyover = 10,
        Help = 11,
        Autocomplete = 12,
        DropDown = 13,
        CheckBox = 14,
        Lookup = 15,
        RadioButton = 16,
        Slider = 17,
        Spinner = 18,
        TextBox = 19,
    }
}
/// Identifies the modes of usage of a questionnaire that should enable a
/// particular questionnaire item See
/// <http://hl7.org/fhir/ValueSet/questionnaire-usage-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireItemUsageModeCode {
    #[prost(enumeration = "questionnaire_item_usage_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `QuestionnaireItemUsageModeCode`.
pub mod questionnaire_item_usage_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        CaptureDisplay = 1,
        Capture = 2,
        Display = 3,
        DisplayNonEmpty = 4,
        CaptureDisplayNonEmpty = 5,
    }
}
/// Statement about the degree of clinical certainty that a specific substance
/// was the cause of the manifestation in a reaction event. See
/// <http://hl7.org/fhir/ValueSet/reaction-event-certainty>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceCertaintyCode {
    #[prost(enumeration = "allergy_intolerance_certainty_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AllergyIntoleranceCertaintyCode`.
pub mod allergy_intolerance_certainty_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unlikely = 1,
        Likely = 2,
        Confirmed = 3,
        Unknown = 4,
    }
}
/// Clinical assessment of the severity of a reaction event as a whole,
/// potentially considering multiple different manifestations. See
/// <http://hl7.org/fhir/ValueSet/reaction-event-severity>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntoleranceSeverityCode {
    #[prost(enumeration = "allergy_intolerance_severity_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `AllergyIntoleranceSeverityCode`.
pub mod allergy_intolerance_severity_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Mild = 1,
        Moderate = 2,
        Severe = 3,
    }
}
/// This value set is provided as an example. The value set to instantiate this
/// attribute should be drawn from a robust terminology code system that
/// consists of or contains concepts to support the medication process. See
/// <http://hl7.org/fhir/ValueSet/reason-medication-given-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReasonMedicationGivenCodesCode {
    #[prost(enumeration = "reason_medication_given_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ReasonMedicationGivenCodesCode`.
pub mod reason_medication_given_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        A = 1,
        B = 2,
        C = 3,
    }
}
/// A set of flags that defines how references are supported.
/// See <http://hl7.org/fhir/ValueSet/reference-handling-policy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReferenceHandlingPolicyCode {
    #[prost(enumeration = "reference_handling_policy_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ReferenceHandlingPolicyCode`.
pub mod reference_handling_policy_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Literal = 1,
        Logical = 2,
        Resolves = 3,
        Enforced = 4,
        Local = 5,
    }
}
/// The type of relationship to the related artifact
/// See <http://hl7.org/fhir/ValueSet/related-artifact-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RelatedArtifactTypeCode {
    #[prost(enumeration = "related_artifact_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `RelatedArtifactTypeCode`.
pub mod related_artifact_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Documentation = 1,
        Justification = 2,
        Citation = 3,
        Predecessor = 4,
        Successor = 5,
        DerivedFrom = 6,
        DependsOn = 7,
        ComposedOf = 8,
    }
}
/// This value set defines a set of codes that can be used to indicate the
/// meaning/use of a reference range for a particular target population. See
/// <http://hl7.org/fhir/ValueSet/referencerange-meaning>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ObservationReferenceRangeMeaningCodesCode {
    #[prost(
        enumeration = "observation_reference_range_meaning_codes_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ObservationReferenceRangeMeaningCodesCode`.
pub mod observation_reference_range_meaning_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Normal = 1,
        Recommended = 2,
        Treatment = 3,
        Therapeutic = 4,
        Pre = 5,
        Post = 6,
        PrePuberty = 7,
        Follicular = 8,
        Midcycle = 9,
        Luteal = 10,
        Postmeopausal = 11,
    }
}
/// The results of executing an action.
/// See <http://hl7.org/fhir/ValueSet/report-action-result-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestReportActionResultCode {
    #[prost(enumeration = "test_report_action_result_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TestReportActionResultCode`.
pub mod test_report_action_result_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Pass = 1,
        Skip = 2,
        Fail = 3,
        Warning = 4,
        Error = 5,
    }
}
/// The type of participant.
/// See <http://hl7.org/fhir/ValueSet/report-participant-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestReportParticipantTypeCode {
    #[prost(enumeration = "test_report_participant_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TestReportParticipantTypeCode`.
pub mod test_report_participant_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        TestEngine = 1,
        Client = 2,
        Server = 3,
    }
}
/// The reported execution result.
/// See <http://hl7.org/fhir/ValueSet/report-result-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestReportResultCode {
    #[prost(enumeration = "test_report_result_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TestReportResultCode`.
pub mod test_report_result_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Pass = 1,
        Fail = 2,
        Pending = 3,
    }
}
/// The current status of the test report.
/// See <http://hl7.org/fhir/ValueSet/report-status-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestReportStatusCode {
    #[prost(enumeration = "test_report_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TestReportStatusCode`.
pub mod test_report_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Completed = 1,
        InProgress = 2,
        Waiting = 3,
        Stopped = 4,
        EnteredInError = 5,
    }
}
/// Type for access of external URI
/// See <http://hl7.org/fhir/ValueSet/repository-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RepositoryTypeCode {
    #[prost(enumeration = "repository_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `RepositoryTypeCode`.
pub mod repository_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Directlink = 1,
        Openapi = 2,
        Login = 3,
        Oauth = 4,
        Other = 5,
    }
}
/// Codes indicating the degree of authority/intentionality associated with a
/// request See <http://hl7.org/fhir/ValueSet/request-intent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RequestIntentCode {
    #[prost(enumeration = "request_intent_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `RequestIntentCode`.
pub mod request_intent_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Proposal = 1,
        Plan = 2,
        Order = 3,
        OriginalOrder = 4,
        ReflexOrder = 5,
        FillerOrder = 6,
        InstanceOrder = 7,
        Option = 8,
    }
}
/// The clinical priority of a diagnostic order.
/// See <http://hl7.org/fhir/ValueSet/request-priority>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RequestPriorityCode {
    #[prost(enumeration = "request_priority_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `RequestPriorityCode`.
pub mod request_priority_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Routine = 1,
        Urgent = 2,
        Asap = 3,
        Stat = 4,
    }
}
/// Codes identifying the stage lifecycle stage of a request
/// See <http://hl7.org/fhir/ValueSet/request-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RequestStatusCode {
    #[prost(enumeration = "request_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `RequestStatusCode`.
pub mod request_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Active = 2,
        Suspended = 3,
        Cancelled = 4,
        Completed = 5,
        EnteredInError = 6,
        Unknown = 7,
    }
}
/// Codes that convey the current status of the research study
/// See <http://hl7.org/fhir/ValueSet/research-study-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchStudyStatusCode {
    #[prost(enumeration = "research_study_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ResearchStudyStatusCode`.
pub mod research_study_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        InProgress = 2,
        Suspended = 3,
        Stopped = 4,
        Completed = 5,
        EnteredInError = 6,
    }
}
/// Indicates the progression of a study subject through a study
/// See <http://hl7.org/fhir/ValueSet/research-subject-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchSubjectStatusCode {
    #[prost(enumeration = "research_subject_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ResearchSubjectStatusCode`.
pub mod research_subject_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Candidate = 1,
        Enrolled = 2,
        Active = 3,
        Suspended = 4,
        Withdrawn = 5,
        Completed = 6,
    }
}
/// The type of payee Resource
/// See <http://hl7.org/fhir/ValueSet/resource-type-link>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PayeeResourceTypeCode {
    #[prost(enumeration = "payee_resource_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `PayeeResourceTypeCode`.
pub mod payee_resource_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Organization = 1,
        Patient = 2,
        Practitioner = 3,
        Relatedperson = 4,
    }
}
/// One of the resource types defined as part of FHIR.
/// See <http://hl7.org/fhir/ValueSet/resource-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResourceTypeCode {
    #[prost(enumeration = "resource_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ResourceTypeCode`.
pub mod resource_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Account = 1,
        ActivityDefinition = 2,
        AdverseEvent = 3,
        AllergyIntolerance = 4,
        Appointment = 5,
        AppointmentResponse = 6,
        AuditEvent = 7,
        Basic = 8,
        Binary = 9,
        BodySite = 10,
        Bundle = 11,
        CapabilityStatement = 12,
        CarePlan = 13,
        CareTeam = 14,
        ChargeItem = 15,
        Claim = 16,
        ClaimResponse = 17,
        ClinicalImpression = 18,
        CodeSystem = 19,
        Communication = 20,
        CommunicationRequest = 21,
        CompartmentDefinition = 22,
        Composition = 23,
        ConceptMap = 24,
        Condition = 25,
        Consent = 26,
        Contract = 27,
        Coverage = 28,
        DataElement = 29,
        DetectedIssue = 30,
        Device = 31,
        DeviceComponent = 32,
        DeviceMetric = 33,
        DeviceRequest = 34,
        DeviceUseStatement = 35,
        DiagnosticReport = 36,
        DocumentManifest = 37,
        DocumentReference = 38,
        DomainResource = 39,
        EligibilityRequest = 40,
        EligibilityResponse = 41,
        Encounter = 42,
        Endpoint = 43,
        EnrollmentRequest = 44,
        EnrollmentResponse = 45,
        EpisodeOfCare = 46,
        ExpansionProfile = 47,
        ExplanationOfBenefit = 48,
        FamilyMemberHistory = 49,
        Flag = 50,
        Goal = 51,
        GraphDefinition = 52,
        Group = 53,
        GuidanceResponse = 54,
        HealthcareService = 55,
        ImagingManifest = 56,
        ImagingStudy = 57,
        Immunization = 58,
        ImmunizationRecommendation = 59,
        ImplementationGuide = 60,
        Library = 61,
        Linkage = 62,
        List = 63,
        Location = 64,
        Measure = 65,
        MeasureReport = 66,
        Media = 67,
        Medication = 68,
        MedicationAdministration = 69,
        MedicationDispense = 70,
        MedicationRequest = 71,
        MedicationStatement = 72,
        MessageDefinition = 73,
        MessageHeader = 74,
        NamingSystem = 75,
        NutritionOrder = 76,
        Observation = 77,
        OperationDefinition = 78,
        OperationOutcome = 79,
        Organization = 80,
        Parameters = 81,
        Patient = 82,
        PaymentNotice = 83,
        PaymentReconciliation = 84,
        Person = 85,
        PlanDefinition = 86,
        Practitioner = 87,
        PractitionerRole = 88,
        Procedure = 89,
        ProcedureRequest = 90,
        ProcessRequest = 91,
        ProcessResponse = 92,
        Provenance = 93,
        Questionnaire = 94,
        QuestionnaireResponse = 95,
        ReferralRequest = 96,
        RelatedPerson = 97,
        RequestGroup = 98,
        ResearchStudy = 99,
        ResearchSubject = 100,
        Resource = 101,
        RiskAssessment = 102,
        Schedule = 103,
        SearchParameter = 104,
        Sequence = 105,
        ServiceDefinition = 106,
        Slot = 107,
        Specimen = 108,
        StructureDefinition = 109,
        StructureMap = 110,
        Subscription = 111,
        Substance = 112,
        SupplyDelivery = 113,
        SupplyRequest = 114,
        Task = 115,
        TestReport = 116,
        TestScript = 117,
        Set = 118,
        VisionPrescription = 119,
    }
}
/// Codes indicating the type of validation to perform
/// See <http://hl7.org/fhir/ValueSet/resource-validation-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResourceValidationModeCode {
    #[prost(enumeration = "resource_validation_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ResourceValidationModeCode`.
pub mod resource_validation_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Create = 1,
        Update = 2,
        Delete = 3,
    }
}
/// The kind of response to a message
/// See <http://hl7.org/fhir/ValueSet/response-code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResponseTypeCode {
    #[prost(enumeration = "response_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ResponseTypeCode`.
pub mod response_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Ok = 1,
        TransientError = 2,
        FatalError = 3,
    }
}
/// The mode of a RESTful capability statement.
/// See <http://hl7.org/fhir/ValueSet/restful-capability-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RestfulCapabilityModeCode {
    #[prost(enumeration = "restful_capability_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `RestfulCapabilityModeCode`.
pub mod restful_capability_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Client = 1,
        Server = 2,
    }
}
/// Types of security services used with FHIR.
/// See <http://hl7.org/fhir/ValueSet/restful-security-service>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RestfulSecurityServiceCode {
    #[prost(enumeration = "restful_security_service_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `RestfulSecurityServiceCode`.
pub mod restful_security_service_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Oauth = 1,
        SmartOnFhir = 2,
        Ntlm = 3,
        Basic = 4,
        Kerberos = 5,
        Certificates = 6,
    }
}
/// Codes representing the likelihood of a particular outcome in a risk
/// assessment. See <http://hl7.org/fhir/ValueSet/risk-probability>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RiskProbabilityCode {
    #[prost(enumeration = "risk_probability_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `RiskProbabilityCode`.
pub mod risk_probability_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Negligible = 1,
        Low = 2,
        Moderate = 3,
        High = 4,
        Certain = 5,
    }
}
/// What Search Comparator Codes are supported in search
/// See <http://hl7.org/fhir/ValueSet/search-comparator>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SearchComparatorCode {
    #[prost(enumeration = "search_comparator_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SearchComparatorCode`.
pub mod search_comparator_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Eq = 1,
        Ne = 2,
        Gt = 3,
        Lt = 4,
        Ge = 5,
        Le = 6,
        Sa = 7,
        Eb = 8,
        Ap = 9,
    }
}
/// Why an entry is in the result set - whether it's included as a match or
/// because of an _include requirement. See
/// <http://hl7.org/fhir/ValueSet/search-entry-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SearchEntryModeCode {
    #[prost(enumeration = "search_entry_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SearchEntryModeCode`.
pub mod search_entry_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Match = 1,
        Include = 2,
        Outcome = 3,
    }
}
/// A supported modifier for a search parameter.
/// See <http://hl7.org/fhir/ValueSet/search-modifier-code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SearchModifierCodeCode {
    #[prost(enumeration = "search_modifier_code_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SearchModifierCodeCode`.
pub mod search_modifier_code_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Missing = 1,
        Exact = 2,
        Contains = 3,
        Not = 4,
        Text = 5,
        In = 6,
        NotIn = 7,
        Below = 8,
        Above = 9,
        Type = 10,
    }
}
/// Data types allowed to be used for search parameters.
/// See <http://hl7.org/fhir/ValueSet/search-param-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SearchParamTypeCode {
    #[prost(enumeration = "search_param_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SearchParamTypeCode`.
pub mod search_param_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Number = 1,
        Date = 2,
        String = 3,
        Token = 4,
        Reference = 5,
        Composite = 6,
        Quantity = 7,
        Uri = 8,
    }
}
/// How a search parameter relates to the set of elements returned by
/// evaluating its xpath query. See
/// <http://hl7.org/fhir/ValueSet/search-xpath-usage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct XPathUsageTypeCode {
    #[prost(enumeration = "x_path_usage_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `XPathUsageTypeCode`.
pub mod x_path_usage_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Normal = 1,
        Phonetic = 2,
        Nearby = 3,
        Distance = 4,
        Other = 5,
    }
}
/// Type if a sequence -- DNA, RNA, or amino acid sequence
/// See <http://hl7.org/fhir/ValueSet/sequence-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SequenceTypeCode {
    #[prost(enumeration = "sequence_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SequenceTypeCode`.
pub mod sequence_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Aa = 1,
        Dna = 2,
        Rna = 3,
    }
}
/// The code(s) that detail the conditions under which the healthcare service
/// is available/offered. See
/// <http://hl7.org/fhir/ValueSet/service-provision-conditions>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ServiceProvisionConditionsCode {
    #[prost(enumeration = "service_provision_conditions_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ServiceProvisionConditionsCode`.
pub mod service_provision_conditions_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Free = 1,
        Disc = 2,
        Cost = 3,
    }
}
/// The methods of referral can be used when referring to a specific
/// HealthCareService resource. See
/// <http://hl7.org/fhir/ValueSet/service-referral-method>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReferralMethodCode {
    #[prost(enumeration = "referral_method_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ReferralMethodCode`.
pub mod referral_method_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Fax = 1,
        Phone = 2,
        Elec = 3,
        Semail = 4,
        Mail = 5,
    }
}
/// The free/busy status of the slot.
/// See <http://hl7.org/fhir/ValueSet/slotstatus>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SlotStatusCode {
    #[prost(enumeration = "slot_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SlotStatusCode`.
pub mod slot_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Busy = 1,
        Free = 2,
        BusyUnavailable = 3,
        BusyTentative = 4,
        EnteredInError = 5,
    }
}
/// A set of generally useful codes defined so they can be included in value
/// sets. See <http://hl7.org/fhir/ValueSet/special-values>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecialValuesCode {
    #[prost(enumeration = "special_values_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SpecialValuesCode`.
pub mod special_values_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        True = 1,
        False = 2,
        Trace = 3,
        Sufficient = 4,
        Withdrawn = 5,
        NilKnown = 6,
    }
}
/// Codes for device specification types such as serial number, part number,
/// hardware revision, software revision, etc. See
/// <http://hl7.org/fhir/ValueSet/specification-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceSpecificationSpecTypeCode {
    #[prost(enumeration = "device_specification_spec_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `DeviceSpecificationSpecTypeCode`.
pub mod device_specification_spec_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Unspecified = 1,
        SerialNumber = 2,
        PartNumber = 3,
        HardwareRevision = 4,
        SoftwareRevision = 5,
        FirmwareRevision = 6,
        ProtocolRevision = 7,
        Gmdn = 8,
    }
}
/// Codes providing the status/availability of a specimen.
/// See <http://hl7.org/fhir/ValueSet/specimen-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SpecimenStatusCode {
    #[prost(enumeration = "specimen_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SpecimenStatusCode`.
pub mod specimen_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Available = 1,
        Unavailable = 2,
        Unsatisfactory = 3,
        EnteredInError = 4,
    }
}
/// Defines the type of structure that a definition is describing.
/// See <http://hl7.org/fhir/ValueSet/structure-definition-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinitionKindCode {
    #[prost(enumeration = "structure_definition_kind_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `StructureDefinitionKindCode`.
pub mod structure_definition_kind_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        PrimitiveType = 1,
        ComplexType = 2,
        Resource = 3,
        Logical = 4,
    }
}
/// The type of method used to execute a subscription.
/// See <http://hl7.org/fhir/ValueSet/subscription-channel-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubscriptionChannelTypeCode {
    #[prost(enumeration = "subscription_channel_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SubscriptionChannelTypeCode`.
pub mod subscription_channel_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        RestHook = 1,
        Websocket = 2,
        Email = 3,
        Sms = 4,
        Message = 5,
    }
}
/// The status of a subscription.
/// See <http://hl7.org/fhir/ValueSet/subscription-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubscriptionStatusCode {
    #[prost(enumeration = "subscription_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SubscriptionStatusCode`.
pub mod subscription_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Requested = 1,
        Active = 2,
        Error = 3,
        Off = 4,
    }
}
/// Tags to put on a resource after subscriptions have been sent.
/// See <http://hl7.org/fhir/ValueSet/subscription-tag>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubscriptionTagCode {
    #[prost(enumeration = "subscription_tag_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SubscriptionTagCode`.
pub mod subscription_tag_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Queued = 1,
        Delivered = 2,
    }
}
/// Substance category codes
/// See <http://hl7.org/fhir/ValueSet/substance-category>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SubstanceCategoryCodesCode {
    #[prost(enumeration = "substance_category_codes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SubstanceCategoryCodesCode`.
pub mod substance_category_codes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Allergen = 1,
        Biological = 2,
        Body = 3,
        Chemical = 4,
        Food = 5,
        Drug = 6,
        Material = 7,
    }
}
/// A code to indicate if the substance is actively used
/// See <http://hl7.org/fhir/ValueSet/substance-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FhirSubstanceStatusCode {
    #[prost(enumeration = "fhir_substance_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `FHIRSubstanceStatusCode`.
pub mod fhir_substance_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Active = 1,
        Inactive = 2,
        EnteredInError = 3,
    }
}
/// Status of the supply delivery.
/// See <http://hl7.org/fhir/ValueSet/supplydelivery-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyDeliveryStatusCode {
    #[prost(enumeration = "supply_delivery_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SupplyDeliveryStatusCode`.
pub mod supply_delivery_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        InProgress = 1,
        Completed = 2,
        Abandoned = 3,
        EnteredInError = 4,
    }
}
/// This value sets refers to a specific supply item.
/// See <http://hl7.org/fhir/ValueSet/supplydelivery-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyItemTypeCode {
    #[prost(enumeration = "supply_item_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SupplyItemTypeCode`.
pub mod supply_item_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Medication = 1,
        Device = 2,
    }
}
/// This value sets refers to a Category of supply.
/// See <http://hl7.org/fhir/ValueSet/supplyrequest-kind>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyTypeCode {
    #[prost(enumeration = "supply_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SupplyTypeCode`.
pub mod supply_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Central = 1,
        Nonstock = 2,
    }
}
/// Why the supply item was requested
/// See <http://hl7.org/fhir/ValueSet/supplyrequest-reason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyRequestReasonCode {
    #[prost(enumeration = "supply_request_reason_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SupplyRequestReasonCode`.
pub mod supply_request_reason_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        PatientCare = 1,
        WardStock = 2,
    }
}
/// Status of the supply request
/// See <http://hl7.org/fhir/ValueSet/supplyrequest-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyRequestStatusCode {
    #[prost(enumeration = "supply_request_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SupplyRequestStatusCode`.
pub mod supply_request_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Active = 2,
        Suspended = 3,
        Cancelled = 4,
        Completed = 5,
        EnteredInError = 6,
        Unknown = 7,
    }
}
/// Operations supported by REST at the system level.
/// <http://hl7.org/fhir/ValueSet/system-restful-interaction>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SystemRestfulInteractionCode {
    #[prost(enumeration = "system_restful_interaction_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SystemRestfulInteractionCode`.
pub mod system_restful_interaction_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Transaction = 1,
        Batch = 2,
        SearchSystem = 3,
        HistorySystem = 4,
    }
}
/// How to manage the intersection between a fixed version in a value set, and
/// a fixed version of the system in the expansion profile See
/// <http://hl7.org/fhir/ValueSet/system-version-processing-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SystemVersionProcessingModeCode {
    #[prost(enumeration = "system_version_processing_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `SystemVersionProcessingModeCode`.
pub mod system_version_processing_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Default = 1,
        Check = 2,
        Override = 3,
    }
}
/// The type(s) of task performers allowed
/// See <http://hl7.org/fhir/ValueSet/task-performer-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TaskPerformerTypeCode {
    #[prost(enumeration = "task_performer_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TaskPerformerTypeCode`.
pub mod task_performer_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Requester = 1,
        Dispatcher = 2,
        Scheduler = 3,
        Performer = 4,
        Monitor = 5,
        Manager = 6,
        Acquirer = 7,
        Reviewer = 8,
    }
}
/// The status indicates the level of maturity of the design and may be used to
/// manage the use of the design See
/// <http://hl7.org/fhir/ValueSet/template-status-code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TemplateStatusCodeCode {
    #[prost(enumeration = "template_status_code_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TemplateStatusCodeCode`.
pub mod template_status_code_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Pending = 2,
        Active = 3,
        Review = 4,
        Cancelled = 5,
        Rejected = 6,
        Retired = 7,
        Terminated = 8,
    }
}
/// The current status of the task.
/// See <http://hl7.org/fhir/ValueSet/task-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TaskStatusCode {
    #[prost(enumeration = "task_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TaskStatusCode`.
pub mod task_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Draft = 1,
        Requested = 2,
        Received = 3,
        Accepted = 4,
        Rejected = 5,
        Ready = 6,
        Cancelled = 7,
        InProgress = 8,
        OnHold = 9,
        Failed = 10,
        Completed = 11,
        EnteredInError = 12,
    }
}
/// This value set defines a set of codes that are used to indicate the
/// supported operations of a testing engine or tool. See
/// <http://hl7.org/fhir/ValueSet/testscript-operation-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestScriptOperationCodeCode {
    #[prost(enumeration = "test_script_operation_code_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TestScriptOperationCodeCode`.
pub mod test_script_operation_code_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Read = 1,
        Vread = 2,
        Update = 3,
        UpdateCreate = 4,
        Delete = 5,
        DeleteCondSingle = 6,
        DeleteCondMultiple = 7,
        History = 8,
        Create = 9,
        Search = 10,
        Batch = 11,
        Transaction = 12,
        Capabilities = 13,
        Apply = 14,
        Cancel = 15,
        Closure = 16,
        Compose = 17,
        Conforms = 18,
        DataRequirements = 19,
        Document = 20,
        Evaluate = 21,
        EvaluateMeasure = 22,
        Everything = 23,
        Expand = 24,
        Fail = 25,
        Find = 26,
        Finish = 27,
        Implements = 28,
        Lookup = 29,
        Match = 30,
        Meta = 31,
        MetaAdd = 32,
        MetaDelete = 33,
        Populate = 34,
        Populatehtml = 35,
        Populatelink = 36,
        ProcessMessage = 37,
        Questionnaire = 38,
        Release = 39,
        Reserve = 40,
        Resume = 41,
        SetInput = 42,
        SetOutput = 43,
        Start = 44,
        Stats = 45,
        Stop = 46,
        Subset = 47,
        Subsumes = 48,
        Suspend = 49,
        Transform = 50,
        Translate = 51,
        Validate = 52,
        ValidateCode = 53,
    }
}
/// This value set defines a set of codes that are used to indicate the profile
/// type of a test system when acting as the destination within a TestScript.
/// See <http://hl7.org/fhir/ValueSet/testscript-profile-destination-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestScriptProfileDestinationTypeCode {
    #[prost(
        enumeration = "test_script_profile_destination_type_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TestScriptProfileDestinationTypeCode`.
pub mod test_script_profile_destination_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        FhirServer = 1,
        FhirSdcFormmanager = 2,
        FhirSdcFormprocessor = 3,
        FhirSdcFormreceiver = 4,
    }
}
/// This value set defines a set of codes that are used to indicate the profile
/// type of a test system when acting as the origin within a TestScript. See
/// <http://hl7.org/fhir/ValueSet/testscript-profile-origin-types>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestScriptProfileOriginTypeCode {
    #[prost(enumeration = "test_script_profile_origin_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TestScriptProfileOriginTypeCode`.
pub mod test_script_profile_origin_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        FhirClient = 1,
        FhirSdcFormfiller = 2,
    }
}
/// A code that indicates how transactions are supported.
/// See <http://hl7.org/fhir/ValueSet/transaction-mode>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TransactionModeCode {
    #[prost(enumeration = "transaction_mode_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TransactionModeCode`.
pub mod transaction_mode_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NotSupported = 1,
        Batch = 2,
        Transaction = 3,
        Both = 4,
    }
}
/// How a type relates to its baseDefinition.
/// See <http://hl7.org/fhir/ValueSet/type-derivation-rule>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TypeDerivationRuleCode {
    #[prost(enumeration = "type_derivation_rule_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TypeDerivationRuleCode`.
pub mod type_derivation_rule_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Specialization = 1,
        Constraint = 2,
    }
}
/// Operations supported by REST at the type or instance level.
/// See <http://hl7.org/fhir/ValueSet/type-restful-interaction>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TypeRestfulInteractionCode {
    #[prost(enumeration = "type_restful_interaction_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `TypeRestfulInteractionCode`.
pub mod type_restful_interaction_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Read = 1,
        Vread = 2,
        Update = 3,
        Patch = 4,
        Delete = 5,
        HistoryInstance = 6,
        HistoryType = 7,
        Create = 8,
        SearchType = 9,
    }
}
/// Codes to identify how UDI data was entered
/// See <http://hl7.org/fhir/ValueSet/udi-entry-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UdiEntryTypeCode {
    #[prost(enumeration = "udi_entry_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `UDIEntryTypeCode`.
pub mod udi_entry_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Barcode = 1,
        Rfid = 2,
        Manual = 3,
        Card = 4,
        SelfReported = 5,
        Unknown = 6,
    }
}
/// A code that indicates whether an application accepts unknown elements or
/// extensions when reading resources. See
/// <http://hl7.org/fhir/ValueSet/unknown-content-code>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UnknownContentCodeCode {
    #[prost(enumeration = "unknown_content_code_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `UnknownContentCodeCode`.
pub mod unknown_content_code_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        No = 1,
        Extensions = 2,
        Elements = 3,
        Both = 4,
    }
}
/// A code that specifies a type of context being specified by a usage context
/// See <http://hl7.org/fhir/ValueSet/usage-context-type>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UsageContextTypeCode {
    #[prost(enumeration = "usage_context_type_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `UsageContextTypeCode`.
pub mod usage_context_type_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Gender = 1,
        Age = 2,
        Focus = 3,
        User = 4,
        Workflow = 5,
        Task = 6,
        Venue = 7,
        Species = 8,
    }
}
/// Set of codes used to value Act.Confidentiality and Role.Confidentiality
/// attribute in accordance with the definition for concept domain
/// "Confidentiality". See
/// <http://hl7.org/fhir/ValueSet/v3-ConfidentialityClassification>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConfidentialityClassificationCode {
    #[prost(enumeration = "confidentiality_classification_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ConfidentialityClassificationCode`.
pub mod confidentiality_classification_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        U = 1,
        L = 2,
        M = 3,
        N = 4,
        R = 5,
        V = 6,
    }
}
/// The value set to instantiate this attribute should be drawn from a
/// terminologically robust code system that consists of or contains concepts
/// to support describing the validity of a dose relative to a particular
/// recommended schedule. This value set is provided as a suggestive example.
/// See <http://hl7.org/fhir/ValueSet/vaccination-protocol-dose-status>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct VaccinationProtocolDoseStatuscodesCode {
    #[prost(
        enumeration = "vaccination_protocol_dose_statuscodes_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `VaccinationProtocolDoseStatuscodesCode`.
pub mod vaccination_protocol_dose_statuscodes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Count = 1,
        Nocount = 2,
    }
}
/// The value set to instantiate this attribute should be drawn from a
/// terminologically robust code system that consists of or contains concepts
/// to support describing the reason why an administered dose has been assigned
/// a particular status. Often, this reason describes why a dose is considered
/// invalid. This value set is provided as a suggestive example. See
/// <http://hl7.org/fhir/ValueSet/vaccination-protocol-dose-status-reason>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct VaccinationProtocolDoseStatusReasoncodesCode {
    #[prost(
        enumeration = "vaccination_protocol_dose_status_reasoncodes_code::Value",
        tag = "1"
    )]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `VaccinationProtocolDoseStatusReasoncodesCode`.
pub mod vaccination_protocol_dose_status_reasoncodes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Advstorage = 1,
        Coldchbrk = 2,
        Explot = 3,
        Outsidesched = 4,
        Prodrecall = 5,
    }
}
/// Codes providing the status of the variant test result
/// See <http://hl7.org/fhir/ValueSet/variant-state>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SequenceStatusCode {
    #[prost(enumeration = "sequence_status_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `sequenceStatusCode`.
pub mod sequence_status_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Positive = 1,
        Negative = 2,
        Absent = 3,
    }
}
/// How the system supports versioning for a resource.
/// See <http://hl7.org/fhir/ValueSet/versioning-policy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResourceVersionPolicyCode {
    #[prost(enumeration = "resource_version_policy_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `ResourceVersionPolicyCode`.
pub mod resource_version_policy_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        NoVersion = 1,
        Versioned = 2,
        VersionedUpdate = 3,
    }
}
/// A coded concept listing the base codes.
/// See <http://hl7.org/fhir/ValueSet/vision-base-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct VisionBaseCode {
    #[prost(enumeration = "vision_base_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `VisionBaseCode`.
pub mod vision_base_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Up = 1,
        Down = 2,
        In = 3,
        Out = 4,
    }
}
/// A coded concept listing the eye codes.
/// See <http://hl7.org/fhir/ValueSet/vision-eye-codes>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct VisionEyesCode {
    #[prost(enumeration = "vision_eyes_code::Value", tag = "1")]
    pub value: i32,
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "3")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Nested message and enum types in `VisionEyesCode`.
pub mod vision_eyes_code {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        InvalidUninitialized = 0,
        Right = 1,
        Left = 2,
    }
}
/// Auto-generated from StructureDefinition for BackboneElement, last updated
/// 2017-04-19T07:44:43.294+10:00. Base for elements defined inside a resource.
/// See <http://hl7.org/fhir/StructureDefinition/BackboneElement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BackboneElement {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "3")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for ContactDetail, last updated
/// 2017-04-19T07:44:43.294+10:00. Contact information. See
/// <http://hl7.org/fhir/StructureDefinition/ContactDetail>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContactDetail {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Name of an individual to contact
    #[prost(message, optional, tag = "3")]
    pub name: ::core::option::Option<String>,
    /// Contact details for individual or organization
    #[prost(message, repeated, tag = "4")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
}
/// Auto-generated from StructureDefinition for Contributor, last updated
/// 2017-04-19T07:44:43.294+10:00. Contributor information. See
/// <http://hl7.org/fhir/StructureDefinition/Contributor>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Contributor {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// author | editor | reviewer | endorser
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<ContributorTypeCode>,
    /// Who contributed the content
    #[prost(message, optional, tag = "4")]
    pub name: ::core::option::Option<String>,
    /// Contact details of the contributor
    #[prost(message, repeated, tag = "5")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
}
/// Auto-generated from StructureDefinition for DataRequirement, last updated
/// 2017-04-19T07:44:43.294+10:00. Describes a required data item. See
/// <http://hl7.org/fhir/StructureDefinition/DataRequirement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DataRequirement {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// The type of the required data
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<FhirAllTypesCode>,
    /// The profile of the required data
    #[prost(message, repeated, tag = "4")]
    pub profile: prost::alloc::vec::Vec<Uri>,
    /// Indicates that specific structure elements are referenced by the knowledge
    /// module
    #[prost(message, repeated, tag = "5")]
    pub must_support: prost::alloc::vec::Vec<String>,
    #[prost(message, repeated, tag = "6")]
    pub code_filter: prost::alloc::vec::Vec<data_requirement::CodeFilter>,
    #[prost(message, repeated, tag = "7")]
    pub date_filter: prost::alloc::vec::Vec<data_requirement::DateFilter>,
}
/// Nested message and enum types in `DataRequirement`.
pub mod data_requirement {
    /// What codes are expected
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CodeFilter {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// The code-valued attribute of the filter
        #[prost(message, optional, tag = "3")]
        pub path: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "4")]
        pub value_set: ::core::option::Option<code_filter::ValueSet>,
        /// What code is expected
        #[prost(message, repeated, tag = "5")]
        pub value_code: prost::alloc::vec::Vec<super::Code>,
        /// What Coding is expected
        #[prost(message, repeated, tag = "6")]
        pub value_coding: prost::alloc::vec::Vec<super::Coding>,
        /// What CodeableConcept is expected
        #[prost(message, repeated, tag = "7")]
        pub value_codeable_concept: prost::alloc::vec::Vec<super::CodeableConcept>,
    }
    /// Nested message and enum types in `CodeFilter`.
    pub mod code_filter {
        /// Valueset for the filter
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueSet {
            #[prost(oneof = "value_set::ValueSet", tags = "1, 2")]
            pub value_set: ::core::option::Option<value_set::ValueSet>,
        }
        /// Nested message and enum types in `ValueSet`.
        pub mod value_set {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum ValueSet {
                #[prost(message, tag = "1")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// What dates/date ranges are expected
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DateFilter {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// The date-valued attribute of the filter
        #[prost(message, optional, tag = "3")]
        pub path: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "4")]
        pub value: ::core::option::Option<date_filter::Value>,
    }
    /// Nested message and enum types in `DateFilter`.
    pub mod date_filter {
        /// The value of the filter, as a Period, DateTime, or Duration value
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Value {
            #[prost(oneof = "value::Value", tags = "1, 2, 3")]
            pub value: ::core::option::Option<value::Value>,
        }
        /// Nested message and enum types in `Value`.
        pub mod value {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Value {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
                #[prost(message, tag = "3")]
                Duration(super::super::super::Duration),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Element, last updated
/// 2017-04-19T07:44:43.294+10:00. Base for all elements. See
/// <http://hl7.org/fhir/StructureDefinition/Element>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Element {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
}
/// Auto-generated from StructureDefinition for ElementDefinition, last updated
/// 2017-04-19T07:44:43.294+10:00. Definition of an element in a resource or
/// extension. See <http://hl7.org/fhir/StructureDefinition/ElementDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ElementDefinition {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Path of the element in the hierarchy of elements
    #[prost(message, optional, tag = "3")]
    pub path: ::core::option::Option<String>,
    /// xmlAttr | xmlText | typeAttr | cdaText | xhtml
    #[prost(message, repeated, tag = "4")]
    pub representation: prost::alloc::vec::Vec<PropertyRepresentationCode>,
    /// Name for this particular element (in a set of slices)
    #[prost(message, optional, tag = "5")]
    pub slice_name: ::core::option::Option<String>,
    /// Name for element to display with or prompt for element
    #[prost(message, optional, tag = "6")]
    pub label: ::core::option::Option<String>,
    /// Corresponding codes in terminologies
    #[prost(message, repeated, tag = "7")]
    pub code: prost::alloc::vec::Vec<Coding>,
    #[prost(message, optional, tag = "8")]
    pub slicing: ::core::option::Option<element_definition::Slicing>,
    /// Concise definition for space-constrained presentation
    #[prost(message, optional, tag = "9")]
    pub short: ::core::option::Option<String>,
    /// Full formal definition as narrative text
    #[prost(message, optional, tag = "10")]
    pub definition: ::core::option::Option<Markdown>,
    /// Comments about the use of this element
    #[prost(message, optional, tag = "11")]
    pub comment: ::core::option::Option<Markdown>,
    /// Why this resource has been created
    #[prost(message, optional, tag = "12")]
    pub requirements: ::core::option::Option<Markdown>,
    /// Other names
    #[prost(message, repeated, tag = "13")]
    pub alias: prost::alloc::vec::Vec<String>,
    /// Minimum Cardinality
    #[prost(message, optional, tag = "14")]
    pub min: ::core::option::Option<UnsignedInt>,
    /// Maximum Cardinality (a number or *)
    #[prost(message, optional, tag = "15")]
    pub max: ::core::option::Option<String>,
    #[prost(message, optional, tag = "16")]
    pub base: ::core::option::Option<element_definition::Base>,
    /// Reference to definition of content for the element
    #[prost(message, optional, tag = "17")]
    pub content_reference: ::core::option::Option<Uri>,
    #[prost(message, repeated, tag = "18")]
    pub r#type: prost::alloc::vec::Vec<element_definition::TypeRef>,
    #[prost(message, optional, tag = "19")]
    pub default_value: ::core::option::Option<element_definition::DefaultValue>,
    /// Implicit meaning when this element is missing
    #[prost(message, optional, tag = "20")]
    pub meaning_when_missing: ::core::option::Option<Markdown>,
    /// What the order of the elements means
    #[prost(message, optional, tag = "21")]
    pub order_meaning: ::core::option::Option<String>,
    #[prost(message, optional, tag = "22")]
    pub fixed: ::core::option::Option<element_definition::Fixed>,
    #[prost(message, optional, tag = "23")]
    pub pattern: ::core::option::Option<element_definition::Pattern>,
    #[prost(message, repeated, tag = "24")]
    pub example: prost::alloc::vec::Vec<element_definition::Example>,
    #[prost(message, optional, tag = "25")]
    pub min_value: ::core::option::Option<element_definition::MinValue>,
    #[prost(message, optional, tag = "26")]
    pub max_value: ::core::option::Option<element_definition::MaxValue>,
    /// Max length for strings
    #[prost(message, optional, tag = "27")]
    pub max_length: ::core::option::Option<Integer>,
    /// Reference to invariant about presence
    #[prost(message, repeated, tag = "28")]
    pub condition: prost::alloc::vec::Vec<Id>,
    #[prost(message, repeated, tag = "29")]
    pub constraint: prost::alloc::vec::Vec<element_definition::Constraint>,
    /// If the element must supported
    #[prost(message, optional, tag = "30")]
    pub must_support: ::core::option::Option<Boolean>,
    /// If this modifies the meaning of other elements
    #[prost(message, optional, tag = "31")]
    pub is_modifier: ::core::option::Option<Boolean>,
    /// Include when _summary = true?
    #[prost(message, optional, tag = "32")]
    pub is_summary: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "33")]
    pub binding: ::core::option::Option<element_definition::ElementDefinitionBinding>,
    #[prost(message, repeated, tag = "34")]
    pub mapping: prost::alloc::vec::Vec<element_definition::Mapping>,
}
/// Nested message and enum types in `ElementDefinition`.
pub mod element_definition {
    /// This element is sliced - slices follow
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Slicing {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "3")]
        pub discriminator: prost::alloc::vec::Vec<slicing::Discriminator>,
        /// Text description of how slicing works (or not)
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// If elements must be in same order as slices
        #[prost(message, optional, tag = "5")]
        pub ordered: ::core::option::Option<super::Boolean>,
        /// closed | open | openAtEnd
        #[prost(message, optional, tag = "6")]
        pub rules: ::core::option::Option<super::SlicingRulesCode>,
    }
    /// Nested message and enum types in `Slicing`.
    pub mod slicing {
        /// Element values that are used to distinguish the slices
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Discriminator {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// value | exists | pattern | type | profile
            #[prost(message, optional, tag = "3")]
            pub r#type: ::core::option::Option<super::super::DiscriminatorTypeCode>,
            /// Path to element value
            #[prost(message, optional, tag = "4")]
            pub path: ::core::option::Option<super::super::String>,
        }
    }
    /// Base definition information for tools
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Base {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Path that identifies the base element
        #[prost(message, optional, tag = "3")]
        pub path: ::core::option::Option<super::String>,
        /// Min cardinality of the base element
        #[prost(message, optional, tag = "4")]
        pub min: ::core::option::Option<super::UnsignedInt>,
        /// Max cardinality of the base element
        #[prost(message, optional, tag = "5")]
        pub max: ::core::option::Option<super::String>,
    }
    /// Data type and Profile for this element
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TypeRef {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Data type or Resource (reference to definition)
        #[prost(message, optional, tag = "3")]
        pub code: ::core::option::Option<super::Uri>,
        /// Profile (StructureDefinition) to apply (or IG)
        #[prost(message, optional, tag = "4")]
        pub profile: ::core::option::Option<super::Uri>,
        /// Profile (StructureDefinition) to apply to reference target (or IG)
        #[prost(message, optional, tag = "5")]
        pub target_profile: ::core::option::Option<super::Uri>,
        /// contained | referenced | bundled - how aggregated
        #[prost(message, repeated, tag = "6")]
        pub aggregation: prost::alloc::vec::Vec<super::AggregationModeCode>,
        /// either | independent | specific
        #[prost(message, optional, tag = "7")]
        pub versioning: ::core::option::Option<super::ReferenceVersionRulesCode>,
    }
    /// Specified value if missing from instance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DefaultValue {
        #[prost(
            oneof = "default_value::DefaultValue",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
        )]
        pub default_value: ::core::option::Option<default_value::DefaultValue>,
    }
    /// Nested message and enum types in `DefaultValue`.
    pub mod default_value {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum DefaultValue {
            #[prost(message, tag = "1")]
            Base64Binary(super::super::Base64Binary),
            #[prost(message, tag = "2")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "3")]
            Code(super::super::Code),
            #[prost(message, tag = "4")]
            Date(super::super::Date),
            #[prost(message, tag = "5")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "6")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "7")]
            Id(super::super::Id),
            #[prost(message, tag = "8")]
            Instant(super::super::Instant),
            #[prost(message, tag = "9")]
            Integer(super::super::Integer),
            #[prost(message, tag = "10")]
            Markdown(super::super::Markdown),
            #[prost(message, tag = "11")]
            Oid(super::super::Oid),
            #[prost(message, tag = "12")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "13")]
            StringValue(super::super::String),
            #[prost(message, tag = "14")]
            Time(super::super::Time),
            #[prost(message, tag = "15")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "16")]
            Uri(super::super::Uri),
            #[prost(message, tag = "17")]
            Address(super::super::Address),
            #[prost(message, tag = "18")]
            Age(super::super::Age),
            #[prost(message, tag = "19")]
            Annotation(super::super::Annotation),
            #[prost(message, tag = "20")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "21")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "22")]
            Coding(super::super::Coding),
            #[prost(message, tag = "23")]
            ContactPoint(super::super::ContactPoint),
            #[prost(message, tag = "24")]
            Count(super::super::Count),
            #[prost(message, tag = "25")]
            Distance(super::super::Distance),
            #[prost(message, tag = "26")]
            Duration(super::super::Duration),
            #[prost(message, tag = "27")]
            HumanName(super::super::HumanName),
            #[prost(message, tag = "28")]
            Identifier(super::super::Identifier),
            #[prost(message, tag = "29")]
            Money(super::super::Money),
            #[prost(message, tag = "30")]
            Period(super::super::Period),
            #[prost(message, tag = "31")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "32")]
            Range(super::super::Range),
            #[prost(message, tag = "33")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "34")]
            Reference(super::super::Reference),
            #[prost(message, tag = "35")]
            SampledData(super::super::SampledData),
            #[prost(message, tag = "36")]
            Signature(super::super::Signature),
            #[prost(message, tag = "37")]
            Timing(super::super::Timing),
            #[prost(message, tag = "38")]
            Meta(super::super::Meta),
        }
    }
    /// Value must be exactly this
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Fixed {
        #[prost(
            oneof = "fixed::Fixed",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
        )]
        pub fixed: ::core::option::Option<fixed::Fixed>,
    }
    /// Nested message and enum types in `Fixed`.
    pub mod fixed {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Fixed {
            #[prost(message, tag = "1")]
            Base64Binary(super::super::Base64Binary),
            #[prost(message, tag = "2")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "3")]
            Code(super::super::Code),
            #[prost(message, tag = "4")]
            Date(super::super::Date),
            #[prost(message, tag = "5")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "6")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "7")]
            Id(super::super::Id),
            #[prost(message, tag = "8")]
            Instant(super::super::Instant),
            #[prost(message, tag = "9")]
            Integer(super::super::Integer),
            #[prost(message, tag = "10")]
            Markdown(super::super::Markdown),
            #[prost(message, tag = "11")]
            Oid(super::super::Oid),
            #[prost(message, tag = "12")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "13")]
            StringValue(super::super::String),
            #[prost(message, tag = "14")]
            Time(super::super::Time),
            #[prost(message, tag = "15")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "16")]
            Uri(super::super::Uri),
            #[prost(message, tag = "17")]
            Address(super::super::Address),
            #[prost(message, tag = "18")]
            Age(super::super::Age),
            #[prost(message, tag = "19")]
            Annotation(super::super::Annotation),
            #[prost(message, tag = "20")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "21")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "22")]
            Coding(super::super::Coding),
            #[prost(message, tag = "23")]
            ContactPoint(super::super::ContactPoint),
            #[prost(message, tag = "24")]
            Count(super::super::Count),
            #[prost(message, tag = "25")]
            Distance(super::super::Distance),
            #[prost(message, tag = "26")]
            Duration(super::super::Duration),
            #[prost(message, tag = "27")]
            HumanName(super::super::HumanName),
            #[prost(message, tag = "28")]
            Identifier(super::super::Identifier),
            #[prost(message, tag = "29")]
            Money(super::super::Money),
            #[prost(message, tag = "30")]
            Period(super::super::Period),
            #[prost(message, tag = "31")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "32")]
            Range(super::super::Range),
            #[prost(message, tag = "33")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "34")]
            Reference(super::super::Reference),
            #[prost(message, tag = "35")]
            SampledData(super::super::SampledData),
            #[prost(message, tag = "36")]
            Signature(super::super::Signature),
            #[prost(message, tag = "37")]
            Timing(super::super::Timing),
            #[prost(message, tag = "38")]
            Meta(super::super::Meta),
        }
    }
    /// Value must have at least these property values
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Pattern {
        #[prost(
            oneof = "pattern::Pattern",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
        )]
        pub pattern: ::core::option::Option<pattern::Pattern>,
    }
    /// Nested message and enum types in `Pattern`.
    pub mod pattern {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Pattern {
            #[prost(message, tag = "1")]
            Base64Binary(super::super::Base64Binary),
            #[prost(message, tag = "2")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "3")]
            Code(super::super::Code),
            #[prost(message, tag = "4")]
            Date(super::super::Date),
            #[prost(message, tag = "5")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "6")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "7")]
            Id(super::super::Id),
            #[prost(message, tag = "8")]
            Instant(super::super::Instant),
            #[prost(message, tag = "9")]
            Integer(super::super::Integer),
            #[prost(message, tag = "10")]
            Markdown(super::super::Markdown),
            #[prost(message, tag = "11")]
            Oid(super::super::Oid),
            #[prost(message, tag = "12")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "13")]
            StringValue(super::super::String),
            #[prost(message, tag = "14")]
            Time(super::super::Time),
            #[prost(message, tag = "15")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "16")]
            Uri(super::super::Uri),
            #[prost(message, tag = "17")]
            Address(super::super::Address),
            #[prost(message, tag = "18")]
            Age(super::super::Age),
            #[prost(message, tag = "19")]
            Annotation(super::super::Annotation),
            #[prost(message, tag = "20")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "21")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "22")]
            Coding(super::super::Coding),
            #[prost(message, tag = "23")]
            ContactPoint(super::super::ContactPoint),
            #[prost(message, tag = "24")]
            Count(super::super::Count),
            #[prost(message, tag = "25")]
            Distance(super::super::Distance),
            #[prost(message, tag = "26")]
            Duration(super::super::Duration),
            #[prost(message, tag = "27")]
            HumanName(super::super::HumanName),
            #[prost(message, tag = "28")]
            Identifier(super::super::Identifier),
            #[prost(message, tag = "29")]
            Money(super::super::Money),
            #[prost(message, tag = "30")]
            Period(super::super::Period),
            #[prost(message, tag = "31")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "32")]
            Range(super::super::Range),
            #[prost(message, tag = "33")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "34")]
            Reference(super::super::Reference),
            #[prost(message, tag = "35")]
            SampledData(super::super::SampledData),
            #[prost(message, tag = "36")]
            Signature(super::super::Signature),
            #[prost(message, tag = "37")]
            Timing(super::super::Timing),
            #[prost(message, tag = "38")]
            Meta(super::super::Meta),
        }
    }
    /// Example value (as defined for type)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Example {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Describes the purpose of this example
        #[prost(message, optional, tag = "3")]
        pub label: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "4")]
        pub value: ::core::option::Option<example::Value>,
    }
    /// Nested message and enum types in `Example`.
    pub mod example {
        /// Value of Example (one of allowed types)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Value {
            #[prost(
                oneof = "value::Value",
                tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
            )]
            pub value: ::core::option::Option<value::Value>,
        }
        /// Nested message and enum types in `Value`.
        pub mod value {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Value {
                #[prost(message, tag = "1")]
                Base64Binary(super::super::super::Base64Binary),
                #[prost(message, tag = "2")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "3")]
                Code(super::super::super::Code),
                #[prost(message, tag = "4")]
                Date(super::super::super::Date),
                #[prost(message, tag = "5")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "6")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "7")]
                Id(super::super::super::Id),
                #[prost(message, tag = "8")]
                Instant(super::super::super::Instant),
                #[prost(message, tag = "9")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "10")]
                Markdown(super::super::super::Markdown),
                #[prost(message, tag = "11")]
                Oid(super::super::super::Oid),
                #[prost(message, tag = "12")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "13")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "14")]
                Time(super::super::super::Time),
                #[prost(message, tag = "15")]
                UnsignedInt(super::super::super::UnsignedInt),
                #[prost(message, tag = "16")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "17")]
                Address(super::super::super::Address),
                #[prost(message, tag = "18")]
                Age(super::super::super::Age),
                #[prost(message, tag = "19")]
                Annotation(super::super::super::Annotation),
                #[prost(message, tag = "20")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "21")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "22")]
                Coding(super::super::super::Coding),
                #[prost(message, tag = "23")]
                ContactPoint(super::super::super::ContactPoint),
                #[prost(message, tag = "24")]
                Count(super::super::super::Count),
                #[prost(message, tag = "25")]
                Distance(super::super::super::Distance),
                #[prost(message, tag = "26")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "27")]
                HumanName(super::super::super::HumanName),
                #[prost(message, tag = "28")]
                Identifier(super::super::super::Identifier),
                #[prost(message, tag = "29")]
                Money(super::super::super::Money),
                #[prost(message, tag = "30")]
                Period(super::super::super::Period),
                #[prost(message, tag = "31")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "32")]
                Range(super::super::super::Range),
                #[prost(message, tag = "33")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "34")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "35")]
                SampledData(super::super::super::SampledData),
                #[prost(message, tag = "36")]
                Signature(super::super::super::Signature),
                #[prost(message, tag = "37")]
                Timing(super::super::super::Timing),
                #[prost(message, tag = "38")]
                Meta(super::super::super::Meta),
            }
        }
    }
    /// Minimum Allowed Value (for some types)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MinValue {
        #[prost(oneof = "min_value::MinValue", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
        pub min_value: ::core::option::Option<min_value::MinValue>,
    }
    /// Nested message and enum types in `MinValue`.
    pub mod min_value {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum MinValue {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "3")]
            Instant(super::super::Instant),
            #[prost(message, tag = "4")]
            Time(super::super::Time),
            #[prost(message, tag = "5")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "6")]
            Integer(super::super::Integer),
            #[prost(message, tag = "7")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "8")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "9")]
            Quantity(super::super::Quantity),
        }
    }
    /// Maximum Allowed Value (for some types)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MaxValue {
        #[prost(oneof = "max_value::MaxValue", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9")]
        pub max_value: ::core::option::Option<max_value::MaxValue>,
    }
    /// Nested message and enum types in `MaxValue`.
    pub mod max_value {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum MaxValue {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "3")]
            Instant(super::super::Instant),
            #[prost(message, tag = "4")]
            Time(super::super::Time),
            #[prost(message, tag = "5")]
            Decimal(super::super::Decimal),
            #[prost(message, tag = "6")]
            Integer(super::super::Integer),
            #[prost(message, tag = "7")]
            PositiveInt(super::super::PositiveInt),
            #[prost(message, tag = "8")]
            UnsignedInt(super::super::UnsignedInt),
            #[prost(message, tag = "9")]
            Quantity(super::super::Quantity),
        }
    }
    /// Condition that must evaluate to true
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Constraint {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Target of 'condition' reference above
        #[prost(message, optional, tag = "3")]
        pub key: ::core::option::Option<super::Id>,
        /// Why this constraint is necessary or appropriate
        #[prost(message, optional, tag = "4")]
        pub requirements: ::core::option::Option<super::String>,
        /// error | warning
        #[prost(message, optional, tag = "5")]
        pub severity: ::core::option::Option<super::ConstraintSeverityCode>,
        /// Human description of constraint
        #[prost(message, optional, tag = "6")]
        pub human: ::core::option::Option<super::String>,
        /// FHIRPath expression of constraint
        #[prost(message, optional, tag = "7")]
        pub expression: ::core::option::Option<super::String>,
        /// XPath expression of constraint
        #[prost(message, optional, tag = "8")]
        pub xpath: ::core::option::Option<super::String>,
        /// Reference to original source of constraint
        #[prost(message, optional, tag = "9")]
        pub source: ::core::option::Option<super::Uri>,
    }
    /// ValueSet details if this is coded
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ElementDefinitionBinding {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// required | extensible | preferred | example
        #[prost(message, optional, tag = "3")]
        pub strength: ::core::option::Option<super::BindingStrengthCode>,
        /// Human explanation of the value set
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub value_set: ::core::option::Option<element_definition_binding::ValueSet>,
    }
    /// Nested message and enum types in `ElementDefinitionBinding`.
    pub mod element_definition_binding {
        /// Source of value set
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ValueSet {
            #[prost(oneof = "value_set::ValueSet", tags = "1, 2")]
            pub value_set: ::core::option::Option<value_set::ValueSet>,
        }
        /// Nested message and enum types in `ValueSet`.
        pub mod value_set {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum ValueSet {
                #[prost(message, tag = "1")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Map element to another set of definitions
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Mapping {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to mapping declaration
        #[prost(message, optional, tag = "3")]
        pub identity: ::core::option::Option<super::Id>,
        /// Computable language of mapping
        #[prost(message, optional, tag = "4")]
        pub language: ::core::option::Option<super::MimeTypeCode>,
        /// Details of the mapping
        #[prost(message, optional, tag = "5")]
        pub map: ::core::option::Option<super::String>,
        /// Comments about the mapping or its use
        #[prost(message, optional, tag = "6")]
        pub comment: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for Narrative, last updated
/// 2017-04-19T07:44:43.294+10:00. A human-readable formatted text, including
/// images. See <http://hl7.org/fhir/StructureDefinition/Narrative>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Narrative {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// generated | extensions | additional | empty
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<NarrativeStatusCode>,
    /// Limited xhtml content
    #[prost(message, optional, tag = "4")]
    pub div: ::core::option::Option<Xhtml>,
}
/// Auto-generated from StructureDefinition for ParameterDefinition, last updated
/// 2017-04-19T07:44:43.294+10:00. Definition of a parameter to a module. See
/// <http://hl7.org/fhir/StructureDefinition/ParameterDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ParameterDefinition {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Name used to access the parameter value
    #[prost(message, optional, tag = "3")]
    pub name: ::core::option::Option<Code>,
    /// in | out
    #[prost(message, optional, tag = "4")]
    pub r#use: ::core::option::Option<OperationParameterUseCode>,
    /// Minimum cardinality
    #[prost(message, optional, tag = "5")]
    pub min: ::core::option::Option<Integer>,
    /// Maximum cardinality (a number of *)
    #[prost(message, optional, tag = "6")]
    pub max: ::core::option::Option<String>,
    /// A brief description of the parameter
    #[prost(message, optional, tag = "7")]
    pub documentation: ::core::option::Option<String>,
    /// What type of value
    #[prost(message, optional, tag = "8")]
    pub r#type: ::core::option::Option<FhirAllTypesCode>,
    /// What profile the value is expected to be
    #[prost(message, optional, tag = "9")]
    pub profile: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for RelatedArtifact, last updated
/// 2017-04-19T07:44:43.294+10:00. Related artifacts for a knowledge resource.
/// See <http://hl7.org/fhir/StructureDefinition/RelatedArtifact>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RelatedArtifact {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// documentation | justification | citation | predecessor | successor |
    /// derived-from | depends-on | composed-of
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<RelatedArtifactTypeCode>,
    /// Brief description of the related artifact
    #[prost(message, optional, tag = "4")]
    pub display: ::core::option::Option<String>,
    /// Bibliographic citation for the artifact
    #[prost(message, optional, tag = "5")]
    pub citation: ::core::option::Option<String>,
    /// Where the artifact can be accessed
    #[prost(message, optional, tag = "6")]
    pub url: ::core::option::Option<Uri>,
    /// What document is being referenced
    #[prost(message, optional, tag = "7")]
    pub document: ::core::option::Option<Attachment>,
    /// What resource is being referenced
    #[prost(message, optional, tag = "8")]
    pub resource: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for TriggerDefinition, last updated
/// 2017-04-19T07:44:43.294+10:00. Defines an expected trigger for a module. See
/// <http://hl7.org/fhir/StructureDefinition/TriggerDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TriggerDefinition {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// named-event | periodic | data-added | data-modified | data-removed |
    /// data-accessed | data-access-ended
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<TriggerTypeCode>,
    /// Triggering event name
    #[prost(message, optional, tag = "4")]
    pub event_name: ::core::option::Option<String>,
    #[prost(message, optional, tag = "5")]
    pub event_timing: ::core::option::Option<trigger_definition::EventTiming>,
    /// Triggering data of the event
    #[prost(message, optional, tag = "6")]
    pub event_data: ::core::option::Option<DataRequirement>,
}
/// Nested message and enum types in `TriggerDefinition`.
pub mod trigger_definition {
    /// Timing of the event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EventTiming {
        #[prost(oneof = "event_timing::EventTiming", tags = "1, 2, 3, 4")]
        pub event_timing: ::core::option::Option<event_timing::EventTiming>,
    }
    /// Nested message and enum types in `EventTiming`.
    pub mod event_timing {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum EventTiming {
            #[prost(message, tag = "1")]
            Timing(super::super::Timing),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
            #[prost(message, tag = "3")]
            Date(super::super::Date),
            #[prost(message, tag = "4")]
            DateTime(super::super::DateTime),
        }
    }
}
/// Auto-generated from StructureDefinition for UsageContext, last updated
/// 2017-04-19T07:44:43.294+10:00. Describes the context of use for a conformance
/// or knowledge resource. See
/// <http://hl7.org/fhir/StructureDefinition/UsageContext>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct UsageContext {
    /// xml:id (or equivalent in JSON)
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<String>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "2")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Type of context being specified
    #[prost(message, optional, tag = "3")]
    pub code: ::core::option::Option<Coding>,
    #[prost(message, optional, tag = "4")]
    pub value: ::core::option::Option<usage_context::Value>,
}
/// Nested message and enum types in `UsageContext`.
pub mod usage_context {
    /// Value that defines the context
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Value {
        #[prost(oneof = "value::Value", tags = "1, 2, 3")]
        pub value: ::core::option::Option<value::Value>,
    }
    /// Nested message and enum types in `Value`.
    pub mod value {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Value {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "3")]
            Range(super::super::Range),
        }
    }
}
/// Auto-generated from StructureDefinition for Account, last updated
/// 2017-04-19T07:44:43.294+10:00. Tracks balance, charges, for patient or cost
/// center. See <http://hl7.org/fhir/StructureDefinition/Account>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Account {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Account number
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | inactive | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<AccountStatusCode>,
    /// E.g. patient, expense, depreciation
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Human-readable label
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// What is account tied to?
    #[prost(message, optional, tag = "13")]
    pub subject: ::core::option::Option<Reference>,
    /// Transaction window
    #[prost(message, optional, tag = "14")]
    pub period: ::core::option::Option<Period>,
    /// Time window that transactions may be posted to this account
    #[prost(message, optional, tag = "15")]
    pub active: ::core::option::Option<Period>,
    /// How much is in account?
    #[prost(message, optional, tag = "16")]
    pub balance: ::core::option::Option<Money>,
    #[prost(message, repeated, tag = "17")]
    pub coverage: prost::alloc::vec::Vec<account::Coverage>,
    /// Who is responsible?
    #[prost(message, optional, tag = "18")]
    pub owner: ::core::option::Option<Reference>,
    /// Explanation of purpose/use
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "20")]
    pub guarantor: prost::alloc::vec::Vec<account::Guarantor>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    /// The party(s) that are responsible for covering the payment of this account,
    /// and what order should they be applied to the account
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Coverage {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The party(s) that are responsible for covering the payment of this
        /// account
        #[prost(message, optional, tag = "4")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// The priority of the coverage in the context of this account
        #[prost(message, optional, tag = "5")]
        pub priority: ::core::option::Option<super::PositiveInt>,
    }
    /// Responsible for the account
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Guarantor {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Responsible entity
        #[prost(message, optional, tag = "4")]
        pub party: ::core::option::Option<super::Reference>,
        /// Credit or other hold applied
        #[prost(message, optional, tag = "5")]
        pub on_hold: ::core::option::Option<super::Boolean>,
        /// Guarrantee account during
        #[prost(message, optional, tag = "6")]
        pub period: ::core::option::Option<super::Period>,
    }
}
/// Auto-generated from StructureDefinition for ActivityDefinition, last updated
/// 2017-04-19T07:44:43.294+10:00. The definition of a specific activity to be
/// taken, independent of any particular patient or context. See
/// <http://hl7.org/fhir/StructureDefinition/ActivityDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ActivityDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this activity definition (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the activity definition
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the activity definition
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this activity definition (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this activity definition (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Natural language description of the activity definition
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<Markdown>,
    /// Why this activity definition is defined
    #[prost(message, optional, tag = "19")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the asset
    #[prost(message, optional, tag = "20")]
    pub usage: ::core::option::Option<String>,
    /// When the activity definition was approved by publisher
    #[prost(message, optional, tag = "21")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the activity definition was last reviewed
    #[prost(message, optional, tag = "22")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the activity definition is expected to be used
    #[prost(message, optional, tag = "23")]
    pub effective_period: ::core::option::Option<Period>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "24")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for activity definition (if applicable)
    #[prost(message, repeated, tag = "25")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// E.g. Education, Treatment, Assessment, etc
    #[prost(message, repeated, tag = "26")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// A content contributor
    #[prost(message, repeated, tag = "27")]
    pub contributor: prost::alloc::vec::Vec<Contributor>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "28")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "29")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Additional documentation, citations, etc
    #[prost(message, repeated, tag = "30")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Logic used by the asset
    #[prost(message, repeated, tag = "31")]
    pub library: prost::alloc::vec::Vec<Reference>,
    /// Kind of resource
    #[prost(message, optional, tag = "32")]
    pub kind: ::core::option::Option<ResourceTypeCode>,
    /// Detail type of activity
    #[prost(message, optional, tag = "33")]
    pub code: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "34")]
    pub timing: ::core::option::Option<activity_definition::TimingType>,
    /// Where it should happen
    #[prost(message, optional, tag = "35")]
    pub location: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "36")]
    pub participant: prost::alloc::vec::Vec<activity_definition::Participant>,
    #[prost(message, optional, tag = "37")]
    pub product: ::core::option::Option<activity_definition::Product>,
    /// How much is administered/consumed/supplied
    #[prost(message, optional, tag = "38")]
    pub quantity: ::core::option::Option<SimpleQuantity>,
    /// Detailed dosage instructions
    #[prost(message, repeated, tag = "39")]
    pub dosage: prost::alloc::vec::Vec<Dosage>,
    /// What part of body to perform on
    #[prost(message, repeated, tag = "40")]
    pub body_site: prost::alloc::vec::Vec<CodeableConcept>,
    /// Transform to apply the template
    #[prost(message, optional, tag = "41")]
    pub transform: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "42")]
    pub dynamic_value: prost::alloc::vec::Vec<activity_definition::DynamicValue>,
}
/// Nested message and enum types in `ActivityDefinition`.
pub mod activity_definition {
    /// When activity is to occur
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TimingType {
        #[prost(oneof = "timing_type::Timing", tags = "1, 2, 3, 4")]
        pub timing: ::core::option::Option<timing_type::Timing>,
    }
    /// Nested message and enum types in `TimingType`.
    pub mod timing_type {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Timing {
            #[prost(message, tag = "1")]
            TimingValue(super::super::Timing),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "3")]
            Period(super::super::Period),
            #[prost(message, tag = "4")]
            Range(super::super::Range),
        }
    }
    /// Who should participate in the action
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// patient | practitioner | related-person
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::ActionParticipantTypeCode>,
        /// E.g. Nurse, Surgeon, Parent, etc
        #[prost(message, optional, tag = "5")]
        pub role: ::core::option::Option<super::CodeableConcept>,
    }
    /// What's administered/supplied
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Product {
        #[prost(oneof = "product::Product", tags = "1, 2")]
        pub product: ::core::option::Option<product::Product>,
    }
    /// Nested message and enum types in `Product`.
    pub mod product {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Product {
            #[prost(message, tag = "1")]
            Reference(super::super::Reference),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// Dynamic aspects of the definition
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DynamicValue {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Natural language description of the dynamic value
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// The path to the element to be set dynamically
        #[prost(message, optional, tag = "5")]
        pub path: ::core::option::Option<super::String>,
        /// Language of the expression
        #[prost(message, optional, tag = "6")]
        pub language: ::core::option::Option<super::String>,
        /// An expression that provides the dynamic value for the customization
        #[prost(message, optional, tag = "7")]
        pub expression: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for AdverseEvent, last updated
/// 2017-04-19T07:44:43.294+10:00. Medical care, research study or other
/// healthcare event causing physical injury. See
/// <http://hl7.org/fhir/StructureDefinition/AdverseEvent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AdverseEvent {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier for the event
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// AE | PAE
    /// An adverse event is an event that caused harm to a patient,  an adverse
    /// reaction is a something that is a subject-specific event that is a result
    /// of an exposure to a medication, food, device or environmental substance, a
    /// potential adverse event is something that occurred and that could have
    /// caused harm to a patient but did not
    #[prost(message, optional, tag = "10")]
    pub category: ::core::option::Option<AdverseEventCategoryCode>,
    /// actual | potential
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Subject or group impacted by event
    #[prost(message, optional, tag = "12")]
    pub subject: ::core::option::Option<Reference>,
    /// When the event occurred
    #[prost(message, optional, tag = "13")]
    pub date: ::core::option::Option<DateTime>,
    /// Adverse Reaction Events linked to exposure to substance
    #[prost(message, repeated, tag = "14")]
    pub reaction: prost::alloc::vec::Vec<Reference>,
    /// Location where adverse event occurred
    #[prost(message, optional, tag = "15")]
    pub location: ::core::option::Option<Reference>,
    /// Mild | Moderate | Severe
    #[prost(message, optional, tag = "16")]
    pub seriousness: ::core::option::Option<CodeableConcept>,
    /// resolved | recovering | ongoing | resolvedWithSequelae | fatal | unknown
    #[prost(message, optional, tag = "17")]
    pub outcome: ::core::option::Option<CodeableConcept>,
    /// Who recorded the adverse event
    #[prost(message, optional, tag = "18")]
    pub recorder: ::core::option::Option<Reference>,
    /// Who  was involved in the adverse event or the potential adverse event
    #[prost(message, optional, tag = "19")]
    pub event_participant: ::core::option::Option<Reference>,
    /// Description of the adverse event
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "21")]
    pub suspect_entity: prost::alloc::vec::Vec<adverse_event::SuspectEntity>,
    /// AdverseEvent.subjectMedicalHistory
    #[prost(message, repeated, tag = "22")]
    pub subject_medical_history: prost::alloc::vec::Vec<Reference>,
    /// AdverseEvent.referenceDocument
    #[prost(message, repeated, tag = "23")]
    pub reference_document: prost::alloc::vec::Vec<Reference>,
    /// AdverseEvent.study
    #[prost(message, repeated, tag = "24")]
    pub study: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `AdverseEvent`.
pub mod adverse_event {
    /// The suspected agent causing the adverse event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SuspectEntity {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Refers to the specific entity that caused the adverse event
        #[prost(message, optional, tag = "4")]
        pub instance: ::core::option::Option<super::Reference>,
        /// causality1 | causality2
        #[prost(message, optional, tag = "5")]
        pub causality: ::core::option::Option<super::AdverseEventCausalityCode>,
        /// assess1 | assess2
        #[prost(message, optional, tag = "6")]
        pub causality_assessment: ::core::option::Option<super::CodeableConcept>,
        /// AdverseEvent.suspectEntity.causalityProductRelatedness
        #[prost(message, optional, tag = "7")]
        pub causality_product_relatedness: ::core::option::Option<super::String>,
        /// method1 | method2
        #[prost(message, optional, tag = "8")]
        pub causality_method: ::core::option::Option<super::CodeableConcept>,
        /// AdverseEvent.suspectEntity.causalityAuthor
        #[prost(message, optional, tag = "9")]
        pub causality_author: ::core::option::Option<super::Reference>,
        /// result1 | result2
        #[prost(message, optional, tag = "10")]
        pub causality_result: ::core::option::Option<super::CodeableConcept>,
    }
}
/// Auto-generated from StructureDefinition for AllergyIntolerance, last updated
/// 2017-04-19T07:44:43.294+10:00. Allergy or Intolerance (generally: Risk of
/// adverse reaction to a substance). See
/// <http://hl7.org/fhir/StructureDefinition/AllergyIntolerance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AllergyIntolerance {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External ids for this item
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | inactive | resolved
    #[prost(message, optional, tag = "10")]
    pub clinical_status: ::core::option::Option<AllergyIntoleranceClinicalStatusCode>,
    /// unconfirmed | confirmed | refuted | entered-in-error
    #[prost(message, optional, tag = "11")]
    pub verification_status: ::core::option::Option<AllergyIntoleranceVerificationStatusCode>,
    /// allergy | intolerance - Underlying mechanism (if known)
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<AllergyIntoleranceTypeCode>,
    /// food | medication | environment | biologic
    #[prost(message, repeated, tag = "13")]
    pub category: prost::alloc::vec::Vec<AllergyIntoleranceCategoryCode>,
    /// low | high | unable-to-assess
    #[prost(message, optional, tag = "14")]
    pub criticality: ::core::option::Option<AllergyIntoleranceCriticalityCode>,
    /// Code that identifies the allergy or intolerance
    #[prost(message, optional, tag = "15")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who the sensitivity is for
    #[prost(message, optional, tag = "16")]
    pub patient: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "17")]
    pub onset: ::core::option::Option<allergy_intolerance::Onset>,
    /// Date record was believed accurate
    #[prost(message, optional, tag = "18")]
    pub asserted_date: ::core::option::Option<DateTime>,
    /// Who recorded the sensitivity
    #[prost(message, optional, tag = "19")]
    pub recorder: ::core::option::Option<Reference>,
    /// Source of the information about the allergy
    #[prost(message, optional, tag = "20")]
    pub asserter: ::core::option::Option<Reference>,
    /// Date(/time) of last known occurrence of a reaction
    #[prost(message, optional, tag = "21")]
    pub last_occurrence: ::core::option::Option<DateTime>,
    /// Additional text not captured in other fields
    #[prost(message, repeated, tag = "22")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "23")]
    pub reaction: prost::alloc::vec::Vec<allergy_intolerance::Reaction>,
}
/// Nested message and enum types in `AllergyIntolerance`.
pub mod allergy_intolerance {
    /// When allergy or intolerance was identified
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Onset {
        #[prost(oneof = "onset::Onset", tags = "1, 2, 3, 4, 5")]
        pub onset: ::core::option::Option<onset::Onset>,
    }
    /// Nested message and enum types in `Onset`.
    pub mod onset {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Onset {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Age(super::super::Age),
            #[prost(message, tag = "3")]
            Period(super::super::Period),
            #[prost(message, tag = "4")]
            Range(super::super::Range),
            #[prost(message, tag = "5")]
            StringValue(super::super::String),
        }
    }
    /// Adverse Reaction Events linked to exposure to substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Reaction {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Specific substance or pharmaceutical product considered to be responsible
        /// for event
        #[prost(message, optional, tag = "4")]
        pub substance: ::core::option::Option<super::CodeableConcept>,
        /// Clinical symptoms/signs associated with the Event
        #[prost(message, repeated, tag = "5")]
        pub manifestation: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Description of the event as a whole
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        /// Date(/time) when manifestations showed
        #[prost(message, optional, tag = "7")]
        pub onset: ::core::option::Option<super::DateTime>,
        /// mild | moderate | severe (of event as a whole)
        #[prost(message, optional, tag = "8")]
        pub severity: ::core::option::Option<super::AllergyIntoleranceSeverityCode>,
        /// How the subject was exposed to the substance
        #[prost(message, optional, tag = "9")]
        pub exposure_route: ::core::option::Option<super::CodeableConcept>,
        /// Text about event not captured in other fields
        #[prost(message, repeated, tag = "10")]
        pub note: prost::alloc::vec::Vec<super::Annotation>,
    }
}
/// Auto-generated from StructureDefinition for Appointment, last updated
/// 2017-04-19T07:44:43.294+10:00. A booking of a healthcare event among
/// patient(s), practitioner(s), related person(s) and/or device(s) for a
/// specific date/time. This may result in one or more Encounter(s). See
/// <http://hl7.org/fhir/StructureDefinition/Appointment>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Appointment {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this item
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// proposed | pending | booked | arrived | fulfilled | cancelled | noshow |
    /// entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<AppointmentStatusCode>,
    /// A broad categorisation of the service that is to be performed during this
    /// appointment
    #[prost(message, optional, tag = "11")]
    pub service_category: ::core::option::Option<CodeableConcept>,
    /// The specific service that is to be performed during this appointment
    #[prost(message, repeated, tag = "12")]
    pub service_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// The specialty of a practitioner that would be required to perform the
    /// service requested in this appointment
    #[prost(message, repeated, tag = "13")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// The style of appointment or patient that has been booked in the slot (not
    /// service type)
    #[prost(message, optional, tag = "14")]
    pub appointment_type: ::core::option::Option<CodeableConcept>,
    /// Reason this appointment is scheduled
    #[prost(message, repeated, tag = "15")]
    pub reason: prost::alloc::vec::Vec<CodeableConcept>,
    /// Reason the appointment is to takes place (resource)
    #[prost(message, repeated, tag = "16")]
    pub indication: prost::alloc::vec::Vec<Reference>,
    /// Used to make informed decisions if needing to re-prioritize
    #[prost(message, optional, tag = "17")]
    pub priority: ::core::option::Option<UnsignedInt>,
    /// Shown on a subject line in a meeting request, or appointment list
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<String>,
    /// Additional information to support the appointment
    #[prost(message, repeated, tag = "19")]
    pub supporting_information: prost::alloc::vec::Vec<Reference>,
    /// When appointment is to take place
    #[prost(message, optional, tag = "20")]
    pub start: ::core::option::Option<Instant>,
    /// When appointment is to conclude
    #[prost(message, optional, tag = "21")]
    pub end: ::core::option::Option<Instant>,
    /// Can be less than start/end (e.g. estimate)
    #[prost(message, optional, tag = "22")]
    pub minutes_duration: ::core::option::Option<PositiveInt>,
    /// The slots that this appointment is filling
    #[prost(message, repeated, tag = "23")]
    pub slot: prost::alloc::vec::Vec<Reference>,
    /// The date that this appointment was initially created
    #[prost(message, optional, tag = "24")]
    pub created: ::core::option::Option<DateTime>,
    /// Additional comments
    #[prost(message, optional, tag = "25")]
    pub comment: ::core::option::Option<String>,
    /// The ReferralRequest provided as information to allocate to the Encounter
    #[prost(message, repeated, tag = "26")]
    pub incoming_referral: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "27")]
    pub participant: prost::alloc::vec::Vec<appointment::Participant>,
    /// Potential date/time interval(s) requested to allocate the appointment
    /// within
    #[prost(message, repeated, tag = "28")]
    pub requested_period: prost::alloc::vec::Vec<Period>,
}
/// Nested message and enum types in `Appointment`.
pub mod appointment {
    /// Participants involved in appointment
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Role of participant in the appointment
        #[prost(message, repeated, tag = "4")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Person, Location/HealthcareService or Device
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
        /// required | optional | information-only
        #[prost(message, optional, tag = "6")]
        pub required: ::core::option::Option<super::ParticipantRequiredCode>,
        /// accepted | declined | tentative | needs-action
        #[prost(message, optional, tag = "7")]
        pub status: ::core::option::Option<super::ParticipationStatusCode>,
    }
}
/// Auto-generated from StructureDefinition for AppointmentResponse, last updated
/// 2017-04-19T07:44:43.294+10:00. A reply to an appointment request for a
/// patient and/or practitioner(s), such as a confirmation or rejection. See
/// <http://hl7.org/fhir/StructureDefinition/AppointmentResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AppointmentResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this item
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Appointment this response relates to
    #[prost(message, optional, tag = "10")]
    pub appointment: ::core::option::Option<Reference>,
    /// Time from appointment, or requested new start time
    #[prost(message, optional, tag = "11")]
    pub start: ::core::option::Option<Instant>,
    /// Time from appointment, or requested new end time
    #[prost(message, optional, tag = "12")]
    pub end: ::core::option::Option<Instant>,
    /// Role of participant in the appointment
    #[prost(message, repeated, tag = "13")]
    pub participant_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Person, Location/HealthcareService or Device
    #[prost(message, optional, tag = "14")]
    pub actor: ::core::option::Option<Reference>,
    /// accepted | declined | tentative | in-process | completed | needs-action |
    /// entered-in-error
    #[prost(message, optional, tag = "15")]
    pub participant_status: ::core::option::Option<ParticipationStatusCode>,
    /// Additional comments
    #[prost(message, optional, tag = "16")]
    pub comment: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for AuditEvent, last updated
/// 2017-04-19T07:44:43.294+10:00. Event record kept for security purposes. See
/// <http://hl7.org/fhir/StructureDefinition/AuditEvent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct AuditEvent {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Type/identifier of event
    #[prost(message, optional, tag = "9")]
    pub r#type: ::core::option::Option<Coding>,
    /// More specific type/id for the event
    #[prost(message, repeated, tag = "10")]
    pub subtype: prost::alloc::vec::Vec<Coding>,
    /// Type of action performed during the event
    #[prost(message, optional, tag = "11")]
    pub action: ::core::option::Option<AuditEventActionCode>,
    /// Time when the event occurred on source
    #[prost(message, optional, tag = "12")]
    pub recorded: ::core::option::Option<Instant>,
    /// Whether the event succeeded or failed
    #[prost(message, optional, tag = "13")]
    pub outcome: ::core::option::Option<AuditEventOutcomeCode>,
    /// Description of the event outcome
    #[prost(message, optional, tag = "14")]
    pub outcome_desc: ::core::option::Option<String>,
    /// The purposeOfUse of the event
    #[prost(message, repeated, tag = "15")]
    pub purpose_of_event: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "16")]
    pub agent: prost::alloc::vec::Vec<audit_event::Agent>,
    #[prost(message, optional, tag = "17")]
    pub source: ::core::option::Option<audit_event::Source>,
    #[prost(message, repeated, tag = "18")]
    pub entity: prost::alloc::vec::Vec<audit_event::Entity>,
}
/// Nested message and enum types in `AuditEvent`.
pub mod audit_event {
    /// Actor involved in the event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Agent {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Agent role in the event
        #[prost(message, repeated, tag = "4")]
        pub role: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Direct reference to resource
        #[prost(message, optional, tag = "5")]
        pub reference: ::core::option::Option<super::Reference>,
        /// Unique identifier for the user
        #[prost(message, optional, tag = "6")]
        pub user_id: ::core::option::Option<super::Identifier>,
        /// Alternative User id e.g. authentication
        #[prost(message, optional, tag = "7")]
        pub alt_id: ::core::option::Option<super::String>,
        /// Human-meaningful name for the agent
        #[prost(message, optional, tag = "8")]
        pub name: ::core::option::Option<super::String>,
        /// Whether user is initiator
        #[prost(message, optional, tag = "9")]
        pub requestor: ::core::option::Option<super::Boolean>,
        /// Where
        #[prost(message, optional, tag = "10")]
        pub location: ::core::option::Option<super::Reference>,
        /// Policy that authorized event
        #[prost(message, repeated, tag = "11")]
        pub policy: prost::alloc::vec::Vec<super::Uri>,
        /// Type of media
        #[prost(message, optional, tag = "12")]
        pub media: ::core::option::Option<super::Coding>,
        #[prost(message, optional, tag = "13")]
        pub network: ::core::option::Option<agent::Network>,
        /// Reason given for this user
        #[prost(message, repeated, tag = "14")]
        pub purpose_of_use: prost::alloc::vec::Vec<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Agent`.
    pub mod agent {
        /// Logical network location for application activity
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Network {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Identifier for the network access point of the user device
            #[prost(message, optional, tag = "4")]
            pub address: ::core::option::Option<super::super::String>,
            /// The type of network access point
            #[prost(message, optional, tag = "5")]
            pub r#type: ::core::option::Option<super::super::AuditEventAgentNetworkTypeCode>,
        }
    }
    /// Audit Event Reporter
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Source {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Logical source location within the enterprise
        #[prost(message, optional, tag = "4")]
        pub site: ::core::option::Option<super::String>,
        /// The identity of source detecting the event
        #[prost(message, optional, tag = "5")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// The type of source where event originated
        #[prost(message, repeated, tag = "6")]
        pub r#type: prost::alloc::vec::Vec<super::Coding>,
    }
    /// Data or objects used
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Entity {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Specific instance of object
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Specific instance of resource
        #[prost(message, optional, tag = "5")]
        pub reference: ::core::option::Option<super::Reference>,
        /// Type of entity involved
        #[prost(message, optional, tag = "6")]
        pub r#type: ::core::option::Option<super::Coding>,
        /// What role the entity played
        #[prost(message, optional, tag = "7")]
        pub role: ::core::option::Option<super::Coding>,
        /// Life-cycle stage for the entity
        #[prost(message, optional, tag = "8")]
        pub lifecycle: ::core::option::Option<super::Coding>,
        /// Security labels on the entity
        #[prost(message, repeated, tag = "9")]
        pub security_label: prost::alloc::vec::Vec<super::Coding>,
        /// Descriptor for entity
        #[prost(message, optional, tag = "10")]
        pub name: ::core::option::Option<super::String>,
        /// Descriptive text
        #[prost(message, optional, tag = "11")]
        pub description: ::core::option::Option<super::String>,
        /// Query parameters
        #[prost(message, optional, tag = "12")]
        pub query: ::core::option::Option<super::Base64Binary>,
        #[prost(message, repeated, tag = "13")]
        pub detail: prost::alloc::vec::Vec<entity::Detail>,
    }
    /// Nested message and enum types in `Entity`.
    pub mod entity {
        /// Additional Information about the entity
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Detail {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Name of the property
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::String>,
            /// Property value
            #[prost(message, optional, tag = "5")]
            pub value: ::core::option::Option<super::super::Base64Binary>,
        }
    }
}
/// Auto-generated from StructureDefinition for Basic, last updated
/// 2017-04-19T07:44:43.294+10:00. Resource for non-supported content. See
/// <http://hl7.org/fhir/StructureDefinition/Basic>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Basic {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Kind of Resource
    #[prost(message, optional, tag = "10")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Identifies the focus of this resource
    #[prost(message, optional, tag = "11")]
    pub subject: ::core::option::Option<Reference>,
    /// When created
    #[prost(message, optional, tag = "12")]
    pub created: ::core::option::Option<Date>,
    /// Who created
    #[prost(message, optional, tag = "13")]
    pub author: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Binary, last updated
/// 2017-04-19T07:44:43.294+10:00. Pure binary content defined by a format other
/// than FHIR. See <http://hl7.org/fhir/StructureDefinition/Binary>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Binary {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// MimeType of the binary content
    #[prost(message, optional, tag = "5")]
    pub content_type: ::core::option::Option<MimeTypeCode>,
    /// Access Control Management
    #[prost(message, optional, tag = "6")]
    pub security_context: ::core::option::Option<Reference>,
    /// The actual content
    #[prost(message, optional, tag = "7")]
    pub content: ::core::option::Option<Base64Binary>,
}
/// Auto-generated from StructureDefinition for BodySite, last updated
/// 2017-04-19T07:44:43.294+10:00. Specific and identified anatomical location.
/// See <http://hl7.org/fhir/StructureDefinition/BodySite>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct BodySite {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Bodysite identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this body site record is in active use
    #[prost(message, optional, tag = "10")]
    pub active: ::core::option::Option<Boolean>,
    /// Named anatomical location
    #[prost(message, optional, tag = "11")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Modification to location code
    #[prost(message, repeated, tag = "12")]
    pub qualifier: prost::alloc::vec::Vec<CodeableConcept>,
    /// Anatomical location description
    #[prost(message, optional, tag = "13")]
    pub description: ::core::option::Option<String>,
    /// Attached images
    #[prost(message, repeated, tag = "14")]
    pub image: prost::alloc::vec::Vec<Attachment>,
    /// Who this is about
    #[prost(message, optional, tag = "15")]
    pub patient: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Bundle, last updated
/// 2017-04-19T07:44:43.294+10:00. Contains a collection of resources. See
/// <http://hl7.org/fhir/StructureDefinition/Bundle>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Bundle {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Persistent identifier for the bundle
    #[prost(message, optional, tag = "5")]
    pub identifier: ::core::option::Option<Identifier>,
    /// document | message | transaction | transaction-response | batch |
    /// batch-response | history | searchset | collection
    #[prost(message, optional, tag = "6")]
    pub r#type: ::core::option::Option<BundleTypeCode>,
    /// If search, the total number of matches
    #[prost(message, optional, tag = "7")]
    pub total: ::core::option::Option<UnsignedInt>,
    #[prost(message, repeated, tag = "8")]
    pub link: prost::alloc::vec::Vec<bundle::Link>,
    #[prost(message, repeated, tag = "9")]
    pub entry: prost::alloc::vec::Vec<bundle::Entry>,
    /// Digital Signature
    #[prost(message, optional, tag = "10")]
    pub signature: ::core::option::Option<Signature>,
}
/// Nested message and enum types in `Bundle`.
pub mod bundle {
    /// Links related to this Bundle
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Link {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// See
        /// <http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1>
        #[prost(message, optional, tag = "4")]
        pub relation: ::core::option::Option<super::String>,
        /// Reference details for the link
        #[prost(message, optional, tag = "5")]
        pub url: ::core::option::Option<super::Uri>,
    }
    /// Entry in the bundle - will have a resource, or information
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Entry {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Links related to this entry
        #[prost(message, repeated, tag = "4")]
        pub link: prost::alloc::vec::Vec<Link>,
        /// Absolute URL for resource (server address, or UUID/OID)
        #[prost(message, optional, tag = "5")]
        pub full_url: ::core::option::Option<super::Uri>,
        /// A resource in the bundle
        #[prost(message, optional, tag = "6")]
        pub resource: ::core::option::Option<super::ContainedResource>,
        #[prost(message, optional, tag = "7")]
        pub search: ::core::option::Option<entry::Search>,
        #[prost(message, optional, tag = "8")]
        pub request: ::core::option::Option<entry::Request>,
        #[prost(message, optional, tag = "9")]
        pub response: ::core::option::Option<entry::Response>,
    }
    /// Nested message and enum types in `Entry`.
    pub mod entry {
        /// Search related information
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Search {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// match | include | outcome - why this is in the result set
            #[prost(message, optional, tag = "4")]
            pub mode: ::core::option::Option<super::super::SearchEntryModeCode>,
            /// Search ranking (between 0 and 1)
            #[prost(message, optional, tag = "5")]
            pub score: ::core::option::Option<super::super::Decimal>,
        }
        /// Transaction Related Information
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Request {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// GET | POST | PUT | DELETE
            #[prost(message, optional, tag = "4")]
            pub method: ::core::option::Option<super::super::HttpVerbCode>,
            /// URL for HTTP equivalent of this entry
            #[prost(message, optional, tag = "5")]
            pub url: ::core::option::Option<super::super::Uri>,
            /// For managing cache currency
            #[prost(message, optional, tag = "6")]
            pub if_none_match: ::core::option::Option<super::super::String>,
            /// For managing update contention
            #[prost(message, optional, tag = "7")]
            pub if_modified_since: ::core::option::Option<super::super::Instant>,
            /// For managing update contention
            #[prost(message, optional, tag = "8")]
            pub if_match: ::core::option::Option<super::super::String>,
            /// For conditional creates
            #[prost(message, optional, tag = "9")]
            pub if_none_exist: ::core::option::Option<super::super::String>,
        }
        /// Transaction Related Information
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Response {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Status response code (text optional)
            #[prost(message, optional, tag = "4")]
            pub status: ::core::option::Option<super::super::String>,
            /// The location, if the operation returns a location
            #[prost(message, optional, tag = "5")]
            pub location: ::core::option::Option<super::super::Uri>,
            /// The etag for the resource (if relevant)
            #[prost(message, optional, tag = "6")]
            pub etag: ::core::option::Option<super::super::String>,
            /// Server's date time modified
            #[prost(message, optional, tag = "7")]
            pub last_modified: ::core::option::Option<super::super::Instant>,
            /// OperationOutcome with hints and warnings (for batch/transaction)
            #[prost(message, optional, tag = "8")]
            pub outcome: ::core::option::Option<super::super::ContainedResource>,
        }
    }
}
/// Auto-generated from StructureDefinition for CapabilityStatement, last updated
/// 2017-04-19T07:44:43.294+10:00. A statement of system capabilities. See
/// <http://hl7.org/fhir/StructureDefinition/CapabilityStatement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CapabilityStatement {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this capability statement (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the capability statement
    #[prost(message, optional, tag = "10")]
    pub version: ::core::option::Option<String>,
    /// Name for this capability statement (computer friendly)
    #[prost(message, optional, tag = "11")]
    pub name: ::core::option::Option<String>,
    /// Name for this capability statement (human friendly)
    #[prost(message, optional, tag = "12")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "14")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "15")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "16")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "17")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the capability statement
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "19")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for capability statement (if applicable)
    #[prost(message, repeated, tag = "20")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this capability statement is defined
    #[prost(message, optional, tag = "21")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "22")]
    pub copyright: ::core::option::Option<Markdown>,
    /// instance | capability | requirements
    #[prost(message, optional, tag = "23")]
    pub kind: ::core::option::Option<CapabilityStatementKindCode>,
    /// Canonical URL of another capability statement this implements
    #[prost(message, repeated, tag = "24")]
    pub instantiates: prost::alloc::vec::Vec<Uri>,
    #[prost(message, optional, tag = "25")]
    pub software: ::core::option::Option<capability_statement::Software>,
    #[prost(message, optional, tag = "26")]
    pub implementation: ::core::option::Option<capability_statement::Implementation>,
    /// FHIR Version the system uses
    #[prost(message, optional, tag = "27")]
    pub fhir_version: ::core::option::Option<Id>,
    /// no | extensions | elements | both
    #[prost(message, optional, tag = "28")]
    pub accept_unknown: ::core::option::Option<UnknownContentCodeCode>,
    /// formats supported (xml | json | ttl | mime type)
    #[prost(message, repeated, tag = "29")]
    pub format: prost::alloc::vec::Vec<MimeTypeCode>,
    /// Patch formats supported
    #[prost(message, repeated, tag = "30")]
    pub patch_format: prost::alloc::vec::Vec<MimeTypeCode>,
    /// Implementation guides supported
    #[prost(message, repeated, tag = "31")]
    pub implementation_guide: prost::alloc::vec::Vec<Uri>,
    /// Profiles for use cases supported
    #[prost(message, repeated, tag = "32")]
    pub profile: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "33")]
    pub rest: prost::alloc::vec::Vec<capability_statement::Rest>,
    #[prost(message, repeated, tag = "34")]
    pub messaging: prost::alloc::vec::Vec<capability_statement::Messaging>,
    #[prost(message, repeated, tag = "35")]
    pub document: prost::alloc::vec::Vec<capability_statement::Document>,
}
/// Nested message and enum types in `CapabilityStatement`.
pub mod capability_statement {
    /// Software that is covered by this capability statement
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Software {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// A name the software is known by
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Version covered by this statement
        #[prost(message, optional, tag = "5")]
        pub version: ::core::option::Option<super::String>,
        /// Date this version released
        #[prost(message, optional, tag = "6")]
        pub release_date: ::core::option::Option<super::DateTime>,
    }
    /// If this describes a specific instance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Implementation {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Describes this specific instance
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Base URL for the installation
        #[prost(message, optional, tag = "5")]
        pub url: ::core::option::Option<super::Uri>,
    }
    /// If the endpoint is a RESTful one
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Rest {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// client | server
        #[prost(message, optional, tag = "4")]
        pub mode: ::core::option::Option<super::RestfulCapabilityModeCode>,
        /// General description of implementation
        #[prost(message, optional, tag = "5")]
        pub documentation: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "6")]
        pub security: ::core::option::Option<rest::Security>,
        #[prost(message, repeated, tag = "7")]
        pub resource: prost::alloc::vec::Vec<rest::Resource>,
        #[prost(message, repeated, tag = "8")]
        pub interaction: prost::alloc::vec::Vec<rest::SystemInteraction>,
        /// Search parameters for searching all resources
        #[prost(message, repeated, tag = "9")]
        pub search_param: prost::alloc::vec::Vec<rest::resource::SearchParam>,
        #[prost(message, repeated, tag = "10")]
        pub operation: prost::alloc::vec::Vec<rest::Operation>,
        /// Compartments served/used by system
        #[prost(message, repeated, tag = "11")]
        pub compartment: prost::alloc::vec::Vec<super::Uri>,
    }
    /// Nested message and enum types in `Rest`.
    pub mod rest {
        /// Information about security of implementation
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Security {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Adds CORS Headers (<http://enable-cors.org/>)
            #[prost(message, optional, tag = "4")]
            pub cors: ::core::option::Option<super::super::Boolean>,
            /// OAuth | SMART-on-FHIR | NTLM | Basic | Kerberos | Certificates
            #[prost(message, repeated, tag = "5")]
            pub service: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// General description of how security works
            #[prost(message, optional, tag = "6")]
            pub description: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "7")]
            pub certificate: prost::alloc::vec::Vec<security::Certificate>,
        }
        /// Nested message and enum types in `Security`.
        pub mod security {
            /// Certificates associated with security profiles
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Certificate {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Mime type for certificates
                #[prost(message, optional, tag = "4")]
                pub r#type: ::core::option::Option<super::super::super::MimeTypeCode>,
                /// Actual certificate
                #[prost(message, optional, tag = "5")]
                pub blob: ::core::option::Option<super::super::super::Base64Binary>,
            }
        }
        /// Resource served on the REST interface
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Resource {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// A resource type that is supported
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::ResourceTypeCode>,
            /// Base System profile for all uses of resource
            #[prost(message, optional, tag = "5")]
            pub profile: ::core::option::Option<super::super::Reference>,
            /// Additional information about the use of the resource type
            #[prost(message, optional, tag = "6")]
            pub documentation: ::core::option::Option<super::super::Markdown>,
            #[prost(message, repeated, tag = "7")]
            pub interaction: prost::alloc::vec::Vec<resource::ResourceInteraction>,
            /// no-version | versioned | versioned-update
            #[prost(message, optional, tag = "8")]
            pub versioning: ::core::option::Option<super::super::ResourceVersionPolicyCode>,
            /// Whether vRead can return past versions
            #[prost(message, optional, tag = "9")]
            pub read_history: ::core::option::Option<super::super::Boolean>,
            /// If update can commit to a new identity
            #[prost(message, optional, tag = "10")]
            pub update_create: ::core::option::Option<super::super::Boolean>,
            /// If allows/uses conditional create
            #[prost(message, optional, tag = "11")]
            pub conditional_create: ::core::option::Option<super::super::Boolean>,
            /// not-supported | modified-since | not-match | full-support
            #[prost(message, optional, tag = "12")]
            pub conditional_read: ::core::option::Option<super::super::ConditionalReadStatusCode>,
            /// If allows/uses conditional update
            #[prost(message, optional, tag = "13")]
            pub conditional_update: ::core::option::Option<super::super::Boolean>,
            /// not-supported | single | multiple - how conditional delete is supported
            #[prost(message, optional, tag = "14")]
            pub conditional_delete:
                ::core::option::Option<super::super::ConditionalDeleteStatusCode>,
            /// literal | logical | resolves | enforced | local
            #[prost(message, repeated, tag = "15")]
            pub reference_policy: prost::alloc::vec::Vec<super::super::ReferenceHandlingPolicyCode>,
            /// _include values supported by the server
            #[prost(message, repeated, tag = "16")]
            pub search_include: prost::alloc::vec::Vec<super::super::String>,
            /// _revinclude values supported by the server
            #[prost(message, repeated, tag = "17")]
            pub search_rev_include: prost::alloc::vec::Vec<super::super::String>,
            #[prost(message, repeated, tag = "18")]
            pub search_param: prost::alloc::vec::Vec<resource::SearchParam>,
        }
        /// Nested message and enum types in `Resource`.
        pub mod resource {
            /// What operations are supported?
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ResourceInteraction {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// read | vread | update | patch | delete | history-instance |
                /// history-type | create | search-type
                #[prost(message, optional, tag = "4")]
                pub code: ::core::option::Option<super::super::super::TypeRestfulInteractionCode>,
                /// Anything special about operation behavior
                #[prost(message, optional, tag = "5")]
                pub documentation: ::core::option::Option<super::super::super::String>,
            }
            /// Search parameters supported by implementation
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct SearchParam {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Name of search parameter
                #[prost(message, optional, tag = "4")]
                pub name: ::core::option::Option<super::super::super::String>,
                /// Source of definition for parameter
                #[prost(message, optional, tag = "5")]
                pub definition: ::core::option::Option<super::super::super::Uri>,
                /// number | date | string | token | reference | composite | quantity |
                /// uri
                #[prost(message, optional, tag = "6")]
                pub r#type: ::core::option::Option<super::super::super::SearchParamTypeCode>,
                /// Server-specific usage
                #[prost(message, optional, tag = "7")]
                pub documentation: ::core::option::Option<super::super::super::String>,
            }
        }
        /// What operations are supported?
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SystemInteraction {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// transaction | batch | search-system | history-system
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::SystemRestfulInteractionCode>,
            /// Anything special about operation behavior
            #[prost(message, optional, tag = "5")]
            pub documentation: ::core::option::Option<super::super::String>,
        }
        /// Definition of an operation or a custom query
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Operation {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Name by which the operation/query is invoked
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::String>,
            /// The defined operation/query
            #[prost(message, optional, tag = "5")]
            pub definition: ::core::option::Option<super::super::Reference>,
        }
    }
    /// If messaging is supported
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Messaging {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub endpoint: prost::alloc::vec::Vec<messaging::Endpoint>,
        /// Reliable Message Cache Length (min)
        #[prost(message, optional, tag = "5")]
        pub reliable_cache: ::core::option::Option<super::UnsignedInt>,
        /// Messaging interface behavior details
        #[prost(message, optional, tag = "6")]
        pub documentation: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "7")]
        pub supported_message: prost::alloc::vec::Vec<messaging::SupportedMessage>,
        #[prost(message, repeated, tag = "8")]
        pub event: prost::alloc::vec::Vec<messaging::Event>,
    }
    /// Nested message and enum types in `Messaging`.
    pub mod messaging {
        /// Where messages should be sent
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Endpoint {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// http | ftp | mllp +
            #[prost(message, optional, tag = "4")]
            pub protocol: ::core::option::Option<super::super::Coding>,
            /// Network address or identifier of the end-point
            #[prost(message, optional, tag = "5")]
            pub address: ::core::option::Option<super::super::Uri>,
        }
        /// Messages supported by this system
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SupportedMessage {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// sender | receiver
            #[prost(message, optional, tag = "4")]
            pub mode: ::core::option::Option<super::super::EventCapabilityModeCode>,
            /// Message supported by this system
            #[prost(message, optional, tag = "5")]
            pub definition: ::core::option::Option<super::super::Reference>,
        }
        /// Declare support for this event
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Event {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Event type
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::Coding>,
            /// Consequence | Currency | Notification
            #[prost(message, optional, tag = "5")]
            pub category: ::core::option::Option<super::super::MessageSignificanceCategoryCode>,
            /// sender | receiver
            #[prost(message, optional, tag = "6")]
            pub mode: ::core::option::Option<super::super::EventCapabilityModeCode>,
            /// Resource that's focus of message
            #[prost(message, optional, tag = "7")]
            pub focus: ::core::option::Option<super::super::ResourceTypeCode>,
            /// Profile that describes the request
            #[prost(message, optional, tag = "8")]
            pub request: ::core::option::Option<super::super::Reference>,
            /// Profile that describes the response
            #[prost(message, optional, tag = "9")]
            pub response: ::core::option::Option<super::super::Reference>,
            /// Endpoint-specific event documentation
            #[prost(message, optional, tag = "10")]
            pub documentation: ::core::option::Option<super::super::String>,
        }
    }
    /// Document definition
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Document {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// producer | consumer
        #[prost(message, optional, tag = "4")]
        pub mode: ::core::option::Option<super::DocumentModeCode>,
        /// Description of document support
        #[prost(message, optional, tag = "5")]
        pub documentation: ::core::option::Option<super::String>,
        /// Constraint on a resource used in the document
        #[prost(message, optional, tag = "6")]
        pub profile: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for CarePlan, last updated
/// 2017-04-19T07:44:43.294+10:00. Healthcare plan for patient or group. See
/// <http://hl7.org/fhir/StructureDefinition/CarePlan>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CarePlan {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this plan
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Protocol or definition
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Reference>,
    /// Fulfills care plan
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// CarePlan replaced by this CarePlan
    #[prost(message, repeated, tag = "12")]
    pub replaces: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced CarePlan
    #[prost(message, repeated, tag = "13")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// draft | active | suspended | completed | entered-in-error | cancelled |
    /// unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<CarePlanStatusCode>,
    /// proposal | plan | order | option
    #[prost(message, optional, tag = "15")]
    pub intent: ::core::option::Option<CarePlanIntentCode>,
    /// Type of plan
    #[prost(message, repeated, tag = "16")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Human-friendly name for the CarePlan
    #[prost(message, optional, tag = "17")]
    pub title: ::core::option::Option<String>,
    /// Summary of nature of plan
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<String>,
    /// Who care plan is for
    #[prost(message, optional, tag = "19")]
    pub subject: ::core::option::Option<Reference>,
    /// Created in context of
    #[prost(message, optional, tag = "20")]
    pub context: ::core::option::Option<Reference>,
    /// Time period plan covers
    #[prost(message, optional, tag = "21")]
    pub period: ::core::option::Option<Period>,
    /// Who is responsible for contents of the plan
    #[prost(message, repeated, tag = "22")]
    pub author: prost::alloc::vec::Vec<Reference>,
    /// Who's involved in plan?
    #[prost(message, repeated, tag = "23")]
    pub care_team: prost::alloc::vec::Vec<Reference>,
    /// Health issues this plan addresses
    #[prost(message, repeated, tag = "24")]
    pub addresses: prost::alloc::vec::Vec<Reference>,
    /// Information considered as part of plan
    #[prost(message, repeated, tag = "25")]
    pub supporting_info: prost::alloc::vec::Vec<Reference>,
    /// Desired outcome of plan
    #[prost(message, repeated, tag = "26")]
    pub goal: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "27")]
    pub activity: prost::alloc::vec::Vec<care_plan::Activity>,
    /// Comments about the plan
    #[prost(message, repeated, tag = "28")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `CarePlan`.
pub mod care_plan {
    /// Action to occur as part of plan
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Activity {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Results of the activity
        #[prost(message, repeated, tag = "4")]
        pub outcome_codeable_concept: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Appointment, Encounter, Procedure, etc.
        #[prost(message, repeated, tag = "5")]
        pub outcome_reference: prost::alloc::vec::Vec<super::Reference>,
        /// Comments about the activity status/progress
        #[prost(message, repeated, tag = "6")]
        pub progress: prost::alloc::vec::Vec<super::Annotation>,
        /// Activity details defined in specific resource
        #[prost(message, optional, tag = "7")]
        pub reference: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "8")]
        pub detail: ::core::option::Option<activity::Detail>,
    }
    /// Nested message and enum types in `Activity`.
    pub mod activity {
        /// In-line definition of activity
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Detail {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// diet | drug | encounter | observation | procedure | supply | other
            #[prost(message, optional, tag = "4")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Protocol or definition
            #[prost(message, optional, tag = "5")]
            pub definition: ::core::option::Option<super::super::Reference>,
            /// Detail type of activity
            #[prost(message, optional, tag = "6")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// Why activity should be done or why activity was prohibited
            #[prost(message, repeated, tag = "7")]
            pub reason_code: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Condition triggering need for activity
            #[prost(message, repeated, tag = "8")]
            pub reason_reference: prost::alloc::vec::Vec<super::super::Reference>,
            /// Goals this activity relates to
            #[prost(message, repeated, tag = "9")]
            pub goal: prost::alloc::vec::Vec<super::super::Reference>,
            /// not-started | scheduled | in-progress | on-hold | completed | cancelled
            /// | unknown
            #[prost(message, optional, tag = "10")]
            pub status: ::core::option::Option<super::super::CarePlanActivityStatusCode>,
            /// Reason for current status
            #[prost(message, optional, tag = "11")]
            pub status_reason: ::core::option::Option<super::super::String>,
            /// Do NOT do
            #[prost(message, optional, tag = "12")]
            pub prohibited: ::core::option::Option<super::super::Boolean>,
            #[prost(message, optional, tag = "13")]
            pub scheduled: ::core::option::Option<detail::Scheduled>,
            /// Where it should happen
            #[prost(message, optional, tag = "14")]
            pub location: ::core::option::Option<super::super::Reference>,
            /// Who will be responsible?
            #[prost(message, repeated, tag = "15")]
            pub performer: prost::alloc::vec::Vec<super::super::Reference>,
            #[prost(message, optional, tag = "16")]
            pub product: ::core::option::Option<detail::Product>,
            /// How to consume/day?
            #[prost(message, optional, tag = "17")]
            pub daily_amount: ::core::option::Option<super::super::SimpleQuantity>,
            /// How much to administer/supply/consume
            #[prost(message, optional, tag = "18")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// Extra info describing activity to perform
            #[prost(message, optional, tag = "19")]
            pub description: ::core::option::Option<super::super::String>,
        }
        /// Nested message and enum types in `Detail`.
        pub mod detail {
            /// When activity is to occur
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Scheduled {
                #[prost(oneof = "scheduled::Scheduled", tags = "1, 2, 3")]
                pub scheduled: ::core::option::Option<scheduled::Scheduled>,
            }
            /// Nested message and enum types in `Scheduled`.
            pub mod scheduled {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Scheduled {
                    #[prost(message, tag = "1")]
                    Timing(super::super::super::super::Timing),
                    #[prost(message, tag = "2")]
                    Period(super::super::super::super::Period),
                    #[prost(message, tag = "3")]
                    StringValue(super::super::super::super::String),
                }
            }
            /// What is to be administered/supplied
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Product {
                #[prost(oneof = "product::Product", tags = "1, 2")]
                pub product: ::core::option::Option<product::Product>,
            }
            /// Nested message and enum types in `Product`.
            pub mod product {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Product {
                    #[prost(message, tag = "1")]
                    CodeableConcept(super::super::super::super::CodeableConcept),
                    #[prost(message, tag = "2")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for CareTeam, last updated
/// 2017-04-19T07:44:43.294+10:00. Planned participants in the coordination and
/// delivery of care for a patient or group. See
/// <http://hl7.org/fhir/StructureDefinition/CareTeam>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CareTeam {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this team
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// proposed | active | suspended | inactive | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<CareTeamStatusCode>,
    /// Type of team
    #[prost(message, repeated, tag = "11")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Name of the team, such as crisis assessment team
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Who care team is for
    #[prost(message, optional, tag = "13")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or episode associated with CareTeam
    #[prost(message, optional, tag = "14")]
    pub context: ::core::option::Option<Reference>,
    /// Time period team covers
    #[prost(message, optional, tag = "15")]
    pub period: ::core::option::Option<Period>,
    #[prost(message, repeated, tag = "16")]
    pub participant: prost::alloc::vec::Vec<care_team::Participant>,
    /// Why the care team exists
    #[prost(message, repeated, tag = "17")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why the care team exists
    #[prost(message, repeated, tag = "18")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Organization responsible for the care team
    #[prost(message, repeated, tag = "19")]
    pub managing_organization: prost::alloc::vec::Vec<Reference>,
    /// Comments made about the CareTeam
    #[prost(message, repeated, tag = "20")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `CareTeam`.
pub mod care_team {
    /// Members of the team
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of involvement
        #[prost(message, optional, tag = "4")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Who is involved
        #[prost(message, optional, tag = "5")]
        pub member: ::core::option::Option<super::Reference>,
        /// Organization of the practitioner
        #[prost(message, optional, tag = "6")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
        /// Time period of participant
        #[prost(message, optional, tag = "7")]
        pub period: ::core::option::Option<super::Period>,
    }
}
/// Auto-generated from StructureDefinition for ChargeItem, last updated
/// 2017-04-19T07:44:43.294+10:00. Item containing charge code(s) associated with
/// the provision of healthcare provider products. See
/// <http://hl7.org/fhir/StructureDefinition/ChargeItem>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ChargeItem {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for item
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Defining information about the code of this charge item
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Uri>,
    /// planned | billable | not-billable | aborted | billed | entered-in-error |
    /// unknown
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<ChargeItemStatusCode>,
    /// Part of referenced ChargeItem
    #[prost(message, repeated, tag = "12")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// A code that identifies the charge, like a billing code
    #[prost(message, optional, tag = "13")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Individual service was done for/to
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter / Episode associated with event
    #[prost(message, optional, tag = "15")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "16")]
    pub occurrence: ::core::option::Option<charge_item::Occurrence>,
    #[prost(message, repeated, tag = "17")]
    pub participant: prost::alloc::vec::Vec<charge_item::Participant>,
    /// Organization providing the charged sevice
    #[prost(message, optional, tag = "18")]
    pub performing_organization: ::core::option::Option<Reference>,
    /// Organization requesting the charged service
    #[prost(message, optional, tag = "19")]
    pub requesting_organization: ::core::option::Option<Reference>,
    /// Quantity of which the charge item has been serviced
    #[prost(message, optional, tag = "20")]
    pub quantity: ::core::option::Option<Quantity>,
    /// Anatomical location, if relevant
    #[prost(message, repeated, tag = "21")]
    pub bodysite: prost::alloc::vec::Vec<CodeableConcept>,
    /// Factor overriding the associated rules
    #[prost(message, optional, tag = "22")]
    pub factor_override: ::core::option::Option<Decimal>,
    /// Price overriding the associated rules
    #[prost(message, optional, tag = "23")]
    pub price_override: ::core::option::Option<Money>,
    /// Reason for overriding the list price/factor
    #[prost(message, optional, tag = "24")]
    pub override_reason: ::core::option::Option<String>,
    /// Individual who was entering
    #[prost(message, optional, tag = "25")]
    pub enterer: ::core::option::Option<Reference>,
    /// Date the charge item was entered
    #[prost(message, optional, tag = "26")]
    pub entered_date: ::core::option::Option<DateTime>,
    /// Why was the charged  service rendered?
    #[prost(message, repeated, tag = "27")]
    pub reason: prost::alloc::vec::Vec<CodeableConcept>,
    /// Which rendered service is being charged?
    #[prost(message, repeated, tag = "28")]
    pub service: prost::alloc::vec::Vec<Reference>,
    /// Account to place this charge
    #[prost(message, repeated, tag = "29")]
    pub account: prost::alloc::vec::Vec<Reference>,
    /// Comments made about the ChargeItem
    #[prost(message, repeated, tag = "30")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Further information supporting the this charge
    #[prost(message, repeated, tag = "31")]
    pub supporting_information: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `ChargeItem`.
pub mod charge_item {
    /// When the charged service was applied
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Occurrence {
        #[prost(oneof = "occurrence::Occurrence", tags = "1, 2, 3")]
        pub occurrence: ::core::option::Option<occurrence::Occurrence>,
    }
    /// Nested message and enum types in `Occurrence`.
    pub mod occurrence {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Occurrence {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
        }
    }
    /// Who performed charged service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// What type of performance was done
        #[prost(message, optional, tag = "4")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Individual who was performing
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for Claim, last updated
/// 2017-04-19T07:44:43.294+10:00. Claim, Pre-determination or Pre-authorization.
/// See <http://hl7.org/fhir/StructureDefinition/Claim>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Claim {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Claim number
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// Type or discipline
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Finer grained claim type information
    #[prost(message, repeated, tag = "12")]
    pub sub_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// complete | proposed | exploratory | other
    #[prost(message, optional, tag = "13")]
    pub r#use: ::core::option::Option<UseCode>,
    /// The subject of the Products and Services
    #[prost(message, optional, tag = "14")]
    pub patient: ::core::option::Option<Reference>,
    /// Period for charge submission
    #[prost(message, optional, tag = "15")]
    pub billable_period: ::core::option::Option<Period>,
    /// Creation date
    #[prost(message, optional, tag = "16")]
    pub created: ::core::option::Option<DateTime>,
    /// Author
    #[prost(message, optional, tag = "17")]
    pub enterer: ::core::option::Option<Reference>,
    /// Target
    #[prost(message, optional, tag = "18")]
    pub insurer: ::core::option::Option<Reference>,
    /// Responsible provider
    #[prost(message, optional, tag = "19")]
    pub provider: ::core::option::Option<Reference>,
    /// Responsible organization
    #[prost(message, optional, tag = "20")]
    pub organization: ::core::option::Option<Reference>,
    /// Desired processing priority
    #[prost(message, optional, tag = "21")]
    pub priority: ::core::option::Option<CodeableConcept>,
    /// Funds requested to be reserved
    #[prost(message, optional, tag = "22")]
    pub funds_reserve: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "23")]
    pub related: prost::alloc::vec::Vec<claim::RelatedClaim>,
    /// Prescription authorizing services or products
    #[prost(message, optional, tag = "24")]
    pub prescription: ::core::option::Option<Reference>,
    /// Original prescription if superceded by fulfiller
    #[prost(message, optional, tag = "25")]
    pub original_prescription: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "26")]
    pub payee: ::core::option::Option<claim::Payee>,
    /// Treatment Referral
    #[prost(message, optional, tag = "27")]
    pub referral: ::core::option::Option<Reference>,
    /// Servicing Facility
    #[prost(message, optional, tag = "28")]
    pub facility: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "29")]
    pub care_team: prost::alloc::vec::Vec<claim::CareTeam>,
    #[prost(message, repeated, tag = "30")]
    pub information: prost::alloc::vec::Vec<claim::SpecialCondition>,
    #[prost(message, repeated, tag = "31")]
    pub diagnosis: prost::alloc::vec::Vec<claim::Diagnosis>,
    #[prost(message, repeated, tag = "32")]
    pub procedure: prost::alloc::vec::Vec<claim::Procedure>,
    #[prost(message, repeated, tag = "33")]
    pub insurance: prost::alloc::vec::Vec<claim::Insurance>,
    #[prost(message, optional, tag = "34")]
    pub accident: ::core::option::Option<claim::Accident>,
    /// Period unable to work
    #[prost(message, optional, tag = "35")]
    pub employment_impacted: ::core::option::Option<Period>,
    /// Period in hospital
    #[prost(message, optional, tag = "36")]
    pub hospitalization: ::core::option::Option<Period>,
    #[prost(message, repeated, tag = "37")]
    pub item: prost::alloc::vec::Vec<claim::Item>,
    /// Total claim cost
    #[prost(message, optional, tag = "38")]
    pub total: ::core::option::Option<Money>,
}
/// Nested message and enum types in `Claim`.
pub mod claim {
    /// Related Claims which may be revelant to processing this claimn
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelatedClaim {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to the related claim
        #[prost(message, optional, tag = "4")]
        pub claim: ::core::option::Option<super::Reference>,
        /// How the reference claim is related
        #[prost(message, optional, tag = "5")]
        pub relationship: ::core::option::Option<super::CodeableConcept>,
        /// Related file or case reference
        #[prost(message, optional, tag = "6")]
        pub reference: ::core::option::Option<super::Identifier>,
    }
    /// Party to be paid any benefits payable
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payee {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of party: Subscriber, Provider, other
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// organization | patient | practitioner | relatedperson
        #[prost(message, optional, tag = "5")]
        pub resource_type: ::core::option::Option<super::Coding>,
        /// Party to receive the payable
        #[prost(message, optional, tag = "6")]
        pub party: ::core::option::Option<super::Reference>,
    }
    /// Members of the care team
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CareTeam {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Number to covey order of careTeam
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Provider individual or organization
        #[prost(message, optional, tag = "5")]
        pub provider: ::core::option::Option<super::Reference>,
        /// Billing provider
        #[prost(message, optional, tag = "6")]
        pub responsible: ::core::option::Option<super::Boolean>,
        /// Role on the team
        #[prost(message, optional, tag = "7")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Type, classification or Specialization
        #[prost(message, optional, tag = "8")]
        pub qualification: ::core::option::Option<super::CodeableConcept>,
    }
    /// Exceptions, special considerations, the condition, situation, prior or
    /// concurrent issues
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SpecialCondition {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Information instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// General class of information
        #[prost(message, optional, tag = "5")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Type of information
        #[prost(message, optional, tag = "6")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "7")]
        pub timing: ::core::option::Option<special_condition::TimingType>,
        #[prost(message, optional, tag = "8")]
        pub value: ::core::option::Option<special_condition::Value>,
        /// Reason associated with the information
        #[prost(message, optional, tag = "9")]
        pub reason: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `SpecialCondition`.
    pub mod special_condition {
        /// When it occurred
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimingType {
            #[prost(oneof = "timing_type::Timing", tags = "1, 2")]
            pub timing: ::core::option::Option<timing_type::Timing>,
        }
        /// Nested message and enum types in `TimingType`.
        pub mod timing_type {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Timing {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Additional Data or supporting information
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Value {
            #[prost(oneof = "value::Value", tags = "1, 2, 3, 4")]
            pub value: ::core::option::Option<value::Value>,
        }
        /// Nested message and enum types in `Value`.
        pub mod value {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Value {
                #[prost(message, tag = "1")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "2")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "3")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "4")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// List of Diagnosis
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Diagnosis {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Number to covey order of diagnosis
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        #[prost(message, optional, tag = "5")]
        pub diagnosis: ::core::option::Option<diagnosis::DiagnosisType>,
        /// Timing or nature of the diagnosis
        #[prost(message, repeated, tag = "6")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Package billing code
        #[prost(message, optional, tag = "7")]
        pub package_code: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Diagnosis`.
    pub mod diagnosis {
        /// Patient's diagnosis
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DiagnosisType {
            #[prost(oneof = "diagnosis_type::Diagnosis", tags = "1, 2")]
            pub diagnosis: ::core::option::Option<diagnosis_type::Diagnosis>,
        }
        /// Nested message and enum types in `DiagnosisType`.
        pub mod diagnosis_type {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Diagnosis {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Procedures performed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Procedure {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Procedure sequence for reference
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// When the procedure was performed
        #[prost(message, optional, tag = "5")]
        pub date: ::core::option::Option<super::DateTime>,
        #[prost(message, optional, tag = "6")]
        pub procedure: ::core::option::Option<procedure::ProcedureType>,
    }
    /// Nested message and enum types in `Procedure`.
    pub mod procedure {
        /// Patient's list of procedures performed
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ProcedureType {
            #[prost(oneof = "procedure_type::Procedure", tags = "1, 2")]
            pub procedure: ::core::option::Option<procedure_type::Procedure>,
        }
        /// Nested message and enum types in `ProcedureType`.
        pub mod procedure_type {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Procedure {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Insurance or medical plan
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Insurance {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Service instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Is the focal Coverage
        #[prost(message, optional, tag = "5")]
        pub focal: ::core::option::Option<super::Boolean>,
        /// Insurance information
        #[prost(message, optional, tag = "6")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// Business agreement
        #[prost(message, optional, tag = "7")]
        pub business_arrangement: ::core::option::Option<super::String>,
        /// Pre-Authorization/Determination Reference
        #[prost(message, repeated, tag = "8")]
        pub pre_auth_ref: prost::alloc::vec::Vec<super::String>,
        /// Adjudication results
        #[prost(message, optional, tag = "9")]
        pub claim_response: ::core::option::Option<super::Reference>,
    }
    /// Details about an accident
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Accident {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// When the accident occurred
        /// see information codes
        /// see information codes
        #[prost(message, optional, tag = "4")]
        pub date: ::core::option::Option<super::Date>,
        /// The nature of the accident
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "6")]
        pub location: ::core::option::Option<accident::Location>,
    }
    /// Nested message and enum types in `Accident`.
    pub mod accident {
        /// Accident Place
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Location {
            #[prost(oneof = "location::Location", tags = "1, 2")]
            pub location: ::core::option::Option<location::Location>,
        }
        /// Nested message and enum types in `Location`.
        pub mod location {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Location {
                #[prost(message, tag = "1")]
                Address(super::super::super::Address),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Goods and Services
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Service instance
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Applicable careTeam members
        #[prost(message, repeated, tag = "5")]
        pub care_team_link_id: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable diagnoses
        #[prost(message, repeated, tag = "6")]
        pub diagnosis_link_id: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable procedures
        #[prost(message, repeated, tag = "7")]
        pub procedure_link_id: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable exception and supporting information
        #[prost(message, repeated, tag = "8")]
        pub information_link_id: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Revenue or cost center code
        #[prost(message, optional, tag = "9")]
        pub revenue: ::core::option::Option<super::CodeableConcept>,
        /// Type of service or product
        #[prost(message, optional, tag = "10")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Billing Code
        #[prost(message, optional, tag = "11")]
        pub service: ::core::option::Option<super::CodeableConcept>,
        /// Service/Product billing modifiers
        #[prost(message, repeated, tag = "12")]
        pub modifier: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Program specific reason for item inclusion
        #[prost(message, repeated, tag = "13")]
        pub program_code: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, optional, tag = "14")]
        pub serviced: ::core::option::Option<item::Serviced>,
        #[prost(message, optional, tag = "15")]
        pub location: ::core::option::Option<item::Location>,
        /// Count of Products or Services
        #[prost(message, optional, tag = "16")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Fee, charge or cost per point
        #[prost(message, optional, tag = "17")]
        pub unit_price: ::core::option::Option<super::Money>,
        /// Price scaling factor
        #[prost(message, optional, tag = "18")]
        pub factor: ::core::option::Option<super::Decimal>,
        /// Total item cost
        #[prost(message, optional, tag = "19")]
        pub net: ::core::option::Option<super::Money>,
        /// Unique Device Identifier
        #[prost(message, repeated, tag = "20")]
        pub udi: prost::alloc::vec::Vec<super::Reference>,
        /// Service Location
        #[prost(message, optional, tag = "21")]
        pub body_site: ::core::option::Option<super::CodeableConcept>,
        /// Service Sub-location
        #[prost(message, repeated, tag = "22")]
        pub sub_site: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Encounters related to this billed item
        #[prost(message, repeated, tag = "23")]
        pub encounter: prost::alloc::vec::Vec<super::Reference>,
        #[prost(message, repeated, tag = "24")]
        pub detail: prost::alloc::vec::Vec<item::Detail>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// Date or dates of Service
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Serviced {
            #[prost(oneof = "serviced::Serviced", tags = "1, 2")]
            pub serviced: ::core::option::Option<serviced::Serviced>,
        }
        /// Nested message and enum types in `Serviced`.
        pub mod serviced {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Serviced {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Place of service
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Location {
            #[prost(oneof = "location::Location", tags = "1, 2, 3")]
            pub location: ::core::option::Option<location::Location>,
        }
        /// Nested message and enum types in `Location`.
        pub mod location {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Location {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Address(super::super::super::Address),
                #[prost(message, tag = "3")]
                Reference(super::super::super::Reference),
            }
        }
        /// Additional items
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Detail {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Service instance
            #[prost(message, optional, tag = "4")]
            pub sequence: ::core::option::Option<super::super::PositiveInt>,
            /// Revenue or cost center code
            #[prost(message, optional, tag = "5")]
            pub revenue: ::core::option::Option<super::super::CodeableConcept>,
            /// Type of service or product
            #[prost(message, optional, tag = "6")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Billing Code
            #[prost(message, optional, tag = "7")]
            pub service: ::core::option::Option<super::super::CodeableConcept>,
            /// Service/Product billing modifiers
            #[prost(message, repeated, tag = "8")]
            pub modifier: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Program specific reason for item inclusion
            #[prost(message, repeated, tag = "9")]
            pub program_code: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Count of Products or Services
            #[prost(message, optional, tag = "10")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// Fee, charge or cost per point
            #[prost(message, optional, tag = "11")]
            pub unit_price: ::core::option::Option<super::super::Money>,
            /// Price scaling factor
            #[prost(message, optional, tag = "12")]
            pub factor: ::core::option::Option<super::super::Decimal>,
            /// Total additional item cost
            #[prost(message, optional, tag = "13")]
            pub net: ::core::option::Option<super::super::Money>,
            /// Unique Device Identifier
            #[prost(message, repeated, tag = "14")]
            pub udi: prost::alloc::vec::Vec<super::super::Reference>,
            #[prost(message, repeated, tag = "15")]
            pub sub_detail: prost::alloc::vec::Vec<detail::SubDetail>,
        }
        /// Nested message and enum types in `Detail`.
        pub mod detail {
            /// Additional items
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct SubDetail {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Service instance
                #[prost(message, optional, tag = "4")]
                pub sequence: ::core::option::Option<super::super::super::PositiveInt>,
                /// Revenue or cost center code
                #[prost(message, optional, tag = "5")]
                pub revenue: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Type of service or product
                #[prost(message, optional, tag = "6")]
                pub category: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Billing Code
                #[prost(message, optional, tag = "7")]
                pub service: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Service/Product billing modifiers
                #[prost(message, repeated, tag = "8")]
                pub modifier: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Program specific reason for item inclusion
                #[prost(message, repeated, tag = "9")]
                pub program_code: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Count of Products or Services
                #[prost(message, optional, tag = "10")]
                pub quantity: ::core::option::Option<super::super::super::SimpleQuantity>,
                /// Fee, charge or cost per point
                #[prost(message, optional, tag = "11")]
                pub unit_price: ::core::option::Option<super::super::super::Money>,
                /// Price scaling factor
                #[prost(message, optional, tag = "12")]
                pub factor: ::core::option::Option<super::super::super::Decimal>,
                /// Net additional item cost
                #[prost(message, optional, tag = "13")]
                pub net: ::core::option::Option<super::super::super::Money>,
                /// Unique Device Identifier
                #[prost(message, repeated, tag = "14")]
                pub udi: prost::alloc::vec::Vec<super::super::super::Reference>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for ClaimResponse, last updated
/// 2017-04-19T07:44:43.294+10:00. Remittance resource. See
/// <http://hl7.org/fhir/StructureDefinition/ClaimResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ClaimResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Response  number
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// The subject of the Products and Services
    #[prost(message, optional, tag = "11")]
    pub patient: ::core::option::Option<Reference>,
    /// Creation date
    #[prost(message, optional, tag = "12")]
    pub created: ::core::option::Option<DateTime>,
    /// Insurance issuing organization
    #[prost(message, optional, tag = "13")]
    pub insurer: ::core::option::Option<Reference>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "14")]
    pub request_provider: ::core::option::Option<Reference>,
    /// Responsible organization
    #[prost(message, optional, tag = "15")]
    pub request_organization: ::core::option::Option<Reference>,
    /// Id of resource triggering adjudication
    #[prost(message, optional, tag = "16")]
    pub request: ::core::option::Option<Reference>,
    /// complete | error | partial
    #[prost(message, optional, tag = "17")]
    pub outcome: ::core::option::Option<CodeableConcept>,
    /// Disposition Message
    #[prost(message, optional, tag = "18")]
    pub disposition: ::core::option::Option<String>,
    /// Party to be paid any benefits payable
    #[prost(message, optional, tag = "19")]
    pub payee_type: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "20")]
    pub item: prost::alloc::vec::Vec<claim_response::Item>,
    #[prost(message, repeated, tag = "21")]
    pub add_item: prost::alloc::vec::Vec<claim_response::AddedItem>,
    #[prost(message, repeated, tag = "22")]
    pub error: prost::alloc::vec::Vec<claim_response::Error>,
    /// Total Cost of service from the Claim
    #[prost(message, optional, tag = "23")]
    pub total_cost: ::core::option::Option<Money>,
    /// Unallocated deductible
    #[prost(message, optional, tag = "24")]
    pub unalloc_deductable: ::core::option::Option<Money>,
    /// Total benefit payable for the Claim
    #[prost(message, optional, tag = "25")]
    pub total_benefit: ::core::option::Option<Money>,
    #[prost(message, optional, tag = "26")]
    pub payment: ::core::option::Option<claim_response::Payment>,
    /// Funds reserved status
    #[prost(message, optional, tag = "27")]
    pub reserved: ::core::option::Option<Coding>,
    /// Printed Form Identifier
    #[prost(message, optional, tag = "28")]
    pub form: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "29")]
    pub process_note: prost::alloc::vec::Vec<claim_response::Note>,
    /// Request for additional information
    #[prost(message, repeated, tag = "30")]
    pub communication_request: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "31")]
    pub insurance: prost::alloc::vec::Vec<claim_response::Insurance>,
}
/// Nested message and enum types in `ClaimResponse`.
pub mod claim_response {
    /// Line items
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Service instance
        #[prost(message, optional, tag = "4")]
        pub sequence_link_id: ::core::option::Option<super::PositiveInt>,
        /// List of note numbers which apply
        #[prost(message, repeated, tag = "5")]
        pub note_number: prost::alloc::vec::Vec<super::PositiveInt>,
        #[prost(message, repeated, tag = "6")]
        pub adjudication: prost::alloc::vec::Vec<item::Adjudication>,
        #[prost(message, repeated, tag = "7")]
        pub detail: prost::alloc::vec::Vec<item::ItemDetail>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// Adjudication details
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Adjudication {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Adjudication category such as co-pay, eligible, benefit, etc.
            #[prost(message, optional, tag = "4")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Explanation of Adjudication outcome
            #[prost(message, optional, tag = "5")]
            pub reason: ::core::option::Option<super::super::CodeableConcept>,
            /// Monetary amount
            #[prost(message, optional, tag = "6")]
            pub amount: ::core::option::Option<super::super::Money>,
            /// Non-monetary value
            #[prost(message, optional, tag = "7")]
            pub value: ::core::option::Option<super::super::Decimal>,
        }
        /// Detail line items
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ItemDetail {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Service instance
            #[prost(message, optional, tag = "4")]
            pub sequence_link_id: ::core::option::Option<super::super::PositiveInt>,
            /// List of note numbers which apply
            #[prost(message, repeated, tag = "5")]
            pub note_number: prost::alloc::vec::Vec<super::super::PositiveInt>,
            /// Detail level adjudication details
            #[prost(message, repeated, tag = "6")]
            pub adjudication: prost::alloc::vec::Vec<Adjudication>,
            #[prost(message, repeated, tag = "7")]
            pub sub_detail: prost::alloc::vec::Vec<item_detail::SubDetail>,
        }
        /// Nested message and enum types in `ItemDetail`.
        pub mod item_detail {
            /// Subdetail line items
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct SubDetail {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Service instance
                #[prost(message, optional, tag = "4")]
                pub sequence_link_id: ::core::option::Option<super::super::super::PositiveInt>,
                /// List of note numbers which apply
                #[prost(message, repeated, tag = "5")]
                pub note_number: prost::alloc::vec::Vec<super::super::super::PositiveInt>,
                /// Subdetail level adjudication details
                #[prost(message, repeated, tag = "6")]
                pub adjudication: prost::alloc::vec::Vec<super::Adjudication>,
            }
        }
    }
    /// Insurer added line items
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AddedItem {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Service instances
        #[prost(message, repeated, tag = "4")]
        pub sequence_link_id: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Revenue or cost center code
        #[prost(message, optional, tag = "5")]
        pub revenue: ::core::option::Option<super::CodeableConcept>,
        /// Type of service or product
        #[prost(message, optional, tag = "6")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Group, Service or Product
        #[prost(message, optional, tag = "7")]
        pub service: ::core::option::Option<super::CodeableConcept>,
        /// Service/Product billing modifiers
        #[prost(message, repeated, tag = "8")]
        pub modifier: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Professional fee or Product charge
        #[prost(message, optional, tag = "9")]
        pub fee: ::core::option::Option<super::Money>,
        /// List of note numbers which apply
        #[prost(message, repeated, tag = "10")]
        pub note_number: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Added items adjudication
        #[prost(message, repeated, tag = "11")]
        pub adjudication: prost::alloc::vec::Vec<item::Adjudication>,
        #[prost(message, repeated, tag = "12")]
        pub detail: prost::alloc::vec::Vec<added_item::AddedItemsDetail>,
    }
    /// Nested message and enum types in `AddedItem`.
    pub mod added_item {
        /// Added items details
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AddedItemsDetail {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Revenue or cost center code
            #[prost(message, optional, tag = "4")]
            pub revenue: ::core::option::Option<super::super::CodeableConcept>,
            /// Type of service or product
            #[prost(message, optional, tag = "5")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Service or Product
            #[prost(message, optional, tag = "6")]
            pub service: ::core::option::Option<super::super::CodeableConcept>,
            /// Service/Product billing modifiers
            #[prost(message, repeated, tag = "7")]
            pub modifier: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Professional fee or Product charge
            #[prost(message, optional, tag = "8")]
            pub fee: ::core::option::Option<super::super::Money>,
            /// List of note numbers which apply
            #[prost(message, repeated, tag = "9")]
            pub note_number: prost::alloc::vec::Vec<super::super::PositiveInt>,
            /// Added items detail adjudication
            #[prost(message, repeated, tag = "10")]
            pub adjudication: prost::alloc::vec::Vec<super::item::Adjudication>,
        }
    }
    /// Processing errors
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Error {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Item sequence number
        #[prost(message, optional, tag = "4")]
        pub sequence_link_id: ::core::option::Option<super::PositiveInt>,
        /// Detail sequence number
        #[prost(message, optional, tag = "5")]
        pub detail_sequence_link_id: ::core::option::Option<super::PositiveInt>,
        /// Subdetail sequence number
        #[prost(message, optional, tag = "6")]
        pub subdetail_sequence_link_id: ::core::option::Option<super::PositiveInt>,
        /// Error code detailing processing issues
        #[prost(message, optional, tag = "7")]
        pub code: ::core::option::Option<super::CodeableConcept>,
    }
    /// Payment details, if paid
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payment {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Partial or Complete
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Payment adjustment for non-Claim issues
        #[prost(message, optional, tag = "5")]
        pub adjustment: ::core::option::Option<super::Money>,
        /// Explanation for the non-claim adjustment
        #[prost(message, optional, tag = "6")]
        pub adjustment_reason: ::core::option::Option<super::CodeableConcept>,
        /// Expected data of Payment
        #[prost(message, optional, tag = "7")]
        pub date: ::core::option::Option<super::Date>,
        /// Payable amount after adjustment
        #[prost(message, optional, tag = "8")]
        pub amount: ::core::option::Option<super::Money>,
        /// Identifier of the payment instrument
        #[prost(message, optional, tag = "9")]
        pub identifier: ::core::option::Option<super::Identifier>,
    }
    /// Processing notes
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Note {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Sequence Number for this note
        #[prost(message, optional, tag = "4")]
        pub number: ::core::option::Option<super::PositiveInt>,
        /// display | print | printoper
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Note explanatory text
        #[prost(message, optional, tag = "6")]
        pub text: ::core::option::Option<super::String>,
        /// Language if different from the resource
        #[prost(message, optional, tag = "7")]
        pub language: ::core::option::Option<super::CodeableConcept>,
    }
    /// Insurance or medical plan
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Insurance {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Service instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Is the focal Coverage
        #[prost(message, optional, tag = "5")]
        pub focal: ::core::option::Option<super::Boolean>,
        /// Insurance information
        #[prost(message, optional, tag = "6")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// Business agreement
        #[prost(message, optional, tag = "7")]
        pub business_arrangement: ::core::option::Option<super::String>,
        /// Pre-Authorization/Determination Reference
        #[prost(message, repeated, tag = "8")]
        pub pre_auth_ref: prost::alloc::vec::Vec<super::String>,
        /// Adjudication results
        #[prost(message, optional, tag = "9")]
        pub claim_response: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for ClinicalImpression, last updated
/// 2017-04-19T07:44:43.294+10:00. A clinical assessment performed when planning
/// treatments and management strategies for a patient. See
/// <http://hl7.org/fhir/StructureDefinition/ClinicalImpression>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ClinicalImpression {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// draft | completed | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<ClinicalImpressionStatusCode>,
    /// Kind of assessment performed
    #[prost(message, optional, tag = "11")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Why/how the assessment was performed
    #[prost(message, optional, tag = "12")]
    pub description: ::core::option::Option<String>,
    /// Patient or group assessed
    #[prost(message, optional, tag = "13")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or Episode created from
    #[prost(message, optional, tag = "14")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "15")]
    pub effective: ::core::option::Option<clinical_impression::Effective>,
    /// When the assessment was documented
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// The clinician performing the assessment
    #[prost(message, optional, tag = "17")]
    pub assessor: ::core::option::Option<Reference>,
    /// Reference to last assessment
    #[prost(message, optional, tag = "18")]
    pub previous: ::core::option::Option<Reference>,
    /// Relevant impressions of patient state
    #[prost(message, repeated, tag = "19")]
    pub problem: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "20")]
    pub investigation: prost::alloc::vec::Vec<clinical_impression::Investigation>,
    /// Clinical Protocol followed
    #[prost(message, repeated, tag = "21")]
    pub protocol: prost::alloc::vec::Vec<Uri>,
    /// Summary of the assessment
    #[prost(message, optional, tag = "22")]
    pub summary: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "23")]
    pub finding: prost::alloc::vec::Vec<clinical_impression::Finding>,
    /// Estimate of likely outcome
    #[prost(message, repeated, tag = "24")]
    pub prognosis_codeable_concept: prost::alloc::vec::Vec<CodeableConcept>,
    /// RiskAssessment expressing likely outcome
    #[prost(message, repeated, tag = "25")]
    pub prognosis_reference: prost::alloc::vec::Vec<Reference>,
    /// Action taken as part of assessment procedure
    #[prost(message, repeated, tag = "26")]
    pub action: prost::alloc::vec::Vec<Reference>,
    /// Comments made about the ClinicalImpression
    #[prost(message, repeated, tag = "27")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `ClinicalImpression`.
pub mod clinical_impression {
    /// Time of assessment
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Effective {
        #[prost(oneof = "effective::Effective", tags = "1, 2")]
        pub effective: ::core::option::Option<effective::Effective>,
    }
    /// Nested message and enum types in `Effective`.
    pub mod effective {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Effective {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// One or more sets of investigations (signs, symptions, etc.)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Investigation {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// A name/code for the set
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Record of a specific investigation
        #[prost(message, repeated, tag = "5")]
        pub item: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Possible or likely findings and diagnoses
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Finding {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub item: ::core::option::Option<finding::Item>,
        /// Which investigations support finding
        #[prost(message, optional, tag = "5")]
        pub basis: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Finding`.
    pub mod finding {
        /// What was found
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Item {
            #[prost(oneof = "item::Item", tags = "1, 2")]
            pub item: ::core::option::Option<item::Item>,
        }
        /// Nested message and enum types in `Item`.
        pub mod item {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Item {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for CodeSystem, last updated
/// 2017-04-19T07:44:43.294+10:00. A set of codes drawn from one or more code
/// systems. See <http://hl7.org/fhir/StructureDefinition/CodeSystem>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CodeSystem {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this code system (globally unique) (Coding.system)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the code system
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Business version of the code system (Coding.version)
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this code system (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this code system (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the code system
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for code system (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this code system is defined
    #[prost(message, optional, tag = "22")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "23")]
    pub copyright: ::core::option::Option<Markdown>,
    /// If code comparison is case sensitive
    #[prost(message, optional, tag = "24")]
    pub case_sensitive: ::core::option::Option<Boolean>,
    /// Canonical URL for value set with entire code system
    #[prost(message, optional, tag = "25")]
    pub value_set: ::core::option::Option<Uri>,
    /// grouped-by | is-a | part-of | classified-with
    #[prost(message, optional, tag = "26")]
    pub hierarchy_meaning: ::core::option::Option<CodeSystemHierarchyMeaningCode>,
    /// If code system defines a post-composition grammar
    #[prost(message, optional, tag = "27")]
    pub compositional: ::core::option::Option<Boolean>,
    /// If definitions are not stable
    #[prost(message, optional, tag = "28")]
    pub version_needed: ::core::option::Option<Boolean>,
    /// not-present | example | fragment | complete
    #[prost(message, optional, tag = "29")]
    pub content: ::core::option::Option<CodeSystemContentModeCode>,
    /// Total concepts in the code system
    #[prost(message, optional, tag = "30")]
    pub count: ::core::option::Option<UnsignedInt>,
    #[prost(message, repeated, tag = "31")]
    pub filter: prost::alloc::vec::Vec<code_system::Filter>,
    #[prost(message, repeated, tag = "32")]
    pub property: prost::alloc::vec::Vec<code_system::Property>,
    #[prost(message, repeated, tag = "33")]
    pub concept: prost::alloc::vec::Vec<code_system::ConceptDefinition>,
}
/// Nested message and enum types in `CodeSystem`.
pub mod code_system {
    /// Filter that can be used in a value set
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Filter {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Code that identifies the filter
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::Code>,
        /// How or why the filter is used
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        /// Operators that can be used with filter
        #[prost(message, repeated, tag = "6")]
        pub operator: prost::alloc::vec::Vec<super::FilterOperatorCode>,
        /// What to use for the value
        #[prost(message, optional, tag = "7")]
        pub value: ::core::option::Option<super::String>,
    }
    /// Additional information supplied about each concept
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Property {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifies the property on the concepts, and when referred to in
        /// operations
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::Code>,
        /// Formal identifier for the property
        #[prost(message, optional, tag = "5")]
        pub uri: ::core::option::Option<super::Uri>,
        /// Why the property is defined, and/or what it conveys
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        /// code | Coding | string | integer | boolean | dateTime
        #[prost(message, optional, tag = "7")]
        pub r#type: ::core::option::Option<super::PropertyTypeCode>,
    }
    /// Concepts in the code system
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ConceptDefinition {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Code that identifies concept
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::Code>,
        /// Text to display to the user
        #[prost(message, optional, tag = "5")]
        pub display: ::core::option::Option<super::String>,
        /// Formal definition
        #[prost(message, optional, tag = "6")]
        pub definition: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "7")]
        pub designation: prost::alloc::vec::Vec<concept_definition::Designation>,
        #[prost(message, repeated, tag = "8")]
        pub property: prost::alloc::vec::Vec<concept_definition::ConceptProperty>,
        /// Child Concepts (is-a/contains/categorizes)
        #[prost(message, repeated, tag = "9")]
        pub concept: prost::alloc::vec::Vec<ConceptDefinition>,
    }
    /// Nested message and enum types in `ConceptDefinition`.
    pub mod concept_definition {
        /// Additional representations for the concept
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Designation {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Human language of the designation
            #[prost(message, optional, tag = "4")]
            pub language: ::core::option::Option<super::super::LanguageCode>,
            /// Details how this designation would be used
            #[prost(message, optional, tag = "5")]
            pub r#use: ::core::option::Option<super::super::Coding>,
            /// The text value for this designation
            #[prost(message, optional, tag = "6")]
            pub value: ::core::option::Option<super::super::String>,
        }
        /// Property value for the concept
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ConceptProperty {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Reference to CodeSystem.property.code
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::Code>,
            #[prost(message, optional, tag = "5")]
            pub value: ::core::option::Option<concept_property::Value>,
        }
        /// Nested message and enum types in `ConceptProperty`.
        pub mod concept_property {
            /// Value of the property for this concept
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Value {
                #[prost(oneof = "value::Value", tags = "1, 2, 3, 4, 5, 6")]
                pub value: ::core::option::Option<value::Value>,
            }
            /// Nested message and enum types in `Value`.
            pub mod value {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Value {
                    #[prost(message, tag = "1")]
                    Code(super::super::super::super::Code),
                    #[prost(message, tag = "2")]
                    Coding(super::super::super::super::Coding),
                    #[prost(message, tag = "3")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "4")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "5")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "6")]
                    DateTime(super::super::super::super::DateTime),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Communication, last updated
/// 2017-04-19T07:44:43.294+10:00. A record of information transmitted from a
/// sender to a receiver. See
/// <http://hl7.org/fhir/StructureDefinition/Communication>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Communication {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates protocol or definition
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Reference>,
    /// Request fulfilled by this communication
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of this action
    #[prost(message, repeated, tag = "12")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// preparation | in-progress | suspended | aborted | completed |
    /// entered-in-error
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<EventStatusCode>,
    /// Communication did not occur
    #[prost(message, optional, tag = "14")]
    pub not_done: ::core::option::Option<Boolean>,
    /// Why communication did not occur
    #[prost(message, optional, tag = "15")]
    pub not_done_reason: ::core::option::Option<CodeableConcept>,
    /// Message category
    #[prost(message, repeated, tag = "16")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// A channel of communication
    #[prost(message, repeated, tag = "17")]
    pub medium: prost::alloc::vec::Vec<CodeableConcept>,
    /// Focus of message
    #[prost(message, optional, tag = "18")]
    pub subject: ::core::option::Option<Reference>,
    /// Message recipient
    #[prost(message, repeated, tag = "19")]
    pub recipient: prost::alloc::vec::Vec<Reference>,
    /// Focal resources
    #[prost(message, repeated, tag = "20")]
    pub topic: prost::alloc::vec::Vec<Reference>,
    /// Encounter or episode leading to message
    #[prost(message, optional, tag = "21")]
    pub context: ::core::option::Option<Reference>,
    /// When sent
    #[prost(message, optional, tag = "22")]
    pub sent: ::core::option::Option<DateTime>,
    /// When received
    #[prost(message, optional, tag = "23")]
    pub received: ::core::option::Option<DateTime>,
    /// Message sender
    #[prost(message, optional, tag = "24")]
    pub sender: ::core::option::Option<Reference>,
    /// Indication for message
    #[prost(message, repeated, tag = "25")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why was communication done?
    #[prost(message, repeated, tag = "26")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "27")]
    pub payload: prost::alloc::vec::Vec<communication::Payload>,
    /// Comments made about the communication
    #[prost(message, repeated, tag = "28")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `Communication`.
pub mod communication {
    /// Message payload
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payload {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub content: ::core::option::Option<payload::Content>,
    }
    /// Nested message and enum types in `Payload`.
    pub mod payload {
        /// Message part content
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Content {
            #[prost(oneof = "content::Content", tags = "1, 2, 3")]
            pub content: ::core::option::Option<content::Content>,
        }
        /// Nested message and enum types in `Content`.
        pub mod content {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Content {
                #[prost(message, tag = "1")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "2")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "3")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for CommunicationRequest, last
/// updated 2017-04-19T07:44:43.294+10:00. A request for information to be sent
/// to a receiver. See
/// <http://hl7.org/fhir/StructureDefinition/CommunicationRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CommunicationRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Fulfills plan or proposal
    #[prost(message, repeated, tag = "10")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Request(s) replaced by this request
    #[prost(message, repeated, tag = "11")]
    pub replaces: prost::alloc::vec::Vec<Reference>,
    /// Composite request this is part of
    #[prost(message, optional, tag = "12")]
    pub group_identifier: ::core::option::Option<Identifier>,
    /// draft | active | suspended | cancelled | completed | entered-in-error |
    /// unknown
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<RequestStatusCode>,
    /// Message category
    #[prost(message, repeated, tag = "14")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Message urgency
    #[prost(message, optional, tag = "15")]
    pub priority: ::core::option::Option<RequestPriorityCode>,
    /// A channel of communication
    #[prost(message, repeated, tag = "16")]
    pub medium: prost::alloc::vec::Vec<CodeableConcept>,
    /// Focus of message
    #[prost(message, optional, tag = "17")]
    pub subject: ::core::option::Option<Reference>,
    /// Message recipient
    #[prost(message, repeated, tag = "18")]
    pub recipient: prost::alloc::vec::Vec<Reference>,
    /// Focal resources
    #[prost(message, repeated, tag = "19")]
    pub topic: prost::alloc::vec::Vec<Reference>,
    /// Encounter or episode leading to message
    #[prost(message, optional, tag = "20")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "21")]
    pub payload: prost::alloc::vec::Vec<communication_request::Payload>,
    #[prost(message, optional, tag = "22")]
    pub occurrence: ::core::option::Option<communication_request::Occurrence>,
    /// When request transitioned to being actionable
    #[prost(message, optional, tag = "23")]
    pub authored_on: ::core::option::Option<DateTime>,
    /// Message sender
    #[prost(message, optional, tag = "24")]
    pub sender: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "25")]
    pub requester: ::core::option::Option<communication_request::Requester>,
    /// Why is communication needed?
    #[prost(message, repeated, tag = "26")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why is communication needed?
    #[prost(message, repeated, tag = "27")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Comments made about communication request
    #[prost(message, repeated, tag = "28")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `CommunicationRequest`.
pub mod communication_request {
    /// Message payload
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payload {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub content: ::core::option::Option<payload::Content>,
    }
    /// Nested message and enum types in `Payload`.
    pub mod payload {
        /// Message part content
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Content {
            #[prost(oneof = "content::Content", tags = "1, 2, 3")]
            pub content: ::core::option::Option<content::Content>,
        }
        /// Nested message and enum types in `Content`.
        pub mod content {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Content {
                #[prost(message, tag = "1")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "2")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "3")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// When scheduled
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Occurrence {
        #[prost(oneof = "occurrence::Occurrence", tags = "1, 2")]
        pub occurrence: ::core::option::Option<occurrence::Occurrence>,
    }
    /// Nested message and enum types in `Occurrence`.
    pub mod occurrence {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Occurrence {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Who/what is requesting service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Requester {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Individual making the request
        #[prost(message, optional, tag = "4")]
        pub agent: ::core::option::Option<super::Reference>,
        /// Organization agent is acting for
        #[prost(message, optional, tag = "5")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for CompartmentDefinition, last
/// updated 2017-04-19T07:44:43.294+10:00. Compartment Definition for a resource.
/// See <http://hl7.org/fhir/StructureDefinition/CompartmentDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct CompartmentDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this compartment definition (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Name for this compartment definition (computer friendly)
    #[prost(message, optional, tag = "10")]
    pub name: ::core::option::Option<String>,
    /// Name for this compartment definition (human friendly)
    #[prost(message, optional, tag = "11")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "13")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "14")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "15")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "16")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the compartment definition
    #[prost(message, optional, tag = "17")]
    pub description: ::core::option::Option<Markdown>,
    /// Why this compartment definition is defined
    #[prost(message, optional, tag = "18")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "19")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for compartment definition (if applicable)
    #[prost(message, repeated, tag = "20")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Patient | Encounter | RelatedPerson | Practitioner | Device
    #[prost(message, optional, tag = "21")]
    pub code: ::core::option::Option<CompartmentTypeCode>,
    /// Whether the search syntax is supported
    #[prost(message, optional, tag = "22")]
    pub search: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "23")]
    pub resource: prost::alloc::vec::Vec<compartment_definition::Resource>,
}
/// Nested message and enum types in `CompartmentDefinition`.
pub mod compartment_definition {
    /// How a resource is related to the compartment
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Resource {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name of resource type
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::ResourceTypeCode>,
        /// Search Parameter Name, or chained parameters
        #[prost(message, repeated, tag = "5")]
        pub param: prost::alloc::vec::Vec<super::String>,
        /// Additional documentation about the resource and compartment
        #[prost(message, optional, tag = "6")]
        pub documentation: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for Composition, last updated
/// 2017-04-19T07:44:43.294+10:00. A set of resources composed into a single
/// coherent clinical statement with clinical attestation. See
/// <http://hl7.org/fhir/StructureDefinition/Composition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Composition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical identifier of composition (version-independent)
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// preliminary | final | amended | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<CompositionStatusCode>,
    /// Kind of composition (LOINC if possible)
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Categorization of Composition
    #[prost(message, optional, tag = "12")]
    pub class_value: ::core::option::Option<CodeableConcept>,
    /// Who and/or what the composition is about
    #[prost(message, optional, tag = "13")]
    pub subject: ::core::option::Option<Reference>,
    /// Context of the Composition
    #[prost(message, optional, tag = "14")]
    pub encounter: ::core::option::Option<Reference>,
    /// Composition editing time
    #[prost(message, optional, tag = "15")]
    pub date: ::core::option::Option<DateTime>,
    /// Who and/or what authored the composition
    #[prost(message, repeated, tag = "16")]
    pub author: prost::alloc::vec::Vec<Reference>,
    /// Human Readable name/title
    #[prost(message, optional, tag = "17")]
    pub title: ::core::option::Option<String>,
    /// As defined by affinity domain
    #[prost(message, optional, tag = "18")]
    pub confidentiality: ::core::option::Option<ConfidentialityClassificationCode>,
    #[prost(message, repeated, tag = "19")]
    pub attester: prost::alloc::vec::Vec<composition::Attester>,
    /// Organization which maintains the composition
    #[prost(message, optional, tag = "20")]
    pub custodian: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "21")]
    pub relates_to: prost::alloc::vec::Vec<composition::RelatesTo>,
    #[prost(message, repeated, tag = "22")]
    pub event: prost::alloc::vec::Vec<composition::Event>,
    #[prost(message, repeated, tag = "23")]
    pub section: prost::alloc::vec::Vec<composition::Section>,
}
/// Nested message and enum types in `Composition`.
pub mod composition {
    /// Attests to accuracy of composition
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Attester {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// personal | professional | legal | official
        #[prost(message, repeated, tag = "4")]
        pub mode: prost::alloc::vec::Vec<super::CompositionAttestationModeCode>,
        /// When the composition was attested
        #[prost(message, optional, tag = "5")]
        pub time: ::core::option::Option<super::DateTime>,
        /// Who attested the composition
        #[prost(message, optional, tag = "6")]
        pub party: ::core::option::Option<super::Reference>,
    }
    /// Relationships to other compositions/documents
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelatesTo {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// replaces | transforms | signs | appends
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::DocumentRelationshipTypeCode>,
        #[prost(message, optional, tag = "5")]
        pub target: ::core::option::Option<relates_to::Target>,
    }
    /// Nested message and enum types in `RelatesTo`.
    pub mod relates_to {
        /// Target of the relationship
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Target {
            #[prost(oneof = "target::Target", tags = "1, 2")]
            pub target: ::core::option::Option<target::Target>,
        }
        /// Nested message and enum types in `Target`.
        pub mod target {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Target {
                #[prost(message, tag = "1")]
                Identifier(super::super::super::Identifier),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// The clinical service(s) being documented
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Event {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Code(s) that apply to the event being documented
        #[prost(message, repeated, tag = "4")]
        pub code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// The period covered by the documentation
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
        /// The event(s) being documented
        #[prost(message, repeated, tag = "6")]
        pub detail: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Composition is broken into sections
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Section {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Label for section (e.g. for ToC)
        #[prost(message, optional, tag = "4")]
        pub title: ::core::option::Option<super::String>,
        /// Classification of section (recommended)
        #[prost(message, optional, tag = "5")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Text summary of the section, for human interpretation
        #[prost(message, optional, tag = "6")]
        pub text: ::core::option::Option<super::Narrative>,
        /// working | snapshot | changes
        #[prost(message, optional, tag = "7")]
        pub mode: ::core::option::Option<super::ListModeCode>,
        /// Order of section entries
        #[prost(message, optional, tag = "8")]
        pub ordered_by: ::core::option::Option<super::CodeableConcept>,
        /// A reference to data that supports this section
        #[prost(message, repeated, tag = "9")]
        pub entry: prost::alloc::vec::Vec<super::Reference>,
        /// Why the section is empty
        #[prost(message, optional, tag = "10")]
        pub empty_reason: ::core::option::Option<super::CodeableConcept>,
        /// Nested Section
        #[prost(message, repeated, tag = "11")]
        pub section: prost::alloc::vec::Vec<Section>,
    }
}
/// Auto-generated from StructureDefinition for ConceptMap, last updated
/// 2017-04-19T07:44:43.294+10:00. A map from one set of concepts to one or more
/// other concepts. See <http://hl7.org/fhir/StructureDefinition/ConceptMap>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ConceptMap {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this concept map (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the concept map
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Business version of the concept map
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this concept map (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this concept map (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the concept map
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for concept map (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this concept map is defined
    #[prost(message, optional, tag = "22")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "23")]
    pub copyright: ::core::option::Option<Markdown>,
    #[prost(message, optional, tag = "24")]
    pub source: ::core::option::Option<concept_map::Source>,
    #[prost(message, optional, tag = "25")]
    pub target: ::core::option::Option<concept_map::Target>,
    #[prost(message, repeated, tag = "26")]
    pub group: prost::alloc::vec::Vec<concept_map::Group>,
}
/// Nested message and enum types in `ConceptMap`.
pub mod concept_map {
    /// Identifies the source of the concepts which are being mapped
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Source {
        #[prost(oneof = "source::Source", tags = "1, 2")]
        pub source: ::core::option::Option<source::Source>,
    }
    /// Nested message and enum types in `Source`.
    pub mod source {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Source {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Provides context to the mappings
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Target {
        #[prost(oneof = "target::Target", tags = "1, 2")]
        pub target: ::core::option::Option<target::Target>,
    }
    /// Nested message and enum types in `Target`.
    pub mod target {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Target {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Same source and target systems
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Group {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Code System (if value set crosses code systems)
        #[prost(message, optional, tag = "4")]
        pub source: ::core::option::Option<super::Uri>,
        /// Specific version of the  code system
        #[prost(message, optional, tag = "5")]
        pub source_version: ::core::option::Option<super::String>,
        /// System of the target (if necessary)
        #[prost(message, optional, tag = "6")]
        pub target: ::core::option::Option<super::Uri>,
        /// Specific version of the  code system
        #[prost(message, optional, tag = "7")]
        pub target_version: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "8")]
        pub element: prost::alloc::vec::Vec<group::SourceElement>,
        #[prost(message, optional, tag = "9")]
        pub unmapped: ::core::option::Option<group::Unmapped>,
    }
    /// Nested message and enum types in `Group`.
    pub mod group {
        /// Mappings for a concept from the source set
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SourceElement {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Identifies element being mapped
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::Code>,
            /// Display for the code
            #[prost(message, optional, tag = "5")]
            pub display: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "6")]
            pub target: prost::alloc::vec::Vec<source_element::TargetElement>,
        }
        /// Nested message and enum types in `SourceElement`.
        pub mod source_element {
            /// Concept in target system for element
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct TargetElement {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Code that identifies the target element
                #[prost(message, optional, tag = "4")]
                pub code: ::core::option::Option<super::super::super::Code>,
                /// Display for the code
                #[prost(message, optional, tag = "5")]
                pub display: ::core::option::Option<super::super::super::String>,
                /// relatedto | equivalent | equal | wider | subsumes | narrower |
                /// specializes | inexact | unmatched | disjoint
                #[prost(message, optional, tag = "6")]
                pub equivalence:
                    ::core::option::Option<super::super::super::ConceptMapEquivalenceCode>,
                /// Description of status/issues in mapping
                #[prost(message, optional, tag = "7")]
                pub comment: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "8")]
                pub depends_on: prost::alloc::vec::Vec<target_element::OtherElement>,
                /// Other concepts that this mapping also produces
                #[prost(message, repeated, tag = "9")]
                pub product: prost::alloc::vec::Vec<target_element::OtherElement>,
            }
            /// Nested message and enum types in `TargetElement`.
            pub mod target_element {
                /// Other elements required for this mapping (from context)
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct OtherElement {
                    /// xml:id (or equivalent in JSON)
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional Content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Reference to property mapping depends on
                    #[prost(message, optional, tag = "4")]
                    pub property: ::core::option::Option<super::super::super::super::Uri>,
                    /// Code System (if necessary)
                    #[prost(message, optional, tag = "5")]
                    pub system: ::core::option::Option<super::super::super::super::Uri>,
                    /// Value of the referenced element
                    #[prost(message, optional, tag = "6")]
                    pub code: ::core::option::Option<super::super::super::super::String>,
                    /// Display for the code
                    #[prost(message, optional, tag = "7")]
                    pub display: ::core::option::Option<super::super::super::super::String>,
                }
            }
        }
        /// When no match in the mappings
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Unmapped {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// provided | fixed | other-map
            #[prost(message, optional, tag = "4")]
            pub mode: ::core::option::Option<super::super::ConceptMapGroupUnmappedModeCode>,
            /// Fixed code when mode = fixed
            #[prost(message, optional, tag = "5")]
            pub code: ::core::option::Option<super::super::Code>,
            /// Display for the code
            #[prost(message, optional, tag = "6")]
            pub display: ::core::option::Option<super::super::String>,
            /// Canonical URL for other concept map
            #[prost(message, optional, tag = "7")]
            pub url: ::core::option::Option<super::super::Uri>,
        }
    }
}
/// Auto-generated from StructureDefinition for Condition, last updated
/// 2017-04-19T07:44:43.294+10:00. Detailed information about conditions,
/// problems or diagnoses. See <http://hl7.org/fhir/StructureDefinition/Condition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Condition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this condition
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | recurrence | inactive | remission | resolved
    #[prost(message, optional, tag = "10")]
    pub clinical_status: ::core::option::Option<ConditionClinicalStatusCodesCode>,
    /// provisional | differential | confirmed | refuted | entered-in-error |
    /// unknown
    #[prost(message, optional, tag = "11")]
    pub verification_status: ::core::option::Option<ConditionVerificationStatusCode>,
    /// problem-list-item | encounter-diagnosis
    #[prost(message, repeated, tag = "12")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Subjective severity of condition
    #[prost(message, optional, tag = "13")]
    pub severity: ::core::option::Option<CodeableConcept>,
    /// Identification of the condition, problem or diagnosis
    #[prost(message, optional, tag = "14")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Anatomical location, if relevant
    #[prost(message, repeated, tag = "15")]
    pub body_site: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who has the condition?
    #[prost(message, optional, tag = "16")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or episode when condition first asserted
    #[prost(message, optional, tag = "17")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "18")]
    pub onset: ::core::option::Option<condition::Onset>,
    #[prost(message, optional, tag = "19")]
    pub abatement: ::core::option::Option<condition::Abatement>,
    /// Date record was believed accurate
    #[prost(message, optional, tag = "20")]
    pub asserted_date: ::core::option::Option<DateTime>,
    /// Person who asserts this condition
    #[prost(message, optional, tag = "21")]
    pub asserter: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "22")]
    pub stage: ::core::option::Option<condition::Stage>,
    #[prost(message, repeated, tag = "23")]
    pub evidence: prost::alloc::vec::Vec<condition::Evidence>,
    /// Additional information about the Condition
    #[prost(message, repeated, tag = "24")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `Condition`.
pub mod condition {
    /// Estimated or actual date,  date-time, or age
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Onset {
        #[prost(oneof = "onset::Onset", tags = "1, 2, 3, 4, 5")]
        pub onset: ::core::option::Option<onset::Onset>,
    }
    /// Nested message and enum types in `Onset`.
    pub mod onset {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Onset {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Age(super::super::Age),
            #[prost(message, tag = "3")]
            Period(super::super::Period),
            #[prost(message, tag = "4")]
            Range(super::super::Range),
            #[prost(message, tag = "5")]
            StringValue(super::super::String),
        }
    }
    /// If/when in resolution/remission
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Abatement {
        #[prost(oneof = "abatement::Abatement", tags = "1, 2, 3, 4, 5, 6")]
        pub abatement: ::core::option::Option<abatement::Abatement>,
    }
    /// Nested message and enum types in `Abatement`.
    pub mod abatement {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Abatement {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Age(super::super::Age),
            #[prost(message, tag = "3")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "4")]
            Period(super::super::Period),
            #[prost(message, tag = "5")]
            Range(super::super::Range),
            #[prost(message, tag = "6")]
            StringValue(super::super::String),
        }
    }
    /// Stage/grade, usually assessed formally
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Stage {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Simple summary (disease specific)
        #[prost(message, optional, tag = "4")]
        pub summary: ::core::option::Option<super::CodeableConcept>,
        /// Formal record of assessment
        #[prost(message, repeated, tag = "5")]
        pub assessment: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Supporting evidence
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Evidence {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Manifestation/symptom
        #[prost(message, repeated, tag = "4")]
        pub code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Supporting information found elsewhere
        #[prost(message, repeated, tag = "5")]
        pub detail: prost::alloc::vec::Vec<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for Consent, last updated
/// 2017-04-19T07:44:43.294+10:00. A healthcare consumer's policy choices to
/// permits or denies recipients or roles to perform actions for specific
/// purposes and periods of time. See
/// <http://hl7.org/fhir/StructureDefinition/Consent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Consent {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifier for this record (external references)
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// draft | proposed | active | rejected | inactive | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<ConsentStateCode>,
    /// Classification of the consent statement - for indexing/retrieval
    #[prost(message, repeated, tag = "11")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Who the consent applies to
    #[prost(message, optional, tag = "12")]
    pub patient: ::core::option::Option<Reference>,
    /// Period that this consent applies
    #[prost(message, optional, tag = "13")]
    pub period: ::core::option::Option<Period>,
    /// When this Consent was created or indexed
    #[prost(message, optional, tag = "14")]
    pub date_time: ::core::option::Option<DateTime>,
    /// Who is agreeing to the policy and exceptions
    #[prost(message, repeated, tag = "15")]
    pub consenting_party: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "16")]
    pub actor: prost::alloc::vec::Vec<consent::Actor>,
    /// Actions controlled by this consent
    #[prost(message, repeated, tag = "17")]
    pub action: prost::alloc::vec::Vec<CodeableConcept>,
    /// Custodian of the consent
    #[prost(message, repeated, tag = "18")]
    pub organization: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "19")]
    pub source: ::core::option::Option<consent::Source>,
    #[prost(message, repeated, tag = "20")]
    pub policy: prost::alloc::vec::Vec<consent::Policy>,
    /// Policy that this consents to
    #[prost(message, optional, tag = "21")]
    pub policy_rule: ::core::option::Option<Uri>,
    /// Security Labels that define affected resources
    #[prost(message, repeated, tag = "22")]
    pub security_label: prost::alloc::vec::Vec<Coding>,
    /// Context of activities for which the agreement is made
    #[prost(message, repeated, tag = "23")]
    pub purpose: prost::alloc::vec::Vec<Coding>,
    /// Timeframe for data controlled by this consent
    #[prost(message, optional, tag = "24")]
    pub data_period: ::core::option::Option<Period>,
    #[prost(message, repeated, tag = "25")]
    pub data: prost::alloc::vec::Vec<consent::Data>,
    #[prost(message, repeated, tag = "26")]
    pub except: prost::alloc::vec::Vec<consent::Except>,
}
/// Nested message and enum types in `Consent`.
pub mod consent {
    /// Who|what controlled by this consent (or group, by role)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Actor {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// How the actor is involved
        #[prost(message, optional, tag = "4")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Resource for the actor (or group, by role)
        #[prost(message, optional, tag = "5")]
        pub reference: ::core::option::Option<super::Reference>,
    }
    /// Source from which this consent is taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Source {
        #[prost(oneof = "source::Source", tags = "1, 2, 3")]
        pub source: ::core::option::Option<source::Source>,
    }
    /// Nested message and enum types in `Source`.
    pub mod source {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Source {
            #[prost(message, tag = "1")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "2")]
            Identifier(super::super::Identifier),
            #[prost(message, tag = "3")]
            Reference(super::super::Reference),
        }
    }
    /// Policies covered by this consent
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Policy {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Enforcement source for policy
        #[prost(message, optional, tag = "4")]
        pub authority: ::core::option::Option<super::Uri>,
        /// Specific policy covered by this consent
        #[prost(message, optional, tag = "5")]
        pub uri: ::core::option::Option<super::Uri>,
    }
    /// Data controlled by this consent
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Data {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// instance | related | dependents | authoredby
        #[prost(message, optional, tag = "4")]
        pub meaning: ::core::option::Option<super::ConsentDataMeaningCode>,
        /// The actual data reference
        #[prost(message, optional, tag = "5")]
        pub reference: ::core::option::Option<super::Reference>,
    }
    /// Additional rule -  addition or removal of permissions
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Except {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// deny | permit
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::ConsentExceptTypeCode>,
        /// Timeframe for this exception
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
        #[prost(message, repeated, tag = "6")]
        pub actor: prost::alloc::vec::Vec<except::ExceptActor>,
        /// Actions controlled by this exception
        #[prost(message, repeated, tag = "7")]
        pub action: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Security Labels that define affected resources
        #[prost(message, repeated, tag = "8")]
        pub security_label: prost::alloc::vec::Vec<super::Coding>,
        /// Context of activities covered by this exception
        #[prost(message, repeated, tag = "9")]
        pub purpose: prost::alloc::vec::Vec<super::Coding>,
        /// e.g. Resource Type, Profile, or CDA etc
        #[prost(message, repeated, tag = "10")]
        pub class_value: prost::alloc::vec::Vec<super::Coding>,
        /// e.g. LOINC or SNOMED CT code, etc in the content
        #[prost(message, repeated, tag = "11")]
        pub code: prost::alloc::vec::Vec<super::Coding>,
        /// Timeframe for data controlled by this exception
        #[prost(message, optional, tag = "12")]
        pub data_period: ::core::option::Option<super::Period>,
        #[prost(message, repeated, tag = "13")]
        pub data: prost::alloc::vec::Vec<except::ExceptData>,
    }
    /// Nested message and enum types in `Except`.
    pub mod except {
        /// Who|what controlled by this exception (or group, by role)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ExceptActor {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// How the actor is involved
            #[prost(message, optional, tag = "4")]
            pub role: ::core::option::Option<super::super::CodeableConcept>,
            /// Resource for the actor (or group, by role)
            #[prost(message, optional, tag = "5")]
            pub reference: ::core::option::Option<super::super::Reference>,
        }
        /// Data controlled by this exception
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ExceptData {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// instance | related | dependents | authoredby
            #[prost(message, optional, tag = "4")]
            pub meaning: ::core::option::Option<super::super::ConsentDataMeaningCode>,
            /// The actual data reference
            #[prost(message, optional, tag = "5")]
            pub reference: ::core::option::Option<super::super::Reference>,
        }
    }
}
/// Auto-generated from StructureDefinition for Contract, last updated
/// 2017-04-19T07:44:43.294+10:00. Legal Agreement. See
/// <http://hl7.org/fhir/StructureDefinition/Contract>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Contract {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Contract number
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// amended | appended | cancelled | disputed | entered-in-error | executable |
    /// executed | negotiable | offered | policy | rejected | renewed | revoked |
    /// resolved | terminated
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<ContractResourceStatusCode>,
    /// When this Contract was issued
    #[prost(message, optional, tag = "11")]
    pub issued: ::core::option::Option<DateTime>,
    /// Effective time
    #[prost(message, optional, tag = "12")]
    pub applies: ::core::option::Option<Period>,
    /// Contract Target Entity
    #[prost(message, repeated, tag = "13")]
    pub subject: prost::alloc::vec::Vec<Reference>,
    /// Context of the Contract
    #[prost(message, repeated, tag = "14")]
    pub topic: prost::alloc::vec::Vec<Reference>,
    /// Authority under which this Contract has standing
    #[prost(message, repeated, tag = "15")]
    pub authority: prost::alloc::vec::Vec<Reference>,
    /// Domain in which this Contract applies
    #[prost(message, repeated, tag = "16")]
    pub domain: prost::alloc::vec::Vec<Reference>,
    /// Type or form
    #[prost(message, optional, tag = "17")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Subtype within the context of type
    #[prost(message, repeated, tag = "18")]
    pub sub_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Action stipulated by this Contract
    #[prost(message, repeated, tag = "19")]
    pub action: prost::alloc::vec::Vec<CodeableConcept>,
    /// Rationale for the stiplulated action
    #[prost(message, repeated, tag = "20")]
    pub action_reason: prost::alloc::vec::Vec<CodeableConcept>,
    /// Decision by Grantor
    #[prost(message, optional, tag = "21")]
    pub decision_type: ::core::option::Option<CodeableConcept>,
    /// Content derived from the basal information
    #[prost(message, optional, tag = "22")]
    pub content_derivative: ::core::option::Option<CodeableConcept>,
    /// Security Labels that define affected resources
    #[prost(message, repeated, tag = "23")]
    pub security_label: prost::alloc::vec::Vec<Coding>,
    #[prost(message, repeated, tag = "24")]
    pub agent: prost::alloc::vec::Vec<contract::Agent>,
    #[prost(message, repeated, tag = "25")]
    pub signer: prost::alloc::vec::Vec<contract::Signatory>,
    #[prost(message, repeated, tag = "26")]
    pub valued_item: prost::alloc::vec::Vec<contract::ValuedItem>,
    #[prost(message, repeated, tag = "27")]
    pub term: prost::alloc::vec::Vec<contract::Term>,
    #[prost(message, optional, tag = "28")]
    pub binding: ::core::option::Option<contract::Binding>,
    #[prost(message, repeated, tag = "29")]
    pub friendly: prost::alloc::vec::Vec<contract::FriendlyLanguage>,
    #[prost(message, repeated, tag = "30")]
    pub legal: prost::alloc::vec::Vec<contract::LegalLanguage>,
    #[prost(message, repeated, tag = "31")]
    pub rule: prost::alloc::vec::Vec<contract::ComputableLanguage>,
}
/// Nested message and enum types in `Contract`.
pub mod contract {
    /// Entity being ascribed responsibility
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Agent {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Contract Agent Type
        #[prost(message, optional, tag = "4")]
        pub actor: ::core::option::Option<super::Reference>,
        /// Role type of the agent
        #[prost(message, repeated, tag = "5")]
        pub role: prost::alloc::vec::Vec<super::CodeableConcept>,
    }
    /// Contract Signatory
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Signatory {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Contract Signatory Role
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::Coding>,
        /// Contract Signatory Party
        #[prost(message, optional, tag = "5")]
        pub party: ::core::option::Option<super::Reference>,
        /// Contract Documentation Signature
        #[prost(message, repeated, tag = "6")]
        pub signature: prost::alloc::vec::Vec<super::Signature>,
    }
    /// Contract Valued Item List
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ValuedItem {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub entity: ::core::option::Option<valued_item::Entity>,
        /// Contract Valued Item Number
        #[prost(message, optional, tag = "5")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Contract Valued Item Effective Tiem
        #[prost(message, optional, tag = "6")]
        pub effective_time: ::core::option::Option<super::DateTime>,
        /// Count of Contract Valued Items
        #[prost(message, optional, tag = "7")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Contract Valued Item fee, charge, or cost
        #[prost(message, optional, tag = "8")]
        pub unit_price: ::core::option::Option<super::Money>,
        /// Contract Valued Item Price Scaling Factor
        #[prost(message, optional, tag = "9")]
        pub factor: ::core::option::Option<super::Decimal>,
        /// Contract Valued Item Difficulty Scaling Factor
        #[prost(message, optional, tag = "10")]
        pub points: ::core::option::Option<super::Decimal>,
        /// Total Contract Valued Item Value
        #[prost(message, optional, tag = "11")]
        pub net: ::core::option::Option<super::Money>,
    }
    /// Nested message and enum types in `ValuedItem`.
    pub mod valued_item {
        /// Contract Valued Item Type
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Entity {
            #[prost(oneof = "entity::Entity", tags = "1, 2")]
            pub entity: ::core::option::Option<entity::Entity>,
        }
        /// Nested message and enum types in `Entity`.
        pub mod entity {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Entity {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Contract Term List
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Term {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Contract Term Number
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Contract Term Issue Date Time
        #[prost(message, optional, tag = "5")]
        pub issued: ::core::option::Option<super::DateTime>,
        /// Contract Term Effective Time
        #[prost(message, optional, tag = "6")]
        pub applies: ::core::option::Option<super::Period>,
        /// Contract Term Type or Form
        #[prost(message, optional, tag = "7")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Contract Term Type specific classification
        #[prost(message, optional, tag = "8")]
        pub sub_type: ::core::option::Option<super::CodeableConcept>,
        /// Context of the Contract term
        #[prost(message, repeated, tag = "9")]
        pub topic: prost::alloc::vec::Vec<super::Reference>,
        /// Contract Term Activity
        #[prost(message, repeated, tag = "10")]
        pub action: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Purpose for the Contract Term Action
        #[prost(message, repeated, tag = "11")]
        pub action_reason: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Security Labels that define affected terms
        #[prost(message, repeated, tag = "12")]
        pub security_label: prost::alloc::vec::Vec<super::Coding>,
        #[prost(message, repeated, tag = "13")]
        pub agent: prost::alloc::vec::Vec<term::TermAgent>,
        /// Human readable Contract term text
        #[prost(message, optional, tag = "14")]
        pub text: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "15")]
        pub valued_item: prost::alloc::vec::Vec<term::TermValuedItem>,
        /// Nested Contract Term Group
        #[prost(message, repeated, tag = "16")]
        pub group: prost::alloc::vec::Vec<Term>,
    }
    /// Nested message and enum types in `Term`.
    pub mod term {
        /// Contract Term Agent List
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TermAgent {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Contract Term Agent Subject
            #[prost(message, optional, tag = "4")]
            pub actor: ::core::option::Option<super::super::Reference>,
            /// Type of the Contract Term Agent
            #[prost(message, repeated, tag = "5")]
            pub role: prost::alloc::vec::Vec<super::super::CodeableConcept>,
        }
        /// Contract Term Valued Item List
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TermValuedItem {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub entity: ::core::option::Option<term_valued_item::Entity>,
            /// Contract Term Valued Item Number
            #[prost(message, optional, tag = "5")]
            pub identifier: ::core::option::Option<super::super::Identifier>,
            /// Contract Term Valued Item Effective Tiem
            #[prost(message, optional, tag = "6")]
            pub effective_time: ::core::option::Option<super::super::DateTime>,
            /// Contract Term Valued Item Count
            #[prost(message, optional, tag = "7")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// Contract Term Valued Item fee, charge, or cost
            #[prost(message, optional, tag = "8")]
            pub unit_price: ::core::option::Option<super::super::Money>,
            /// Contract Term Valued Item Price Scaling Factor
            #[prost(message, optional, tag = "9")]
            pub factor: ::core::option::Option<super::super::Decimal>,
            /// Contract Term Valued Item Difficulty Scaling Factor
            #[prost(message, optional, tag = "10")]
            pub points: ::core::option::Option<super::super::Decimal>,
            /// Total Contract Term Valued Item Value
            #[prost(message, optional, tag = "11")]
            pub net: ::core::option::Option<super::super::Money>,
        }
        /// Nested message and enum types in `TermValuedItem`.
        pub mod term_valued_item {
            /// Contract Term Valued Item Type
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Entity {
                #[prost(oneof = "entity::Entity", tags = "1, 2")]
                pub entity: ::core::option::Option<entity::Entity>,
            }
            /// Nested message and enum types in `Entity`.
            pub mod entity {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Entity {
                    #[prost(message, tag = "1")]
                    CodeableConcept(super::super::super::super::CodeableConcept),
                    #[prost(message, tag = "2")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
    }
    /// Binding Contract
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Binding {
        #[prost(oneof = "binding::Binding", tags = "1, 2")]
        pub binding: ::core::option::Option<binding::Binding>,
    }
    /// Nested message and enum types in `Binding`.
    pub mod binding {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Binding {
            #[prost(message, tag = "1")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Contract Friendly Language
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FriendlyLanguage {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub content: ::core::option::Option<friendly_language::Content>,
    }
    /// Nested message and enum types in `FriendlyLanguage`.
    pub mod friendly_language {
        /// Easily comprehended representation of this Contract
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Content {
            #[prost(oneof = "content::Content", tags = "1, 2")]
            pub content: ::core::option::Option<content::Content>,
        }
        /// Nested message and enum types in `Content`.
        pub mod content {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Content {
                #[prost(message, tag = "1")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Contract Legal Language
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct LegalLanguage {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub content: ::core::option::Option<legal_language::Content>,
    }
    /// Nested message and enum types in `LegalLanguage`.
    pub mod legal_language {
        /// Contract Legal Text
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Content {
            #[prost(oneof = "content::Content", tags = "1, 2")]
            pub content: ::core::option::Option<content::Content>,
        }
        /// Nested message and enum types in `Content`.
        pub mod content {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Content {
                #[prost(message, tag = "1")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Computable Contract Language
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ComputableLanguage {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub content: ::core::option::Option<computable_language::Content>,
    }
    /// Nested message and enum types in `ComputableLanguage`.
    pub mod computable_language {
        /// Computable Contract Rules
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Content {
            #[prost(oneof = "content::Content", tags = "1, 2")]
            pub content: ::core::option::Option<content::Content>,
        }
        /// Nested message and enum types in `Content`.
        pub mod content {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Content {
                #[prost(message, tag = "1")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Coverage, last updated
/// 2017-04-19T07:44:43.294+10:00. Insurance or medical plan or a payment
/// agreement. See <http://hl7.org/fhir/StructureDefinition/Coverage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Coverage {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The primary coverage ID
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// Type of coverage such as medical or accident
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Owner of the policy
    #[prost(message, optional, tag = "12")]
    pub policy_holder: ::core::option::Option<Reference>,
    /// Subscriber to the policy
    #[prost(message, optional, tag = "13")]
    pub subscriber: ::core::option::Option<Reference>,
    /// ID assigned to the Subscriber
    #[prost(message, optional, tag = "14")]
    pub subscriber_id: ::core::option::Option<String>,
    /// Plan Beneficiary
    #[prost(message, optional, tag = "15")]
    pub beneficiary: ::core::option::Option<Reference>,
    /// Beneficiary relationship to the Subscriber
    #[prost(message, optional, tag = "16")]
    pub relationship: ::core::option::Option<CodeableConcept>,
    /// Coverage start and end dates
    #[prost(message, optional, tag = "17")]
    pub period: ::core::option::Option<Period>,
    /// Identifier for the plan or agreement issuer
    #[prost(message, repeated, tag = "18")]
    pub payor: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "19")]
    pub grouping: ::core::option::Option<coverage::Group>,
    /// Dependent number
    #[prost(message, optional, tag = "20")]
    pub dependent: ::core::option::Option<String>,
    /// The plan instance or sequence counter
    #[prost(message, optional, tag = "21")]
    pub sequence: ::core::option::Option<String>,
    /// Relative order of the coverage
    #[prost(message, optional, tag = "22")]
    pub order: ::core::option::Option<PositiveInt>,
    /// Insurer network
    #[prost(message, optional, tag = "23")]
    pub network: ::core::option::Option<String>,
    /// Contract details
    #[prost(message, repeated, tag = "24")]
    pub contract: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `Coverage`.
pub mod coverage {
    /// Additional coverage classifications
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Group {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// An identifier for the group
        #[prost(message, optional, tag = "4")]
        pub group: ::core::option::Option<super::String>,
        /// Display text for an identifier for the group
        #[prost(message, optional, tag = "5")]
        pub group_display: ::core::option::Option<super::String>,
        /// An identifier for the subsection of the group
        #[prost(message, optional, tag = "6")]
        pub sub_group: ::core::option::Option<super::String>,
        /// Display text for the subsection of the group
        #[prost(message, optional, tag = "7")]
        pub sub_group_display: ::core::option::Option<super::String>,
        /// An identifier for the plan
        #[prost(message, optional, tag = "8")]
        pub plan: ::core::option::Option<super::String>,
        /// Display text for the plan
        #[prost(message, optional, tag = "9")]
        pub plan_display: ::core::option::Option<super::String>,
        /// An identifier for the subsection of the plan
        #[prost(message, optional, tag = "10")]
        pub sub_plan: ::core::option::Option<super::String>,
        /// Display text for the subsection of the plan
        #[prost(message, optional, tag = "11")]
        pub sub_plan_display: ::core::option::Option<super::String>,
        /// An identifier for the class
        #[prost(message, optional, tag = "12")]
        pub class_value: ::core::option::Option<super::String>,
        /// Display text for the class
        #[prost(message, optional, tag = "13")]
        pub class_display: ::core::option::Option<super::String>,
        /// An identifier for the subsection of the class
        #[prost(message, optional, tag = "14")]
        pub sub_class: ::core::option::Option<super::String>,
        /// Display text for the subsection of the subclass
        #[prost(message, optional, tag = "15")]
        pub sub_class_display: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for DataElement, last updated
/// 2017-04-19T07:44:43.294+10:00. Resource data element. See
/// <http://hl7.org/fhir/StructureDefinition/DataElement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DataElement {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this data element (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the data element
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the data element
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "13")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "14")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "15")]
    pub publisher: ::core::option::Option<String>,
    /// Name for this data element (computer friendly)
    #[prost(message, optional, tag = "16")]
    pub name: ::core::option::Option<String>,
    /// Name for this data element (human friendly)
    #[prost(message, optional, tag = "17")]
    pub title: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "19")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for data element (if applicable)
    #[prost(message, repeated, tag = "20")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "21")]
    pub copyright: ::core::option::Option<Markdown>,
    /// comparable | fully-specified | equivalent | convertable | scaleable |
    /// flexible
    #[prost(message, optional, tag = "22")]
    pub stringency: ::core::option::Option<DataElementStringencyCode>,
    #[prost(message, repeated, tag = "23")]
    pub mapping: prost::alloc::vec::Vec<data_element::Mapping>,
    /// Definition of element
    #[prost(message, repeated, tag = "24")]
    pub element: prost::alloc::vec::Vec<ElementDefinition>,
}
/// Nested message and enum types in `DataElement`.
pub mod data_element {
    /// External specification mapped to
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Mapping {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Internal id when this mapping is used
        #[prost(message, optional, tag = "4")]
        pub identity: ::core::option::Option<super::Id>,
        /// Identifies what this mapping refers to
        #[prost(message, optional, tag = "5")]
        pub uri: ::core::option::Option<super::Uri>,
        /// Names what this mapping refers to
        #[prost(message, optional, tag = "6")]
        pub name: ::core::option::Option<super::String>,
        /// Versions, issues, scope limitations, etc.
        #[prost(message, optional, tag = "7")]
        pub comment: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for DetectedIssue, last updated
/// 2017-04-19T07:44:43.294+10:00. Clinical issue with action. See
/// <http://hl7.org/fhir/StructureDefinition/DetectedIssue>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DetectedIssue {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique id for the detected issue
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// registered | preliminary | final | amended +
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<ObservationStatusCode>,
    /// Issue Category, e.g. drug-drug, duplicate therapy, etc.
    #[prost(message, optional, tag = "11")]
    pub category: ::core::option::Option<CodeableConcept>,
    /// high | moderate | low
    #[prost(message, optional, tag = "12")]
    pub severity: ::core::option::Option<DetectedIssueSeverityCode>,
    /// Associated patient
    #[prost(message, optional, tag = "13")]
    pub patient: ::core::option::Option<Reference>,
    /// When identified
    #[prost(message, optional, tag = "14")]
    pub date: ::core::option::Option<DateTime>,
    /// The provider or device that identified the issue
    #[prost(message, optional, tag = "15")]
    pub author: ::core::option::Option<Reference>,
    /// Problem resource
    #[prost(message, repeated, tag = "16")]
    pub implicated: prost::alloc::vec::Vec<Reference>,
    /// Description and context
    #[prost(message, optional, tag = "17")]
    pub detail: ::core::option::Option<String>,
    /// Authority for issue
    #[prost(message, optional, tag = "18")]
    pub reference: ::core::option::Option<Uri>,
    #[prost(message, repeated, tag = "19")]
    pub mitigation: prost::alloc::vec::Vec<detected_issue::Mitigation>,
}
/// Nested message and enum types in `DetectedIssue`.
pub mod detected_issue {
    /// Step taken to address
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Mitigation {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// What mitigation?
        #[prost(message, optional, tag = "4")]
        pub action: ::core::option::Option<super::CodeableConcept>,
        /// Date committed
        #[prost(message, optional, tag = "5")]
        pub date: ::core::option::Option<super::DateTime>,
        /// Who is committing?
        #[prost(message, optional, tag = "6")]
        pub author: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for Device, last updated
/// 2017-04-19T07:44:43.294+10:00. Item used in healthcare. See
/// <http://hl7.org/fhir/StructureDefinition/Device>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Device {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Instance identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "10")]
    pub udi: ::core::option::Option<device::Udi>,
    /// active | inactive | entered-in-error | unknown
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<FhirDeviceStatusCode>,
    /// What kind of device this is
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Lot number of manufacture
    #[prost(message, optional, tag = "13")]
    pub lot_number: ::core::option::Option<String>,
    /// Name of device manufacturer
    #[prost(message, optional, tag = "14")]
    pub manufacturer: ::core::option::Option<String>,
    /// Date when the device was made
    #[prost(message, optional, tag = "15")]
    pub manufacture_date: ::core::option::Option<DateTime>,
    /// Date and time of expiry of this device (if applicable)
    #[prost(message, optional, tag = "16")]
    pub expiration_date: ::core::option::Option<DateTime>,
    /// Model id assigned by the manufacturer
    #[prost(message, optional, tag = "17")]
    pub model: ::core::option::Option<String>,
    /// Version number (i.e. software)
    #[prost(message, optional, tag = "18")]
    pub version: ::core::option::Option<String>,
    /// Patient to whom Device is affixed
    #[prost(message, optional, tag = "19")]
    pub patient: ::core::option::Option<Reference>,
    /// Organization responsible for device
    #[prost(message, optional, tag = "20")]
    pub owner: ::core::option::Option<Reference>,
    /// Details for human/organization for support
    #[prost(message, repeated, tag = "21")]
    pub contact: prost::alloc::vec::Vec<ContactPoint>,
    /// Where the resource is found
    #[prost(message, optional, tag = "22")]
    pub location: ::core::option::Option<Reference>,
    /// Network address to contact device
    #[prost(message, optional, tag = "23")]
    pub url: ::core::option::Option<Uri>,
    /// Device notes and comments
    #[prost(message, repeated, tag = "24")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Safety Characteristics of Device
    #[prost(message, repeated, tag = "25")]
    pub safety: prost::alloc::vec::Vec<CodeableConcept>,
}
/// Nested message and enum types in `Device`.
pub mod device {
    /// Unique Device Identifier (UDI) Barcode string
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Udi {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Mandatory fixed portion of UDI
        #[prost(message, optional, tag = "4")]
        pub device_identifier: ::core::option::Option<super::String>,
        /// Device Name as appears on UDI label
        #[prost(message, optional, tag = "5")]
        pub name: ::core::option::Option<super::String>,
        /// Regional UDI authority
        #[prost(message, optional, tag = "6")]
        pub jurisdiction: ::core::option::Option<super::Uri>,
        /// UDI Human Readable Barcode String
        #[prost(message, optional, tag = "7")]
        pub carrier_hrf: ::core::option::Option<super::String>,
        /// UDI Machine Readable Barcode String
        #[prost(message, optional, tag = "8")]
        pub carrier_aidc: ::core::option::Option<super::Base64Binary>,
        /// UDI Issuing Organization
        #[prost(message, optional, tag = "9")]
        pub issuer: ::core::option::Option<super::Uri>,
        /// barcode | rfid | manual +
        #[prost(message, optional, tag = "10")]
        pub entry_type: ::core::option::Option<super::UdiEntryTypeCode>,
    }
}
/// Auto-generated from StructureDefinition for DeviceComponent, last updated
/// 2017-04-19T07:44:43.294+10:00. An instance of a medical-related component of
/// a medical device. See <http://hl7.org/fhir/StructureDefinition/DeviceComponent>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceComponent {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Instance id assigned by the software stack
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// What kind of component it is
    #[prost(message, optional, tag = "10")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Recent system change timestamp
    #[prost(message, optional, tag = "11")]
    pub last_system_change: ::core::option::Option<Instant>,
    /// Top-level device resource link
    #[prost(message, optional, tag = "12")]
    pub source: ::core::option::Option<Reference>,
    /// Parent resource link
    #[prost(message, optional, tag = "13")]
    pub parent: ::core::option::Option<Reference>,
    /// Current operational status of the component, for example On, Off or Standby
    #[prost(message, repeated, tag = "14")]
    pub operational_status: prost::alloc::vec::Vec<CodeableConcept>,
    /// Current supported parameter group
    #[prost(message, optional, tag = "15")]
    pub parameter_group: ::core::option::Option<CodeableConcept>,
    /// other | chemical | electrical | impedance | nuclear | optical | thermal |
    /// biological | mechanical | acoustical | manual+
    #[prost(message, optional, tag = "16")]
    pub measurement_principle: ::core::option::Option<MeasmntPrincipleCode>,
    #[prost(message, repeated, tag = "17")]
    pub production_specification: prost::alloc::vec::Vec<device_component::ProductionSpecification>,
    /// Language code for the human-readable text strings produced by the device
    #[prost(message, optional, tag = "18")]
    pub language_code: ::core::option::Option<CodeableConcept>,
}
/// Nested message and enum types in `DeviceComponent`.
pub mod device_component {
    /// Specification details such as Component Revisions, or Serial Numbers
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ProductionSpecification {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type or kind of production specification, for example serial number or
        /// software revision
        #[prost(message, optional, tag = "4")]
        pub spec_type: ::core::option::Option<super::CodeableConcept>,
        /// Internal component unique identification
        #[prost(message, optional, tag = "5")]
        pub component_id: ::core::option::Option<super::Identifier>,
        /// A printable string defining the component
        #[prost(message, optional, tag = "6")]
        pub production_spec: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for DeviceMetric, last updated
/// 2017-04-19T07:44:43.294+10:00. Measurement, calculation or setting capability
/// of a medical device. See <http://hl7.org/fhir/StructureDefinition/DeviceMetric>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceMetric {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier of this DeviceMetric
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Identity of metric, for example Heart Rate or PEEP Setting
    #[prost(message, optional, tag = "10")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Unit of Measure for the Metric
    #[prost(message, optional, tag = "11")]
    pub unit: ::core::option::Option<CodeableConcept>,
    /// Describes the link to the source Device
    #[prost(message, optional, tag = "12")]
    pub source: ::core::option::Option<Reference>,
    /// Describes the link to the parent DeviceComponent
    #[prost(message, optional, tag = "13")]
    pub parent: ::core::option::Option<Reference>,
    /// on | off | standby | entered-in-error
    #[prost(message, optional, tag = "14")]
    pub operational_status: ::core::option::Option<DeviceMetricOperationalStatusCode>,
    /// black | red | green | yellow | blue | magenta | cyan | white
    #[prost(message, optional, tag = "15")]
    pub color: ::core::option::Option<DeviceMetricColorCode>,
    /// measurement | setting | calculation | unspecified
    #[prost(message, optional, tag = "16")]
    pub category: ::core::option::Option<DeviceMetricCategoryCode>,
    /// Describes the measurement repetition time
    #[prost(message, optional, tag = "17")]
    pub measurement_period: ::core::option::Option<Timing>,
    #[prost(message, repeated, tag = "18")]
    pub calibration: prost::alloc::vec::Vec<device_metric::Calibration>,
}
/// Nested message and enum types in `DeviceMetric`.
pub mod device_metric {
    /// Describes the calibrations that have been performed or that are required to
    /// be performed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Calibration {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// unspecified | offset | gain | two-point
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::DeviceMetricCalibrationTypeCode>,
        /// not-calibrated | calibration-required | calibrated | unspecified
        #[prost(message, optional, tag = "5")]
        pub state: ::core::option::Option<super::DeviceMetricCalibrationStateCode>,
        /// Describes the time last calibration has been performed
        #[prost(message, optional, tag = "6")]
        pub time: ::core::option::Option<super::Instant>,
    }
}
/// Auto-generated from StructureDefinition for DeviceRequest, last updated
/// 2017-04-19T07:44:43.294+10:00. Medical device request. See
/// <http://hl7.org/fhir/StructureDefinition/DeviceRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Request identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Protocol or definition
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Reference>,
    /// What request fulfills
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// What request replaces
    #[prost(message, repeated, tag = "12")]
    pub prior_request: prost::alloc::vec::Vec<Reference>,
    /// Identifier of composite request
    #[prost(message, optional, tag = "13")]
    pub group_identifier: ::core::option::Option<Identifier>,
    /// draft | active | suspended | completed | entered-in-error | cancelled
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<RequestStatusCode>,
    /// proposal | plan | original-order | encoded | reflex-order
    #[prost(message, optional, tag = "15")]
    pub intent: ::core::option::Option<CodeableConcept>,
    /// Indicates how quickly the {{title}} should be addressed with respect to
    /// other requests
    #[prost(message, optional, tag = "16")]
    pub priority: ::core::option::Option<RequestPriorityCode>,
    #[prost(message, optional, tag = "17")]
    pub code: ::core::option::Option<device_request::Code>,
    /// Focus of request
    #[prost(message, optional, tag = "18")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or Episode motivating request
    #[prost(message, optional, tag = "19")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "20")]
    pub occurrence: ::core::option::Option<device_request::Occurrence>,
    /// When recorded
    #[prost(message, optional, tag = "21")]
    pub authored_on: ::core::option::Option<DateTime>,
    #[prost(message, optional, tag = "22")]
    pub requester: ::core::option::Option<device_request::Requester>,
    /// Fille role
    #[prost(message, optional, tag = "23")]
    pub performer_type: ::core::option::Option<CodeableConcept>,
    /// Requested Filler
    #[prost(message, optional, tag = "24")]
    pub performer: ::core::option::Option<Reference>,
    /// Coded Reason for request
    #[prost(message, repeated, tag = "25")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Linked Reason for request
    #[prost(message, repeated, tag = "26")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Additional clinical information
    #[prost(message, repeated, tag = "27")]
    pub supporting_info: prost::alloc::vec::Vec<Reference>,
    /// Notes or comments
    #[prost(message, repeated, tag = "28")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Request provenance
    #[prost(message, repeated, tag = "29")]
    pub relevant_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `DeviceRequest`.
pub mod device_request {
    /// Device requested
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Code {
        #[prost(oneof = "code::Code", tags = "1, 2")]
        pub code: ::core::option::Option<code::Code>,
    }
    /// Nested message and enum types in `Code`.
    pub mod code {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Code {
            #[prost(message, tag = "1")]
            Reference(super::super::Reference),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// Desired time or schedule for use
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Occurrence {
        #[prost(oneof = "occurrence::Occurrence", tags = "1, 2, 3")]
        pub occurrence: ::core::option::Option<occurrence::Occurrence>,
    }
    /// Nested message and enum types in `Occurrence`.
    pub mod occurrence {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Occurrence {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
        }
    }
    /// Who/what is requesting diagnostics
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Requester {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Individual making the request
        #[prost(message, optional, tag = "4")]
        pub agent: ::core::option::Option<super::Reference>,
        /// Organization agent is acting for
        #[prost(message, optional, tag = "5")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for DeviceUseStatement, last updated
/// 2017-04-19T07:44:43.294+10:00. Record of use of a device. See
/// <http://hl7.org/fhir/StructureDefinition/DeviceUseStatement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DeviceUseStatement {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier for this record
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | completed | entered-in-error +
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<DeviceUseStatementStatusCode>,
    /// Patient using device
    #[prost(message, optional, tag = "11")]
    pub subject: ::core::option::Option<Reference>,
    /// Period device was used
    #[prost(message, optional, tag = "12")]
    pub when_used: ::core::option::Option<Period>,
    #[prost(message, optional, tag = "13")]
    pub timing: ::core::option::Option<device_use_statement::TimingType>,
    /// When statement was recorded
    #[prost(message, optional, tag = "14")]
    pub recorded_on: ::core::option::Option<DateTime>,
    /// Who made the statement
    #[prost(message, optional, tag = "15")]
    pub source: ::core::option::Option<Reference>,
    /// Reference to device used
    #[prost(message, optional, tag = "16")]
    pub device: ::core::option::Option<Reference>,
    /// Why device was used
    #[prost(message, repeated, tag = "17")]
    pub indication: prost::alloc::vec::Vec<CodeableConcept>,
    /// Target body site
    #[prost(message, optional, tag = "18")]
    pub body_site: ::core::option::Option<CodeableConcept>,
    /// Addition details (comments, instructions)
    #[prost(message, repeated, tag = "19")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `DeviceUseStatement`.
pub mod device_use_statement {
    /// How often  the device was used
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct TimingType {
        #[prost(oneof = "timing_type::Timing", tags = "1, 2, 3")]
        pub timing: ::core::option::Option<timing_type::Timing>,
    }
    /// Nested message and enum types in `TimingType`.
    pub mod timing_type {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Timing {
            #[prost(message, tag = "1")]
            TimingValue(super::super::Timing),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            DateTime(super::super::DateTime),
        }
    }
}
/// Auto-generated from StructureDefinition for DiagnosticReport, last updated
/// 2017-04-19T07:44:43.294+10:00. A Diagnostic report - a combination of request
/// information, atomic results, images, interpretation, as well as formatted
/// reports. See <http://hl7.org/fhir/StructureDefinition/DiagnosticReport>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DiagnosticReport {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier for report
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// What was requested
    #[prost(message, repeated, tag = "10")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// registered | partial | preliminary | final +
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<DiagnosticReportStatusCode>,
    /// Service category
    #[prost(message, optional, tag = "12")]
    pub category: ::core::option::Option<CodeableConcept>,
    /// Name/Code for this diagnostic report
    #[prost(message, optional, tag = "13")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// The subject of the report - usually, but not always, the patient
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Health care event when test ordered
    #[prost(message, optional, tag = "15")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "16")]
    pub effective: ::core::option::Option<diagnostic_report::Effective>,
    /// DateTime this version was released
    #[prost(message, optional, tag = "17")]
    pub issued: ::core::option::Option<Instant>,
    #[prost(message, repeated, tag = "18")]
    pub performer: prost::alloc::vec::Vec<diagnostic_report::Performer>,
    /// Specimens this report is based on
    #[prost(message, repeated, tag = "19")]
    pub specimen: prost::alloc::vec::Vec<Reference>,
    /// Observations - simple, or complex nested groups
    #[prost(message, repeated, tag = "20")]
    pub result: prost::alloc::vec::Vec<Reference>,
    /// Reference to full details of imaging associated with the diagnostic report
    #[prost(message, repeated, tag = "21")]
    pub imaging_study: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "22")]
    pub image: prost::alloc::vec::Vec<diagnostic_report::Image>,
    /// Clinical Interpretation of test results
    #[prost(message, optional, tag = "23")]
    pub conclusion: ::core::option::Option<String>,
    /// Codes for the conclusion
    #[prost(message, repeated, tag = "24")]
    pub coded_diagnosis: prost::alloc::vec::Vec<CodeableConcept>,
    /// Entire report as issued
    #[prost(message, repeated, tag = "25")]
    pub presented_form: prost::alloc::vec::Vec<Attachment>,
}
/// Nested message and enum types in `DiagnosticReport`.
pub mod diagnostic_report {
    /// Clinically relevant time/time-period for report
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Effective {
        #[prost(oneof = "effective::Effective", tags = "1, 2")]
        pub effective: ::core::option::Option<effective::Effective>,
    }
    /// Nested message and enum types in `Effective`.
    pub mod effective {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Effective {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Participants in producing the report
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Performer {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of performer
        #[prost(message, optional, tag = "4")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Practitioner or Organization  participant
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
    }
    /// Key images associated with this report
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Image {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Comment about the image (e.g. explanation)
        #[prost(message, optional, tag = "4")]
        pub comment: ::core::option::Option<super::String>,
        /// Reference to the image source
        #[prost(message, optional, tag = "5")]
        pub link: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for DocumentManifest, last updated
/// 2017-04-19T07:44:43.294+10:00. A list that defines a set of documents. See
/// <http://hl7.org/fhir/StructureDefinition/DocumentManifest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DocumentManifest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique Identifier for the set of documents
    #[prost(message, optional, tag = "9")]
    pub master_identifier: ::core::option::Option<Identifier>,
    /// Other identifiers for the manifest
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// current | superseded | entered-in-error
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<DocumentReferenceStatusCode>,
    /// Kind of document set
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// The subject of the set of documents
    #[prost(message, optional, tag = "13")]
    pub subject: ::core::option::Option<Reference>,
    /// When this document manifest created
    #[prost(message, optional, tag = "14")]
    pub created: ::core::option::Option<DateTime>,
    /// Who and/or what authored the manifest
    #[prost(message, repeated, tag = "15")]
    pub author: prost::alloc::vec::Vec<Reference>,
    /// Intended to get notified about this set of documents
    #[prost(message, repeated, tag = "16")]
    pub recipient: prost::alloc::vec::Vec<Reference>,
    /// The source system/application/software
    #[prost(message, optional, tag = "17")]
    pub source: ::core::option::Option<Uri>,
    /// Human-readable description (title)
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "19")]
    pub content: prost::alloc::vec::Vec<document_manifest::Content>,
    #[prost(message, repeated, tag = "20")]
    pub related: prost::alloc::vec::Vec<document_manifest::Related>,
}
/// Nested message and enum types in `DocumentManifest`.
pub mod document_manifest {
    /// The items included
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Content {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub p: ::core::option::Option<content::P>,
    }
    /// Nested message and enum types in `Content`.
    pub mod content {
        /// Contents of this set of documents
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct P {
            #[prost(oneof = "p::P", tags = "1, 2")]
            pub p: ::core::option::Option<p::P>,
        }
        /// Nested message and enum types in `P`.
        pub mod p {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum P {
                #[prost(message, tag = "1")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Related things
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Related {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifiers of things that are related
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Related Resource
        #[prost(message, optional, tag = "5")]
        pub r#ref: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for DocumentReference, last updated
/// 2017-04-19T07:44:43.294+10:00. A reference to a document. See
/// <http://hl7.org/fhir/StructureDefinition/DocumentReference>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DocumentReference {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Master Version Specific Identifier
    #[prost(message, optional, tag = "9")]
    pub master_identifier: ::core::option::Option<Identifier>,
    /// Other identifiers for the document
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// current | superseded | entered-in-error
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<DocumentReferenceStatusCode>,
    /// preliminary | final | appended | amended | entered-in-error
    #[prost(message, optional, tag = "12")]
    pub doc_status: ::core::option::Option<CompositionStatusCode>,
    /// Kind of document (LOINC if possible)
    #[prost(message, optional, tag = "13")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Categorization of document
    #[prost(message, optional, tag = "14")]
    pub class_value: ::core::option::Option<CodeableConcept>,
    /// Who/what is the subject of the document
    #[prost(message, optional, tag = "15")]
    pub subject: ::core::option::Option<Reference>,
    /// Document creation time
    #[prost(message, optional, tag = "16")]
    pub created: ::core::option::Option<DateTime>,
    /// When this document reference was created
    #[prost(message, optional, tag = "17")]
    pub indexed: ::core::option::Option<Instant>,
    /// Who and/or what authored the document
    #[prost(message, repeated, tag = "18")]
    pub author: prost::alloc::vec::Vec<Reference>,
    /// Who/what authenticated the document
    #[prost(message, optional, tag = "19")]
    pub authenticator: ::core::option::Option<Reference>,
    /// Organization which maintains the document
    #[prost(message, optional, tag = "20")]
    pub custodian: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "21")]
    pub relates_to: prost::alloc::vec::Vec<document_reference::RelatesTo>,
    /// Human-readable description (title)
    #[prost(message, optional, tag = "22")]
    pub description: ::core::option::Option<String>,
    /// Document security-tags
    #[prost(message, repeated, tag = "23")]
    pub security_label: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "24")]
    pub content: prost::alloc::vec::Vec<document_reference::Content>,
    #[prost(message, optional, tag = "25")]
    pub context: ::core::option::Option<document_reference::Context>,
}
/// Nested message and enum types in `DocumentReference`.
pub mod document_reference {
    /// Relationships to other documents
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelatesTo {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// replaces | transforms | signs | appends
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::DocumentRelationshipTypeCode>,
        /// Target of the relationship
        #[prost(message, optional, tag = "5")]
        pub target: ::core::option::Option<super::Reference>,
    }
    /// Document referenced
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Content {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Where to access the document
        #[prost(message, optional, tag = "4")]
        pub attachment: ::core::option::Option<super::Attachment>,
        /// Format/content rules for the document
        #[prost(message, optional, tag = "5")]
        pub format: ::core::option::Option<super::Coding>,
    }
    /// Clinical context of document
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Context {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Context of the document  content
        #[prost(message, optional, tag = "4")]
        pub encounter: ::core::option::Option<super::Reference>,
        /// Main clinical acts documented
        #[prost(message, repeated, tag = "5")]
        pub event: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Time of service that is being documented
        #[prost(message, optional, tag = "6")]
        pub period: ::core::option::Option<super::Period>,
        /// Kind of facility where patient was seen
        #[prost(message, optional, tag = "7")]
        pub facility_type: ::core::option::Option<super::CodeableConcept>,
        /// Additional details about where the content was created (e.g. clinical
        /// specialty)
        #[prost(message, optional, tag = "8")]
        pub practice_setting: ::core::option::Option<super::CodeableConcept>,
        /// Patient demographics from source
        #[prost(message, optional, tag = "9")]
        pub source_patient_info: ::core::option::Option<super::Reference>,
        #[prost(message, repeated, tag = "10")]
        pub related: prost::alloc::vec::Vec<context::Related>,
    }
    /// Nested message and enum types in `Context`.
    pub mod context {
        /// Related identifiers or resources
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Related {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Identifier of related objects or events
            #[prost(message, optional, tag = "4")]
            pub identifier: ::core::option::Option<super::super::Identifier>,
            /// Related Resource
            #[prost(message, optional, tag = "5")]
            pub r#ref: ::core::option::Option<super::super::Reference>,
        }
    }
}
/// Auto-generated from StructureDefinition for EligibilityRequest, last updated
/// 2017-04-19T07:44:43.294+10:00. Determine insurance validity and scope of
/// coverage. See <http://hl7.org/fhir/StructureDefinition/EligibilityRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EligibilityRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// Desired processing priority
    #[prost(message, optional, tag = "11")]
    pub priority: ::core::option::Option<CodeableConcept>,
    /// The subject of the Products and Services
    #[prost(message, optional, tag = "12")]
    pub patient: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "13")]
    pub serviced: ::core::option::Option<eligibility_request::Serviced>,
    /// Creation date
    #[prost(message, optional, tag = "14")]
    pub created: ::core::option::Option<DateTime>,
    /// Author
    #[prost(message, optional, tag = "15")]
    pub enterer: ::core::option::Option<Reference>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "16")]
    pub provider: ::core::option::Option<Reference>,
    /// Responsible organization
    #[prost(message, optional, tag = "17")]
    pub organization: ::core::option::Option<Reference>,
    /// Target
    #[prost(message, optional, tag = "18")]
    pub insurer: ::core::option::Option<Reference>,
    /// Servicing Facility
    #[prost(message, optional, tag = "19")]
    pub facility: ::core::option::Option<Reference>,
    /// Insurance or medical plan
    #[prost(message, optional, tag = "20")]
    pub coverage: ::core::option::Option<Reference>,
    /// Business agreement
    #[prost(message, optional, tag = "21")]
    pub business_arrangement: ::core::option::Option<String>,
    /// Type of services covered
    #[prost(message, optional, tag = "22")]
    pub benefit_category: ::core::option::Option<CodeableConcept>,
    /// Detailed services covered within the type
    #[prost(message, optional, tag = "23")]
    pub benefit_sub_category: ::core::option::Option<CodeableConcept>,
}
/// Nested message and enum types in `EligibilityRequest`.
pub mod eligibility_request {
    /// Estimated date or dates of Service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Serviced {
        #[prost(oneof = "serviced::Serviced", tags = "1, 2")]
        pub serviced: ::core::option::Option<serviced::Serviced>,
    }
    /// Nested message and enum types in `Serviced`.
    pub mod serviced {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Serviced {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
}
/// Auto-generated from StructureDefinition for EligibilityResponse, last updated
/// 2017-04-19T07:44:43.294+10:00. EligibilityResponse resource. See
/// <http://hl7.org/fhir/StructureDefinition/EligibilityResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EligibilityResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// Creation date
    #[prost(message, optional, tag = "11")]
    pub created: ::core::option::Option<DateTime>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "12")]
    pub request_provider: ::core::option::Option<Reference>,
    /// Responsible organization
    #[prost(message, optional, tag = "13")]
    pub request_organization: ::core::option::Option<Reference>,
    /// Eligibility reference
    #[prost(message, optional, tag = "14")]
    pub request: ::core::option::Option<Reference>,
    /// complete | error | partial
    #[prost(message, optional, tag = "15")]
    pub outcome: ::core::option::Option<CodeableConcept>,
    /// Disposition Message
    #[prost(message, optional, tag = "16")]
    pub disposition: ::core::option::Option<String>,
    /// Insurer issuing the coverage
    #[prost(message, optional, tag = "17")]
    pub insurer: ::core::option::Option<Reference>,
    /// Coverage inforce indicator
    #[prost(message, optional, tag = "18")]
    pub inforce: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "19")]
    pub insurance: prost::alloc::vec::Vec<eligibility_response::Insurance>,
    /// Printed Form Identifier
    #[prost(message, optional, tag = "20")]
    pub form: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "21")]
    pub error: prost::alloc::vec::Vec<eligibility_response::Errors>,
}
/// Nested message and enum types in `EligibilityResponse`.
pub mod eligibility_response {
    /// Details by insurance coverage
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Insurance {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Updated Coverage details
        #[prost(message, optional, tag = "4")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// Contract details
        #[prost(message, optional, tag = "5")]
        pub contract: ::core::option::Option<super::Reference>,
        #[prost(message, repeated, tag = "6")]
        pub benefit_balance: prost::alloc::vec::Vec<insurance::Benefits>,
    }
    /// Nested message and enum types in `Insurance`.
    pub mod insurance {
        /// Benefits by Category
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Benefits {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of services covered
            #[prost(message, optional, tag = "4")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Detailed services covered within the type
            #[prost(message, optional, tag = "5")]
            pub sub_category: ::core::option::Option<super::super::CodeableConcept>,
            /// Excluded from the plan
            #[prost(message, optional, tag = "6")]
            pub excluded: ::core::option::Option<super::super::Boolean>,
            /// Short name for the benefit
            #[prost(message, optional, tag = "7")]
            pub name: ::core::option::Option<super::super::String>,
            /// Description of the benefit or services covered
            #[prost(message, optional, tag = "8")]
            pub description: ::core::option::Option<super::super::String>,
            /// In or out of network
            #[prost(message, optional, tag = "9")]
            pub network: ::core::option::Option<super::super::CodeableConcept>,
            /// Individual or family
            #[prost(message, optional, tag = "10")]
            pub unit: ::core::option::Option<super::super::CodeableConcept>,
            /// Annual or lifetime
            #[prost(message, optional, tag = "11")]
            pub term: ::core::option::Option<super::super::CodeableConcept>,
            #[prost(message, repeated, tag = "12")]
            pub financial: prost::alloc::vec::Vec<benefits::Benefit>,
        }
        /// Nested message and enum types in `Benefits`.
        pub mod benefits {
            /// Benefit Summary
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Benefit {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Deductable, visits, benefit amount
                #[prost(message, optional, tag = "4")]
                pub r#type: ::core::option::Option<super::super::super::CodeableConcept>,
                #[prost(message, optional, tag = "5")]
                pub allowed: ::core::option::Option<benefit::Allowed>,
                #[prost(message, optional, tag = "6")]
                pub used: ::core::option::Option<benefit::Used>,
            }
            /// Nested message and enum types in `Benefit`.
            pub mod benefit {
                /// Benefits allowed
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct Allowed {
                    #[prost(oneof = "allowed::Allowed", tags = "1, 2, 3")]
                    pub allowed: ::core::option::Option<allowed::Allowed>,
                }
                /// Nested message and enum types in `Allowed`.
                pub mod allowed {
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Oneof)]
                    pub enum Allowed {
                        #[prost(message, tag = "1")]
                        UnsignedInt(super::super::super::super::super::UnsignedInt),
                        #[prost(message, tag = "2")]
                        StringValue(super::super::super::super::super::String),
                        #[prost(message, tag = "3")]
                        Money(super::super::super::super::super::Money),
                    }
                }
                /// Benefits used
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct Used {
                    #[prost(oneof = "used::Used", tags = "1, 2")]
                    pub used: ::core::option::Option<used::Used>,
                }
                /// Nested message and enum types in `Used`.
                pub mod used {
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Oneof)]
                    pub enum Used {
                        #[prost(message, tag = "1")]
                        UnsignedInt(super::super::super::super::super::UnsignedInt),
                        #[prost(message, tag = "2")]
                        Money(super::super::super::super::super::Money),
                    }
                }
            }
        }
    }
    /// Processing errors
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Errors {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Error code detailing processing issues
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
    }
}
/// Auto-generated from StructureDefinition for Encounter, last updated
/// 2017-04-19T07:44:43.294+10:00. An interaction during which services are
/// provided to the patient. See
/// <http://hl7.org/fhir/StructureDefinition/Encounter>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Encounter {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifier(s) by which this encounter is known
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// planned | arrived | triaged | in-progress | onleave | finished | cancelled
    /// +
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<EncounterStatusCode>,
    #[prost(message, repeated, tag = "11")]
    pub status_history: prost::alloc::vec::Vec<encounter::StatusHistory>,
    /// inpatient | outpatient | ambulatory | emergency +
    #[prost(message, optional, tag = "12")]
    pub class_value: ::core::option::Option<Coding>,
    #[prost(message, repeated, tag = "13")]
    pub class_history: prost::alloc::vec::Vec<encounter::ClassHistory>,
    /// Specific type of encounter
    #[prost(message, repeated, tag = "14")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Indicates the urgency of the encounter
    #[prost(message, optional, tag = "15")]
    pub priority: ::core::option::Option<CodeableConcept>,
    /// The patient ro group present at the encounter
    #[prost(message, optional, tag = "16")]
    pub subject: ::core::option::Option<Reference>,
    /// Episode(s) of care that this encounter should be recorded against
    #[prost(message, repeated, tag = "17")]
    pub episode_of_care: prost::alloc::vec::Vec<Reference>,
    /// The ReferralRequest that initiated this encounter
    #[prost(message, repeated, tag = "18")]
    pub incoming_referral: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "19")]
    pub participant: prost::alloc::vec::Vec<encounter::Participant>,
    /// The appointment that scheduled this encounter
    #[prost(message, optional, tag = "20")]
    pub appointment: ::core::option::Option<Reference>,
    /// The start and end time of the encounter
    #[prost(message, optional, tag = "21")]
    pub period: ::core::option::Option<Period>,
    /// Quantity of time the encounter lasted (less time absent)
    #[prost(message, optional, tag = "22")]
    pub length: ::core::option::Option<Duration>,
    /// Reason the encounter takes place (code)
    #[prost(message, repeated, tag = "23")]
    pub reason: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "24")]
    pub diagnosis: prost::alloc::vec::Vec<encounter::Diagnosis>,
    /// The set of accounts that may be used for billing for this Encounter
    #[prost(message, repeated, tag = "25")]
    pub account: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "26")]
    pub hospitalization: ::core::option::Option<encounter::Hospitalization>,
    #[prost(message, repeated, tag = "27")]
    pub location: prost::alloc::vec::Vec<encounter::Location>,
    /// The custodian organization of this Encounter record
    #[prost(message, optional, tag = "28")]
    pub service_provider: ::core::option::Option<Reference>,
    /// Another Encounter this encounter is part of
    #[prost(message, optional, tag = "29")]
    pub part_of: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `Encounter`.
pub mod encounter {
    /// List of past encounter statuses
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusHistory {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// planned | arrived | triaged | in-progress | onleave | finished |
        /// cancelled +
        #[prost(message, optional, tag = "4")]
        pub status: ::core::option::Option<super::EncounterStatusCode>,
        /// The time that the episode was in the specified status
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// List of past encounter classes
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ClassHistory {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// inpatient | outpatient | ambulatory | emergency +
        #[prost(message, optional, tag = "4")]
        pub class_value: ::core::option::Option<super::Coding>,
        /// The time that the episode was in the specified class
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// List of participants involved in the encounter
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Role of participant in encounter
        #[prost(message, repeated, tag = "4")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Period of time during the encounter that the participant participated
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
        /// Persons involved in the encounter other than the patient
        #[prost(message, optional, tag = "6")]
        pub individual: ::core::option::Option<super::Reference>,
    }
    /// The list of diagnosis relevant to this encounter
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Diagnosis {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reason the encounter takes place (resource)
        #[prost(message, optional, tag = "4")]
        pub condition: ::core::option::Option<super::Reference>,
        /// Role that this diagnosis has within the encounter (e.g. admission,
        /// billing, discharge …)
        #[prost(message, optional, tag = "5")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Ranking of the diagnosis (for each role type)
        #[prost(message, optional, tag = "6")]
        pub rank: ::core::option::Option<super::PositiveInt>,
    }
    /// Details about the admission to a healthcare service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Hospitalization {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Pre-admission identifier
        #[prost(message, optional, tag = "4")]
        pub pre_admission_identifier: ::core::option::Option<super::Identifier>,
        /// The location from which the patient came before admission
        #[prost(message, optional, tag = "5")]
        pub origin: ::core::option::Option<super::Reference>,
        /// From where patient was admitted (physician referral, transfer)
        #[prost(message, optional, tag = "6")]
        pub admit_source: ::core::option::Option<super::CodeableConcept>,
        /// The type of hospital re-admission that has occurred (if any). If the
        /// value is absent, then this is not identified as a readmission
        #[prost(message, optional, tag = "7")]
        pub re_admission: ::core::option::Option<super::CodeableConcept>,
        /// Diet preferences reported by the patient
        #[prost(message, repeated, tag = "8")]
        pub diet_preference: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Special courtesies (VIP, board member)
        #[prost(message, repeated, tag = "9")]
        pub special_courtesy: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Wheelchair, translator, stretcher, etc.
        #[prost(message, repeated, tag = "10")]
        pub special_arrangement: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Location to which the patient is discharged
        #[prost(message, optional, tag = "11")]
        pub destination: ::core::option::Option<super::Reference>,
        /// Category or kind of location after discharge
        #[prost(message, optional, tag = "12")]
        pub discharge_disposition: ::core::option::Option<super::CodeableConcept>,
    }
    /// List of locations where the patient has been
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Location {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Location the encounter takes place
        #[prost(message, optional, tag = "4")]
        pub location: ::core::option::Option<super::Reference>,
        /// planned | active | reserved | completed
        #[prost(message, optional, tag = "5")]
        pub status: ::core::option::Option<super::EncounterLocationStatusCode>,
        /// Time period during which the patient was present at the location
        #[prost(message, optional, tag = "6")]
        pub period: ::core::option::Option<super::Period>,
    }
}
/// Auto-generated from StructureDefinition for Endpoint, last updated
/// 2017-04-19T07:44:43.294+10:00. The technical details of an endpoint that can
/// be used for electronic services. See
/// <http://hl7.org/fhir/StructureDefinition/Endpoint>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Endpoint {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifies this endpoint across multiple systems
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | suspended | error | off | entered-in-error | test
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<EndpointStatusCode>,
    /// Protocol/Profile/Standard to be used with this endpoint connection
    #[prost(message, optional, tag = "11")]
    pub connection_type: ::core::option::Option<Coding>,
    /// A name that this endpoint can be identified by
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Organization that manages this endpoint (may not be the organization that
    /// exposes the endpoint)
    #[prost(message, optional, tag = "13")]
    pub managing_organization: ::core::option::Option<Reference>,
    /// Contact details for source (e.g. troubleshooting)
    #[prost(message, repeated, tag = "14")]
    pub contact: prost::alloc::vec::Vec<ContactPoint>,
    /// Interval the endpoint is expected to be operational
    #[prost(message, optional, tag = "15")]
    pub period: ::core::option::Option<Period>,
    /// The type of content that may be used at this endpoint (e.g. XDS Discharge
    /// summaries)
    #[prost(message, repeated, tag = "16")]
    pub payload_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Mimetype to send. If not specified, the content could be anything
    /// (including no payload, if the connectionType defined this)
    #[prost(message, repeated, tag = "17")]
    pub payload_mime_type: prost::alloc::vec::Vec<MimeTypeCode>,
    /// The technical base address for connecting to this endpoint
    #[prost(message, optional, tag = "18")]
    pub address: ::core::option::Option<Uri>,
    /// Usage depends on the channel type
    #[prost(message, repeated, tag = "19")]
    pub header: prost::alloc::vec::Vec<String>,
}
/// Auto-generated from StructureDefinition for EnrollmentRequest, last updated
/// 2017-04-19T07:44:43.294+10:00. Enrollment request. See
/// <http://hl7.org/fhir/StructureDefinition/EnrollmentRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EnrollmentRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// Creation date
    #[prost(message, optional, tag = "11")]
    pub created: ::core::option::Option<DateTime>,
    /// Target
    #[prost(message, optional, tag = "12")]
    pub insurer: ::core::option::Option<Reference>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "13")]
    pub provider: ::core::option::Option<Reference>,
    /// Responsible organization
    #[prost(message, optional, tag = "14")]
    pub organization: ::core::option::Option<Reference>,
    /// The subject of the Products and Services
    #[prost(message, optional, tag = "15")]
    pub subject: ::core::option::Option<Reference>,
    /// Insurance information
    #[prost(message, optional, tag = "16")]
    pub coverage: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for EnrollmentResponse, last updated
/// 2017-04-19T07:44:43.294+10:00. EnrollmentResponse resource. See
/// <http://hl7.org/fhir/StructureDefinition/EnrollmentResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EnrollmentResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// Claim reference
    #[prost(message, optional, tag = "11")]
    pub request: ::core::option::Option<Reference>,
    /// complete | error | partial
    #[prost(message, optional, tag = "12")]
    pub outcome: ::core::option::Option<CodeableConcept>,
    /// Disposition Message
    #[prost(message, optional, tag = "13")]
    pub disposition: ::core::option::Option<String>,
    /// Creation date
    #[prost(message, optional, tag = "14")]
    pub created: ::core::option::Option<DateTime>,
    /// Insurer
    #[prost(message, optional, tag = "15")]
    pub organization: ::core::option::Option<Reference>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "16")]
    pub request_provider: ::core::option::Option<Reference>,
    /// Responsible organization
    #[prost(message, optional, tag = "17")]
    pub request_organization: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for EpisodeOfCare, last updated
/// 2017-04-19T07:44:43.294+10:00. An association of a Patient with an
/// Organization and  Healthcare Provider(s) for a period of time that the
/// Organization assumes some level of responsibility. See
/// <http://hl7.org/fhir/StructureDefinition/EpisodeOfCare>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct EpisodeOfCare {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier(s) relevant for this EpisodeOfCare
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// planned | waitlist | active | onhold | finished | cancelled |
    /// entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<EpisodeOfCareStatusCode>,
    #[prost(message, repeated, tag = "11")]
    pub status_history: prost::alloc::vec::Vec<episode_of_care::StatusHistory>,
    /// Type/class  - e.g. specialist referral, disease management
    #[prost(message, repeated, tag = "12")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "13")]
    pub diagnosis: prost::alloc::vec::Vec<episode_of_care::Diagnosis>,
    /// The patient who is the focus of this episode of care
    #[prost(message, optional, tag = "14")]
    pub patient: ::core::option::Option<Reference>,
    /// Organization that assumes care
    #[prost(message, optional, tag = "15")]
    pub managing_organization: ::core::option::Option<Reference>,
    /// Interval during responsibility is assumed
    #[prost(message, optional, tag = "16")]
    pub period: ::core::option::Option<Period>,
    /// Originating Referral Request(s)
    #[prost(message, repeated, tag = "17")]
    pub referral_request: prost::alloc::vec::Vec<Reference>,
    /// Care manager/care co-ordinator for the patient
    #[prost(message, optional, tag = "18")]
    pub care_manager: ::core::option::Option<Reference>,
    /// Other practitioners facilitating this episode of care
    #[prost(message, repeated, tag = "19")]
    pub team: prost::alloc::vec::Vec<Reference>,
    /// The set of accounts that may be used for billing for this EpisodeOfCare
    #[prost(message, repeated, tag = "20")]
    pub account: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `EpisodeOfCare`.
pub mod episode_of_care {
    /// Past list of status codes (the current status may be included to cover the
    /// start date of the status)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct StatusHistory {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// planned | waitlist | active | onhold | finished | cancelled |
        /// entered-in-error
        #[prost(message, optional, tag = "4")]
        pub status: ::core::option::Option<super::EpisodeOfCareStatusCode>,
        /// Duration the EpisodeOfCare was in the specified status
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// The list of diagnosis relevant to this episode of care
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Diagnosis {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Conditions/problems/diagnoses this episode of care is for
        #[prost(message, optional, tag = "4")]
        pub condition: ::core::option::Option<super::Reference>,
        /// Role that this diagnosis has within the episode of care (e.g. admission,
        /// billing, discharge …)
        #[prost(message, optional, tag = "5")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Ranking of the diagnosis (for each role type)
        #[prost(message, optional, tag = "6")]
        pub rank: ::core::option::Option<super::PositiveInt>,
    }
}
/// Auto-generated from StructureDefinition for ExpansionProfile, last updated
/// 2017-04-19T07:44:43.294+10:00. Defines behaviour and contraints on the
/// ValueSet Expansion operation. See
/// <http://hl7.org/fhir/StructureDefinition/ExpansionProfile>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExpansionProfile {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this expansion profile (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the expansion profile
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Business version of the expansion profile
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this expansion profile (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "14")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "15")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "16")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "17")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the expansion profile
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "19")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for expansion profile (if applicable)
    #[prost(message, repeated, tag = "20")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, repeated, tag = "21")]
    pub fixed_version: prost::alloc::vec::Vec<expansion_profile::FixedVersion>,
    #[prost(message, optional, tag = "22")]
    pub excluded_system: ::core::option::Option<expansion_profile::ExcludedSystem>,
    /// Whether the expansion should include concept designations
    #[prost(message, optional, tag = "23")]
    pub include_designations: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "24")]
    pub designation: ::core::option::Option<expansion_profile::Designation>,
    /// Include or exclude the value set definition in the expansion
    #[prost(message, optional, tag = "25")]
    pub include_definition: ::core::option::Option<Boolean>,
    /// Include or exclude inactive concepts in the expansion
    #[prost(message, optional, tag = "26")]
    pub active_only: ::core::option::Option<Boolean>,
    /// Nested codes in the expansion or not
    #[prost(message, optional, tag = "27")]
    pub exclude_nested: ::core::option::Option<Boolean>,
    /// Include or exclude codes which cannot be rendered in user interfaces in the
    /// value set expansion
    #[prost(message, optional, tag = "28")]
    pub exclude_not_for_ui: ::core::option::Option<Boolean>,
    /// Include or exclude codes which are post coordinated expressions in the
    /// value set expansion
    #[prost(message, optional, tag = "29")]
    pub exclude_post_coordinated: ::core::option::Option<Boolean>,
    /// Specify the language for the display element of codes in the value set
    /// expansion
    #[prost(message, optional, tag = "30")]
    pub display_language: ::core::option::Option<LanguageCode>,
    /// Controls behaviour of the value set expand operation when value sets are
    /// too large to be completely expanded
    #[prost(message, optional, tag = "31")]
    pub limited_expansion: ::core::option::Option<Boolean>,
}
/// Nested message and enum types in `ExpansionProfile`.
pub mod expansion_profile {
    /// Fix use of a code system to a particular version
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FixedVersion {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// System to have its version fixed
        #[prost(message, optional, tag = "4")]
        pub system: ::core::option::Option<super::Uri>,
        /// Specific version of the code system referred to
        #[prost(message, optional, tag = "5")]
        pub version: ::core::option::Option<super::String>,
        /// default | check | override
        #[prost(message, optional, tag = "6")]
        pub mode: ::core::option::Option<super::SystemVersionProcessingModeCode>,
    }
    /// Systems/Versions to be exclude
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ExcludedSystem {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The specific code system to be excluded
        #[prost(message, optional, tag = "4")]
        pub system: ::core::option::Option<super::Uri>,
        /// Specific version of the code system referred to
        #[prost(message, optional, tag = "5")]
        pub version: ::core::option::Option<super::String>,
    }
    /// When the expansion profile imposes designation contraints
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Designation {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub include: ::core::option::Option<designation::DesignationInclude>,
        #[prost(message, optional, tag = "5")]
        pub exclude: ::core::option::Option<designation::DesignationExclude>,
    }
    /// Nested message and enum types in `Designation`.
    pub mod designation {
        /// Designations to be included
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DesignationInclude {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, repeated, tag = "4")]
            pub designation:
                prost::alloc::vec::Vec<designation_include::DesignationIncludeDesignation>,
        }
        /// Nested message and enum types in `DesignationInclude`.
        pub mod designation_include {
            /// The designation to be included
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct DesignationIncludeDesignation {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Human language of the designation to be included
                #[prost(message, optional, tag = "4")]
                pub language: ::core::option::Option<super::super::super::LanguageCode>,
                /// What kind of Designation to include
                #[prost(message, optional, tag = "5")]
                pub r#use: ::core::option::Option<super::super::super::Coding>,
            }
        }
        /// Designations to be excluded
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DesignationExclude {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, repeated, tag = "4")]
            pub designation:
                prost::alloc::vec::Vec<designation_exclude::DesignationExcludeDesignation>,
        }
        /// Nested message and enum types in `DesignationExclude`.
        pub mod designation_exclude {
            /// The designation to be excluded
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct DesignationExcludeDesignation {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Human language of the designation to be excluded
                #[prost(message, optional, tag = "4")]
                pub language: ::core::option::Option<super::super::super::LanguageCode>,
                /// What kind of Designation to exclude
                #[prost(message, optional, tag = "5")]
                pub r#use: ::core::option::Option<super::super::super::Coding>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for ExplanationOfBenefit, last
/// updated 2017-04-19T07:44:43.294+10:00. Explanation of Benefit resource. See
/// <http://hl7.org/fhir/StructureDefinition/ExplanationOfBenefit>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ExplanationOfBenefit {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<ExplanationOfBenefitStatusCode>,
    /// Type or discipline
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Finer grained claim type information
    #[prost(message, repeated, tag = "12")]
    pub sub_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// The subject of the Products and Services
    #[prost(message, optional, tag = "13")]
    pub patient: ::core::option::Option<Reference>,
    /// Period for charge submission
    #[prost(message, optional, tag = "14")]
    pub billable_period: ::core::option::Option<Period>,
    /// Creation date
    #[prost(message, optional, tag = "15")]
    pub created: ::core::option::Option<DateTime>,
    /// Author
    #[prost(message, optional, tag = "16")]
    pub enterer: ::core::option::Option<Reference>,
    /// Insurer responsible for the EOB
    #[prost(message, optional, tag = "17")]
    pub insurer: ::core::option::Option<Reference>,
    /// Responsible provider for the claim
    #[prost(message, optional, tag = "18")]
    pub provider: ::core::option::Option<Reference>,
    /// Responsible organization for the claim
    #[prost(message, optional, tag = "19")]
    pub organization: ::core::option::Option<Reference>,
    /// Treatment Referral
    #[prost(message, optional, tag = "20")]
    pub referral: ::core::option::Option<Reference>,
    /// Servicing Facility
    #[prost(message, optional, tag = "21")]
    pub facility: ::core::option::Option<Reference>,
    /// Claim reference
    #[prost(message, optional, tag = "22")]
    pub claim: ::core::option::Option<Reference>,
    /// Claim response reference
    #[prost(message, optional, tag = "23")]
    pub claim_response: ::core::option::Option<Reference>,
    /// complete | error | partial
    #[prost(message, optional, tag = "24")]
    pub outcome: ::core::option::Option<CodeableConcept>,
    /// Disposition Message
    #[prost(message, optional, tag = "25")]
    pub disposition: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "26")]
    pub related: prost::alloc::vec::Vec<explanation_of_benefit::RelatedClaim>,
    /// Prescription authorizing services or products
    #[prost(message, optional, tag = "27")]
    pub prescription: ::core::option::Option<Reference>,
    /// Original prescription if superceded by fulfiller
    #[prost(message, optional, tag = "28")]
    pub original_prescription: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "29")]
    pub payee: ::core::option::Option<explanation_of_benefit::Payee>,
    #[prost(message, repeated, tag = "30")]
    pub information: prost::alloc::vec::Vec<explanation_of_benefit::SupportingInformation>,
    #[prost(message, repeated, tag = "31")]
    pub care_team: prost::alloc::vec::Vec<explanation_of_benefit::CareTeam>,
    #[prost(message, repeated, tag = "32")]
    pub diagnosis: prost::alloc::vec::Vec<explanation_of_benefit::Diagnosis>,
    #[prost(message, repeated, tag = "33")]
    pub procedure: prost::alloc::vec::Vec<explanation_of_benefit::Procedure>,
    /// Precedence (primary, secondary, etc.)
    #[prost(message, optional, tag = "34")]
    pub precedence: ::core::option::Option<PositiveInt>,
    #[prost(message, optional, tag = "35")]
    pub insurance: ::core::option::Option<explanation_of_benefit::Insurance>,
    #[prost(message, optional, tag = "36")]
    pub accident: ::core::option::Option<explanation_of_benefit::Accident>,
    /// Period unable to work
    #[prost(message, optional, tag = "37")]
    pub employment_impacted: ::core::option::Option<Period>,
    /// Period in hospital
    #[prost(message, optional, tag = "38")]
    pub hospitalization: ::core::option::Option<Period>,
    #[prost(message, repeated, tag = "39")]
    pub item: prost::alloc::vec::Vec<explanation_of_benefit::Item>,
    #[prost(message, repeated, tag = "40")]
    pub add_item: prost::alloc::vec::Vec<explanation_of_benefit::AddedItem>,
    /// Total Cost of service from the Claim
    #[prost(message, optional, tag = "41")]
    pub total_cost: ::core::option::Option<Money>,
    /// Unallocated deductable
    #[prost(message, optional, tag = "42")]
    pub unalloc_deductable: ::core::option::Option<Money>,
    /// Total benefit payable for the Claim
    #[prost(message, optional, tag = "43")]
    pub total_benefit: ::core::option::Option<Money>,
    #[prost(message, optional, tag = "44")]
    pub payment: ::core::option::Option<explanation_of_benefit::Payment>,
    /// Printed Form Identifier
    #[prost(message, optional, tag = "45")]
    pub form: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "46")]
    pub process_note: prost::alloc::vec::Vec<explanation_of_benefit::Note>,
    #[prost(message, repeated, tag = "47")]
    pub benefit_balance: prost::alloc::vec::Vec<explanation_of_benefit::BenefitBalance>,
}
/// Nested message and enum types in `ExplanationOfBenefit`.
pub mod explanation_of_benefit {
    /// Related Claims which may be revelant to processing this claim
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct RelatedClaim {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to the related claim
        #[prost(message, optional, tag = "4")]
        pub claim: ::core::option::Option<super::Reference>,
        /// How the reference claim is related
        #[prost(message, optional, tag = "5")]
        pub relationship: ::core::option::Option<super::CodeableConcept>,
        /// Related file or case reference
        #[prost(message, optional, tag = "6")]
        pub reference: ::core::option::Option<super::Identifier>,
    }
    /// Party to be paid any benefits payable
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payee {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of party: Subscriber, Provider, other
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// organization | patient | practitioner | relatedperson
        #[prost(message, optional, tag = "5")]
        pub resource_type: ::core::option::Option<super::CodeableConcept>,
        /// Party to receive the payable
        #[prost(message, optional, tag = "6")]
        pub party: ::core::option::Option<super::Reference>,
    }
    /// Exceptions, special considerations, the condition, situation, prior or
    /// concurrent issues
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SupportingInformation {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Information instance identifier
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// General class of information
        #[prost(message, optional, tag = "5")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Type of information
        #[prost(message, optional, tag = "6")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "7")]
        pub timing: ::core::option::Option<supporting_information::TimingType>,
        #[prost(message, optional, tag = "8")]
        pub value: ::core::option::Option<supporting_information::Value>,
        /// Reason associated with the information
        #[prost(message, optional, tag = "9")]
        pub reason: ::core::option::Option<super::Coding>,
    }
    /// Nested message and enum types in `SupportingInformation`.
    pub mod supporting_information {
        /// When it occurred
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimingType {
            #[prost(oneof = "timing_type::Timing", tags = "1, 2")]
            pub timing: ::core::option::Option<timing_type::Timing>,
        }
        /// Nested message and enum types in `TimingType`.
        pub mod timing_type {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Timing {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Additional Data or supporting information
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Value {
            #[prost(oneof = "value::Value", tags = "1, 2, 3, 4")]
            pub value: ::core::option::Option<value::Value>,
        }
        /// Nested message and enum types in `Value`.
        pub mod value {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Value {
                #[prost(message, tag = "1")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "2")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "3")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "4")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Care Team members
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct CareTeam {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Number to covey order of careteam
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Member of the Care Team
        #[prost(message, optional, tag = "5")]
        pub provider: ::core::option::Option<super::Reference>,
        /// Billing practitioner
        #[prost(message, optional, tag = "6")]
        pub responsible: ::core::option::Option<super::Boolean>,
        /// Role on the team
        #[prost(message, optional, tag = "7")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Type, classification or Specialization
        #[prost(message, optional, tag = "8")]
        pub qualification: ::core::option::Option<super::CodeableConcept>,
    }
    /// List of Diagnosis
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Diagnosis {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Number to covey order of diagnosis
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        #[prost(message, optional, tag = "5")]
        pub diagnosis: ::core::option::Option<diagnosis::DiagnosisType>,
        /// Timing or nature of the diagnosis
        #[prost(message, repeated, tag = "6")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Package billing code
        #[prost(message, optional, tag = "7")]
        pub package_code: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Diagnosis`.
    pub mod diagnosis {
        /// Patient's diagnosis
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DiagnosisType {
            #[prost(oneof = "diagnosis_type::Diagnosis", tags = "1, 2")]
            pub diagnosis: ::core::option::Option<diagnosis_type::Diagnosis>,
        }
        /// Nested message and enum types in `DiagnosisType`.
        pub mod diagnosis_type {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Diagnosis {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Procedures performed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Procedure {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Procedure sequence for reference
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// When the procedure was performed
        #[prost(message, optional, tag = "5")]
        pub date: ::core::option::Option<super::DateTime>,
        #[prost(message, optional, tag = "6")]
        pub procedure: ::core::option::Option<procedure::ProcedureType>,
    }
    /// Nested message and enum types in `Procedure`.
    pub mod procedure {
        /// Patient's list of procedures performed
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ProcedureType {
            #[prost(oneof = "procedure_type::Procedure", tags = "1, 2")]
            pub procedure: ::core::option::Option<procedure_type::Procedure>,
        }
        /// Nested message and enum types in `ProcedureType`.
        pub mod procedure_type {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Procedure {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Insurance or medical plan
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Insurance {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Insurance information
        #[prost(message, optional, tag = "4")]
        pub coverage: ::core::option::Option<super::Reference>,
        /// Pre-Authorization/Determination Reference
        #[prost(message, repeated, tag = "5")]
        pub pre_auth_ref: prost::alloc::vec::Vec<super::String>,
    }
    /// Details of an accident
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Accident {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// When the accident occurred
        #[prost(message, optional, tag = "4")]
        pub date: ::core::option::Option<super::Date>,
        /// The nature of the accident
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "6")]
        pub location: ::core::option::Option<accident::Location>,
    }
    /// Nested message and enum types in `Accident`.
    pub mod accident {
        /// Accident Place
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Location {
            #[prost(oneof = "location::Location", tags = "1, 2")]
            pub location: ::core::option::Option<location::Location>,
        }
        /// Nested message and enum types in `Location`.
        pub mod location {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Location {
                #[prost(message, tag = "1")]
                Address(super::super::super::Address),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Goods and Services
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Service instance
        #[prost(message, optional, tag = "4")]
        pub sequence: ::core::option::Option<super::PositiveInt>,
        /// Applicable careteam members
        #[prost(message, repeated, tag = "5")]
        pub care_team_link_id: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable diagnoses
        #[prost(message, repeated, tag = "6")]
        pub diagnosis_link_id: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable procedures
        #[prost(message, repeated, tag = "7")]
        pub procedure_link_id: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Applicable exception and supporting information
        #[prost(message, repeated, tag = "8")]
        pub information_link_id: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Revenue or cost center code
        #[prost(message, optional, tag = "9")]
        pub revenue: ::core::option::Option<super::CodeableConcept>,
        /// Type of service or product
        #[prost(message, optional, tag = "10")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Billing Code
        #[prost(message, optional, tag = "11")]
        pub service: ::core::option::Option<super::CodeableConcept>,
        /// Service/Product billing modifiers
        #[prost(message, repeated, tag = "12")]
        pub modifier: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Program specific reason for item inclusion
        #[prost(message, repeated, tag = "13")]
        pub program_code: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, optional, tag = "14")]
        pub serviced: ::core::option::Option<item::Serviced>,
        #[prost(message, optional, tag = "15")]
        pub location: ::core::option::Option<item::Location>,
        /// Count of Products or Services
        #[prost(message, optional, tag = "16")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Fee, charge or cost per point
        #[prost(message, optional, tag = "17")]
        pub unit_price: ::core::option::Option<super::Money>,
        /// Price scaling factor
        #[prost(message, optional, tag = "18")]
        pub factor: ::core::option::Option<super::Decimal>,
        /// Total item cost
        #[prost(message, optional, tag = "19")]
        pub net: ::core::option::Option<super::Money>,
        /// Unique Device Identifier
        #[prost(message, repeated, tag = "20")]
        pub udi: prost::alloc::vec::Vec<super::Reference>,
        /// Service Location
        #[prost(message, optional, tag = "21")]
        pub body_site: ::core::option::Option<super::CodeableConcept>,
        /// Service Sub-location
        #[prost(message, repeated, tag = "22")]
        pub sub_site: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Encounters related to this billed item
        #[prost(message, repeated, tag = "23")]
        pub encounter: prost::alloc::vec::Vec<super::Reference>,
        /// List of note numbers which apply
        #[prost(message, repeated, tag = "24")]
        pub note_number: prost::alloc::vec::Vec<super::PositiveInt>,
        #[prost(message, repeated, tag = "25")]
        pub adjudication: prost::alloc::vec::Vec<item::Adjudication>,
        #[prost(message, repeated, tag = "26")]
        pub detail: prost::alloc::vec::Vec<item::Detail>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// Date or dates of Service
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Serviced {
            #[prost(oneof = "serviced::Serviced", tags = "1, 2")]
            pub serviced: ::core::option::Option<serviced::Serviced>,
        }
        /// Nested message and enum types in `Serviced`.
        pub mod serviced {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Serviced {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
        /// Place of service
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Location {
            #[prost(oneof = "location::Location", tags = "1, 2, 3")]
            pub location: ::core::option::Option<location::Location>,
        }
        /// Nested message and enum types in `Location`.
        pub mod location {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Location {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Address(super::super::super::Address),
                #[prost(message, tag = "3")]
                Reference(super::super::super::Reference),
            }
        }
        /// Adjudication details
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Adjudication {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Adjudication category such as co-pay, eligible, benefit, etc.
            #[prost(message, optional, tag = "4")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Explanation of Adjudication outcome
            #[prost(message, optional, tag = "5")]
            pub reason: ::core::option::Option<super::super::CodeableConcept>,
            /// Monetary amount
            #[prost(message, optional, tag = "6")]
            pub amount: ::core::option::Option<super::super::Money>,
            /// Non-monitory value
            #[prost(message, optional, tag = "7")]
            pub value: ::core::option::Option<super::super::Decimal>,
        }
        /// Additional items
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Detail {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Service instance
            #[prost(message, optional, tag = "4")]
            pub sequence: ::core::option::Option<super::super::PositiveInt>,
            /// Group or type of product or service
            #[prost(message, optional, tag = "5")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            /// Revenue or cost center code
            #[prost(message, optional, tag = "6")]
            pub revenue: ::core::option::Option<super::super::CodeableConcept>,
            /// Type of service or product
            #[prost(message, optional, tag = "7")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Billing Code
            #[prost(message, optional, tag = "8")]
            pub service: ::core::option::Option<super::super::CodeableConcept>,
            /// Service/Product billing modifiers
            #[prost(message, repeated, tag = "9")]
            pub modifier: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Program specific reason for item inclusion
            #[prost(message, repeated, tag = "10")]
            pub program_code: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Count of Products or Services
            #[prost(message, optional, tag = "11")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            /// Fee, charge or cost per point
            #[prost(message, optional, tag = "12")]
            pub unit_price: ::core::option::Option<super::super::Money>,
            /// Price scaling factor
            #[prost(message, optional, tag = "13")]
            pub factor: ::core::option::Option<super::super::Decimal>,
            /// Total additional item cost
            #[prost(message, optional, tag = "14")]
            pub net: ::core::option::Option<super::super::Money>,
            /// Unique Device Identifier
            #[prost(message, repeated, tag = "15")]
            pub udi: prost::alloc::vec::Vec<super::super::Reference>,
            /// List of note numbers which apply
            #[prost(message, repeated, tag = "16")]
            pub note_number: prost::alloc::vec::Vec<super::super::PositiveInt>,
            /// Detail level adjudication details
            #[prost(message, repeated, tag = "17")]
            pub adjudication: prost::alloc::vec::Vec<Adjudication>,
            #[prost(message, repeated, tag = "18")]
            pub sub_detail: prost::alloc::vec::Vec<detail::SubDetail>,
        }
        /// Nested message and enum types in `Detail`.
        pub mod detail {
            /// Additional items
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct SubDetail {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Service instance
                #[prost(message, optional, tag = "4")]
                pub sequence: ::core::option::Option<super::super::super::PositiveInt>,
                /// Type of product or service
                #[prost(message, optional, tag = "5")]
                pub r#type: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Revenue or cost center code
                #[prost(message, optional, tag = "6")]
                pub revenue: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Type of service or product
                #[prost(message, optional, tag = "7")]
                pub category: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Billing Code
                #[prost(message, optional, tag = "8")]
                pub service: ::core::option::Option<super::super::super::CodeableConcept>,
                /// Service/Product billing modifiers
                #[prost(message, repeated, tag = "9")]
                pub modifier: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Program specific reason for item inclusion
                #[prost(message, repeated, tag = "10")]
                pub program_code: prost::alloc::vec::Vec<super::super::super::CodeableConcept>,
                /// Count of Products or Services
                #[prost(message, optional, tag = "11")]
                pub quantity: ::core::option::Option<super::super::super::SimpleQuantity>,
                /// Fee, charge or cost per point
                #[prost(message, optional, tag = "12")]
                pub unit_price: ::core::option::Option<super::super::super::Money>,
                /// Price scaling factor
                #[prost(message, optional, tag = "13")]
                pub factor: ::core::option::Option<super::super::super::Decimal>,
                /// Net additional item cost
                #[prost(message, optional, tag = "14")]
                pub net: ::core::option::Option<super::super::super::Money>,
                /// Unique Device Identifier
                #[prost(message, repeated, tag = "15")]
                pub udi: prost::alloc::vec::Vec<super::super::super::Reference>,
                /// List of note numbers which apply
                #[prost(message, repeated, tag = "16")]
                pub note_number: prost::alloc::vec::Vec<super::super::super::PositiveInt>,
                /// Language if different from the resource
                #[prost(message, repeated, tag = "17")]
                pub adjudication: prost::alloc::vec::Vec<super::Adjudication>,
            }
        }
    }
    /// Insurer added line items
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AddedItem {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Service instances
        #[prost(message, repeated, tag = "4")]
        pub sequence_link_id: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Revenue or cost center code
        #[prost(message, optional, tag = "5")]
        pub revenue: ::core::option::Option<super::CodeableConcept>,
        /// Type of service or product
        #[prost(message, optional, tag = "6")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Billing Code
        #[prost(message, optional, tag = "7")]
        pub service: ::core::option::Option<super::CodeableConcept>,
        /// Service/Product billing modifiers
        #[prost(message, repeated, tag = "8")]
        pub modifier: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Professional fee or Product charge
        #[prost(message, optional, tag = "9")]
        pub fee: ::core::option::Option<super::Money>,
        /// List of note numbers which apply
        #[prost(message, repeated, tag = "10")]
        pub note_number: prost::alloc::vec::Vec<super::PositiveInt>,
        /// Added items adjudication
        #[prost(message, repeated, tag = "11")]
        pub adjudication: prost::alloc::vec::Vec<item::Adjudication>,
        #[prost(message, repeated, tag = "12")]
        pub detail: prost::alloc::vec::Vec<added_item::AddedItemsDetail>,
    }
    /// Nested message and enum types in `AddedItem`.
    pub mod added_item {
        /// Added items details
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct AddedItemsDetail {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Revenue or cost center code
            #[prost(message, optional, tag = "4")]
            pub revenue: ::core::option::Option<super::super::CodeableConcept>,
            /// Type of service or product
            #[prost(message, optional, tag = "5")]
            pub category: ::core::option::Option<super::super::CodeableConcept>,
            /// Billing Code
            #[prost(message, optional, tag = "6")]
            pub service: ::core::option::Option<super::super::CodeableConcept>,
            /// Service/Product billing modifiers
            #[prost(message, repeated, tag = "7")]
            pub modifier: prost::alloc::vec::Vec<super::super::CodeableConcept>,
            /// Professional fee or Product charge
            #[prost(message, optional, tag = "8")]
            pub fee: ::core::option::Option<super::super::Money>,
            /// List of note numbers which apply
            #[prost(message, repeated, tag = "9")]
            pub note_number: prost::alloc::vec::Vec<super::super::PositiveInt>,
            /// Added items detail adjudication
            #[prost(message, repeated, tag = "10")]
            pub adjudication: prost::alloc::vec::Vec<super::item::Adjudication>,
        }
    }
    /// Payment (if paid)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Payment {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Partial or Complete
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Payment adjustment for non-Claim issues
        #[prost(message, optional, tag = "5")]
        pub adjustment: ::core::option::Option<super::Money>,
        /// Explanation for the non-claim adjustment
        #[prost(message, optional, tag = "6")]
        pub adjustment_reason: ::core::option::Option<super::CodeableConcept>,
        /// Expected date of Payment
        #[prost(message, optional, tag = "7")]
        pub date: ::core::option::Option<super::Date>,
        /// Payable amount after adjustment
        #[prost(message, optional, tag = "8")]
        pub amount: ::core::option::Option<super::Money>,
        /// Identifier of the payment instrument
        #[prost(message, optional, tag = "9")]
        pub identifier: ::core::option::Option<super::Identifier>,
    }
    /// Processing notes
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Note {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Sequence number for this note
        #[prost(message, optional, tag = "4")]
        pub number: ::core::option::Option<super::PositiveInt>,
        /// display | print | printoper
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Note explanitory text
        #[prost(message, optional, tag = "6")]
        pub text: ::core::option::Option<super::String>,
        /// Language if different from the resource
        #[prost(message, optional, tag = "7")]
        pub language: ::core::option::Option<super::CodeableConcept>,
    }
    /// Balance by Benefit Category
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct BenefitBalance {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of services covered
        #[prost(message, optional, tag = "4")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Detailed services covered within the type
        #[prost(message, optional, tag = "5")]
        pub sub_category: ::core::option::Option<super::CodeableConcept>,
        /// Excluded from the plan
        #[prost(message, optional, tag = "6")]
        pub excluded: ::core::option::Option<super::Boolean>,
        /// Short name for the benefit
        #[prost(message, optional, tag = "7")]
        pub name: ::core::option::Option<super::String>,
        /// Description of the benefit or services covered
        #[prost(message, optional, tag = "8")]
        pub description: ::core::option::Option<super::String>,
        /// In or out of network
        #[prost(message, optional, tag = "9")]
        pub network: ::core::option::Option<super::CodeableConcept>,
        /// Individual or family
        #[prost(message, optional, tag = "10")]
        pub unit: ::core::option::Option<super::CodeableConcept>,
        /// Annual or lifetime
        #[prost(message, optional, tag = "11")]
        pub term: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "12")]
        pub financial: prost::alloc::vec::Vec<benefit_balance::Benefit>,
    }
    /// Nested message and enum types in `BenefitBalance`.
    pub mod benefit_balance {
        /// Benefit Summary
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Benefit {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Deductable, visits, benefit amount
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::CodeableConcept>,
            #[prost(message, optional, tag = "5")]
            pub allowed: ::core::option::Option<benefit::Allowed>,
            #[prost(message, optional, tag = "6")]
            pub used: ::core::option::Option<benefit::Used>,
        }
        /// Nested message and enum types in `Benefit`.
        pub mod benefit {
            /// Benefits allowed
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Allowed {
                #[prost(oneof = "allowed::Allowed", tags = "1, 2, 3")]
                pub allowed: ::core::option::Option<allowed::Allowed>,
            }
            /// Nested message and enum types in `Allowed`.
            pub mod allowed {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Allowed {
                    #[prost(message, tag = "1")]
                    UnsignedInt(super::super::super::super::UnsignedInt),
                    #[prost(message, tag = "2")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "3")]
                    Money(super::super::super::super::Money),
                }
            }
            /// Benefits used
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Used {
                #[prost(oneof = "used::Used", tags = "1, 2")]
                pub used: ::core::option::Option<used::Used>,
            }
            /// Nested message and enum types in `Used`.
            pub mod used {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Used {
                    #[prost(message, tag = "1")]
                    UnsignedInt(super::super::super::super::UnsignedInt),
                    #[prost(message, tag = "2")]
                    Money(super::super::super::super::Money),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for FamilyMemberHistory, last updated
/// 2017-04-19T07:44:43.294+10:00. Information about patient's relatives,
/// relevant for patient. See
/// <http://hl7.org/fhir/StructureDefinition/FamilyMemberHistory>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct FamilyMemberHistory {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Id(s) for this record
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates protocol or definition
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Reference>,
    /// partial | completed | entered-in-error | health-unknown
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<FamilyHistoryStatusCode>,
    /// The taking of a family member's history did not occur
    #[prost(message, optional, tag = "12")]
    pub not_done: ::core::option::Option<Boolean>,
    /// subject-unknown | withheld | unable-to-obtain | deferred
    #[prost(message, optional, tag = "13")]
    pub not_done_reason: ::core::option::Option<CodeableConcept>,
    /// Patient history is about
    #[prost(message, optional, tag = "14")]
    pub patient: ::core::option::Option<Reference>,
    /// When history was captured/updated
    #[prost(message, optional, tag = "15")]
    pub date: ::core::option::Option<DateTime>,
    /// The family member described
    #[prost(message, optional, tag = "16")]
    pub name: ::core::option::Option<String>,
    /// Relationship to the subject
    #[prost(message, optional, tag = "17")]
    pub relationship: ::core::option::Option<CodeableConcept>,
    /// male | female | other | unknown
    #[prost(message, optional, tag = "18")]
    pub gender: ::core::option::Option<AdministrativeGenderCode>,
    #[prost(message, optional, tag = "19")]
    pub born: ::core::option::Option<family_member_history::Born>,
    #[prost(message, optional, tag = "20")]
    pub age: ::core::option::Option<family_member_history::AgeType>,
    /// Age is estimated?
    #[prost(message, optional, tag = "21")]
    pub estimated_age: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "22")]
    pub deceased: ::core::option::Option<family_member_history::Deceased>,
    /// Why was family member history performed?
    #[prost(message, repeated, tag = "23")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why was family member history performed?
    #[prost(message, repeated, tag = "24")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// General note about related person
    #[prost(message, repeated, tag = "25")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "26")]
    pub condition: prost::alloc::vec::Vec<family_member_history::Condition>,
}
/// Nested message and enum types in `FamilyMemberHistory`.
pub mod family_member_history {
    /// (approximate) date of birth
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Born {
        #[prost(oneof = "born::Born", tags = "1, 2, 3")]
        pub born: ::core::option::Option<born::Born>,
    }
    /// Nested message and enum types in `Born`.
    pub mod born {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Born {
            #[prost(message, tag = "1")]
            Period(super::super::Period),
            #[prost(message, tag = "2")]
            Date(super::super::Date),
            #[prost(message, tag = "3")]
            StringValue(super::super::String),
        }
    }
    /// (approximate) age
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AgeType {
        #[prost(oneof = "age_type::Age", tags = "1, 2, 3")]
        pub age: ::core::option::Option<age_type::Age>,
    }
    /// Nested message and enum types in `AgeType`.
    pub mod age_type {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Age {
            #[prost(message, tag = "1")]
            AgeValue(super::super::Age),
            #[prost(message, tag = "2")]
            Range(super::super::Range),
            #[prost(message, tag = "3")]
            StringValue(super::super::String),
        }
    }
    /// Dead? How old/when?
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Deceased {
        #[prost(oneof = "deceased::Deceased", tags = "1, 2, 3, 4, 5")]
        pub deceased: ::core::option::Option<deceased::Deceased>,
    }
    /// Nested message and enum types in `Deceased`.
    pub mod deceased {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Deceased {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            Age(super::super::Age),
            #[prost(message, tag = "3")]
            Range(super::super::Range),
            #[prost(message, tag = "4")]
            Date(super::super::Date),
            #[prost(message, tag = "5")]
            StringValue(super::super::String),
        }
    }
    /// Condition that the related person had
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Condition {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Condition suffered by relation
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// deceased | permanent disability | etc.
        #[prost(message, optional, tag = "5")]
        pub outcome: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "6")]
        pub onset: ::core::option::Option<condition::Onset>,
        /// Extra information about condition
        #[prost(message, repeated, tag = "7")]
        pub note: prost::alloc::vec::Vec<super::Annotation>,
    }
    /// Nested message and enum types in `Condition`.
    pub mod condition {
        /// When condition first manifested
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Onset {
            #[prost(oneof = "onset::Onset", tags = "1, 2, 3, 4")]
            pub onset: ::core::option::Option<onset::Onset>,
        }
        /// Nested message and enum types in `Onset`.
        pub mod onset {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Onset {
                #[prost(message, tag = "1")]
                Age(super::super::super::Age),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
                #[prost(message, tag = "3")]
                Period(super::super::super::Period),
                #[prost(message, tag = "4")]
                StringValue(super::super::super::String),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Flag, last updated
/// 2017-04-19T07:44:43.294+10:00. Key information to flag to healthcare
/// providers. See <http://hl7.org/fhir/StructureDefinition/Flag>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Flag {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | inactive | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FlagStatusCode>,
    /// Clinical, administrative, etc.
    #[prost(message, optional, tag = "11")]
    pub category: ::core::option::Option<CodeableConcept>,
    /// Coded or textual message to display to user
    #[prost(message, optional, tag = "12")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who/What is flag about?
    #[prost(message, optional, tag = "13")]
    pub subject: ::core::option::Option<Reference>,
    /// Time period when flag is active
    #[prost(message, optional, tag = "14")]
    pub period: ::core::option::Option<Period>,
    /// Alert relevant during encounter
    #[prost(message, optional, tag = "15")]
    pub encounter: ::core::option::Option<Reference>,
    /// Flag creator
    #[prost(message, optional, tag = "16")]
    pub author: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Goal, last updated
/// 2017-04-19T07:44:43.294+10:00. Describes the intended objective(s) for a
/// patient, group or organization. See
/// <http://hl7.org/fhir/StructureDefinition/Goal>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Goal {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this goal
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// proposed | accepted | planned | in-progress | on-target | ahead-of-target |
    /// behind-target | sustaining | achieved | on-hold | cancelled |
    /// entered-in-error | rejected
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<GoalStatusCode>,
    /// E.g. Treatment, dietary, behavioral, etc.
    #[prost(message, repeated, tag = "11")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// high-priority | medium-priority | low-priority
    #[prost(message, optional, tag = "12")]
    pub priority: ::core::option::Option<CodeableConcept>,
    /// Code or text describing goal
    #[prost(message, optional, tag = "13")]
    pub description: ::core::option::Option<CodeableConcept>,
    /// Who this goal is intended for
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "15")]
    pub start: ::core::option::Option<goal::Start>,
    #[prost(message, optional, tag = "16")]
    pub target: ::core::option::Option<goal::Target>,
    /// When goal status took effect
    #[prost(message, optional, tag = "17")]
    pub status_date: ::core::option::Option<Date>,
    /// Reason for current status
    #[prost(message, optional, tag = "18")]
    pub status_reason: ::core::option::Option<String>,
    /// Who's responsible for creating Goal?
    #[prost(message, optional, tag = "19")]
    pub expressed_by: ::core::option::Option<Reference>,
    /// Issues addressed by this goal
    #[prost(message, repeated, tag = "20")]
    pub addresses: prost::alloc::vec::Vec<Reference>,
    /// Comments about the goal
    #[prost(message, repeated, tag = "21")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// What result was achieved regarding the goal?
    #[prost(message, repeated, tag = "22")]
    pub outcome_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Observation that resulted from goal
    #[prost(message, repeated, tag = "23")]
    pub outcome_reference: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `Goal`.
pub mod goal {
    /// When goal pursuit begins
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Start {
        #[prost(oneof = "start::Start", tags = "1, 2")]
        pub start: ::core::option::Option<start::Start>,
    }
    /// Nested message and enum types in `Start`.
    pub mod start {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Start {
            #[prost(message, tag = "1")]
            Date(super::super::Date),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// Target outcome for the goal
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Target {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The parameter whose value is being tracked
        #[prost(message, optional, tag = "4")]
        pub measure: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub detail: ::core::option::Option<target::Detail>,
        #[prost(message, optional, tag = "6")]
        pub due: ::core::option::Option<target::Due>,
    }
    /// Nested message and enum types in `Target`.
    pub mod target {
        /// The target value to be achieved
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Detail {
            #[prost(oneof = "detail::Detail", tags = "1, 2, 3")]
            pub detail: ::core::option::Option<detail::Detail>,
        }
        /// Nested message and enum types in `Detail`.
        pub mod detail {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Detail {
                #[prost(message, tag = "1")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
                #[prost(message, tag = "3")]
                CodeableConcept(super::super::super::CodeableConcept),
            }
        }
        /// Reach goal on or before
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Due {
            #[prost(oneof = "due::Due", tags = "1, 2")]
            pub due: ::core::option::Option<due::Due>,
        }
        /// Nested message and enum types in `Due`.
        pub mod due {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Due {
                #[prost(message, tag = "1")]
                Date(super::super::super::Date),
                #[prost(message, tag = "2")]
                Duration(super::super::super::Duration),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for GraphDefinition, last updated
/// 2017-04-19T07:44:43.294+10:00. Definition of an graph of resources. See
/// <http://hl7.org/fhir/StructureDefinition/GraphDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GraphDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this graph definition (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the graph definition
    #[prost(message, optional, tag = "10")]
    pub version: ::core::option::Option<String>,
    /// Name for this graph definition (computer friendly)
    #[prost(message, optional, tag = "11")]
    pub name: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "13")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "14")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "15")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "16")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the graph definition
    #[prost(message, optional, tag = "17")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "18")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for graph definition (if applicable)
    #[prost(message, repeated, tag = "19")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this graph definition is defined
    #[prost(message, optional, tag = "20")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Type of resource at which the graph starts
    #[prost(message, optional, tag = "21")]
    pub start: ::core::option::Option<ResourceTypeCode>,
    /// Profile on base resource
    #[prost(message, optional, tag = "22")]
    pub profile: ::core::option::Option<Uri>,
    #[prost(message, repeated, tag = "23")]
    pub link: prost::alloc::vec::Vec<graph_definition::Link>,
}
/// Nested message and enum types in `GraphDefinition`.
pub mod graph_definition {
    /// Links this graph makes rules about
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Link {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Path in the resource that contains the link
        #[prost(message, optional, tag = "4")]
        pub path: ::core::option::Option<super::String>,
        /// Which slice (if profiled)
        #[prost(message, optional, tag = "5")]
        pub slice_name: ::core::option::Option<super::String>,
        /// Minimum occurrences for this link
        #[prost(message, optional, tag = "6")]
        pub min: ::core::option::Option<super::Integer>,
        /// Maximum occurrences for this link
        #[prost(message, optional, tag = "7")]
        pub max: ::core::option::Option<super::String>,
        /// Why this link is specified
        #[prost(message, optional, tag = "8")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "9")]
        pub target: prost::alloc::vec::Vec<link::Target>,
    }
    /// Nested message and enum types in `Link`.
    pub mod link {
        /// Potential target for the link
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Target {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of resource this link refers to
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::ResourceTypeCode>,
            /// Profile for the target resource
            #[prost(message, optional, tag = "5")]
            pub profile: ::core::option::Option<super::super::Uri>,
            #[prost(message, repeated, tag = "6")]
            pub compartment: prost::alloc::vec::Vec<target::Compartment>,
            /// Additional links from target resource
            #[prost(message, repeated, tag = "7")]
            pub link: prost::alloc::vec::Vec<super::Link>,
        }
        /// Nested message and enum types in `Target`.
        pub mod target {
            /// Compartment Consistency Rules
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Compartment {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Identifies the compartment
                #[prost(message, optional, tag = "4")]
                pub code: ::core::option::Option<super::super::super::CompartmentTypeCode>,
                /// identical | matching | different | custom
                #[prost(message, optional, tag = "5")]
                pub rule: ::core::option::Option<super::super::super::GraphCompartmentRuleCode>,
                /// Custom rule, as a FHIRPath expression
                #[prost(message, optional, tag = "6")]
                pub expression: ::core::option::Option<super::super::super::String>,
                /// Documentation for FHIRPath expression
                #[prost(message, optional, tag = "7")]
                pub description: ::core::option::Option<super::super::super::String>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Group, last updated
/// 2017-04-19T07:44:43.294+10:00. Group of multiple entities. See
/// <http://hl7.org/fhir/StructureDefinition/Group>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Group {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique id
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this group's record is in active use
    #[prost(message, optional, tag = "10")]
    pub active: ::core::option::Option<Boolean>,
    /// person | animal | practitioner | device | medication | substance
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<GroupTypeCode>,
    /// Descriptive or actual
    #[prost(message, optional, tag = "12")]
    pub actual: ::core::option::Option<Boolean>,
    /// Kind of Group members
    #[prost(message, optional, tag = "13")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Label for Group
    #[prost(message, optional, tag = "14")]
    pub name: ::core::option::Option<String>,
    /// Number of members
    #[prost(message, optional, tag = "15")]
    pub quantity: ::core::option::Option<UnsignedInt>,
    #[prost(message, repeated, tag = "16")]
    pub characteristic: prost::alloc::vec::Vec<group::Characteristic>,
    #[prost(message, repeated, tag = "17")]
    pub member: prost::alloc::vec::Vec<group::Member>,
}
/// Nested message and enum types in `Group`.
pub mod group {
    /// Trait of group members
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Characteristic {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Kind of characteristic
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<characteristic::Value>,
        /// Group includes or excludes
        #[prost(message, optional, tag = "6")]
        pub exclude: ::core::option::Option<super::Boolean>,
        /// Period over which characteristic is tested
        #[prost(message, optional, tag = "7")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// Nested message and enum types in `Characteristic`.
    pub mod characteristic {
        /// Value held by characteristic
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Value {
            #[prost(oneof = "value::Value", tags = "1, 2, 3, 4")]
            pub value: ::core::option::Option<value::Value>,
        }
        /// Nested message and enum types in `Value`.
        pub mod value {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Value {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "3")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "4")]
                Range(super::super::super::Range),
            }
        }
    }
    /// Who or what is in group
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Member {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to the group member
        #[prost(message, optional, tag = "4")]
        pub entity: ::core::option::Option<super::Reference>,
        /// Period member belonged to the group
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
        /// If member is no longer in group
        #[prost(message, optional, tag = "6")]
        pub inactive: ::core::option::Option<super::Boolean>,
    }
}
/// Auto-generated from StructureDefinition for GuidanceResponse, last updated
/// 2017-04-19T07:44:43.294+10:00. The formal response to a guidance request. See
/// <http://hl7.org/fhir/StructureDefinition/GuidanceResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct GuidanceResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// The id of the request associated with this response, if any
    #[prost(message, optional, tag = "9")]
    pub request_id: ::core::option::Option<Id>,
    /// Business identifier
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// A reference to a knowledge module
    #[prost(message, optional, tag = "11")]
    pub module: ::core::option::Option<Reference>,
    /// success | data-requested | data-required | in-progress | failure |
    /// entered-in-error
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<GuidanceResponseStatusCode>,
    /// Patient the request was performed for
    #[prost(message, optional, tag = "13")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or Episode during which the response was returned
    #[prost(message, optional, tag = "14")]
    pub context: ::core::option::Option<Reference>,
    /// When the guidance response was processed
    #[prost(message, optional, tag = "15")]
    pub occurrence_date_time: ::core::option::Option<DateTime>,
    /// Device returning the guidance
    #[prost(message, optional, tag = "16")]
    pub performer: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "17")]
    pub reason: ::core::option::Option<guidance_response::Reason>,
    /// Additional notes about the response
    #[prost(message, repeated, tag = "18")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Messages resulting from the evaluation of the artifact or artifacts
    #[prost(message, repeated, tag = "19")]
    pub evaluation_message: prost::alloc::vec::Vec<Reference>,
    /// The output parameters of the evaluation, if any
    #[prost(message, optional, tag = "20")]
    pub output_parameters: ::core::option::Option<Reference>,
    /// Proposed actions, if any
    #[prost(message, optional, tag = "21")]
    pub result: ::core::option::Option<Reference>,
    /// Additional required data
    #[prost(message, repeated, tag = "22")]
    pub data_requirement: prost::alloc::vec::Vec<DataRequirement>,
}
/// Nested message and enum types in `GuidanceResponse`.
pub mod guidance_response {
    /// Reason for the response
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Reason {
        #[prost(oneof = "reason::Reason", tags = "1, 2")]
        pub reason: ::core::option::Option<reason::Reason>,
    }
    /// Nested message and enum types in `Reason`.
    pub mod reason {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for HealthcareService, last updated
/// 2017-04-19T07:44:43.294+10:00. The details of a healthcare service available
/// at a location. See <http://hl7.org/fhir/StructureDefinition/HealthcareService>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct HealthcareService {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifiers for this item
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this healthcareservice is in active use
    #[prost(message, optional, tag = "10")]
    pub active: ::core::option::Option<Boolean>,
    /// Organization that provides this service
    #[prost(message, optional, tag = "11")]
    pub provided_by: ::core::option::Option<Reference>,
    /// Broad category of service being performed or delivered
    #[prost(message, optional, tag = "12")]
    pub category: ::core::option::Option<CodeableConcept>,
    /// Type of service that may be delivered or performed
    #[prost(message, repeated, tag = "13")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Specialties handled by the HealthcareService
    #[prost(message, repeated, tag = "14")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// Location(s) where service may be provided
    #[prost(message, repeated, tag = "15")]
    pub location: prost::alloc::vec::Vec<Reference>,
    /// Description of service as presented to a consumer while searching
    #[prost(message, optional, tag = "16")]
    pub name: ::core::option::Option<String>,
    /// Additional description and/or any specific issues not covered elsewhere
    #[prost(message, optional, tag = "17")]
    pub comment: ::core::option::Option<String>,
    /// Extra details about the service that can't be placed in the other fields
    #[prost(message, optional, tag = "18")]
    pub extra_details: ::core::option::Option<String>,
    /// Facilitates quick identification of the service
    #[prost(message, optional, tag = "19")]
    pub photo: ::core::option::Option<Attachment>,
    /// Contacts related to the healthcare service
    #[prost(message, repeated, tag = "20")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// Location(s) service is inteded for/available to
    #[prost(message, repeated, tag = "21")]
    pub coverage_area: prost::alloc::vec::Vec<Reference>,
    /// Conditions under which service is available/offered
    #[prost(message, repeated, tag = "22")]
    pub service_provision_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Specific eligibility requirements required to use the service
    #[prost(message, optional, tag = "23")]
    pub eligibility: ::core::option::Option<CodeableConcept>,
    /// Describes the eligibility conditions for the service
    #[prost(message, optional, tag = "24")]
    pub eligibility_note: ::core::option::Option<String>,
    /// Program Names that categorize the service
    #[prost(message, repeated, tag = "25")]
    pub program_name: prost::alloc::vec::Vec<String>,
    /// Collection of characteristics (attributes)
    #[prost(message, repeated, tag = "26")]
    pub characteristic: prost::alloc::vec::Vec<CodeableConcept>,
    /// Ways that the service accepts referrals
    #[prost(message, repeated, tag = "27")]
    pub referral_method: prost::alloc::vec::Vec<CodeableConcept>,
    /// If an appointment is required for access to this service
    #[prost(message, optional, tag = "28")]
    pub appointment_required: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "29")]
    pub available_time: prost::alloc::vec::Vec<healthcare_service::AvailableTime>,
    #[prost(message, repeated, tag = "30")]
    pub not_available: prost::alloc::vec::Vec<healthcare_service::NotAvailable>,
    /// Description of availability exceptions
    #[prost(message, optional, tag = "31")]
    pub availability_exceptions: ::core::option::Option<String>,
    /// Technical endpoints providing access to services operated for the location
    #[prost(message, repeated, tag = "32")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `HealthcareService`.
pub mod healthcare_service {
    /// Times the Service Site is available
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AvailableTime {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// mon | tue | wed | thu | fri | sat | sun
        #[prost(message, repeated, tag = "4")]
        pub days_of_week: prost::alloc::vec::Vec<super::DaysOfWeekCode>,
        /// Always available? e.g. 24 hour service
        #[prost(message, optional, tag = "5")]
        pub all_day: ::core::option::Option<super::Boolean>,
        /// Opening time of day (ignored if allDay = true)
        #[prost(message, optional, tag = "6")]
        pub available_start_time: ::core::option::Option<super::Time>,
        /// Closing time of day (ignored if allDay = true)
        #[prost(message, optional, tag = "7")]
        pub available_end_time: ::core::option::Option<super::Time>,
    }
    /// Not available during this time due to provided reason
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct NotAvailable {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reason presented to the user explaining why time not available
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Service not availablefrom this date
        #[prost(message, optional, tag = "5")]
        pub during: ::core::option::Option<super::Period>,
    }
}
/// Auto-generated from StructureDefinition for ImagingManifest, last updated
/// 2017-04-19T07:44:43.294+10:00. Key Object Selection. See
/// <http://hl7.org/fhir/StructureDefinition/ImagingManifest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImagingManifest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// SOP Instance UID
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Patient of the selected objects
    #[prost(message, optional, tag = "10")]
    pub patient: ::core::option::Option<Reference>,
    /// Time when the selection of instances was made
    #[prost(message, optional, tag = "11")]
    pub authoring_time: ::core::option::Option<DateTime>,
    /// Author (human or machine)
    #[prost(message, optional, tag = "12")]
    pub author: ::core::option::Option<Reference>,
    /// Description text
    #[prost(message, optional, tag = "13")]
    pub description: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "14")]
    pub study: prost::alloc::vec::Vec<imaging_manifest::Study>,
}
/// Nested message and enum types in `ImagingManifest`.
pub mod imaging_manifest {
    /// Study identity of the selected instances
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Study {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Study instance UID
        #[prost(message, optional, tag = "4")]
        pub uid: ::core::option::Option<super::Oid>,
        /// Reference to ImagingStudy
        #[prost(message, optional, tag = "5")]
        pub imaging_study: ::core::option::Option<super::Reference>,
        /// Study access service endpoint
        #[prost(message, repeated, tag = "6")]
        pub endpoint: prost::alloc::vec::Vec<super::Reference>,
        #[prost(message, repeated, tag = "7")]
        pub series: prost::alloc::vec::Vec<study::Series>,
    }
    /// Nested message and enum types in `Study`.
    pub mod study {
        /// Series identity of the selected instances
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Series {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Series instance UID
            #[prost(message, optional, tag = "4")]
            pub uid: ::core::option::Option<super::super::Oid>,
            /// Series access endpoint
            #[prost(message, repeated, tag = "5")]
            pub endpoint: prost::alloc::vec::Vec<super::super::Reference>,
            #[prost(message, repeated, tag = "6")]
            pub instance: prost::alloc::vec::Vec<series::Instance>,
        }
        /// Nested message and enum types in `Series`.
        pub mod series {
            /// The selected instance
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Instance {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// SOP class UID of instance
                #[prost(message, optional, tag = "4")]
                pub sop_class: ::core::option::Option<super::super::super::Oid>,
                /// Selected instance UID
                #[prost(message, optional, tag = "5")]
                pub uid: ::core::option::Option<super::super::super::Oid>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for ImagingStudy, last updated
/// 2017-04-19T07:44:43.294+10:00. A set of images produced in single study (one
/// or more series of references images). See
/// <http://hl7.org/fhir/StructureDefinition/ImagingStudy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImagingStudy {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Formal DICOM identifier for the study
    #[prost(message, optional, tag = "9")]
    pub uid: ::core::option::Option<Oid>,
    /// Related workflow identifier ("Accession Number")
    #[prost(message, optional, tag = "10")]
    pub accession: ::core::option::Option<Identifier>,
    /// Other identifiers for the study
    #[prost(message, repeated, tag = "11")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// ONLINE | OFFLINE | NEARLINE | UNAVAILABLE
    #[prost(message, optional, tag = "12")]
    pub availability: ::core::option::Option<InstanceAvailabilityCode>,
    /// All series modality if actual acquisition modalities
    #[prost(message, repeated, tag = "13")]
    pub modality_list: prost::alloc::vec::Vec<Coding>,
    /// Who the images are of
    #[prost(message, optional, tag = "14")]
    pub patient: ::core::option::Option<Reference>,
    /// Originating context
    #[prost(message, optional, tag = "15")]
    pub context: ::core::option::Option<Reference>,
    /// When the study was started
    #[prost(message, optional, tag = "16")]
    pub started: ::core::option::Option<DateTime>,
    /// Request fulfilled
    #[prost(message, repeated, tag = "17")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Referring physician
    #[prost(message, optional, tag = "18")]
    pub referrer: ::core::option::Option<Reference>,
    /// Who interpreted images
    #[prost(message, repeated, tag = "19")]
    pub interpreter: prost::alloc::vec::Vec<Reference>,
    /// Study access endpoint
    #[prost(message, repeated, tag = "20")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
    /// Number of Study Related Series
    #[prost(message, optional, tag = "21")]
    pub number_of_series: ::core::option::Option<UnsignedInt>,
    /// Number of Study Related Instances
    #[prost(message, optional, tag = "22")]
    pub number_of_instances: ::core::option::Option<UnsignedInt>,
    /// The performed Procedure reference
    #[prost(message, repeated, tag = "23")]
    pub procedure_reference: prost::alloc::vec::Vec<Reference>,
    /// The performed procedure code
    #[prost(message, repeated, tag = "24")]
    pub procedure_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why the study was requested
    #[prost(message, optional, tag = "25")]
    pub reason: ::core::option::Option<CodeableConcept>,
    /// Institution-generated description
    #[prost(message, optional, tag = "26")]
    pub description: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "27")]
    pub series: prost::alloc::vec::Vec<imaging_study::Series>,
}
/// Nested message and enum types in `ImagingStudy`.
pub mod imaging_study {
    /// Each study has one or more series of instances
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Series {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Formal DICOM identifier for this series
        #[prost(message, optional, tag = "4")]
        pub uid: ::core::option::Option<super::Oid>,
        /// Numeric identifier of this series
        #[prost(message, optional, tag = "5")]
        pub number: ::core::option::Option<super::UnsignedInt>,
        /// The modality of the instances in the series
        #[prost(message, optional, tag = "6")]
        pub modality: ::core::option::Option<super::Coding>,
        /// A short human readable summary of the series
        #[prost(message, optional, tag = "7")]
        pub description: ::core::option::Option<super::String>,
        /// Number of Series Related Instances
        #[prost(message, optional, tag = "8")]
        pub number_of_instances: ::core::option::Option<super::UnsignedInt>,
        /// ONLINE | OFFLINE | NEARLINE | UNAVAILABLE
        #[prost(message, optional, tag = "9")]
        pub availability: ::core::option::Option<super::InstanceAvailabilityCode>,
        /// Series access endpoint
        #[prost(message, repeated, tag = "10")]
        pub endpoint: prost::alloc::vec::Vec<super::Reference>,
        /// Body part examined
        #[prost(message, optional, tag = "11")]
        pub body_site: ::core::option::Option<super::Coding>,
        /// Body part laterality
        #[prost(message, optional, tag = "12")]
        pub laterality: ::core::option::Option<super::Coding>,
        /// When the series started
        #[prost(message, optional, tag = "13")]
        pub started: ::core::option::Option<super::DateTime>,
        /// Who performed the series
        #[prost(message, repeated, tag = "14")]
        pub performer: prost::alloc::vec::Vec<super::Reference>,
        #[prost(message, repeated, tag = "15")]
        pub instance: prost::alloc::vec::Vec<series::Instance>,
    }
    /// Nested message and enum types in `Series`.
    pub mod series {
        /// A single SOP instance from the series
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Instance {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Formal DICOM identifier for this instance
            #[prost(message, optional, tag = "4")]
            pub uid: ::core::option::Option<super::super::Oid>,
            /// The number of this instance in the series
            #[prost(message, optional, tag = "5")]
            pub number: ::core::option::Option<super::super::UnsignedInt>,
            /// DICOM class type
            #[prost(message, optional, tag = "6")]
            pub sop_class: ::core::option::Option<super::super::Oid>,
            /// Description of instance
            #[prost(message, optional, tag = "7")]
            pub title: ::core::option::Option<super::super::String>,
        }
    }
}
/// Auto-generated from StructureDefinition for Immunization, last updated
/// 2017-04-19T07:44:43.294+10:00. Immunization event information. See
/// <http://hl7.org/fhir/StructureDefinition/Immunization>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Immunization {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// completed | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<ImmunizationStatusCodesCode>,
    /// Flag for whether immunization was given
    #[prost(message, optional, tag = "11")]
    pub not_given: ::core::option::Option<Boolean>,
    /// Vaccine product administered
    #[prost(message, optional, tag = "12")]
    pub vaccine_code: ::core::option::Option<CodeableConcept>,
    /// Who was immunized
    #[prost(message, optional, tag = "13")]
    pub patient: ::core::option::Option<Reference>,
    /// Encounter administered as part of
    #[prost(message, optional, tag = "14")]
    pub encounter: ::core::option::Option<Reference>,
    /// Vaccination administration date
    #[prost(message, optional, tag = "15")]
    pub date: ::core::option::Option<DateTime>,
    /// Indicates context the data was recorded in
    #[prost(message, optional, tag = "16")]
    pub primary_source: ::core::option::Option<Boolean>,
    /// Indicates the source of a secondarily reported record
    #[prost(message, optional, tag = "17")]
    pub report_origin: ::core::option::Option<CodeableConcept>,
    /// Where vaccination occurred
    #[prost(message, optional, tag = "18")]
    pub location: ::core::option::Option<Reference>,
    /// Vaccine manufacturer
    #[prost(message, optional, tag = "19")]
    pub manufacturer: ::core::option::Option<Reference>,
    /// Vaccine lot number
    #[prost(message, optional, tag = "20")]
    pub lot_number: ::core::option::Option<String>,
    /// Vaccine expiration date
    #[prost(message, optional, tag = "21")]
    pub expiration_date: ::core::option::Option<Date>,
    /// Body site vaccine  was administered
    #[prost(message, optional, tag = "22")]
    pub site: ::core::option::Option<CodeableConcept>,
    /// How vaccine entered body
    #[prost(message, optional, tag = "23")]
    pub route: ::core::option::Option<CodeableConcept>,
    /// Amount of vaccine administered
    #[prost(message, optional, tag = "24")]
    pub dose_quantity: ::core::option::Option<SimpleQuantity>,
    #[prost(message, repeated, tag = "25")]
    pub practitioner: prost::alloc::vec::Vec<immunization::Practitioner>,
    /// Vaccination notes
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, optional, tag = "27")]
    pub explanation: ::core::option::Option<immunization::Explanation>,
    #[prost(message, repeated, tag = "28")]
    pub reaction: prost::alloc::vec::Vec<immunization::Reaction>,
    #[prost(message, repeated, tag = "29")]
    pub vaccination_protocol: prost::alloc::vec::Vec<immunization::VaccinationProtocol>,
}
/// Nested message and enum types in `Immunization`.
pub mod immunization {
    /// Who performed event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Practitioner {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// What type of performance was done
        #[prost(message, optional, tag = "4")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// Individual who was performing
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
    }
    /// Administration/non-administration reasons
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Explanation {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Why immunization occurred
        #[prost(message, repeated, tag = "4")]
        pub reason: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Why immunization did not occur
        #[prost(message, repeated, tag = "5")]
        pub reason_not_given: prost::alloc::vec::Vec<super::CodeableConcept>,
    }
    /// Details of a reaction that follows immunization
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Reaction {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// When reaction started
        #[prost(message, optional, tag = "4")]
        pub date: ::core::option::Option<super::DateTime>,
        /// Additional information on reaction
        #[prost(message, optional, tag = "5")]
        pub detail: ::core::option::Option<super::Reference>,
        /// Indicates self-reported reaction
        #[prost(message, optional, tag = "6")]
        pub reported: ::core::option::Option<super::Boolean>,
    }
    /// What protocol was followed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct VaccinationProtocol {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Dose number within series
        #[prost(message, optional, tag = "4")]
        pub dose_sequence: ::core::option::Option<super::PositiveInt>,
        /// Details of vaccine protocol
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        /// Who is responsible for protocol
        #[prost(message, optional, tag = "6")]
        pub authority: ::core::option::Option<super::Reference>,
        /// Name of vaccine series
        #[prost(message, optional, tag = "7")]
        pub series: ::core::option::Option<super::String>,
        /// Recommended number of doses for immunity
        #[prost(message, optional, tag = "8")]
        pub series_doses: ::core::option::Option<super::PositiveInt>,
        /// Disease immunized against
        #[prost(message, repeated, tag = "9")]
        pub target_disease: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Indicates if dose counts towards immunity
        #[prost(message, optional, tag = "10")]
        pub dose_status: ::core::option::Option<super::CodeableConcept>,
        /// Why dose does (not) count
        #[prost(message, optional, tag = "11")]
        pub dose_status_reason: ::core::option::Option<super::CodeableConcept>,
    }
}
/// Auto-generated from StructureDefinition for ImmunizationRecommendation, last
/// updated 2017-04-19T07:44:43.294+10:00. Guidance or advice relating to an
/// immunization. See
/// <http://hl7.org/fhir/StructureDefinition/ImmunizationRecommendation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImmunizationRecommendation {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Who this profile is for
    #[prost(message, optional, tag = "10")]
    pub patient: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "11")]
    pub recommendation: prost::alloc::vec::Vec<immunization_recommendation::Recommendation>,
}
/// Nested message and enum types in `ImmunizationRecommendation`.
pub mod immunization_recommendation {
    /// Vaccine administration recommendations
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Recommendation {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Date recommendation created
        #[prost(message, optional, tag = "4")]
        pub date: ::core::option::Option<super::DateTime>,
        /// Vaccine recommendation applies to
        #[prost(message, optional, tag = "5")]
        pub vaccine_code: ::core::option::Option<super::CodeableConcept>,
        /// Disease to be immunized against
        #[prost(message, optional, tag = "6")]
        pub target_disease: ::core::option::Option<super::CodeableConcept>,
        /// Recommended dose number
        #[prost(message, optional, tag = "7")]
        pub dose_number: ::core::option::Option<super::PositiveInt>,
        /// Vaccine administration status
        #[prost(message, optional, tag = "8")]
        pub forecast_status: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "9")]
        pub date_criterion: prost::alloc::vec::Vec<recommendation::DateCriterion>,
        #[prost(message, optional, tag = "10")]
        pub protocol: ::core::option::Option<recommendation::Protocol>,
        /// Past immunizations supporting recommendation
        #[prost(message, repeated, tag = "11")]
        pub supporting_immunization: prost::alloc::vec::Vec<super::Reference>,
        /// Patient observations supporting recommendation
        #[prost(message, repeated, tag = "12")]
        pub supporting_patient_information: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Nested message and enum types in `Recommendation`.
    pub mod recommendation {
        /// Dates governing proposed immunization
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DateCriterion {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of date
            #[prost(message, optional, tag = "4")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// Recommended date
            #[prost(message, optional, tag = "5")]
            pub value: ::core::option::Option<super::super::DateTime>,
        }
        /// Protocol used by recommendation
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Protocol {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Dose number within sequence
            #[prost(message, optional, tag = "4")]
            pub dose_sequence: ::core::option::Option<super::super::PositiveInt>,
            /// Protocol details
            #[prost(message, optional, tag = "5")]
            pub description: ::core::option::Option<super::super::String>,
            /// Who is responsible for protocol
            #[prost(message, optional, tag = "6")]
            pub authority: ::core::option::Option<super::super::Reference>,
            /// Name of vaccination series
            #[prost(message, optional, tag = "7")]
            pub series: ::core::option::Option<super::super::String>,
        }
    }
}
/// Auto-generated from StructureDefinition for ImplementationGuide, last updated
/// 2017-04-19T07:44:43.294+10:00. A set of rules about how FHIR is used. See
/// <http://hl7.org/fhir/StructureDefinition/ImplementationGuide>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ImplementationGuide {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this implementation guide (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the implementation guide
    #[prost(message, optional, tag = "10")]
    pub version: ::core::option::Option<String>,
    /// Name for this implementation guide (computer friendly)
    #[prost(message, optional, tag = "11")]
    pub name: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "13")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "14")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "15")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "16")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the implementation guide
    #[prost(message, optional, tag = "17")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "18")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for implementation guide (if applicable)
    #[prost(message, repeated, tag = "19")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "20")]
    pub copyright: ::core::option::Option<Markdown>,
    /// FHIR Version this Implementation Guide targets
    #[prost(message, optional, tag = "21")]
    pub fhir_version: ::core::option::Option<Id>,
    #[prost(message, repeated, tag = "22")]
    pub dependency: prost::alloc::vec::Vec<implementation_guide::Dependency>,
    #[prost(message, repeated, tag = "23")]
    pub package_value: prost::alloc::vec::Vec<implementation_guide::Package>,
    #[prost(message, repeated, tag = "24")]
    pub global: prost::alloc::vec::Vec<implementation_guide::Global>,
    /// Image, css, script, etc.
    #[prost(message, repeated, tag = "25")]
    pub binary: prost::alloc::vec::Vec<Uri>,
    #[prost(message, optional, tag = "26")]
    pub page: ::core::option::Option<implementation_guide::Page>,
}
/// Nested message and enum types in `ImplementationGuide`.
pub mod implementation_guide {
    /// Another Implementation guide this depends on
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Dependency {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// reference | inclusion
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::GuideDependencyTypeCode>,
        /// Where to find dependency
        #[prost(message, optional, tag = "5")]
        pub uri: ::core::option::Option<super::Uri>,
    }
    /// Group of resources as used in .page.package
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Package {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name used .page.package
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Human readable text describing the package
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "6")]
        pub resource: prost::alloc::vec::Vec<package::Resource>,
    }
    /// Nested message and enum types in `Package`.
    pub mod package {
        /// Resource in the implementation guide
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Resource {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// If not an example, has its normal meaning
            #[prost(message, optional, tag = "4")]
            pub example: ::core::option::Option<super::super::Boolean>,
            /// Human Name for the resource
            #[prost(message, optional, tag = "5")]
            pub name: ::core::option::Option<super::super::String>,
            /// Reason why included in guide
            #[prost(message, optional, tag = "6")]
            pub description: ::core::option::Option<super::super::String>,
            /// Short code to identify the resource
            #[prost(message, optional, tag = "7")]
            pub acronym: ::core::option::Option<super::super::String>,
            #[prost(message, optional, tag = "8")]
            pub source: ::core::option::Option<resource::Source>,
            /// Resource this is an example of (if applicable)
            #[prost(message, optional, tag = "9")]
            pub example_for: ::core::option::Option<super::super::Reference>,
        }
        /// Nested message and enum types in `Resource`.
        pub mod resource {
            /// Location of the resource
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Source {
                #[prost(oneof = "source::Source", tags = "1, 2")]
                pub source: ::core::option::Option<source::Source>,
            }
            /// Nested message and enum types in `Source`.
            pub mod source {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Source {
                    #[prost(message, tag = "1")]
                    Uri(super::super::super::super::Uri),
                    #[prost(message, tag = "2")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
    }
    /// Profiles that apply globally
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Global {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type this profiles applies to
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::ResourceTypeCode>,
        /// Profile that all resources must conform to
        #[prost(message, optional, tag = "5")]
        pub profile: ::core::option::Option<super::Reference>,
    }
    /// Page/Section in the Guide
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Page {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Where to find that page
        #[prost(message, optional, tag = "4")]
        pub source: ::core::option::Option<super::Uri>,
        /// Short title shown for navigational assistance
        #[prost(message, optional, tag = "5")]
        pub title: ::core::option::Option<super::String>,
        /// page | example | list | include | directory | dictionary | toc | resource
        #[prost(message, optional, tag = "6")]
        pub kind: ::core::option::Option<super::GuidePageKindCode>,
        /// Kind of resource to include in the list
        #[prost(message, repeated, tag = "7")]
        pub r#type: prost::alloc::vec::Vec<super::ResourceTypeCode>,
        /// Name of package to include
        #[prost(message, repeated, tag = "8")]
        pub package_value: prost::alloc::vec::Vec<super::String>,
        /// Format of the page (e.g. html, markdown, etc.)
        #[prost(message, optional, tag = "9")]
        pub format: ::core::option::Option<super::MimeTypeCode>,
        /// Nested Pages / Sections
        #[prost(message, repeated, tag = "10")]
        pub page: prost::alloc::vec::Vec<Page>,
    }
}
/// Auto-generated from StructureDefinition for Library, last updated
/// 2017-04-19T07:44:43.294+10:00. Represents a library of quality improvement
/// components. See <http://hl7.org/fhir/StructureDefinition/Library>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Library {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this library (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the library
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the library
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this library (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this library (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// logic-library | model-definition | asset-collection | module-definition
    #[prost(message, optional, tag = "16")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Date this was last changed
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "18")]
    pub publisher: ::core::option::Option<String>,
    /// Natural language description of the library
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Why this library is defined
    #[prost(message, optional, tag = "20")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the library
    #[prost(message, optional, tag = "21")]
    pub usage: ::core::option::Option<String>,
    /// When the library was approved by publisher
    #[prost(message, optional, tag = "22")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the library was last reviewed
    #[prost(message, optional, tag = "23")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the library is expected to be used
    #[prost(message, optional, tag = "24")]
    pub effective_period: ::core::option::Option<Period>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "25")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for library (if applicable)
    #[prost(message, repeated, tag = "26")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// E.g. Education, Treatment, Assessment, etc
    #[prost(message, repeated, tag = "27")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// A content contributor
    #[prost(message, repeated, tag = "28")]
    pub contributor: prost::alloc::vec::Vec<Contributor>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "29")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "30")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Additional documentation, citations, etc.
    #[prost(message, repeated, tag = "31")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Parameters defined by the library
    #[prost(message, repeated, tag = "32")]
    pub parameter: prost::alloc::vec::Vec<ParameterDefinition>,
    /// What data is referenced by this library
    #[prost(message, repeated, tag = "33")]
    pub data_requirement: prost::alloc::vec::Vec<DataRequirement>,
    /// Contents of the library, either embedded or referenced
    #[prost(message, repeated, tag = "34")]
    pub content: prost::alloc::vec::Vec<Attachment>,
}
/// Auto-generated from StructureDefinition for Linkage, last updated
/// 2017-04-19T07:44:43.294+10:00. Links records for 'same' item. See
/// <http://hl7.org/fhir/StructureDefinition/Linkage>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Linkage {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Whether this linkage assertion is active or not
    #[prost(message, optional, tag = "9")]
    pub active: ::core::option::Option<Boolean>,
    /// Who is responsible for linkages
    #[prost(message, optional, tag = "10")]
    pub author: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "11")]
    pub item: prost::alloc::vec::Vec<linkage::Item>,
}
/// Nested message and enum types in `Linkage`.
pub mod linkage {
    /// Item to be linked
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// source | alternate | historical
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::LinkageTypeCode>,
        /// Resource being linked
        #[prost(message, optional, tag = "5")]
        pub resource: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for List, last updated
/// 2017-04-19T07:44:43.294+10:00. Information summarized from a list of other
/// resources. See <http://hl7.org/fhir/StructureDefinition/List>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct List {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// current | retired | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<ListStatusCode>,
    /// working | snapshot | changes
    #[prost(message, optional, tag = "11")]
    pub mode: ::core::option::Option<ListModeCode>,
    /// Descriptive name for the list
    #[prost(message, optional, tag = "12")]
    pub title: ::core::option::Option<String>,
    /// What the purpose of this list is
    #[prost(message, optional, tag = "13")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// If all resources have the same subject
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Context in which list created
    #[prost(message, optional, tag = "15")]
    pub encounter: ::core::option::Option<Reference>,
    /// When the list was prepared
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Who and/or what defined the list contents (aka Author)
    #[prost(message, optional, tag = "17")]
    pub source: ::core::option::Option<Reference>,
    /// What order the list has
    #[prost(message, optional, tag = "18")]
    pub ordered_by: ::core::option::Option<CodeableConcept>,
    /// Comments about the list
    #[prost(message, repeated, tag = "19")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "20")]
    pub entry: prost::alloc::vec::Vec<list::Entry>,
    /// Why list is empty
    #[prost(message, optional, tag = "21")]
    pub empty_reason: ::core::option::Option<CodeableConcept>,
}
/// Nested message and enum types in `List`.
pub mod list {
    /// Entries in the list
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Entry {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Status/Workflow information about this item
        #[prost(message, optional, tag = "4")]
        pub flag: ::core::option::Option<super::CodeableConcept>,
        /// If this item is actually marked as deleted
        #[prost(message, optional, tag = "5")]
        pub deleted: ::core::option::Option<super::Boolean>,
        /// When item added to list
        #[prost(message, optional, tag = "6")]
        pub date: ::core::option::Option<super::DateTime>,
        /// Actual entry
        #[prost(message, optional, tag = "7")]
        pub item: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for Location, last updated
/// 2017-04-19T07:44:43.294+10:00. Details and position information for a
/// physical place. See <http://hl7.org/fhir/StructureDefinition/Location>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Location {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique code or number identifying the location to its users
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | suspended | inactive
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<LocationStatusCode>,
    /// The Operational status of the location (typically only for a bed/room)
    #[prost(message, optional, tag = "11")]
    pub operational_status: ::core::option::Option<Coding>,
    /// Name of the location as used by humans
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// A list of alternate names that the location is known as, or was known as in
    /// the past
    #[prost(message, repeated, tag = "13")]
    pub alias: prost::alloc::vec::Vec<String>,
    /// Additional details about the location that could be displayed as further
    /// information to identify the location beyond its name
    #[prost(message, optional, tag = "14")]
    pub description: ::core::option::Option<String>,
    /// instance | kind
    #[prost(message, optional, tag = "15")]
    pub mode: ::core::option::Option<LocationModeCode>,
    /// Type of function performed
    #[prost(message, optional, tag = "16")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Contact details of the location
    #[prost(message, repeated, tag = "17")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// Physical location
    #[prost(message, optional, tag = "18")]
    pub address: ::core::option::Option<Address>,
    /// Physical form of the location
    #[prost(message, optional, tag = "19")]
    pub physical_type: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "20")]
    pub position: ::core::option::Option<location::Position>,
    /// Organization responsible for provisioning and upkeep
    #[prost(message, optional, tag = "21")]
    pub managing_organization: ::core::option::Option<Reference>,
    /// Another Location this one is physically part of
    #[prost(message, optional, tag = "22")]
    pub part_of: ::core::option::Option<Reference>,
    /// Technical endpoints providing access to services operated for the location
    #[prost(message, repeated, tag = "23")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `Location`.
pub mod location {
    /// The absolute geographic location
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Position {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Longitude with WGS84 datum
        #[prost(message, optional, tag = "4")]
        pub longitude: ::core::option::Option<super::Decimal>,
        /// Latitude with WGS84 datum
        #[prost(message, optional, tag = "5")]
        pub latitude: ::core::option::Option<super::Decimal>,
        /// Altitude with WGS84 datum
        #[prost(message, optional, tag = "6")]
        pub altitude: ::core::option::Option<super::Decimal>,
    }
}
/// Auto-generated from StructureDefinition for Measure, last updated
/// 2017-04-19T07:44:43.294+10:00. A quality measure definition. See
/// <http://hl7.org/fhir/StructureDefinition/Measure>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Measure {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this measure (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the measure
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the measure
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this measure (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this measure (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Natural language description of the measure
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<Markdown>,
    /// Why this measure is defined
    #[prost(message, optional, tag = "19")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the measure
    #[prost(message, optional, tag = "20")]
    pub usage: ::core::option::Option<String>,
    /// When the measure was approved by publisher
    #[prost(message, optional, tag = "21")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the measure was last reviewed
    #[prost(message, optional, tag = "22")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the measure is expected to be used
    #[prost(message, optional, tag = "23")]
    pub effective_period: ::core::option::Option<Period>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "24")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for measure (if applicable)
    #[prost(message, repeated, tag = "25")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// E.g. Education, Treatment, Assessment, etc
    #[prost(message, repeated, tag = "26")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// A content contributor
    #[prost(message, repeated, tag = "27")]
    pub contributor: prost::alloc::vec::Vec<Contributor>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "28")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "29")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Additional documentation, citations, etc
    #[prost(message, repeated, tag = "30")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Logic used by the measure
    #[prost(message, repeated, tag = "31")]
    pub library: prost::alloc::vec::Vec<Reference>,
    /// Disclaimer for use of the measure or its referenced content
    #[prost(message, optional, tag = "32")]
    pub disclaimer: ::core::option::Option<Markdown>,
    /// proportion | ratio | continuous-variable | cohort
    #[prost(message, optional, tag = "33")]
    pub scoring: ::core::option::Option<CodeableConcept>,
    /// opportunity | all-or-nothing | linear | weighted
    #[prost(message, optional, tag = "34")]
    pub composite_scoring: ::core::option::Option<CodeableConcept>,
    /// process | outcome | structure | patient-reported-outcome | composite
    #[prost(message, repeated, tag = "35")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    /// How is risk adjustment applied for this measure
    #[prost(message, optional, tag = "36")]
    pub risk_adjustment: ::core::option::Option<String>,
    /// How is rate aggregation performed for this measure
    #[prost(message, optional, tag = "37")]
    pub rate_aggregation: ::core::option::Option<String>,
    /// Why does this measure exist
    #[prost(message, optional, tag = "38")]
    pub rationale: ::core::option::Option<Markdown>,
    /// Summary of clinical guidelines
    #[prost(message, optional, tag = "39")]
    pub clinical_recommendation_statement: ::core::option::Option<Markdown>,
    /// Improvement notation for the measure, e.g. higher score indicates better
    /// quality
    #[prost(message, optional, tag = "40")]
    pub improvement_notation: ::core::option::Option<String>,
    /// Defined terms used in the measure documentation
    #[prost(message, repeated, tag = "41")]
    pub definition: prost::alloc::vec::Vec<Markdown>,
    /// Additional guidance for implementers
    #[prost(message, optional, tag = "42")]
    pub guidance: ::core::option::Option<Markdown>,
    /// The measure set, e.g. Preventive Care and Screening
    #[prost(message, optional, tag = "43")]
    pub set: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "44")]
    pub group: prost::alloc::vec::Vec<measure::Group>,
    #[prost(message, repeated, tag = "45")]
    pub supplemental_data: prost::alloc::vec::Vec<measure::SupplementalData>,
}
/// Nested message and enum types in `Measure`.
pub mod measure {
    /// Population criteria group
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Group {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Unique identifier
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// Short name
        #[prost(message, optional, tag = "5")]
        pub name: ::core::option::Option<super::String>,
        /// Summary description
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "7")]
        pub population: prost::alloc::vec::Vec<group::Population>,
        #[prost(message, repeated, tag = "8")]
        pub stratifier: prost::alloc::vec::Vec<group::Stratifier>,
    }
    /// Nested message and enum types in `Group`.
    pub mod group {
        /// Population criteria
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Population {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Unique identifier
            #[prost(message, optional, tag = "4")]
            pub identifier: ::core::option::Option<super::super::Identifier>,
            /// initial-population | numerator | numerator-exclusion | denominator |
            /// denominator-exclusion | denominator-exception | measure-population |
            /// measure-population-exclusion | measure-observation
            #[prost(message, optional, tag = "5")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// Short name
            #[prost(message, optional, tag = "6")]
            pub name: ::core::option::Option<super::super::String>,
            /// The human readable description of this population criteria
            #[prost(message, optional, tag = "7")]
            pub description: ::core::option::Option<super::super::String>,
            /// The name of a valid referenced CQL expression (may be namespaced) that
            /// defines this population criteria
            #[prost(message, optional, tag = "8")]
            pub criteria: ::core::option::Option<super::super::String>,
        }
        /// Stratifier criteria for the measure
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Stratifier {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The identifier for the stratifier used to coordinate the reported data
            /// back to this stratifier
            #[prost(message, optional, tag = "4")]
            pub identifier: ::core::option::Option<super::super::Identifier>,
            /// How the measure should be stratified
            #[prost(message, optional, tag = "5")]
            pub criteria: ::core::option::Option<super::super::String>,
            /// Path to the stratifier
            #[prost(message, optional, tag = "6")]
            pub path: ::core::option::Option<super::super::String>,
        }
    }
    /// What other data should be reported with the measure
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SupplementalData {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifier, unique within the measure
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// supplemental-data | risk-adjustment-factor
        #[prost(message, repeated, tag = "5")]
        pub usage: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Expression describing additional data to be reported
        #[prost(message, optional, tag = "6")]
        pub criteria: ::core::option::Option<super::String>,
        /// Path to the supplemental data element
        #[prost(message, optional, tag = "7")]
        pub path: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for MeasureReport, last updated
/// 2017-04-19T07:44:43.294+10:00. Results of a measure evaluation. See
/// <http://hl7.org/fhir/StructureDefinition/MeasureReport>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MeasureReport {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Additional identifier for the Report
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// complete | pending | error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<MeasureReportStatusCode>,
    /// individual | patient-list | summary
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<MeasureReportTypeCode>,
    /// What measure was evaluated
    #[prost(message, optional, tag = "12")]
    pub measure: ::core::option::Option<Reference>,
    /// What patient the report is for
    #[prost(message, optional, tag = "13")]
    pub patient: ::core::option::Option<Reference>,
    /// When the report was generated
    #[prost(message, optional, tag = "14")]
    pub date: ::core::option::Option<DateTime>,
    /// Who is reporting the data
    #[prost(message, optional, tag = "15")]
    pub reporting_organization: ::core::option::Option<Reference>,
    /// What period the report covers
    #[prost(message, optional, tag = "16")]
    pub period: ::core::option::Option<Period>,
    #[prost(message, repeated, tag = "17")]
    pub group: prost::alloc::vec::Vec<measure_report::Group>,
    /// What data was evaluated to produce the measure score
    #[prost(message, optional, tag = "18")]
    pub evaluated_resources: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `MeasureReport`.
pub mod measure_report {
    /// Measure results for each group
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Group {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// What group of the measure
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        #[prost(message, repeated, tag = "5")]
        pub population: prost::alloc::vec::Vec<group::Population>,
        /// What score this group achieved
        #[prost(message, optional, tag = "6")]
        pub measure_score: ::core::option::Option<super::Decimal>,
        #[prost(message, repeated, tag = "7")]
        pub stratifier: prost::alloc::vec::Vec<group::Stratifier>,
    }
    /// Nested message and enum types in `Group`.
    pub mod group {
        /// The populations in the group
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Population {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Population identifier as defined in the measure
            #[prost(message, optional, tag = "4")]
            pub identifier: ::core::option::Option<super::super::Identifier>,
            /// initial-population | numerator | numerator-exclusion | denominator |
            /// denominator-exclusion | denominator-exception | measure-population |
            /// measure-population-exclusion | measure-score
            #[prost(message, optional, tag = "5")]
            pub code: ::core::option::Option<super::super::CodeableConcept>,
            /// Size of the population
            #[prost(message, optional, tag = "6")]
            pub count: ::core::option::Option<super::super::Integer>,
            /// For patient-list reports, the patients in this population
            #[prost(message, optional, tag = "7")]
            pub patients: ::core::option::Option<super::super::Reference>,
        }
        /// Stratification results
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Stratifier {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// What stratifier of the group
            #[prost(message, optional, tag = "4")]
            pub identifier: ::core::option::Option<super::super::Identifier>,
            #[prost(message, repeated, tag = "5")]
            pub stratum: prost::alloc::vec::Vec<stratifier::StratifierGroup>,
        }
        /// Nested message and enum types in `Stratifier`.
        pub mod stratifier {
            /// Stratum results, one for each unique value in the stratifier
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct StratifierGroup {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// The stratum value, e.g. male
                #[prost(message, optional, tag = "4")]
                pub value: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "5")]
                pub population: prost::alloc::vec::Vec<stratifier_group::StratifierGroupPopulation>,
                /// What score this stratum achieved
                #[prost(message, optional, tag = "6")]
                pub measure_score: ::core::option::Option<super::super::super::Decimal>,
            }
            /// Nested message and enum types in `StratifierGroup`.
            pub mod stratifier_group {
                /// Population results in this stratum
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct StratifierGroupPopulation {
                    /// xml:id (or equivalent in JSON)
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional Content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Population identifier as defined in the measure
                    #[prost(message, optional, tag = "4")]
                    pub identifier: ::core::option::Option<super::super::super::super::Identifier>,
                    /// initial-population | numerator | numerator-exclusion | denominator
                    /// | denominator-exclusion | denominator-exception |
                    /// measure-population | measure-population-exclusion | measure-score
                    #[prost(message, optional, tag = "5")]
                    pub code: ::core::option::Option<super::super::super::super::CodeableConcept>,
                    /// Size of the population
                    #[prost(message, optional, tag = "6")]
                    pub count: ::core::option::Option<super::super::super::super::Integer>,
                    /// For patient-list reports, the patients in this population
                    #[prost(message, optional, tag = "7")]
                    pub patients: ::core::option::Option<super::super::super::super::Reference>,
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Media, last updated
/// 2017-04-19T07:44:43.294+10:00. A photo, video, or audio recording acquired or
/// used in healthcare. The actual content may be inline or provided by direct
/// reference. See <http://hl7.org/fhir/StructureDefinition/Media>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Media {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifier(s) for the image
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Procedure that caused this media to be created
    #[prost(message, repeated, tag = "10")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// photo | video | audio
    #[prost(message, optional, tag = "11")]
    pub r#type: ::core::option::Option<DigitalMediaTypeCode>,
    /// The type of acquisition equipment/process
    #[prost(message, optional, tag = "12")]
    pub subtype: ::core::option::Option<CodeableConcept>,
    /// Imaging view, e.g. Lateral or Antero-posterior
    #[prost(message, optional, tag = "13")]
    pub view: ::core::option::Option<CodeableConcept>,
    /// Who/What this Media is a record of
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter / Episode associated with media
    #[prost(message, optional, tag = "15")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "16")]
    pub occurrence: ::core::option::Option<media::Occurrence>,
    /// The person who generated the image
    #[prost(message, optional, tag = "17")]
    pub operator: ::core::option::Option<Reference>,
    /// Why was event performed?
    #[prost(message, repeated, tag = "18")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Body part in media
    #[prost(message, optional, tag = "19")]
    pub body_site: ::core::option::Option<CodeableConcept>,
    /// Observing Device
    #[prost(message, optional, tag = "20")]
    pub device: ::core::option::Option<Reference>,
    /// Height of the image in pixels (photo/video)
    #[prost(message, optional, tag = "21")]
    pub height: ::core::option::Option<PositiveInt>,
    /// Width of the image in pixels (photo/video)
    #[prost(message, optional, tag = "22")]
    pub width: ::core::option::Option<PositiveInt>,
    /// Number of frames if > 1 (photo)
    #[prost(message, optional, tag = "23")]
    pub frames: ::core::option::Option<PositiveInt>,
    /// Length in seconds (audio / video)
    #[prost(message, optional, tag = "24")]
    pub duration: ::core::option::Option<UnsignedInt>,
    /// Actual Media - reference or data
    #[prost(message, optional, tag = "25")]
    pub content: ::core::option::Option<Attachment>,
    /// Comments made about the media
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `Media`.
pub mod media {
    /// When Media was collected
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Occurrence {
        #[prost(oneof = "occurrence::Occurrence", tags = "1, 2")]
        pub occurrence: ::core::option::Option<occurrence::Occurrence>,
    }
    /// Nested message and enum types in `Occurrence`.
    pub mod occurrence {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Occurrence {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
}
/// Auto-generated from StructureDefinition for Medication, last updated
/// 2017-04-19T07:44:43.294+10:00. Definition of a Medication. See
/// <http://hl7.org/fhir/StructureDefinition/Medication>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Medication {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Codes that identify this medication
    #[prost(message, optional, tag = "9")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// active | inactive | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<MedicationStatusCode>,
    /// True if a brand
    #[prost(message, optional, tag = "11")]
    pub is_brand: ::core::option::Option<Boolean>,
    /// True if medication does not require a prescription
    #[prost(message, optional, tag = "12")]
    pub is_over_the_counter: ::core::option::Option<Boolean>,
    /// Manufacturer of the item
    #[prost(message, optional, tag = "13")]
    pub manufacturer: ::core::option::Option<Reference>,
    /// powder | tablets | capsule +
    #[prost(message, optional, tag = "14")]
    pub form: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "15")]
    pub ingredient: prost::alloc::vec::Vec<medication::Ingredient>,
    #[prost(message, optional, tag = "16")]
    pub package_value: ::core::option::Option<medication::Package>,
    /// Picture of the medication
    #[prost(message, repeated, tag = "17")]
    pub image: prost::alloc::vec::Vec<Attachment>,
}
/// Nested message and enum types in `Medication`.
pub mod medication {
    /// Active or inactive ingredient
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Ingredient {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, optional, tag = "4")]
        pub item: ::core::option::Option<ingredient::Item>,
        /// Active ingredient indicator
        #[prost(message, optional, tag = "5")]
        pub is_active: ::core::option::Option<super::Boolean>,
        /// Quantity of ingredient present
        #[prost(message, optional, tag = "6")]
        pub amount: ::core::option::Option<super::Ratio>,
    }
    /// Nested message and enum types in `Ingredient`.
    pub mod ingredient {
        /// The product contained
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Item {
            #[prost(oneof = "item::Item", tags = "1, 2")]
            pub item: ::core::option::Option<item::Item>,
        }
        /// Nested message and enum types in `Item`.
        pub mod item {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Item {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// Details about packaged medications
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Package {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// E.g. box, vial, blister-pack
        #[prost(message, optional, tag = "4")]
        pub container: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "5")]
        pub content: prost::alloc::vec::Vec<package::Content>,
        #[prost(message, repeated, tag = "6")]
        pub batch: prost::alloc::vec::Vec<package::Batch>,
    }
    /// Nested message and enum types in `Package`.
    pub mod package {
        /// What is  in the package
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Content {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub item: ::core::option::Option<content::Item>,
            /// Quantity present in the package
            #[prost(message, optional, tag = "5")]
            pub amount: ::core::option::Option<super::super::SimpleQuantity>,
        }
        /// Nested message and enum types in `Content`.
        pub mod content {
            /// The item in the package
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Item {
                #[prost(oneof = "item::Item", tags = "1, 2")]
                pub item: ::core::option::Option<item::Item>,
            }
            /// Nested message and enum types in `Item`.
            pub mod item {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Item {
                    #[prost(message, tag = "1")]
                    CodeableConcept(super::super::super::super::CodeableConcept),
                    #[prost(message, tag = "2")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
        /// Identifies a single production run
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Batch {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Identifier assigned to batch
            #[prost(message, optional, tag = "4")]
            pub lot_number: ::core::option::Option<super::super::String>,
            /// When batch will expire
            #[prost(message, optional, tag = "5")]
            pub expiration_date: ::core::option::Option<super::super::DateTime>,
        }
    }
}
/// Auto-generated from StructureDefinition for MedicationAdministration, last
/// updated 2017-04-19T07:44:43.294+10:00. Administration of medication to a
/// patient. See <http://hl7.org/fhir/StructureDefinition/MedicationAdministration>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationAdministration {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates protocol or definition
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced event
    #[prost(message, repeated, tag = "11")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// in-progress | on-hold | completed | entered-in-error | stopped | unknown
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<MedicationAdministrationStatusCode>,
    /// Type of medication usage
    #[prost(message, optional, tag = "13")]
    pub category: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "14")]
    pub medication: ::core::option::Option<medication_administration::Medication>,
    /// Who received medication
    #[prost(message, optional, tag = "15")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or Episode of Care administered as part of
    #[prost(message, optional, tag = "16")]
    pub context: ::core::option::Option<Reference>,
    /// Additional information to support administration
    #[prost(message, repeated, tag = "17")]
    pub supporting_information: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "18")]
    pub effective: ::core::option::Option<medication_administration::Effective>,
    #[prost(message, repeated, tag = "19")]
    pub performer: prost::alloc::vec::Vec<medication_administration::Performer>,
    /// True if medication not administered
    #[prost(message, optional, tag = "20")]
    pub not_given: ::core::option::Option<Boolean>,
    /// Reason administration not performed
    #[prost(message, repeated, tag = "21")]
    pub reason_not_given: prost::alloc::vec::Vec<CodeableConcept>,
    /// Reason administration performed
    #[prost(message, repeated, tag = "22")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Condition or Observation that supports why the medication was administered
    #[prost(message, repeated, tag = "23")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Request administration performed against
    #[prost(message, optional, tag = "24")]
    pub prescription: ::core::option::Option<Reference>,
    /// Device used to administer
    #[prost(message, repeated, tag = "25")]
    pub device: prost::alloc::vec::Vec<Reference>,
    /// Information about the administration
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, optional, tag = "27")]
    pub dosage: ::core::option::Option<medication_administration::Dosage>,
    /// A list of events of interest in the lifecycle
    #[prost(message, repeated, tag = "28")]
    pub event_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `MedicationAdministration`.
pub mod medication_administration {
    /// What was administered
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Medication {
        #[prost(oneof = "medication::Medication", tags = "1, 2")]
        pub medication: ::core::option::Option<medication::Medication>,
    }
    /// Nested message and enum types in `Medication`.
    pub mod medication {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Medication {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Start and end time of administration
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Effective {
        #[prost(oneof = "effective::Effective", tags = "1, 2")]
        pub effective: ::core::option::Option<effective::Effective>,
    }
    /// Nested message and enum types in `Effective`.
    pub mod effective {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Effective {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Who administered substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Performer {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Individual who was performing
        #[prost(message, optional, tag = "4")]
        pub actor: ::core::option::Option<super::Reference>,
        /// Organization organization was acting for
        #[prost(message, optional, tag = "5")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
    /// Details of how medication was taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Dosage {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Free text dosage instructions e.g. SIG
        #[prost(message, optional, tag = "4")]
        pub text: ::core::option::Option<super::String>,
        /// Body site administered to
        #[prost(message, optional, tag = "5")]
        pub site: ::core::option::Option<super::CodeableConcept>,
        /// Path of substance into body
        #[prost(message, optional, tag = "6")]
        pub route: ::core::option::Option<super::CodeableConcept>,
        /// How drug was administered
        #[prost(message, optional, tag = "7")]
        pub method: ::core::option::Option<super::CodeableConcept>,
        /// Amount of medication per dose
        #[prost(message, optional, tag = "8")]
        pub dose: ::core::option::Option<super::SimpleQuantity>,
        #[prost(message, optional, tag = "9")]
        pub rate: ::core::option::Option<dosage::Rate>,
    }
    /// Nested message and enum types in `Dosage`.
    pub mod dosage {
        /// Dose quantity per unit of time
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Rate {
            #[prost(oneof = "rate::Rate", tags = "1, 2")]
            pub rate: ::core::option::Option<rate::Rate>,
        }
        /// Nested message and enum types in `Rate`.
        pub mod rate {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Rate {
                #[prost(message, tag = "1")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "2")]
                Quantity(super::super::super::SimpleQuantity),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for MedicationDispense, last updated
/// 2017-04-19T07:44:43.294+10:00. Dispensing a medication to a named patient.
/// See <http://hl7.org/fhir/StructureDefinition/MedicationDispense>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationDispense {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Event that dispense is part of
    #[prost(message, repeated, tag = "10")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// preparation | in-progress | on-hold | completed | entered-in-error |
    /// stopped
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<MedicationDispenseStatusCode>,
    /// Type of medication dispense
    #[prost(message, optional, tag = "12")]
    pub category: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "13")]
    pub medication: ::core::option::Option<medication_dispense::Medication>,
    /// Who the dispense is for
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter / Episode associated with event
    #[prost(message, optional, tag = "15")]
    pub context: ::core::option::Option<Reference>,
    /// Information that supports the dispensing of the medication
    #[prost(message, repeated, tag = "16")]
    pub supporting_information: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "17")]
    pub performer: prost::alloc::vec::Vec<medication_dispense::Performer>,
    /// Medication order that authorizes the dispense
    #[prost(message, repeated, tag = "18")]
    pub authorizing_prescription: prost::alloc::vec::Vec<Reference>,
    /// Trial fill, partial fill, emergency fill, etc.
    #[prost(message, optional, tag = "19")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Amount dispensed
    #[prost(message, optional, tag = "20")]
    pub quantity: ::core::option::Option<SimpleQuantity>,
    /// Amount of medication expressed as a timing amount
    #[prost(message, optional, tag = "21")]
    pub days_supply: ::core::option::Option<SimpleQuantity>,
    /// When product was packaged and reviewed
    #[prost(message, optional, tag = "22")]
    pub when_prepared: ::core::option::Option<DateTime>,
    /// When product was given out
    #[prost(message, optional, tag = "23")]
    pub when_handed_over: ::core::option::Option<DateTime>,
    /// Where the medication was sent
    #[prost(message, optional, tag = "24")]
    pub destination: ::core::option::Option<Reference>,
    /// Who collected the medication
    #[prost(message, repeated, tag = "25")]
    pub receiver: prost::alloc::vec::Vec<Reference>,
    /// Information about the dispense
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// How the medication is to be used by the patient or administered by the
    /// caregiver
    #[prost(message, repeated, tag = "27")]
    pub dosage_instruction: prost::alloc::vec::Vec<Dosage>,
    #[prost(message, optional, tag = "28")]
    pub substitution: ::core::option::Option<medication_dispense::Substitution>,
    /// Clinical issue with action
    #[prost(message, repeated, tag = "29")]
    pub detected_issue: prost::alloc::vec::Vec<Reference>,
    /// Whether the dispense was or was not performed
    #[prost(message, optional, tag = "30")]
    pub not_done: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "31")]
    pub not_done_reason: ::core::option::Option<medication_dispense::NotDoneReason>,
    /// A list of releveant lifecycle events
    #[prost(message, repeated, tag = "32")]
    pub event_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `MedicationDispense`.
pub mod medication_dispense {
    /// What medication was supplied
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Medication {
        #[prost(oneof = "medication::Medication", tags = "1, 2")]
        pub medication: ::core::option::Option<medication::Medication>,
    }
    /// Nested message and enum types in `Medication`.
    pub mod medication {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Medication {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Who performed event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Performer {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Individual who was performing
        #[prost(message, optional, tag = "4")]
        pub actor: ::core::option::Option<super::Reference>,
        /// Organization organization was acting for
        #[prost(message, optional, tag = "5")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
    /// Whether a substitution was performed on the dispense
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Substitution {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Whether a substitution was or was not performed on the dispense
        #[prost(message, optional, tag = "4")]
        pub was_substituted: ::core::option::Option<super::Boolean>,
        /// Code signifying whether a different drug was dispensed from what was
        /// prescribed
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Why was substitution made
        #[prost(message, repeated, tag = "6")]
        pub reason: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Who is responsible for the substitution
        #[prost(message, repeated, tag = "7")]
        pub responsible_party: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Why a dispense was not performed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct NotDoneReason {
        #[prost(oneof = "not_done_reason::NotDoneReason", tags = "1, 2")]
        pub not_done_reason: ::core::option::Option<not_done_reason::NotDoneReason>,
    }
    /// Nested message and enum types in `NotDoneReason`.
    pub mod not_done_reason {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum NotDoneReason {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for MedicationRequest, last updated
/// 2017-04-19T07:44:43.294+10:00. Ordering of medication for patient or group.
/// See <http://hl7.org/fhir/StructureDefinition/MedicationRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External ids for this request
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Protocol or definition
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Reference>,
    /// What request fulfills
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Composite request this is part of
    #[prost(message, optional, tag = "12")]
    pub group_identifier: ::core::option::Option<Identifier>,
    /// active | on-hold | cancelled | completed | entered-in-error | stopped |
    /// draft | unknown
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<MedicationRequestStatusCode>,
    /// proposal | plan | order | instance-order
    #[prost(message, optional, tag = "14")]
    pub intent: ::core::option::Option<MedicationRequestIntentCode>,
    /// Type of medication usage
    #[prost(message, optional, tag = "15")]
    pub category: ::core::option::Option<CodeableConcept>,
    /// routine | urgent | stat | asap
    #[prost(message, optional, tag = "16")]
    pub priority: ::core::option::Option<MedicationRequestPriorityCode>,
    #[prost(message, optional, tag = "17")]
    pub medication: ::core::option::Option<medication_request::Medication>,
    /// Who or group medication request is for
    #[prost(message, optional, tag = "18")]
    pub subject: ::core::option::Option<Reference>,
    /// Created during encounter/admission/stay
    #[prost(message, optional, tag = "19")]
    pub context: ::core::option::Option<Reference>,
    /// Information to support ordering of the medication
    #[prost(message, repeated, tag = "20")]
    pub supporting_information: prost::alloc::vec::Vec<Reference>,
    /// When request was initially authored
    #[prost(message, optional, tag = "21")]
    pub authored_on: ::core::option::Option<DateTime>,
    #[prost(message, optional, tag = "22")]
    pub requester: ::core::option::Option<medication_request::Requester>,
    /// Person who entered the request
    #[prost(message, optional, tag = "23")]
    pub recorder: ::core::option::Option<Reference>,
    /// Reason or indication for writing the prescription
    #[prost(message, repeated, tag = "24")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Condition or Observation that supports why the prescription is being
    /// written
    #[prost(message, repeated, tag = "25")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Information about the prescription
    #[prost(message, repeated, tag = "26")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// How the medication should be taken
    #[prost(message, repeated, tag = "27")]
    pub dosage_instruction: prost::alloc::vec::Vec<Dosage>,
    #[prost(message, optional, tag = "28")]
    pub dispense_request: ::core::option::Option<medication_request::DispenseRequest>,
    #[prost(message, optional, tag = "29")]
    pub substitution: ::core::option::Option<medication_request::Substitution>,
    /// An order/prescription that is being replaced
    #[prost(message, optional, tag = "30")]
    pub prior_prescription: ::core::option::Option<Reference>,
    /// Clinical Issue with action
    #[prost(message, repeated, tag = "31")]
    pub detected_issue: prost::alloc::vec::Vec<Reference>,
    /// A list of events of interest in the lifecycle
    #[prost(message, repeated, tag = "32")]
    pub event_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `MedicationRequest`.
pub mod medication_request {
    /// Medication to be taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Medication {
        #[prost(oneof = "medication::Medication", tags = "1, 2")]
        pub medication: ::core::option::Option<medication::Medication>,
    }
    /// Nested message and enum types in `Medication`.
    pub mod medication {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Medication {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Who/What requested the Request
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Requester {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Who ordered the initial medication(s)
        #[prost(message, optional, tag = "4")]
        pub agent: ::core::option::Option<super::Reference>,
        /// Organization agent is acting for
        #[prost(message, optional, tag = "5")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
    /// Medication supply authorization
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct DispenseRequest {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Time period supply is authorized for
        #[prost(message, optional, tag = "4")]
        pub validity_period: ::core::option::Option<super::Period>,
        /// Number of refills authorized
        #[prost(message, optional, tag = "5")]
        pub number_of_repeats_allowed: ::core::option::Option<super::PositiveInt>,
        /// Amount of medication to supply per dispense
        #[prost(message, optional, tag = "6")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Number of days supply per dispense
        #[prost(message, optional, tag = "7")]
        pub expected_supply_duration: ::core::option::Option<super::Duration>,
        /// Intended dispenser
        #[prost(message, optional, tag = "8")]
        pub performer: ::core::option::Option<super::Reference>,
    }
    /// Any restrictions on medication substitution
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Substitution {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Whether substitution is allowed or not
        #[prost(message, optional, tag = "4")]
        pub allowed: ::core::option::Option<super::Boolean>,
        /// Why should (not) substitution be made
        #[prost(message, optional, tag = "5")]
        pub reason: ::core::option::Option<super::CodeableConcept>,
    }
}
/// Auto-generated from StructureDefinition for MedicationStatement, last updated
/// 2017-04-19T07:44:43.294+10:00. Record of medication being taken by a patient.
/// See <http://hl7.org/fhir/StructureDefinition/MedicationStatement>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MedicationStatement {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Fulfils plan, proposal or order
    #[prost(message, repeated, tag = "10")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced event
    #[prost(message, repeated, tag = "11")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// Encounter / Episode associated with MedicationStatement
    #[prost(message, optional, tag = "12")]
    pub context: ::core::option::Option<Reference>,
    /// active | completed | entered-in-error | intended | stopped | on-hold
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<MedicationStatementStatusCode>,
    /// Type of medication usage
    #[prost(message, optional, tag = "14")]
    pub category: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "15")]
    pub medication: ::core::option::Option<medication_statement::Medication>,
    #[prost(message, optional, tag = "16")]
    pub effective: ::core::option::Option<medication_statement::Effective>,
    /// When the statement was asserted?
    #[prost(message, optional, tag = "17")]
    pub date_asserted: ::core::option::Option<DateTime>,
    /// Person or organization that provided the information about the taking of
    /// this medication
    #[prost(message, optional, tag = "18")]
    pub information_source: ::core::option::Option<Reference>,
    /// Who is/was taking  the medication
    #[prost(message, optional, tag = "19")]
    pub subject: ::core::option::Option<Reference>,
    /// Additional supporting information
    #[prost(message, repeated, tag = "20")]
    pub derived_from: prost::alloc::vec::Vec<Reference>,
    /// y | n | unk | na
    #[prost(message, optional, tag = "21")]
    pub taken: ::core::option::Option<MedicationStatementTakenCode>,
    /// True if asserting medication was not given
    #[prost(message, repeated, tag = "22")]
    pub reason_not_taken: prost::alloc::vec::Vec<CodeableConcept>,
    /// Reason for why the medication is being/was taken
    #[prost(message, repeated, tag = "23")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Condition or observation that supports why the medication is being/was
    /// taken
    #[prost(message, repeated, tag = "24")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Further information about the statement
    #[prost(message, repeated, tag = "25")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Details of how medication is/was taken or should be taken
    #[prost(message, repeated, tag = "26")]
    pub dosage: prost::alloc::vec::Vec<Dosage>,
}
/// Nested message and enum types in `MedicationStatement`.
pub mod medication_statement {
    /// What medication was taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Medication {
        #[prost(oneof = "medication::Medication", tags = "1, 2")]
        pub medication: ::core::option::Option<medication::Medication>,
    }
    /// Nested message and enum types in `Medication`.
    pub mod medication {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Medication {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// The date/time or interval when the medication was taken
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Effective {
        #[prost(oneof = "effective::Effective", tags = "1, 2")]
        pub effective: ::core::option::Option<effective::Effective>,
    }
    /// Nested message and enum types in `Effective`.
    pub mod effective {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Effective {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
}
/// Auto-generated from StructureDefinition for MessageDefinition, last updated
/// 2017-04-19T07:44:43.294+10:00. A resource that defines a type of message that
/// can be exchanged between systems. See
/// <http://hl7.org/fhir/StructureDefinition/MessageDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this message definition (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the message definition
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Business version of the message definition
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this message definition (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this message definition (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the message definition
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for message definition (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this message definition is defined
    #[prost(message, optional, tag = "22")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "23")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Definition this one is based on
    #[prost(message, optional, tag = "24")]
    pub base: ::core::option::Option<Reference>,
    /// Protocol/workflow this is part of
    #[prost(message, repeated, tag = "25")]
    pub parent: prost::alloc::vec::Vec<Reference>,
    /// Takes the place of
    #[prost(message, repeated, tag = "26")]
    pub replaces: prost::alloc::vec::Vec<Reference>,
    /// Event type
    #[prost(message, optional, tag = "27")]
    pub event: ::core::option::Option<Coding>,
    /// Consequence | Currency | Notification
    #[prost(message, optional, tag = "28")]
    pub category: ::core::option::Option<MessageSignificanceCategoryCode>,
    #[prost(message, repeated, tag = "29")]
    pub focus: prost::alloc::vec::Vec<message_definition::Focus>,
    /// Is a response required?
    #[prost(message, optional, tag = "30")]
    pub response_required: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "31")]
    pub allowed_response: prost::alloc::vec::Vec<message_definition::AllowedResponse>,
}
/// Nested message and enum types in `MessageDefinition`.
pub mod message_definition {
    /// Resource(s) that are the subject of the event
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Focus {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of resource
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::ResourceTypeCode>,
        /// Profile that must be adhered to by focus
        #[prost(message, optional, tag = "5")]
        pub profile: ::core::option::Option<super::Reference>,
        /// Minimum number of focuses of this type
        #[prost(message, optional, tag = "6")]
        pub min: ::core::option::Option<super::UnsignedInt>,
        /// Maximum number of focuses of this type
        #[prost(message, optional, tag = "7")]
        pub max: ::core::option::Option<super::String>,
    }
    /// Responses to this message
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AllowedResponse {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reference to allowed message definition response
        #[prost(message, optional, tag = "4")]
        pub message: ::core::option::Option<super::Reference>,
        /// When should this response be used
        #[prost(message, optional, tag = "5")]
        pub situation: ::core::option::Option<super::Markdown>,
    }
}
/// Auto-generated from StructureDefinition for MessageHeader, last updated
/// 2017-04-19T07:44:43.294+10:00. A resource that describes a message that is
/// exchanged between systems. See
/// <http://hl7.org/fhir/StructureDefinition/MessageHeader>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct MessageHeader {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Code for the event this message represents
    #[prost(message, optional, tag = "9")]
    pub event: ::core::option::Option<Coding>,
    #[prost(message, repeated, tag = "10")]
    pub destination: prost::alloc::vec::Vec<message_header::MessageDestination>,
    /// Intended "real-world" recipient for the data
    #[prost(message, optional, tag = "11")]
    pub receiver: ::core::option::Option<Reference>,
    /// Real world sender of the message
    #[prost(message, optional, tag = "12")]
    pub sender: ::core::option::Option<Reference>,
    /// Time that the message was sent
    #[prost(message, optional, tag = "13")]
    pub timestamp: ::core::option::Option<Instant>,
    /// The source of the data entry
    #[prost(message, optional, tag = "14")]
    pub enterer: ::core::option::Option<Reference>,
    /// The source of the decision
    #[prost(message, optional, tag = "15")]
    pub author: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "16")]
    pub source: ::core::option::Option<message_header::MessageSource>,
    /// Final responsibility for event
    #[prost(message, optional, tag = "17")]
    pub responsible: ::core::option::Option<Reference>,
    /// Cause of event
    #[prost(message, optional, tag = "18")]
    pub reason: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "19")]
    pub response: ::core::option::Option<message_header::Response>,
    /// The actual content of the message
    #[prost(message, repeated, tag = "20")]
    pub focus: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `MessageHeader`.
pub mod message_header {
    /// Message destination application(s)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MessageDestination {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name of system
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Particular delivery destination within the destination
        #[prost(message, optional, tag = "5")]
        pub target: ::core::option::Option<super::Reference>,
        /// Actual destination address or id
        #[prost(message, optional, tag = "6")]
        pub endpoint: ::core::option::Option<super::Uri>,
    }
    /// Message source application
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MessageSource {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name of system
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Name of software running the system
        #[prost(message, optional, tag = "5")]
        pub software: ::core::option::Option<super::String>,
        /// Version of software running
        #[prost(message, optional, tag = "6")]
        pub version: ::core::option::Option<super::String>,
        /// Human contact for problems
        #[prost(message, optional, tag = "7")]
        pub contact: ::core::option::Option<super::ContactPoint>,
        /// Actual message source address or id
        #[prost(message, optional, tag = "8")]
        pub endpoint: ::core::option::Option<super::Uri>,
    }
    /// If this is a reply to prior message
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Response {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Id of original message
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Id>,
        /// ok | transient-error | fatal-error
        #[prost(message, optional, tag = "5")]
        pub code: ::core::option::Option<super::ResponseTypeCode>,
        /// Specific list of hints/warnings/errors
        #[prost(message, optional, tag = "6")]
        pub details: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for NamingSystem, last updated
/// 2017-04-19T07:44:43.294+10:00. System of unique identification. See
/// <http://hl7.org/fhir/StructureDefinition/NamingSystem>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NamingSystem {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Name for this naming system (computer friendly)
    #[prost(message, optional, tag = "9")]
    pub name: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// codesystem | identifier | root
    #[prost(message, optional, tag = "11")]
    pub kind: ::core::option::Option<NamingSystemTypeCode>,
    /// Date this was last changed
    #[prost(message, optional, tag = "12")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "13")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "14")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Who maintains system namespace?
    #[prost(message, optional, tag = "15")]
    pub responsible: ::core::option::Option<String>,
    /// e.g. driver,  provider,  patient, bank etc.
    #[prost(message, optional, tag = "16")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Natural language description of the naming system
    #[prost(message, optional, tag = "17")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "18")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for naming system (if applicable)
    #[prost(message, repeated, tag = "19")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// How/where is it used
    #[prost(message, optional, tag = "20")]
    pub usage: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "21")]
    pub unique_id: prost::alloc::vec::Vec<naming_system::UniqueId>,
    /// Use this instead
    #[prost(message, optional, tag = "22")]
    pub replaced_by: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `NamingSystem`.
pub mod naming_system {
    /// Unique identifiers used for system
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct UniqueId {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// oid | uuid | uri | other
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::NamingSystemIdentifierTypeCode>,
        /// The unique identifier
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<super::String>,
        /// Is this the id that should be used for this type
        #[prost(message, optional, tag = "6")]
        pub preferred: ::core::option::Option<super::Boolean>,
        /// Notes about identifier usage
        #[prost(message, optional, tag = "7")]
        pub comment: ::core::option::Option<super::String>,
        /// When is identifier valid?
        #[prost(message, optional, tag = "8")]
        pub period: ::core::option::Option<super::Period>,
    }
}
/// Auto-generated from StructureDefinition for NutritionOrder, last updated
/// 2017-04-19T07:44:43.294+10:00. Diet, formula or nutritional supplement
/// request. See <http://hl7.org/fhir/StructureDefinition/NutritionOrder>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct NutritionOrder {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifiers assigned to this order
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// proposed | draft | planned | requested | active | on-hold | completed |
    /// cancelled | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<NutritionOrderStatusCode>,
    /// The person who requires the diet, formula or nutritional supplement
    #[prost(message, optional, tag = "11")]
    pub patient: ::core::option::Option<Reference>,
    /// The encounter associated with this nutrition order
    #[prost(message, optional, tag = "12")]
    pub encounter: ::core::option::Option<Reference>,
    /// Date and time the nutrition order was requested
    #[prost(message, optional, tag = "13")]
    pub date_time: ::core::option::Option<DateTime>,
    /// Who ordered the diet, formula or nutritional supplement
    #[prost(message, optional, tag = "14")]
    pub orderer: ::core::option::Option<Reference>,
    /// List of the patient's food and nutrition-related allergies and intolerances
    #[prost(message, repeated, tag = "15")]
    pub allergy_intolerance: prost::alloc::vec::Vec<Reference>,
    /// Order-specific modifier about the type of food that should be given
    #[prost(message, repeated, tag = "16")]
    pub food_preference_modifier: prost::alloc::vec::Vec<CodeableConcept>,
    /// Order-specific modifier about the type of food that should not be given
    #[prost(message, repeated, tag = "17")]
    pub exclude_food_modifier: prost::alloc::vec::Vec<CodeableConcept>,
    #[prost(message, optional, tag = "18")]
    pub oral_diet: ::core::option::Option<nutrition_order::OralDiet>,
    #[prost(message, repeated, tag = "19")]
    pub supplement: prost::alloc::vec::Vec<nutrition_order::Supplement>,
    #[prost(message, optional, tag = "20")]
    pub enteral_formula: ::core::option::Option<nutrition_order::EnteralFormula>,
}
/// Nested message and enum types in `NutritionOrder`.
pub mod nutrition_order {
    /// Oral diet components
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OralDiet {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of oral diet or diet restrictions that describe what can be consumed
        /// orally
        #[prost(message, repeated, tag = "4")]
        pub r#type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Scheduled frequency of diet
        #[prost(message, repeated, tag = "5")]
        pub schedule: prost::alloc::vec::Vec<super::Timing>,
        #[prost(message, repeated, tag = "6")]
        pub nutrient: prost::alloc::vec::Vec<oral_diet::Nutrient>,
        #[prost(message, repeated, tag = "7")]
        pub texture: prost::alloc::vec::Vec<oral_diet::Texture>,
        /// The required consistency of fluids and liquids provided to the patient
        #[prost(message, repeated, tag = "8")]
        pub fluid_consistency_type: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Instructions or additional information about the oral diet
        #[prost(message, optional, tag = "9")]
        pub instruction: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `OralDiet`.
    pub mod oral_diet {
        /// Required  nutrient modifications
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Nutrient {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Type of nutrient that is being modified
            #[prost(message, optional, tag = "4")]
            pub modifier: ::core::option::Option<super::super::CodeableConcept>,
            /// Quantity of the specified nutrient
            #[prost(message, optional, tag = "5")]
            pub amount: ::core::option::Option<super::super::SimpleQuantity>,
        }
        /// Required  texture modifications
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Texture {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Code to indicate how to alter the texture of the foods, e.g. pureed
            #[prost(message, optional, tag = "4")]
            pub modifier: ::core::option::Option<super::super::CodeableConcept>,
            /// Concepts that are used to identify an entity that is ingested for
            /// nutritional purposes
            #[prost(message, optional, tag = "5")]
            pub food_type: ::core::option::Option<super::super::CodeableConcept>,
        }
    }
    /// Supplement components
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Supplement {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of supplement product requested
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Product or brand name of the nutritional supplement
        #[prost(message, optional, tag = "5")]
        pub product_name: ::core::option::Option<super::String>,
        /// Scheduled frequency of supplement
        #[prost(message, repeated, tag = "6")]
        pub schedule: prost::alloc::vec::Vec<super::Timing>,
        /// Amount of the nutritional supplement
        #[prost(message, optional, tag = "7")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Instructions or additional information about the oral supplement
        #[prost(message, optional, tag = "8")]
        pub instruction: ::core::option::Option<super::String>,
    }
    /// Enteral formula components
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct EnteralFormula {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of enteral or infant formula
        #[prost(message, optional, tag = "4")]
        pub base_formula_type: ::core::option::Option<super::CodeableConcept>,
        /// Product or brand name of the enteral or infant formula
        #[prost(message, optional, tag = "5")]
        pub base_formula_product_name: ::core::option::Option<super::String>,
        /// Type of modular component to add to the feeding
        #[prost(message, optional, tag = "6")]
        pub additive_type: ::core::option::Option<super::CodeableConcept>,
        /// Product or brand name of the modular additive
        #[prost(message, optional, tag = "7")]
        pub additive_product_name: ::core::option::Option<super::String>,
        /// Amount of energy per specified volume that is required
        #[prost(message, optional, tag = "8")]
        pub caloric_density: ::core::option::Option<super::SimpleQuantity>,
        /// How the formula should enter the patient's gastrointestinal tract
        #[prost(message, optional, tag = "9")]
        pub routeof_administration: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, repeated, tag = "10")]
        pub administration: prost::alloc::vec::Vec<enteral_formula::Administration>,
        /// Upper limit on formula volume per unit of time
        #[prost(message, optional, tag = "11")]
        pub max_volume_to_deliver: ::core::option::Option<super::SimpleQuantity>,
        /// Formula feeding instructions expressed as text
        #[prost(message, optional, tag = "12")]
        pub administration_instruction: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `EnteralFormula`.
    pub mod enteral_formula {
        /// Formula feeding instruction as structured data
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Administration {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Scheduled frequency of enteral feeding
            #[prost(message, optional, tag = "4")]
            pub schedule: ::core::option::Option<super::super::Timing>,
            /// The volume of formula to provide
            #[prost(message, optional, tag = "5")]
            pub quantity: ::core::option::Option<super::super::SimpleQuantity>,
            #[prost(message, optional, tag = "6")]
            pub rate: ::core::option::Option<administration::Rate>,
        }
        /// Nested message and enum types in `Administration`.
        pub mod administration {
            /// Speed with which the formula is provided per period of time
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Rate {
                #[prost(oneof = "rate::Rate", tags = "1, 2")]
                pub rate: ::core::option::Option<rate::Rate>,
            }
            /// Nested message and enum types in `Rate`.
            pub mod rate {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Rate {
                    #[prost(message, tag = "1")]
                    Quantity(super::super::super::super::SimpleQuantity),
                    #[prost(message, tag = "2")]
                    Ratio(super::super::super::super::Ratio),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Observation, last updated
/// 2017-04-19T07:44:43.294+10:00. Measurements and simple assertions. See
/// <http://hl7.org/fhir/StructureDefinition/Observation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Observation {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for observation
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Fulfills plan, proposal or order
    #[prost(message, repeated, tag = "10")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// registered | preliminary | final | amended +
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<ObservationStatusCode>,
    /// Classification of  type of observation
    #[prost(message, repeated, tag = "12")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Type of observation (code / type)
    #[prost(message, optional, tag = "13")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who and/or what this is about
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Healthcare event during which this observation is made
    #[prost(message, optional, tag = "15")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "16")]
    pub effective: ::core::option::Option<observation::Effective>,
    /// Date/Time this was made available
    #[prost(message, optional, tag = "17")]
    pub issued: ::core::option::Option<Instant>,
    /// Who is responsible for the observation
    #[prost(message, repeated, tag = "18")]
    pub performer: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "19")]
    pub value: ::core::option::Option<observation::Value>,
    /// Why the result is missing
    #[prost(message, optional, tag = "20")]
    pub data_absent_reason: ::core::option::Option<CodeableConcept>,
    /// High, low, normal, etc.
    #[prost(message, optional, tag = "21")]
    pub interpretation: ::core::option::Option<CodeableConcept>,
    /// Comments about result
    #[prost(message, optional, tag = "22")]
    pub comment: ::core::option::Option<String>,
    /// Observed body part
    #[prost(message, optional, tag = "23")]
    pub body_site: ::core::option::Option<CodeableConcept>,
    /// How it was done
    #[prost(message, optional, tag = "24")]
    pub method: ::core::option::Option<CodeableConcept>,
    /// Specimen used for this observation
    #[prost(message, optional, tag = "25")]
    pub specimen: ::core::option::Option<Reference>,
    /// (Measurement) Device
    #[prost(message, optional, tag = "26")]
    pub device: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "27")]
    pub reference_range: prost::alloc::vec::Vec<observation::ReferenceRange>,
    #[prost(message, repeated, tag = "28")]
    pub related: prost::alloc::vec::Vec<observation::Related>,
    #[prost(message, repeated, tag = "29")]
    pub component: prost::alloc::vec::Vec<observation::Component>,
}
/// Nested message and enum types in `Observation`.
pub mod observation {
    /// Clinically relevant time/time-period for observation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Effective {
        #[prost(oneof = "effective::Effective", tags = "1, 2")]
        pub effective: ::core::option::Option<effective::Effective>,
    }
    /// Nested message and enum types in `Effective`.
    pub mod effective {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Effective {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Actual result
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Value {
        #[prost(oneof = "value::Value", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11")]
        pub value: ::core::option::Option<value::Value>,
    }
    /// Nested message and enum types in `Value`.
    pub mod value {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Value {
            #[prost(message, tag = "1")]
            Quantity(super::super::Quantity),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "3")]
            StringValue(super::super::String),
            #[prost(message, tag = "4")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "5")]
            Range(super::super::Range),
            #[prost(message, tag = "6")]
            Ratio(super::super::Ratio),
            #[prost(message, tag = "7")]
            SampledData(super::super::SampledData),
            #[prost(message, tag = "8")]
            Attachment(super::super::Attachment),
            #[prost(message, tag = "9")]
            Time(super::super::Time),
            #[prost(message, tag = "10")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "11")]
            Period(super::super::Period),
        }
    }
    /// Provides guide for interpretation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ReferenceRange {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Low Range, if relevant
        #[prost(message, optional, tag = "4")]
        pub low: ::core::option::Option<super::SimpleQuantity>,
        /// High Range, if relevant
        #[prost(message, optional, tag = "5")]
        pub high: ::core::option::Option<super::SimpleQuantity>,
        /// Reference range qualifier
        #[prost(message, optional, tag = "6")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Reference range population
        #[prost(message, repeated, tag = "7")]
        pub applies_to: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Applicable age range, if relevant
        #[prost(message, optional, tag = "8")]
        pub age: ::core::option::Option<super::Range>,
        /// Text based reference range in an observation
        #[prost(message, optional, tag = "9")]
        pub text: ::core::option::Option<super::String>,
    }
    /// Resource related to this observation
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Related {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// has-member | derived-from | sequel-to | replaces | qualified-by |
        /// interfered-by
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::ObservationRelationshipTypeCode>,
        /// Resource that is related to this one
        #[prost(message, optional, tag = "5")]
        pub target: ::core::option::Option<super::Reference>,
    }
    /// Component results
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Component {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type of component observation (code / type)
        #[prost(message, optional, tag = "4")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<component::Value>,
        /// Why the component result is missing
        #[prost(message, optional, tag = "6")]
        pub data_absent_reason: ::core::option::Option<super::CodeableConcept>,
        /// High, low, normal, etc.
        #[prost(message, optional, tag = "7")]
        pub interpretation: ::core::option::Option<super::CodeableConcept>,
        /// Provides guide for interpretation of component result
        #[prost(message, repeated, tag = "8")]
        pub reference_range: prost::alloc::vec::Vec<ReferenceRange>,
    }
    /// Nested message and enum types in `Component`.
    pub mod component {
        /// Actual component result
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Value {
            #[prost(oneof = "value::Value", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
            pub value: ::core::option::Option<value::Value>,
        }
        /// Nested message and enum types in `Value`.
        pub mod value {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Value {
                #[prost(message, tag = "1")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "2")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "3")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "4")]
                Range(super::super::super::Range),
                #[prost(message, tag = "5")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "6")]
                SampledData(super::super::super::SampledData),
                #[prost(message, tag = "7")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "8")]
                Time(super::super::super::Time),
                #[prost(message, tag = "9")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "10")]
                Period(super::super::super::Period),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for OperationDefinition, last updated
/// 2017-04-19T07:44:43.294+10:00. Definition of an operation or a named query.
/// See <http://hl7.org/fhir/StructureDefinition/OperationDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this operation definition (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the operation definition
    #[prost(message, optional, tag = "10")]
    pub version: ::core::option::Option<String>,
    /// Name for this operation definition (computer friendly)
    #[prost(message, optional, tag = "11")]
    pub name: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// operation | query
    #[prost(message, optional, tag = "13")]
    pub kind: ::core::option::Option<OperationKindCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "14")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "15")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "16")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "17")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the operation definition
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "19")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for operation definition (if applicable)
    #[prost(message, repeated, tag = "20")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this operation definition is defined
    #[prost(message, optional, tag = "21")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Whether content is unchanged by the operation
    #[prost(message, optional, tag = "22")]
    pub idempotent: ::core::option::Option<Boolean>,
    /// Name used to invoke the operation
    #[prost(message, optional, tag = "23")]
    pub code: ::core::option::Option<Code>,
    /// Additional information about use
    #[prost(message, optional, tag = "24")]
    pub comment: ::core::option::Option<String>,
    /// Marks this as a profile of the base
    #[prost(message, optional, tag = "25")]
    pub base: ::core::option::Option<Reference>,
    /// Types this operation applies to
    #[prost(message, repeated, tag = "26")]
    pub resource: prost::alloc::vec::Vec<ResourceTypeCode>,
    /// Invoke at the system level?
    #[prost(message, optional, tag = "27")]
    pub system: ::core::option::Option<Boolean>,
    /// Invole at the type level?
    #[prost(message, optional, tag = "28")]
    pub r#type: ::core::option::Option<Boolean>,
    /// Invoke on an instance?
    #[prost(message, optional, tag = "29")]
    pub instance: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "30")]
    pub parameter: prost::alloc::vec::Vec<operation_definition::Parameter>,
    #[prost(message, repeated, tag = "31")]
    pub overload: prost::alloc::vec::Vec<operation_definition::Overload>,
}
/// Nested message and enum types in `OperationDefinition`.
pub mod operation_definition {
    /// Parameters for the operation/query
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Parameter {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name in Parameters.parameter.name or in URL
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::Code>,
        /// in | out
        #[prost(message, optional, tag = "5")]
        pub r#use: ::core::option::Option<super::OperationParameterUseCode>,
        /// Minimum Cardinality
        #[prost(message, optional, tag = "6")]
        pub min: ::core::option::Option<super::Integer>,
        /// Maximum Cardinality (a number or *)
        #[prost(message, optional, tag = "7")]
        pub max: ::core::option::Option<super::String>,
        /// Description of meaning/use
        #[prost(message, optional, tag = "8")]
        pub documentation: ::core::option::Option<super::String>,
        /// What type this parameter has
        #[prost(message, optional, tag = "9")]
        pub r#type: ::core::option::Option<super::FhirAllTypesCode>,
        /// number | date | string | token | reference | composite | quantity | uri
        #[prost(message, optional, tag = "10")]
        pub search_type: ::core::option::Option<super::SearchParamTypeCode>,
        /// Profile on the type
        #[prost(message, optional, tag = "11")]
        pub profile: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "12")]
        pub binding: ::core::option::Option<parameter::Binding>,
        /// Parts of a nested Parameter
        #[prost(message, repeated, tag = "13")]
        pub part: prost::alloc::vec::Vec<Parameter>,
    }
    /// Nested message and enum types in `Parameter`.
    pub mod parameter {
        /// ValueSet details if this is coded
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Binding {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// required | extensible | preferred | example
            #[prost(message, optional, tag = "4")]
            pub strength: ::core::option::Option<super::super::BindingStrengthCode>,
            #[prost(message, optional, tag = "5")]
            pub value_set: ::core::option::Option<binding::ValueSet>,
        }
        /// Nested message and enum types in `Binding`.
        pub mod binding {
            /// Source of value set
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ValueSet {
                #[prost(oneof = "value_set::ValueSet", tags = "1, 2")]
                pub value_set: ::core::option::Option<value_set::ValueSet>,
            }
            /// Nested message and enum types in `ValueSet`.
            pub mod value_set {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum ValueSet {
                    #[prost(message, tag = "1")]
                    Uri(super::super::super::super::Uri),
                    #[prost(message, tag = "2")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
    }
    /// Define overloaded variants for when  generating code
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Overload {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name of parameter to include in overload
        #[prost(message, repeated, tag = "4")]
        pub parameter_name: prost::alloc::vec::Vec<super::String>,
        /// Comments to go on overload
        #[prost(message, optional, tag = "5")]
        pub comment: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for OperationOutcome, last updated
/// 2017-04-19T07:44:43.294+10:00. Information about the success/failure of an
/// action. See <http://hl7.org/fhir/StructureDefinition/OperationOutcome>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct OperationOutcome {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    #[prost(message, repeated, tag = "9")]
    pub issue: prost::alloc::vec::Vec<operation_outcome::Issue>,
}
/// Nested message and enum types in `OperationOutcome`.
pub mod operation_outcome {
    /// A single issue associated with the action
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Issue {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// fatal | error | warning | information
        #[prost(message, optional, tag = "4")]
        pub severity: ::core::option::Option<super::IssueSeverityCode>,
        /// Error or warning code
        #[prost(message, optional, tag = "5")]
        pub code: ::core::option::Option<super::IssueTypeCode>,
        /// Additional details about the error
        #[prost(message, optional, tag = "6")]
        pub details: ::core::option::Option<super::CodeableConcept>,
        /// Additional diagnostic information about the issue
        #[prost(message, optional, tag = "7")]
        pub diagnostics: ::core::option::Option<super::String>,
        /// Path of element(s) related to issue
        #[prost(message, repeated, tag = "8")]
        pub location: prost::alloc::vec::Vec<super::String>,
        /// FHIRPath of element(s) related to issue
        #[prost(message, repeated, tag = "9")]
        pub expression: prost::alloc::vec::Vec<super::String>,
    }
}
/// Auto-generated from StructureDefinition for Organization, last updated
/// 2017-04-19T07:44:43.294+10:00. A grouping of people or organizations with a
/// common purpose. See <http://hl7.org/fhir/StructureDefinition/Organization>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Organization {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifies this organization  across multiple systems
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether the organization's record is still in active use
    #[prost(message, optional, tag = "10")]
    pub active: ::core::option::Option<Boolean>,
    /// Kind of organization
    #[prost(message, repeated, tag = "11")]
    pub r#type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Name used for the organization
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// A list of alternate names that the organization is known as, or was known
    /// as in the past
    #[prost(message, repeated, tag = "13")]
    pub alias: prost::alloc::vec::Vec<String>,
    /// A contact detail for the organization
    #[prost(message, repeated, tag = "14")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// An address for the organization
    #[prost(message, repeated, tag = "15")]
    pub address: prost::alloc::vec::Vec<Address>,
    /// The organization of which this organization forms a part
    #[prost(message, optional, tag = "16")]
    pub part_of: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "17")]
    pub contact: prost::alloc::vec::Vec<organization::Contact>,
    /// Technical endpoints providing access to services operated for the
    /// organization
    #[prost(message, repeated, tag = "18")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `Organization`.
pub mod organization {
    /// Contact for the organization for a certain purpose
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Contact {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The type of contact
        #[prost(message, optional, tag = "4")]
        pub purpose: ::core::option::Option<super::CodeableConcept>,
        /// A name associated with the contact
        #[prost(message, optional, tag = "5")]
        pub name: ::core::option::Option<super::HumanName>,
        /// Contact details (telephone, email, etc.)  for a contact
        #[prost(message, repeated, tag = "6")]
        pub telecom: prost::alloc::vec::Vec<super::ContactPoint>,
        /// Visiting or postal addresses for the contact
        #[prost(message, optional, tag = "7")]
        pub address: ::core::option::Option<super::Address>,
    }
}
/// Auto-generated from StructureDefinition for Parameters, last updated
/// 2017-04-19T07:44:43.294+10:00. Operation Request or Response. See
/// <http://hl7.org/fhir/StructureDefinition/Parameters>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Parameters {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    #[prost(message, repeated, tag = "5")]
    pub parameter: prost::alloc::vec::Vec<parameters::Parameter>,
}
/// Nested message and enum types in `Parameters`.
pub mod parameters {
    /// Operation Parameter
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Parameter {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Name from the definition
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<parameter::Value>,
        /// If parameter is a whole resource
        #[prost(message, optional, tag = "6")]
        pub resource: ::core::option::Option<super::ContainedResource>,
        /// Named part of a multi-part parameter
        #[prost(message, repeated, tag = "7")]
        pub part: prost::alloc::vec::Vec<Parameter>,
    }
    /// Nested message and enum types in `Parameter`.
    pub mod parameter {
        /// If parameter is a data type
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Value {
            #[prost(
                oneof = "value::Value",
                tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
            )]
            pub value: ::core::option::Option<value::Value>,
        }
        /// Nested message and enum types in `Value`.
        pub mod value {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Value {
                #[prost(message, tag = "1")]
                Base64Binary(super::super::super::Base64Binary),
                #[prost(message, tag = "2")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "3")]
                Code(super::super::super::Code),
                #[prost(message, tag = "4")]
                Date(super::super::super::Date),
                #[prost(message, tag = "5")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "6")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "7")]
                Id(super::super::super::Id),
                #[prost(message, tag = "8")]
                Instant(super::super::super::Instant),
                #[prost(message, tag = "9")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "10")]
                Markdown(super::super::super::Markdown),
                #[prost(message, tag = "11")]
                Oid(super::super::super::Oid),
                #[prost(message, tag = "12")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "13")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "14")]
                Time(super::super::super::Time),
                #[prost(message, tag = "15")]
                UnsignedInt(super::super::super::UnsignedInt),
                #[prost(message, tag = "16")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "17")]
                Address(super::super::super::Address),
                #[prost(message, tag = "18")]
                Age(super::super::super::Age),
                #[prost(message, tag = "19")]
                Annotation(super::super::super::Annotation),
                #[prost(message, tag = "20")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "21")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "22")]
                Coding(super::super::super::Coding),
                #[prost(message, tag = "23")]
                ContactPoint(super::super::super::ContactPoint),
                #[prost(message, tag = "24")]
                Count(super::super::super::Count),
                #[prost(message, tag = "25")]
                Distance(super::super::super::Distance),
                #[prost(message, tag = "26")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "27")]
                HumanName(super::super::super::HumanName),
                #[prost(message, tag = "28")]
                Identifier(super::super::super::Identifier),
                #[prost(message, tag = "29")]
                Money(super::super::super::Money),
                #[prost(message, tag = "30")]
                Period(super::super::super::Period),
                #[prost(message, tag = "31")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "32")]
                Range(super::super::super::Range),
                #[prost(message, tag = "33")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "34")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "35")]
                SampledData(super::super::super::SampledData),
                #[prost(message, tag = "36")]
                Signature(super::super::super::Signature),
                #[prost(message, tag = "37")]
                Timing(super::super::super::Timing),
                #[prost(message, tag = "38")]
                Meta(super::super::super::Meta),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Patient, last updated
/// 2017-04-19T07:44:43.294+10:00. Information about an individual or animal
/// receiving health care services. See
/// <http://hl7.org/fhir/StructureDefinition/Patient>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Patient {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// An identifier for this patient
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this patient's record is in active use
    #[prost(message, optional, tag = "10")]
    pub active: ::core::option::Option<Boolean>,
    /// A name associated with the patient
    #[prost(message, repeated, tag = "11")]
    pub name: prost::alloc::vec::Vec<HumanName>,
    /// A contact detail for the individual
    #[prost(message, repeated, tag = "12")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// male | female | other | unknown
    #[prost(message, optional, tag = "13")]
    pub gender: ::core::option::Option<AdministrativeGenderCode>,
    /// The date of birth for the individual
    #[prost(message, optional, tag = "14")]
    pub birth_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "15")]
    pub deceased: ::core::option::Option<patient::Deceased>,
    /// Addresses for the individual
    #[prost(message, repeated, tag = "16")]
    pub address: prost::alloc::vec::Vec<Address>,
    /// Marital (civil) status of a patient
    #[prost(message, optional, tag = "17")]
    pub marital_status: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "18")]
    pub multiple_birth: ::core::option::Option<patient::MultipleBirth>,
    /// Image of the patient
    #[prost(message, repeated, tag = "19")]
    pub photo: prost::alloc::vec::Vec<Attachment>,
    #[prost(message, repeated, tag = "20")]
    pub contact: prost::alloc::vec::Vec<patient::Contact>,
    #[prost(message, optional, tag = "21")]
    pub animal: ::core::option::Option<patient::Animal>,
    #[prost(message, repeated, tag = "22")]
    pub communication: prost::alloc::vec::Vec<patient::Communication>,
    /// Patient's nominated primary care provider
    #[prost(message, repeated, tag = "23")]
    pub general_practitioner: prost::alloc::vec::Vec<Reference>,
    /// Organization that is the custodian of the patient record
    #[prost(message, optional, tag = "24")]
    pub managing_organization: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "25")]
    pub link: prost::alloc::vec::Vec<patient::Link>,
}
/// Nested message and enum types in `Patient`.
pub mod patient {
    /// Indicates if the individual is deceased or not
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Deceased {
        #[prost(oneof = "deceased::Deceased", tags = "1, 2")]
        pub deceased: ::core::option::Option<deceased::Deceased>,
    }
    /// Nested message and enum types in `Deceased`.
    pub mod deceased {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Deceased {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            DateTime(super::super::DateTime),
        }
    }
    /// Whether patient is part of a multiple birth
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct MultipleBirth {
        #[prost(oneof = "multiple_birth::MultipleBirth", tags = "1, 2")]
        pub multiple_birth: ::core::option::Option<multiple_birth::MultipleBirth>,
    }
    /// Nested message and enum types in `MultipleBirth`.
    pub mod multiple_birth {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum MultipleBirth {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            Integer(super::super::Integer),
        }
    }
    /// A contact party (e.g. guardian, partner, friend) for the patient
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Contact {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The kind of relationship
        #[prost(message, repeated, tag = "4")]
        pub relationship: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// A name associated with the contact person
        #[prost(message, optional, tag = "5")]
        pub name: ::core::option::Option<super::HumanName>,
        /// A contact detail for the person
        #[prost(message, repeated, tag = "6")]
        pub telecom: prost::alloc::vec::Vec<super::ContactPoint>,
        /// Address for the contact person
        #[prost(message, optional, tag = "7")]
        pub address: ::core::option::Option<super::Address>,
        /// male | female | other | unknown
        #[prost(message, optional, tag = "8")]
        pub gender: ::core::option::Option<super::AdministrativeGenderCode>,
        /// Organization that is associated with the contact
        #[prost(message, optional, tag = "9")]
        pub organization: ::core::option::Option<super::Reference>,
        /// The period during which this contact person or organization is valid to
        /// be contacted relating to this patient
        #[prost(message, optional, tag = "10")]
        pub period: ::core::option::Option<super::Period>,
    }
    /// This patient is known to be an animal (non-human)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Animal {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// E.g. Dog, Cow
        #[prost(message, optional, tag = "4")]
        pub species: ::core::option::Option<super::CodeableConcept>,
        /// E.g. Poodle, Angus
        #[prost(message, optional, tag = "5")]
        pub breed: ::core::option::Option<super::CodeableConcept>,
        /// E.g. Neutered, Intact
        #[prost(message, optional, tag = "6")]
        pub gender_status: ::core::option::Option<super::CodeableConcept>,
    }
    /// A list of Languages which may be used to communicate with the patient about
    /// his or her health
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Communication {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The language which can be used to communicate with the patient about his
        /// or her health
        #[prost(message, optional, tag = "4")]
        pub language: ::core::option::Option<super::CodeableConcept>,
        /// Language preference indicator
        #[prost(message, optional, tag = "5")]
        pub preferred: ::core::option::Option<super::Boolean>,
    }
    /// Link to another patient resource that concerns the same actual person
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Link {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The other patient or related person resource that the link refers to
        #[prost(message, optional, tag = "4")]
        pub other: ::core::option::Option<super::Reference>,
        /// replaced-by | replaces | refer | seealso - type of link
        #[prost(message, optional, tag = "5")]
        pub r#type: ::core::option::Option<super::LinkTypeCode>,
    }
}
/// Auto-generated from StructureDefinition for PaymentNotice, last updated
/// 2017-04-19T07:44:43.294+10:00. PaymentNotice request. See
/// <http://hl7.org/fhir/StructureDefinition/PaymentNotice>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PaymentNotice {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// Request reference
    #[prost(message, optional, tag = "11")]
    pub request: ::core::option::Option<Reference>,
    /// Response reference
    #[prost(message, optional, tag = "12")]
    pub response: ::core::option::Option<Reference>,
    /// Payment or clearing date
    #[prost(message, optional, tag = "13")]
    pub status_date: ::core::option::Option<Date>,
    /// Creation date
    #[prost(message, optional, tag = "14")]
    pub created: ::core::option::Option<DateTime>,
    /// Insurer or Regulatory body
    #[prost(message, optional, tag = "15")]
    pub target: ::core::option::Option<Reference>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "16")]
    pub provider: ::core::option::Option<Reference>,
    /// Responsible organization
    #[prost(message, optional, tag = "17")]
    pub organization: ::core::option::Option<Reference>,
    /// Whether payment has been sent or cleared
    #[prost(message, optional, tag = "18")]
    pub payment_status: ::core::option::Option<CodeableConcept>,
}
/// Auto-generated from StructureDefinition for PaymentReconciliation, last
/// updated 2017-04-19T07:44:43.294+10:00. PaymentReconciliation resource. See
/// <http://hl7.org/fhir/StructureDefinition/PaymentReconciliation>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PaymentReconciliation {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// Period covered
    #[prost(message, optional, tag = "11")]
    pub period: ::core::option::Option<Period>,
    /// Creation date
    #[prost(message, optional, tag = "12")]
    pub created: ::core::option::Option<DateTime>,
    /// Insurer
    #[prost(message, optional, tag = "13")]
    pub organization: ::core::option::Option<Reference>,
    /// Claim reference
    #[prost(message, optional, tag = "14")]
    pub request: ::core::option::Option<Reference>,
    /// complete | error | partial
    #[prost(message, optional, tag = "15")]
    pub outcome: ::core::option::Option<CodeableConcept>,
    /// Disposition Message
    #[prost(message, optional, tag = "16")]
    pub disposition: ::core::option::Option<String>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "17")]
    pub request_provider: ::core::option::Option<Reference>,
    /// Responsible organization
    #[prost(message, optional, tag = "18")]
    pub request_organization: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "19")]
    pub detail: prost::alloc::vec::Vec<payment_reconciliation::Details>,
    /// Printed Form Identifier
    #[prost(message, optional, tag = "20")]
    pub form: ::core::option::Option<CodeableConcept>,
    /// Total amount of Payment
    #[prost(message, optional, tag = "21")]
    pub total: ::core::option::Option<Money>,
    #[prost(message, repeated, tag = "22")]
    pub process_note: prost::alloc::vec::Vec<payment_reconciliation::Notes>,
}
/// Nested message and enum types in `PaymentReconciliation`.
pub mod payment_reconciliation {
    /// List of settlements
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Details {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Type code
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Claim
        #[prost(message, optional, tag = "5")]
        pub request: ::core::option::Option<super::Reference>,
        /// Claim Response
        #[prost(message, optional, tag = "6")]
        pub response: ::core::option::Option<super::Reference>,
        /// Organization which submitted the claim
        #[prost(message, optional, tag = "7")]
        pub submitter: ::core::option::Option<super::Reference>,
        /// Organization which is receiving the payment
        #[prost(message, optional, tag = "8")]
        pub payee: ::core::option::Option<super::Reference>,
        /// Invoice date
        #[prost(message, optional, tag = "9")]
        pub date: ::core::option::Option<super::Date>,
        /// Amount being paid
        #[prost(message, optional, tag = "10")]
        pub amount: ::core::option::Option<super::Money>,
    }
    /// Processing comments
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Notes {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// display | print | printoper
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Comment on the processing
        #[prost(message, optional, tag = "5")]
        pub text: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for Person, last updated
/// 2017-04-19T07:44:43.294+10:00. A generic person record. See
/// <http://hl7.org/fhir/StructureDefinition/Person>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Person {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// A human identifier for this person
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// A name associated with the person
    #[prost(message, repeated, tag = "10")]
    pub name: prost::alloc::vec::Vec<HumanName>,
    /// A contact detail for the person
    #[prost(message, repeated, tag = "11")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// male | female | other | unknown
    #[prost(message, optional, tag = "12")]
    pub gender: ::core::option::Option<AdministrativeGenderCode>,
    /// The date on which the person was born
    #[prost(message, optional, tag = "13")]
    pub birth_date: ::core::option::Option<Date>,
    /// One or more addresses for the person
    #[prost(message, repeated, tag = "14")]
    pub address: prost::alloc::vec::Vec<Address>,
    /// Image of the person
    #[prost(message, optional, tag = "15")]
    pub photo: ::core::option::Option<Attachment>,
    /// The organization that is the custodian of the person record
    #[prost(message, optional, tag = "16")]
    pub managing_organization: ::core::option::Option<Reference>,
    /// This person's record is in active use
    #[prost(message, optional, tag = "17")]
    pub active: ::core::option::Option<Boolean>,
    #[prost(message, repeated, tag = "18")]
    pub link: prost::alloc::vec::Vec<person::Link>,
}
/// Nested message and enum types in `Person`.
pub mod person {
    /// Link to a resource that concerns the same actual person
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Link {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The resource to which this actual person is associated
        #[prost(message, optional, tag = "4")]
        pub target: ::core::option::Option<super::Reference>,
        /// level1 | level2 | level3 | level4
        #[prost(message, optional, tag = "5")]
        pub assurance: ::core::option::Option<super::IdentityAssuranceLevelCode>,
    }
}
/// Auto-generated from StructureDefinition for PlanDefinition, last updated
/// 2017-04-19T07:44:43.294+10:00. The definition of a plan for a series of
/// actions, independent of any specific patient or context. See
/// <http://hl7.org/fhir/StructureDefinition/PlanDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PlanDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this plan definition (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the plan definition
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the plan definition
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this plan definition (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this plan definition (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// order-set | protocol | eca-rule
    #[prost(message, optional, tag = "14")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "16")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "17")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "18")]
    pub publisher: ::core::option::Option<String>,
    /// Natural language description of the plan definition
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Why this plan definition is defined
    #[prost(message, optional, tag = "20")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the asset
    #[prost(message, optional, tag = "21")]
    pub usage: ::core::option::Option<String>,
    /// When the plan definition was approved by publisher
    #[prost(message, optional, tag = "22")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the plan definition was last reviewed
    #[prost(message, optional, tag = "23")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the plan definition is expected to be used
    #[prost(message, optional, tag = "24")]
    pub effective_period: ::core::option::Option<Period>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "25")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for plan definition (if applicable)
    #[prost(message, repeated, tag = "26")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// E.g. Education, Treatment, Assessment, etc
    #[prost(message, repeated, tag = "27")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// A content contributor
    #[prost(message, repeated, tag = "28")]
    pub contributor: prost::alloc::vec::Vec<Contributor>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "29")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "30")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Related artifacts for the asset
    #[prost(message, repeated, tag = "31")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Logic used by the plan definition
    #[prost(message, repeated, tag = "32")]
    pub library: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "33")]
    pub goal: prost::alloc::vec::Vec<plan_definition::Goal>,
    #[prost(message, repeated, tag = "34")]
    pub action: prost::alloc::vec::Vec<plan_definition::Action>,
}
/// Nested message and enum types in `PlanDefinition`.
pub mod plan_definition {
    /// What the plan is trying to accomplish
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Goal {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// E.g. Treatment, dietary, behavioral, etc
        #[prost(message, optional, tag = "4")]
        pub category: ::core::option::Option<super::CodeableConcept>,
        /// Code or text describing the goal
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::CodeableConcept>,
        /// high-priority | medium-priority | low-priority
        #[prost(message, optional, tag = "6")]
        pub priority: ::core::option::Option<super::CodeableConcept>,
        /// When goal pursuit begins
        #[prost(message, optional, tag = "7")]
        pub start: ::core::option::Option<super::CodeableConcept>,
        /// What does the goal address
        #[prost(message, repeated, tag = "8")]
        pub addresses: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Supporting documentation for the goal
        #[prost(message, repeated, tag = "9")]
        pub documentation: prost::alloc::vec::Vec<super::RelatedArtifact>,
        #[prost(message, repeated, tag = "10")]
        pub target: prost::alloc::vec::Vec<goal::Target>,
    }
    /// Nested message and enum types in `Goal`.
    pub mod goal {
        /// Target outcome for the goal
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Target {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The parameter whose value is to be tracked
            #[prost(message, optional, tag = "4")]
            pub measure: ::core::option::Option<super::super::CodeableConcept>,
            #[prost(message, optional, tag = "5")]
            pub detail: ::core::option::Option<target::Detail>,
            /// Reach goal within
            #[prost(message, optional, tag = "6")]
            pub due: ::core::option::Option<super::super::Duration>,
        }
        /// Nested message and enum types in `Target`.
        pub mod target {
            /// The target value to be achieved
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Detail {
                #[prost(oneof = "detail::Detail", tags = "1, 2, 3")]
                pub detail: ::core::option::Option<detail::Detail>,
            }
            /// Nested message and enum types in `Detail`.
            pub mod detail {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Detail {
                    #[prost(message, tag = "1")]
                    Quantity(super::super::super::super::Quantity),
                    #[prost(message, tag = "2")]
                    Range(super::super::super::super::Range),
                    #[prost(message, tag = "3")]
                    CodeableConcept(super::super::super::super::CodeableConcept),
                }
            }
        }
    }
    /// Action defined by the plan
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Action {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// User-visible label for the action (e.g. 1. or A.)
        #[prost(message, optional, tag = "4")]
        pub label: ::core::option::Option<super::String>,
        /// User-visible title
        #[prost(message, optional, tag = "5")]
        pub title: ::core::option::Option<super::String>,
        /// Short description of the action
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        /// Static text equivalent of the action, used if the dynamic aspects cannot
        /// be interpreted by the receiving system
        #[prost(message, optional, tag = "7")]
        pub text_equivalent: ::core::option::Option<super::String>,
        /// Code representing the meaning of the action or sub-actions
        #[prost(message, repeated, tag = "8")]
        pub code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Why the action should be performed
        #[prost(message, repeated, tag = "9")]
        pub reason: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Supporting documentation for the intended performer of the action
        #[prost(message, repeated, tag = "10")]
        pub documentation: prost::alloc::vec::Vec<super::RelatedArtifact>,
        /// What goals this action supports
        #[prost(message, repeated, tag = "11")]
        pub goal_id: prost::alloc::vec::Vec<super::Id>,
        /// When the action should be triggered
        #[prost(message, repeated, tag = "12")]
        pub trigger_definition: prost::alloc::vec::Vec<super::TriggerDefinition>,
        #[prost(message, repeated, tag = "13")]
        pub condition: prost::alloc::vec::Vec<action::Condition>,
        /// Input data requirements
        #[prost(message, repeated, tag = "14")]
        pub input: prost::alloc::vec::Vec<super::DataRequirement>,
        /// Output data definition
        #[prost(message, repeated, tag = "15")]
        pub output: prost::alloc::vec::Vec<super::DataRequirement>,
        #[prost(message, repeated, tag = "16")]
        pub related_action: prost::alloc::vec::Vec<action::RelatedAction>,
        #[prost(message, optional, tag = "17")]
        pub timing: ::core::option::Option<action::TimingType>,
        #[prost(message, repeated, tag = "18")]
        pub participant: prost::alloc::vec::Vec<action::Participant>,
        /// create | update | remove | fire-event
        #[prost(message, optional, tag = "19")]
        pub r#type: ::core::option::Option<super::Coding>,
        /// visual-group | logical-group | sentence-group
        #[prost(message, optional, tag = "20")]
        pub grouping_behavior: ::core::option::Option<super::ActionGroupingBehaviorCode>,
        /// any | all | all-or-none | exactly-one | at-most-one | one-or-more
        #[prost(message, optional, tag = "21")]
        pub selection_behavior: ::core::option::Option<super::ActionSelectionBehaviorCode>,
        /// must | could | must-unless-documented
        #[prost(message, optional, tag = "22")]
        pub required_behavior: ::core::option::Option<super::ActionRequiredBehaviorCode>,
        /// yes | no
        #[prost(message, optional, tag = "23")]
        pub precheck_behavior: ::core::option::Option<super::ActionPrecheckBehaviorCode>,
        /// single | multiple
        #[prost(message, optional, tag = "24")]
        pub cardinality_behavior: ::core::option::Option<super::ActionCardinalityBehaviorCode>,
        /// Description of the activity to be performed
        #[prost(message, optional, tag = "25")]
        pub definition: ::core::option::Option<super::Reference>,
        /// Transform to apply the template
        #[prost(message, optional, tag = "26")]
        pub transform: ::core::option::Option<super::Reference>,
        #[prost(message, repeated, tag = "27")]
        pub dynamic_value: prost::alloc::vec::Vec<action::DynamicValue>,
        /// A sub-action
        #[prost(message, repeated, tag = "28")]
        pub action: prost::alloc::vec::Vec<Action>,
    }
    /// Nested message and enum types in `Action`.
    pub mod action {
        /// Whether or not the action is applicable
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Condition {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// applicability | start | stop
            #[prost(message, optional, tag = "4")]
            pub kind: ::core::option::Option<super::super::ActionConditionKindCode>,
            /// Natural language description of the condition
            #[prost(message, optional, tag = "5")]
            pub description: ::core::option::Option<super::super::String>,
            /// Language of the expression
            #[prost(message, optional, tag = "6")]
            pub language: ::core::option::Option<super::super::String>,
            /// Boolean-valued expression
            #[prost(message, optional, tag = "7")]
            pub expression: ::core::option::Option<super::super::String>,
        }
        /// Relationship to another action
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RelatedAction {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// What action is this related to
            #[prost(message, optional, tag = "4")]
            pub action_id: ::core::option::Option<super::super::Id>,
            /// before-start | before | before-end | concurrent-with-start | concurrent
            /// | concurrent-with-end | after-start | after | after-end
            #[prost(message, optional, tag = "5")]
            pub relationship: ::core::option::Option<super::super::ActionRelationshipTypeCode>,
            #[prost(message, optional, tag = "6")]
            pub offset: ::core::option::Option<related_action::Offset>,
        }
        /// Nested message and enum types in `RelatedAction`.
        pub mod related_action {
            /// Time offset for the relationship
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Offset {
                #[prost(oneof = "offset::Offset", tags = "1, 2")]
                pub offset: ::core::option::Option<offset::Offset>,
            }
            /// Nested message and enum types in `Offset`.
            pub mod offset {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Offset {
                    #[prost(message, tag = "1")]
                    Duration(super::super::super::super::Duration),
                    #[prost(message, tag = "2")]
                    Range(super::super::super::super::Range),
                }
            }
        }
        /// When the action should take place
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimingType {
            #[prost(oneof = "timing_type::Timing", tags = "1, 2, 3, 4, 5")]
            pub timing: ::core::option::Option<timing_type::Timing>,
        }
        /// Nested message and enum types in `TimingType`.
        pub mod timing_type {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Timing {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
                #[prost(message, tag = "3")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "4")]
                Range(super::super::super::Range),
                #[prost(message, tag = "5")]
                TimingValue(super::super::super::Timing),
            }
        }
        /// Who should participate in the action
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Participant {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// patient | practitioner | related-person
            #[prost(message, optional, tag = "4")]
            pub r#type: ::core::option::Option<super::super::ActionParticipantTypeCode>,
            /// E.g. Nurse, Surgeon, Parent, etc
            #[prost(message, optional, tag = "5")]
            pub role: ::core::option::Option<super::super::CodeableConcept>,
        }
        /// Dynamic aspects of the definition
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct DynamicValue {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Natural language description of the dynamic value
            #[prost(message, optional, tag = "4")]
            pub description: ::core::option::Option<super::super::String>,
            /// The path to the element to be set dynamically
            #[prost(message, optional, tag = "5")]
            pub path: ::core::option::Option<super::super::String>,
            /// Language of the expression
            #[prost(message, optional, tag = "6")]
            pub language: ::core::option::Option<super::super::String>,
            /// An expression that provides the dynamic value for the customization
            #[prost(message, optional, tag = "7")]
            pub expression: ::core::option::Option<super::super::String>,
        }
    }
}
/// Auto-generated from StructureDefinition for Practitioner, last updated
/// 2017-04-19T07:44:43.294+10:00. A person with a  formal responsibility in the
/// provisioning of healthcare or related services. See
/// <http://hl7.org/fhir/StructureDefinition/Practitioner>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Practitioner {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// A identifier for the person as this agent
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this practitioner's record is in active use
    #[prost(message, optional, tag = "10")]
    pub active: ::core::option::Option<Boolean>,
    /// The name(s) associated with the practitioner
    #[prost(message, repeated, tag = "11")]
    pub name: prost::alloc::vec::Vec<HumanName>,
    /// A contact detail for the practitioner (that apply to all roles)
    #[prost(message, repeated, tag = "12")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// Address(es) of the practitioner that are not role specific (typically home
    /// address)
    #[prost(message, repeated, tag = "13")]
    pub address: prost::alloc::vec::Vec<Address>,
    /// male | female | other | unknown
    #[prost(message, optional, tag = "14")]
    pub gender: ::core::option::Option<AdministrativeGenderCode>,
    /// The date  on which the practitioner was born
    #[prost(message, optional, tag = "15")]
    pub birth_date: ::core::option::Option<Date>,
    /// Image of the person
    #[prost(message, repeated, tag = "16")]
    pub photo: prost::alloc::vec::Vec<Attachment>,
    #[prost(message, repeated, tag = "17")]
    pub qualification: prost::alloc::vec::Vec<practitioner::Qualification>,
    /// A language the practitioner is able to use in patient communication
    #[prost(message, repeated, tag = "18")]
    pub communication: prost::alloc::vec::Vec<CodeableConcept>,
}
/// Nested message and enum types in `Practitioner`.
pub mod practitioner {
    /// Qualifications obtained by training and certification
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Qualification {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// An identifier for this qualification for the practitioner
        #[prost(message, repeated, tag = "4")]
        pub identifier: prost::alloc::vec::Vec<super::Identifier>,
        /// Coded representation of the qualification
        #[prost(message, optional, tag = "5")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Period during which the qualification is valid
        #[prost(message, optional, tag = "6")]
        pub period: ::core::option::Option<super::Period>,
        /// Organization that regulates and issues the qualification
        #[prost(message, optional, tag = "7")]
        pub issuer: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for PractitionerRole, last updated
/// 2017-04-19T07:44:43.294+10:00. Roles/organizations the practitioner is
/// associated with. See <http://hl7.org/fhir/StructureDefinition/PractitionerRole>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct PractitionerRole {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifiers that are specific to a role/location
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this practitioner's record is in active use
    #[prost(message, optional, tag = "10")]
    pub active: ::core::option::Option<Boolean>,
    /// The period during which the practitioner is authorized to perform in these
    /// role(s)
    #[prost(message, optional, tag = "11")]
    pub period: ::core::option::Option<Period>,
    /// Practitioner that is able to provide the defined services for the
    /// organation
    #[prost(message, optional, tag = "12")]
    pub practitioner: ::core::option::Option<Reference>,
    /// Organization where the roles are available
    #[prost(message, optional, tag = "13")]
    pub organization: ::core::option::Option<Reference>,
    /// Roles which this practitioner may perform
    #[prost(message, repeated, tag = "14")]
    pub code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Specific specialty of the practitioner
    #[prost(message, repeated, tag = "15")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// The location(s) at which this practitioner provides care
    #[prost(message, repeated, tag = "16")]
    pub location: prost::alloc::vec::Vec<Reference>,
    /// The list of healthcare services that this worker provides for this role's
    /// Organization/Location(s)
    #[prost(message, repeated, tag = "17")]
    pub healthcare_service: prost::alloc::vec::Vec<Reference>,
    /// Contact details that are specific to the role/location/service
    #[prost(message, repeated, tag = "18")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    #[prost(message, repeated, tag = "19")]
    pub available_time: prost::alloc::vec::Vec<practitioner_role::AvailableTime>,
    #[prost(message, repeated, tag = "20")]
    pub not_available: prost::alloc::vec::Vec<practitioner_role::NotAvailable>,
    /// Description of availability exceptions
    #[prost(message, optional, tag = "21")]
    pub availability_exceptions: ::core::option::Option<String>,
    /// Technical endpoints providing access to services operated for the
    /// practitioner with this role
    #[prost(message, repeated, tag = "22")]
    pub endpoint: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `PractitionerRole`.
pub mod practitioner_role {
    /// Times the Service Site is available
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AvailableTime {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// mon | tue | wed | thu | fri | sat | sun
        #[prost(message, repeated, tag = "4")]
        pub days_of_week: prost::alloc::vec::Vec<super::DaysOfWeekCode>,
        /// Always available? e.g. 24 hour service
        #[prost(message, optional, tag = "5")]
        pub all_day: ::core::option::Option<super::Boolean>,
        /// Opening time of day (ignored if allDay = true)
        #[prost(message, optional, tag = "6")]
        pub available_start_time: ::core::option::Option<super::Time>,
        /// Closing time of day (ignored if allDay = true)
        #[prost(message, optional, tag = "7")]
        pub available_end_time: ::core::option::Option<super::Time>,
    }
    /// Not available during this time due to provided reason
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct NotAvailable {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Reason presented to the user explaining why time not available
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Service not availablefrom this date
        #[prost(message, optional, tag = "5")]
        pub during: ::core::option::Option<super::Period>,
    }
}
/// Auto-generated from StructureDefinition for Procedure, last updated
/// 2017-04-19T07:44:43.294+10:00. An action that is being or was performed on a
/// patient. See <http://hl7.org/fhir/StructureDefinition/Procedure>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Procedure {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Identifiers for this procedure
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates protocol or definition
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Reference>,
    /// A request for this procedure
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced event
    #[prost(message, repeated, tag = "12")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// preparation | in-progress | suspended | aborted | completed |
    /// entered-in-error | unknown
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<EventStatusCode>,
    /// True if procedure was not performed as scheduled
    #[prost(message, optional, tag = "14")]
    pub not_done: ::core::option::Option<Boolean>,
    /// Reason procedure was not performed
    #[prost(message, optional, tag = "15")]
    pub not_done_reason: ::core::option::Option<CodeableConcept>,
    /// Classification of the procedure
    #[prost(message, optional, tag = "16")]
    pub category: ::core::option::Option<CodeableConcept>,
    /// Identification of the procedure
    #[prost(message, optional, tag = "17")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who the procedure was performed on
    #[prost(message, optional, tag = "18")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or episode associated with the procedure
    #[prost(message, optional, tag = "19")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "20")]
    pub performed: ::core::option::Option<procedure::Performed>,
    #[prost(message, repeated, tag = "21")]
    pub performer: prost::alloc::vec::Vec<procedure::Performer>,
    /// Where the procedure happened
    #[prost(message, optional, tag = "22")]
    pub location: ::core::option::Option<Reference>,
    /// Coded reason procedure performed
    #[prost(message, repeated, tag = "23")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Condition that is the reason the procedure performed
    #[prost(message, repeated, tag = "24")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Target body sites
    #[prost(message, repeated, tag = "25")]
    pub body_site: prost::alloc::vec::Vec<CodeableConcept>,
    /// The result of procedure
    #[prost(message, optional, tag = "26")]
    pub outcome: ::core::option::Option<CodeableConcept>,
    /// Any report resulting from the procedure
    #[prost(message, repeated, tag = "27")]
    pub report: prost::alloc::vec::Vec<Reference>,
    /// Complication following the procedure
    #[prost(message, repeated, tag = "28")]
    pub complication: prost::alloc::vec::Vec<CodeableConcept>,
    /// A condition that is a result of the procedure
    #[prost(message, repeated, tag = "29")]
    pub complication_detail: prost::alloc::vec::Vec<Reference>,
    /// Instructions for follow up
    #[prost(message, repeated, tag = "30")]
    pub follow_up: prost::alloc::vec::Vec<CodeableConcept>,
    /// Additional information about the procedure
    #[prost(message, repeated, tag = "31")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "32")]
    pub focal_device: prost::alloc::vec::Vec<procedure::FocalDevice>,
    /// Items used during procedure
    #[prost(message, repeated, tag = "33")]
    pub used_reference: prost::alloc::vec::Vec<Reference>,
    /// Coded items used during the procedure
    #[prost(message, repeated, tag = "34")]
    pub used_code: prost::alloc::vec::Vec<CodeableConcept>,
}
/// Nested message and enum types in `Procedure`.
pub mod procedure {
    /// Date/Period the procedure was performed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Performed {
        #[prost(oneof = "performed::Performed", tags = "1, 2")]
        pub performed: ::core::option::Option<performed::Performed>,
    }
    /// Nested message and enum types in `Performed`.
    pub mod performed {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Performed {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// The people who performed the procedure
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Performer {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The role the actor was in
        #[prost(message, optional, tag = "4")]
        pub role: ::core::option::Option<super::CodeableConcept>,
        /// The reference to the practitioner
        #[prost(message, optional, tag = "5")]
        pub actor: ::core::option::Option<super::Reference>,
        /// Organization the device or practitioner was acting for
        #[prost(message, optional, tag = "6")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
    /// Device changed in procedure
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct FocalDevice {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Kind of change to device
        #[prost(message, optional, tag = "4")]
        pub action: ::core::option::Option<super::CodeableConcept>,
        /// Device that was changed
        #[prost(message, optional, tag = "5")]
        pub manipulated: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for ProcedureRequest, last updated
/// 2017-04-19T07:44:43.294+10:00. A request for a procedure or diagnostic to be
/// performed. See <http://hl7.org/fhir/StructureDefinition/ProcedureRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProcedureRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Identifiers assigned to this order
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Protocol or definition
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Reference>,
    /// What request fulfills
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// What request replaces
    #[prost(message, repeated, tag = "12")]
    pub replaces: prost::alloc::vec::Vec<Reference>,
    /// Composite Request ID
    #[prost(message, optional, tag = "13")]
    pub requisition: ::core::option::Option<Identifier>,
    /// draft | active | suspended | completed | entered-in-error | cancelled
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<RequestStatusCode>,
    /// proposal | plan | order +
    #[prost(message, optional, tag = "15")]
    pub intent: ::core::option::Option<RequestIntentCode>,
    /// routine | urgent | asap | stat
    #[prost(message, optional, tag = "16")]
    pub priority: ::core::option::Option<RequestPriorityCode>,
    /// True if procedure should not be performed
    #[prost(message, optional, tag = "17")]
    pub do_not_perform: ::core::option::Option<Boolean>,
    /// Classification of procedure
    #[prost(message, repeated, tag = "18")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// What is being requested/ordered
    #[prost(message, optional, tag = "19")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Individual the service is ordered for
    #[prost(message, optional, tag = "20")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or Episode during which request was created
    #[prost(message, optional, tag = "21")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "22")]
    pub occurrence: ::core::option::Option<procedure_request::Occurrence>,
    #[prost(message, optional, tag = "23")]
    pub as_needed: ::core::option::Option<procedure_request::AsNeeded>,
    /// Date request signed
    #[prost(message, optional, tag = "24")]
    pub authored_on: ::core::option::Option<DateTime>,
    #[prost(message, optional, tag = "25")]
    pub requester: ::core::option::Option<procedure_request::Requester>,
    /// Performer role
    #[prost(message, optional, tag = "26")]
    pub performer_type: ::core::option::Option<CodeableConcept>,
    /// Requested perfomer
    #[prost(message, optional, tag = "27")]
    pub performer: ::core::option::Option<Reference>,
    /// Explanation/Justification for test
    #[prost(message, repeated, tag = "28")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Explanation/Justification for test
    #[prost(message, repeated, tag = "29")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// Additional clinical information
    #[prost(message, repeated, tag = "30")]
    pub supporting_info: prost::alloc::vec::Vec<Reference>,
    /// Procedure Samples
    #[prost(message, repeated, tag = "31")]
    pub specimen: prost::alloc::vec::Vec<Reference>,
    /// Location on Body
    #[prost(message, repeated, tag = "32")]
    pub body_site: prost::alloc::vec::Vec<CodeableConcept>,
    /// Comments
    #[prost(message, repeated, tag = "33")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Request provenance
    #[prost(message, repeated, tag = "34")]
    pub relevant_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `ProcedureRequest`.
pub mod procedure_request {
    /// When procedure should occur
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Occurrence {
        #[prost(oneof = "occurrence::Occurrence", tags = "1, 2, 3")]
        pub occurrence: ::core::option::Option<occurrence::Occurrence>,
    }
    /// Nested message and enum types in `Occurrence`.
    pub mod occurrence {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Occurrence {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
        }
    }
    /// Preconditions for procedure or diagnostic
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct AsNeeded {
        #[prost(oneof = "as_needed::AsNeeded", tags = "1, 2")]
        pub as_needed: ::core::option::Option<as_needed::AsNeeded>,
    }
    /// Nested message and enum types in `AsNeeded`.
    pub mod as_needed {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum AsNeeded {
            #[prost(message, tag = "1")]
            Boolean(super::super::Boolean),
            #[prost(message, tag = "2")]
            CodeableConcept(super::super::CodeableConcept),
        }
    }
    /// Who/what is requesting procedure or diagnostic
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Requester {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Individual making the request
        #[prost(message, optional, tag = "4")]
        pub agent: ::core::option::Option<super::Reference>,
        /// Organization agent is acting for
        #[prost(message, optional, tag = "5")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for ProcessRequest, last updated
/// 2017-04-19T07:44:43.294+10:00. Request to perform some action on or in
/// regards to an existing resource. See
/// <http://hl7.org/fhir/StructureDefinition/ProcessRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProcessRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// cancel | poll | reprocess | status
    #[prost(message, optional, tag = "11")]
    pub action: ::core::option::Option<ActionListCode>,
    /// Party which is the target of the request
    #[prost(message, optional, tag = "12")]
    pub target: ::core::option::Option<Reference>,
    /// Creation date
    #[prost(message, optional, tag = "13")]
    pub created: ::core::option::Option<DateTime>,
    /// Responsible practitioner
    #[prost(message, optional, tag = "14")]
    pub provider: ::core::option::Option<Reference>,
    /// Responsible organization
    #[prost(message, optional, tag = "15")]
    pub organization: ::core::option::Option<Reference>,
    /// Reference to the Request resource
    #[prost(message, optional, tag = "16")]
    pub request: ::core::option::Option<Reference>,
    /// Reference to the Response resource
    #[prost(message, optional, tag = "17")]
    pub response: ::core::option::Option<Reference>,
    /// Remove history
    #[prost(message, optional, tag = "18")]
    pub nullify: ::core::option::Option<Boolean>,
    /// Reference number/string
    #[prost(message, optional, tag = "19")]
    pub reference: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "20")]
    pub item: prost::alloc::vec::Vec<process_request::Items>,
    /// Resource type(s) to include
    #[prost(message, repeated, tag = "21")]
    pub include: prost::alloc::vec::Vec<String>,
    /// Resource type(s) to exclude
    #[prost(message, repeated, tag = "22")]
    pub exclude: prost::alloc::vec::Vec<String>,
    /// Selection period
    #[prost(message, optional, tag = "23")]
    pub period: ::core::option::Option<Period>,
}
/// Nested message and enum types in `ProcessRequest`.
pub mod process_request {
    /// Items to re-adjudicate
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Items {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Service instance
        #[prost(message, optional, tag = "4")]
        pub sequence_link_id: ::core::option::Option<super::Integer>,
    }
}
/// Auto-generated from StructureDefinition for ProcessResponse, last updated
/// 2017-04-19T07:44:43.294+10:00. ProcessResponse resource. See
/// <http://hl7.org/fhir/StructureDefinition/ProcessResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ProcessResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// Creation date
    #[prost(message, optional, tag = "11")]
    pub created: ::core::option::Option<DateTime>,
    /// Authoring Organization
    #[prost(message, optional, tag = "12")]
    pub organization: ::core::option::Option<Reference>,
    /// Request reference
    #[prost(message, optional, tag = "13")]
    pub request: ::core::option::Option<Reference>,
    /// Processing outcome
    #[prost(message, optional, tag = "14")]
    pub outcome: ::core::option::Option<CodeableConcept>,
    /// Disposition Message
    #[prost(message, optional, tag = "15")]
    pub disposition: ::core::option::Option<String>,
    /// Responsible Practitioner
    #[prost(message, optional, tag = "16")]
    pub request_provider: ::core::option::Option<Reference>,
    /// Responsible organization
    #[prost(message, optional, tag = "17")]
    pub request_organization: ::core::option::Option<Reference>,
    /// Printed Form Identifier
    #[prost(message, optional, tag = "18")]
    pub form: ::core::option::Option<CodeableConcept>,
    #[prost(message, repeated, tag = "19")]
    pub process_note: prost::alloc::vec::Vec<process_response::ProcessNote>,
    /// Error code
    #[prost(message, repeated, tag = "20")]
    pub error: prost::alloc::vec::Vec<CodeableConcept>,
    /// Request for additional information
    #[prost(message, repeated, tag = "21")]
    pub communication_request: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `ProcessResponse`.
pub mod process_response {
    /// Processing comments or additional requirements
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ProcessNote {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// display | print | printoper
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Comment on the processing
        #[prost(message, optional, tag = "5")]
        pub text: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for Provenance, last updated
/// 2017-04-19T07:44:43.294+10:00. Who, What, When for a set of resources. See
/// <http://hl7.org/fhir/StructureDefinition/Provenance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Provenance {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Target Reference(s) (usually version specific)
    #[prost(message, repeated, tag = "9")]
    pub target: prost::alloc::vec::Vec<Reference>,
    /// When the activity occurred
    #[prost(message, optional, tag = "10")]
    pub period: ::core::option::Option<Period>,
    /// When the activity was recorded / updated
    #[prost(message, optional, tag = "11")]
    pub recorded: ::core::option::Option<Instant>,
    /// Policy or plan the activity was defined by
    #[prost(message, repeated, tag = "12")]
    pub policy: prost::alloc::vec::Vec<Uri>,
    /// Where the activity occurred, if relevant
    #[prost(message, optional, tag = "13")]
    pub location: ::core::option::Option<Reference>,
    /// Reason the activity is occurring
    #[prost(message, repeated, tag = "14")]
    pub reason: prost::alloc::vec::Vec<Coding>,
    /// Activity that occurred
    #[prost(message, optional, tag = "15")]
    pub activity: ::core::option::Option<Coding>,
    #[prost(message, repeated, tag = "16")]
    pub agent: prost::alloc::vec::Vec<provenance::Agent>,
    #[prost(message, repeated, tag = "17")]
    pub entity: prost::alloc::vec::Vec<provenance::Entity>,
    /// Signature on target
    #[prost(message, repeated, tag = "18")]
    pub signature: prost::alloc::vec::Vec<Signature>,
}
/// Nested message and enum types in `Provenance`.
pub mod provenance {
    /// Actor involved
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Agent {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// What the agents role was
        #[prost(message, repeated, tag = "4")]
        pub role: prost::alloc::vec::Vec<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub who: ::core::option::Option<agent::Who>,
        #[prost(message, optional, tag = "6")]
        pub on_behalf_of: ::core::option::Option<agent::OnBehalfOf>,
        /// Type of relationship between agents
        #[prost(message, optional, tag = "7")]
        pub related_agent_type: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Agent`.
    pub mod agent {
        /// Who participated
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Who {
            #[prost(oneof = "who::Who", tags = "1, 2")]
            pub who: ::core::option::Option<who::Who>,
        }
        /// Nested message and enum types in `Who`.
        pub mod who {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Who {
                #[prost(message, tag = "1")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
        /// Who the agent is representing
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct OnBehalfOf {
            #[prost(oneof = "on_behalf_of::OnBehalfOf", tags = "1, 2")]
            pub on_behalf_of: ::core::option::Option<on_behalf_of::OnBehalfOf>,
        }
        /// Nested message and enum types in `OnBehalfOf`.
        pub mod on_behalf_of {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum OnBehalfOf {
                #[prost(message, tag = "1")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// An entity used in this activity
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Entity {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// derivation | revision | quotation | source | removal
        #[prost(message, optional, tag = "4")]
        pub role: ::core::option::Option<super::ProvenanceEntityRoleCode>,
        #[prost(message, optional, tag = "5")]
        pub what: ::core::option::Option<entity::What>,
        /// Entity is attributed to this agent
        #[prost(message, repeated, tag = "6")]
        pub agent: prost::alloc::vec::Vec<Agent>,
    }
    /// Nested message and enum types in `Entity`.
    pub mod entity {
        /// Identity of entity
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct What {
            #[prost(oneof = "what::What", tags = "1, 2, 3")]
            pub what: ::core::option::Option<what::What>,
        }
        /// Nested message and enum types in `What`.
        pub mod what {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum What {
                #[prost(message, tag = "1")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "3")]
                Identifier(super::super::super::Identifier),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Questionnaire, last updated
/// 2017-04-19T07:44:43.294+10:00. A structured set of questions. See
/// <http://hl7.org/fhir/StructureDefinition/Questionnaire>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Questionnaire {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this questionnaire (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the questionnaire
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the questionnaire
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this questionnaire (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this questionnaire (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Natural language description of the questionnaire
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<Markdown>,
    /// Why this questionnaire is defined
    #[prost(message, optional, tag = "19")]
    pub purpose: ::core::option::Option<Markdown>,
    /// When the questionnaire was approved by publisher
    #[prost(message, optional, tag = "20")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the questionnaire was last reviewed
    #[prost(message, optional, tag = "21")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the questionnaire is expected to be used
    #[prost(message, optional, tag = "22")]
    pub effective_period: ::core::option::Option<Period>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "23")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for questionnaire (if applicable)
    #[prost(message, repeated, tag = "24")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "25")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "26")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Concept that represents the overall questionnaire
    #[prost(message, repeated, tag = "27")]
    pub code: prost::alloc::vec::Vec<Coding>,
    /// Resource that can be subject of QuestionnaireResponse
    #[prost(message, repeated, tag = "28")]
    pub subject_type: prost::alloc::vec::Vec<ResourceTypeCode>,
    #[prost(message, repeated, tag = "29")]
    pub item: prost::alloc::vec::Vec<questionnaire::Item>,
}
/// Nested message and enum types in `Questionnaire`.
pub mod questionnaire {
    /// Questions and sections within the Questionnaire
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Unique id for item in questionnaire
        #[prost(message, optional, tag = "4")]
        pub link_id: ::core::option::Option<super::String>,
        /// ElementDefinition - details for the item
        #[prost(message, optional, tag = "5")]
        pub definition: ::core::option::Option<super::Uri>,
        /// Corresponding concept for this item in a terminology
        #[prost(message, repeated, tag = "6")]
        pub code: prost::alloc::vec::Vec<super::Coding>,
        /// E.g. "1(a)", "2.5.3"
        #[prost(message, optional, tag = "7")]
        pub prefix: ::core::option::Option<super::String>,
        /// Primary text for the item
        #[prost(message, optional, tag = "8")]
        pub text: ::core::option::Option<super::String>,
        /// group | display | boolean | decimal | integer | date | dateTime +
        #[prost(message, optional, tag = "9")]
        pub r#type: ::core::option::Option<super::QuestionnaireItemTypeCode>,
        #[prost(message, repeated, tag = "10")]
        pub enable_when: prost::alloc::vec::Vec<item::EnableWhen>,
        /// Whether the item must be included in data results
        #[prost(message, optional, tag = "11")]
        pub required: ::core::option::Option<super::Boolean>,
        /// Whether the item may repeat
        #[prost(message, optional, tag = "12")]
        pub repeats: ::core::option::Option<super::Boolean>,
        /// Don't allow human editing
        #[prost(message, optional, tag = "13")]
        pub read_only: ::core::option::Option<super::Boolean>,
        /// No more than this many characters
        #[prost(message, optional, tag = "14")]
        pub max_length: ::core::option::Option<super::Integer>,
        /// Valueset containing permitted answers
        #[prost(message, optional, tag = "15")]
        pub options: ::core::option::Option<super::Reference>,
        #[prost(message, repeated, tag = "16")]
        pub option: prost::alloc::vec::Vec<item::Option>,
        #[prost(message, optional, tag = "17")]
        pub initial: ::core::option::Option<item::Initial>,
        /// Nested questionnaire items
        #[prost(message, repeated, tag = "18")]
        pub item: prost::alloc::vec::Vec<Item>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// Only allow data when
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct EnableWhen {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Question that determines whether item is enabled
            #[prost(message, optional, tag = "4")]
            pub question: ::core::option::Option<super::super::String>,
            /// Enable when answered or not
            #[prost(message, optional, tag = "5")]
            pub has_answer_value: ::core::option::Option<super::super::Boolean>,
            #[prost(message, optional, tag = "6")]
            pub answer: ::core::option::Option<enable_when::Answer>,
        }
        /// Nested message and enum types in `EnableWhen`.
        pub mod enable_when {
            /// Value question must have
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Answer {
                #[prost(
                    oneof = "answer::Answer",
                    tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12"
                )]
                pub answer: ::core::option::Option<answer::Answer>,
            }
            /// Nested message and enum types in `Answer`.
            pub mod answer {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Answer {
                    #[prost(message, tag = "1")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "2")]
                    Decimal(super::super::super::super::Decimal),
                    #[prost(message, tag = "3")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "4")]
                    Date(super::super::super::super::Date),
                    #[prost(message, tag = "5")]
                    DateTime(super::super::super::super::DateTime),
                    #[prost(message, tag = "6")]
                    Time(super::super::super::super::Time),
                    #[prost(message, tag = "7")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "8")]
                    Uri(super::super::super::super::Uri),
                    #[prost(message, tag = "9")]
                    Attachment(super::super::super::super::Attachment),
                    #[prost(message, tag = "10")]
                    Coding(super::super::super::super::Coding),
                    #[prost(message, tag = "11")]
                    Quantity(super::super::super::super::Quantity),
                    #[prost(message, tag = "12")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
        /// Permitted answer
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Option {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub value: ::core::option::Option<option::Value>,
        }
        /// Nested message and enum types in `Option`.
        pub mod option {
            /// Answer value
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Value {
                #[prost(oneof = "value::Value", tags = "1, 2, 3, 4, 5")]
                pub value: ::core::option::Option<value::Value>,
            }
            /// Nested message and enum types in `Value`.
            pub mod value {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Value {
                    #[prost(message, tag = "1")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "2")]
                    Date(super::super::super::super::Date),
                    #[prost(message, tag = "3")]
                    Time(super::super::super::super::Time),
                    #[prost(message, tag = "4")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "5")]
                    Coding(super::super::super::super::Coding),
                }
            }
        }
        /// Default value when item is first rendered
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Initial {
            #[prost(
                oneof = "initial::Initial",
                tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12"
            )]
            pub initial: ::core::option::Option<initial::Initial>,
        }
        /// Nested message and enum types in `Initial`.
        pub mod initial {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Initial {
                #[prost(message, tag = "1")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "2")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "3")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "4")]
                Date(super::super::super::Date),
                #[prost(message, tag = "5")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "6")]
                Time(super::super::super::Time),
                #[prost(message, tag = "7")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "8")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "9")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "10")]
                Coding(super::super::super::Coding),
                #[prost(message, tag = "11")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "12")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for QuestionnaireResponse, last
/// updated 2017-04-19T07:44:43.294+10:00. A structured set of questions and
/// their answers. See
/// <http://hl7.org/fhir/StructureDefinition/QuestionnaireResponse>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct QuestionnaireResponse {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique id for this set of answers
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Request fulfilled by this QuestionnaireResponse
    #[prost(message, repeated, tag = "10")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of this action
    #[prost(message, repeated, tag = "11")]
    pub parent: prost::alloc::vec::Vec<Reference>,
    /// Form being answered
    #[prost(message, optional, tag = "12")]
    pub questionnaire: ::core::option::Option<Reference>,
    /// in-progress | completed | amended | entered-in-error | stopped
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<QuestionnaireResponseStatusCode>,
    /// The subject of the questions
    #[prost(message, optional, tag = "14")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or Episode during which questionnaire was completed
    #[prost(message, optional, tag = "15")]
    pub context: ::core::option::Option<Reference>,
    /// Date the answers were gathered
    #[prost(message, optional, tag = "16")]
    pub authored: ::core::option::Option<DateTime>,
    /// Person who received and recorded the answers
    #[prost(message, optional, tag = "17")]
    pub author: ::core::option::Option<Reference>,
    /// The person who answered the questions
    #[prost(message, optional, tag = "18")]
    pub source: ::core::option::Option<Reference>,
    #[prost(message, repeated, tag = "19")]
    pub item: prost::alloc::vec::Vec<questionnaire_response::Item>,
}
/// Nested message and enum types in `QuestionnaireResponse`.
pub mod questionnaire_response {
    /// Groups and questions
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Item {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Pointer to specific item from Questionnaire
        #[prost(message, optional, tag = "4")]
        pub link_id: ::core::option::Option<super::String>,
        /// ElementDefinition - details for the item
        #[prost(message, optional, tag = "5")]
        pub definition: ::core::option::Option<super::Uri>,
        /// Name for group or question text
        #[prost(message, optional, tag = "6")]
        pub text: ::core::option::Option<super::String>,
        /// The subject this group's answers are about
        #[prost(message, optional, tag = "7")]
        pub subject: ::core::option::Option<super::Reference>,
        #[prost(message, repeated, tag = "8")]
        pub answer: prost::alloc::vec::Vec<item::Answer>,
        /// Nested questionnaire response items
        #[prost(message, repeated, tag = "9")]
        pub item: prost::alloc::vec::Vec<Item>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        /// The response(s) to the question
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Answer {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub value: ::core::option::Option<answer::Value>,
            /// Nested groups and questions
            #[prost(message, repeated, tag = "5")]
            pub item: prost::alloc::vec::Vec<super::Item>,
        }
        /// Nested message and enum types in `Answer`.
        pub mod answer {
            /// Single-valued answer to the question
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Value {
                #[prost(oneof = "value::Value", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12")]
                pub value: ::core::option::Option<value::Value>,
            }
            /// Nested message and enum types in `Value`.
            pub mod value {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Value {
                    #[prost(message, tag = "1")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "2")]
                    Decimal(super::super::super::super::Decimal),
                    #[prost(message, tag = "3")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "4")]
                    Date(super::super::super::super::Date),
                    #[prost(message, tag = "5")]
                    DateTime(super::super::super::super::DateTime),
                    #[prost(message, tag = "6")]
                    Time(super::super::super::super::Time),
                    #[prost(message, tag = "7")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "8")]
                    Uri(super::super::super::super::Uri),
                    #[prost(message, tag = "9")]
                    Attachment(super::super::super::super::Attachment),
                    #[prost(message, tag = "10")]
                    Coding(super::super::super::super::Coding),
                    #[prost(message, tag = "11")]
                    Quantity(super::super::super::super::Quantity),
                    #[prost(message, tag = "12")]
                    Reference(super::super::super::super::Reference),
                }
            }
        }
    }
}
/// Auto-generated from StructureDefinition for ReferralRequest, last updated
/// 2017-04-19T07:44:43.294+10:00. A request for referral or transfer of care.
/// See <http://hl7.org/fhir/StructureDefinition/ReferralRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ReferralRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates protocol or definition
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Reference>,
    /// Request fulfilled by this request
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Request(s) replaced by this request
    #[prost(message, repeated, tag = "12")]
    pub replaces: prost::alloc::vec::Vec<Reference>,
    /// Composite request this is part of
    #[prost(message, optional, tag = "13")]
    pub group_identifier: ::core::option::Option<Identifier>,
    /// draft | active | suspended | cancelled | completed | entered-in-error |
    /// unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<RequestStatusCode>,
    /// proposal | plan | order
    #[prost(message, optional, tag = "15")]
    pub intent: ::core::option::Option<RequestIntentCode>,
    /// Referral/Transition of care request type
    #[prost(message, optional, tag = "16")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Urgency of referral / transfer of care request
    #[prost(message, optional, tag = "17")]
    pub priority: ::core::option::Option<RequestPriorityCode>,
    /// Actions requested as part of the referral
    #[prost(message, repeated, tag = "18")]
    pub service_requested: prost::alloc::vec::Vec<CodeableConcept>,
    /// Patient referred to care or transfer
    #[prost(message, optional, tag = "19")]
    pub subject: ::core::option::Option<Reference>,
    /// Originating encounter
    #[prost(message, optional, tag = "20")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "21")]
    pub occurrence: ::core::option::Option<referral_request::Occurrence>,
    /// Date of creation/activation
    #[prost(message, optional, tag = "22")]
    pub authored_on: ::core::option::Option<DateTime>,
    #[prost(message, optional, tag = "23")]
    pub requester: ::core::option::Option<referral_request::Requester>,
    /// The clinical specialty (discipline) that the referral is requested for
    #[prost(message, optional, tag = "24")]
    pub specialty: ::core::option::Option<CodeableConcept>,
    /// Receiver of referral / transfer of care request
    #[prost(message, repeated, tag = "25")]
    pub recipient: prost::alloc::vec::Vec<Reference>,
    /// Reason for referral / transfer of care request
    #[prost(message, repeated, tag = "26")]
    pub reason_code: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why is service needed?
    #[prost(message, repeated, tag = "27")]
    pub reason_reference: prost::alloc::vec::Vec<Reference>,
    /// A textual description of the referral
    #[prost(message, optional, tag = "28")]
    pub description: ::core::option::Option<String>,
    /// Additonal information to support referral or transfer of care request
    #[prost(message, repeated, tag = "29")]
    pub supporting_info: prost::alloc::vec::Vec<Reference>,
    /// Comments made about referral request
    #[prost(message, repeated, tag = "30")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Key events in history of request
    #[prost(message, repeated, tag = "31")]
    pub relevant_history: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `ReferralRequest`.
pub mod referral_request {
    /// When the service(s) requested in the referral should occur
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Occurrence {
        #[prost(oneof = "occurrence::Occurrence", tags = "1, 2")]
        pub occurrence: ::core::option::Option<occurrence::Occurrence>,
    }
    /// Nested message and enum types in `Occurrence`.
    pub mod occurrence {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Occurrence {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Who/what is requesting service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Requester {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Individual making the request
        #[prost(message, optional, tag = "4")]
        pub agent: ::core::option::Option<super::Reference>,
        /// Organization agent is acting for
        #[prost(message, optional, tag = "5")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
}
/// Auto-generated from StructureDefinition for RelatedPerson, last updated
/// 2017-04-19T07:44:43.294+10:00. An person that is related to a patient, but
/// who is not a direct target of care. See
/// <http://hl7.org/fhir/StructureDefinition/RelatedPerson>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RelatedPerson {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// A human identifier for this person
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this related person's record is in active use
    #[prost(message, optional, tag = "10")]
    pub active: ::core::option::Option<Boolean>,
    /// The patient this person is related to
    #[prost(message, optional, tag = "11")]
    pub patient: ::core::option::Option<Reference>,
    /// The nature of the relationship
    #[prost(message, optional, tag = "12")]
    pub relationship: ::core::option::Option<CodeableConcept>,
    /// A name associated with the person
    #[prost(message, repeated, tag = "13")]
    pub name: prost::alloc::vec::Vec<HumanName>,
    /// A contact detail for the person
    #[prost(message, repeated, tag = "14")]
    pub telecom: prost::alloc::vec::Vec<ContactPoint>,
    /// male | female | other | unknown
    #[prost(message, optional, tag = "15")]
    pub gender: ::core::option::Option<AdministrativeGenderCode>,
    /// The date on which the related person was born
    #[prost(message, optional, tag = "16")]
    pub birth_date: ::core::option::Option<Date>,
    /// Address where the related person can be contacted or visited
    #[prost(message, repeated, tag = "17")]
    pub address: prost::alloc::vec::Vec<Address>,
    /// Image of the person
    #[prost(message, repeated, tag = "18")]
    pub photo: prost::alloc::vec::Vec<Attachment>,
    /// Period of time that this relationship is considered valid
    #[prost(message, optional, tag = "19")]
    pub period: ::core::option::Option<Period>,
}
/// Auto-generated from StructureDefinition for RequestGroup, last updated
/// 2017-04-19T07:44:43.294+10:00. A group of related requests. See
/// <http://hl7.org/fhir/StructureDefinition/RequestGroup>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RequestGroup {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Instantiates protocol or definition
    #[prost(message, repeated, tag = "10")]
    pub definition: prost::alloc::vec::Vec<Reference>,
    /// Fulfills plan, proposal, or order
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Request(s) replaced by this request
    #[prost(message, repeated, tag = "12")]
    pub replaces: prost::alloc::vec::Vec<Reference>,
    /// Composite request this is part of
    #[prost(message, optional, tag = "13")]
    pub group_identifier: ::core::option::Option<Identifier>,
    /// draft | active | suspended | cancelled | completed | entered-in-error |
    /// unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<RequestStatusCode>,
    /// proposal | plan | order
    #[prost(message, optional, tag = "15")]
    pub intent: ::core::option::Option<RequestIntentCode>,
    /// routine | urgent | asap | stat
    #[prost(message, optional, tag = "16")]
    pub priority: ::core::option::Option<RequestPriorityCode>,
    /// Who the request group is about
    #[prost(message, optional, tag = "17")]
    pub subject: ::core::option::Option<Reference>,
    /// Encounter or Episode for the request group
    #[prost(message, optional, tag = "18")]
    pub context: ::core::option::Option<Reference>,
    /// When the request group was authored
    #[prost(message, optional, tag = "19")]
    pub authored_on: ::core::option::Option<DateTime>,
    /// Device or practitioner that authored the request group
    #[prost(message, optional, tag = "20")]
    pub author: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "21")]
    pub reason: ::core::option::Option<request_group::Reason>,
    /// Additional notes about the response
    #[prost(message, repeated, tag = "22")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "23")]
    pub action: prost::alloc::vec::Vec<request_group::Action>,
}
/// Nested message and enum types in `RequestGroup`.
pub mod request_group {
    /// Reason for the request group
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Reason {
        #[prost(oneof = "reason::Reason", tags = "1, 2")]
        pub reason: ::core::option::Option<reason::Reason>,
    }
    /// Nested message and enum types in `Reason`.
    pub mod reason {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Proposed actions, if any
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Action {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// User-visible label for the action (e.g. 1. or A.)
        #[prost(message, optional, tag = "4")]
        pub label: ::core::option::Option<super::String>,
        /// User-visible title
        #[prost(message, optional, tag = "5")]
        pub title: ::core::option::Option<super::String>,
        /// Short description of the action
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        /// Static text equivalent of the action, used if the dynamic aspects cannot
        /// be interpreted by the receiving system
        #[prost(message, optional, tag = "7")]
        pub text_equivalent: ::core::option::Option<super::String>,
        /// Code representing the meaning of the action or sub-actions
        #[prost(message, repeated, tag = "8")]
        pub code: prost::alloc::vec::Vec<super::CodeableConcept>,
        /// Supporting documentation for the intended performer of the action
        #[prost(message, repeated, tag = "9")]
        pub documentation: prost::alloc::vec::Vec<super::RelatedArtifact>,
        #[prost(message, repeated, tag = "10")]
        pub condition: prost::alloc::vec::Vec<action::Condition>,
        #[prost(message, repeated, tag = "11")]
        pub related_action: prost::alloc::vec::Vec<action::RelatedAction>,
        #[prost(message, optional, tag = "12")]
        pub timing: ::core::option::Option<action::TimingType>,
        /// Who should perform the action
        #[prost(message, repeated, tag = "13")]
        pub participant: prost::alloc::vec::Vec<super::Reference>,
        /// create | update | remove | fire-event
        #[prost(message, optional, tag = "14")]
        pub r#type: ::core::option::Option<super::Coding>,
        /// visual-group | logical-group | sentence-group
        #[prost(message, optional, tag = "15")]
        pub grouping_behavior: ::core::option::Option<super::ActionGroupingBehaviorCode>,
        /// any | all | all-or-none | exactly-one | at-most-one | one-or-more
        #[prost(message, optional, tag = "16")]
        pub selection_behavior: ::core::option::Option<super::ActionSelectionBehaviorCode>,
        /// must | could | must-unless-documented
        #[prost(message, optional, tag = "17")]
        pub required_behavior: ::core::option::Option<super::ActionRequiredBehaviorCode>,
        /// yes | no
        #[prost(message, optional, tag = "18")]
        pub precheck_behavior: ::core::option::Option<super::ActionPrecheckBehaviorCode>,
        /// single | multiple
        #[prost(message, optional, tag = "19")]
        pub cardinality_behavior: ::core::option::Option<super::ActionCardinalityBehaviorCode>,
        /// The target of the action
        #[prost(message, optional, tag = "20")]
        pub resource: ::core::option::Option<super::Reference>,
        /// Sub action
        #[prost(message, repeated, tag = "21")]
        pub action: prost::alloc::vec::Vec<Action>,
    }
    /// Nested message and enum types in `Action`.
    pub mod action {
        /// Whether or not the action is applicable
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Condition {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// applicability | start | stop
            #[prost(message, optional, tag = "4")]
            pub kind: ::core::option::Option<super::super::ActionConditionKindCode>,
            /// Natural language description of the condition
            #[prost(message, optional, tag = "5")]
            pub description: ::core::option::Option<super::super::String>,
            /// Language of the expression
            #[prost(message, optional, tag = "6")]
            pub language: ::core::option::Option<super::super::String>,
            /// Boolean-valued expression
            #[prost(message, optional, tag = "7")]
            pub expression: ::core::option::Option<super::super::String>,
        }
        /// Relationship to another action
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RelatedAction {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// What action this is related to
            #[prost(message, optional, tag = "4")]
            pub action_id: ::core::option::Option<super::super::Id>,
            /// before-start | before | before-end | concurrent-with-start | concurrent
            /// | concurrent-with-end | after-start | after | after-end
            #[prost(message, optional, tag = "5")]
            pub relationship: ::core::option::Option<super::super::ActionRelationshipTypeCode>,
            #[prost(message, optional, tag = "6")]
            pub offset: ::core::option::Option<related_action::Offset>,
        }
        /// Nested message and enum types in `RelatedAction`.
        pub mod related_action {
            /// Time offset for the relationship
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Offset {
                #[prost(oneof = "offset::Offset", tags = "1, 2")]
                pub offset: ::core::option::Option<offset::Offset>,
            }
            /// Nested message and enum types in `Offset`.
            pub mod offset {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Offset {
                    #[prost(message, tag = "1")]
                    Duration(super::super::super::super::Duration),
                    #[prost(message, tag = "2")]
                    Range(super::super::super::super::Range),
                }
            }
        }
        /// When the action should take place
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TimingType {
            #[prost(oneof = "timing_type::Timing", tags = "1, 2, 3, 4, 5")]
            pub timing: ::core::option::Option<timing_type::Timing>,
        }
        /// Nested message and enum types in `TimingType`.
        pub mod timing_type {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Timing {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
                #[prost(message, tag = "3")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "4")]
                Range(super::super::super::Range),
                #[prost(message, tag = "5")]
                TimingValue(super::super::super::Timing),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for ResearchStudy, last updated
/// 2017-04-19T07:44:43.294+10:00. Investigation to increase healthcare-related
/// patient-independent knowledge. See
/// <http://hl7.org/fhir/StructureDefinition/ResearchStudy>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchStudy {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for study
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Name for this study
    #[prost(message, optional, tag = "10")]
    pub title: ::core::option::Option<String>,
    /// Steps followed in executing study
    #[prost(message, repeated, tag = "11")]
    pub protocol: prost::alloc::vec::Vec<Reference>,
    /// Part of larger study
    #[prost(message, repeated, tag = "12")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// draft | in-progress | suspended | stopped | completed | entered-in-error
    #[prost(message, optional, tag = "13")]
    pub status: ::core::option::Option<ResearchStudyStatusCode>,
    /// Classifications for the study
    #[prost(message, repeated, tag = "14")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// Drugs, devices, conditions, etc. under study
    #[prost(message, repeated, tag = "15")]
    pub focus: prost::alloc::vec::Vec<CodeableConcept>,
    /// Contact details for the study
    #[prost(message, repeated, tag = "16")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// References and dependencies
    #[prost(message, repeated, tag = "17")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// Used to search for the study
    #[prost(message, repeated, tag = "18")]
    pub keyword: prost::alloc::vec::Vec<CodeableConcept>,
    /// Geographic region(s) for study
    #[prost(message, repeated, tag = "19")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// What this is study doing
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<Markdown>,
    /// Inclusion & exclusion criteria
    #[prost(message, repeated, tag = "21")]
    pub enrollment: prost::alloc::vec::Vec<Reference>,
    /// When the study began and ended
    #[prost(message, optional, tag = "22")]
    pub period: ::core::option::Option<Period>,
    /// Organization responsible for the study
    #[prost(message, optional, tag = "23")]
    pub sponsor: ::core::option::Option<Reference>,
    /// The individual responsible for the study
    #[prost(message, optional, tag = "24")]
    pub principal_investigator: ::core::option::Option<Reference>,
    /// Location involved in study execution
    #[prost(message, repeated, tag = "25")]
    pub site: prost::alloc::vec::Vec<Reference>,
    /// Reason for terminating study early
    #[prost(message, optional, tag = "26")]
    pub reason_stopped: ::core::option::Option<CodeableConcept>,
    /// Comments made about the event
    #[prost(message, repeated, tag = "27")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    #[prost(message, repeated, tag = "28")]
    pub arm: prost::alloc::vec::Vec<research_study::Arm>,
}
/// Nested message and enum types in `ResearchStudy`.
pub mod research_study {
    /// Defined path through the study for a subject
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Arm {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Label for study arm
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Categorization of study arm
        #[prost(message, optional, tag = "5")]
        pub code: ::core::option::Option<super::CodeableConcept>,
        /// Short explanation of study path
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for ResearchSubject, last updated
/// 2017-04-19T07:44:43.294+10:00. Investigation to increase healthcare-related
/// patient-independent knowledge. See
/// <http://hl7.org/fhir/StructureDefinition/ResearchSubject>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ResearchSubject {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business Identifier for research subject
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// candidate | enrolled | active | suspended | withdrawn | completed
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<ResearchSubjectStatusCode>,
    /// Start and end of participation
    #[prost(message, optional, tag = "11")]
    pub period: ::core::option::Option<Period>,
    /// Study subject is part of
    #[prost(message, optional, tag = "12")]
    pub study: ::core::option::Option<Reference>,
    /// Who is part of study
    #[prost(message, optional, tag = "13")]
    pub individual: ::core::option::Option<Reference>,
    /// What path should be followed
    #[prost(message, optional, tag = "14")]
    pub assigned_arm: ::core::option::Option<String>,
    /// What path was followed
    #[prost(message, optional, tag = "15")]
    pub actual_arm: ::core::option::Option<String>,
    /// Agreement to participate in study
    #[prost(message, optional, tag = "16")]
    pub consent: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for RiskAssessment, last updated
/// 2017-04-19T07:44:43.294+10:00. Potential outcomes for a subject with
/// likelihood. See <http://hl7.org/fhir/StructureDefinition/RiskAssessment>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct RiskAssessment {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier for the assessment
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Request fulfilled by this assessment
    #[prost(message, optional, tag = "10")]
    pub based_on: ::core::option::Option<Reference>,
    /// Part of this occurrence
    #[prost(message, optional, tag = "11")]
    pub parent: ::core::option::Option<Reference>,
    /// registered | preliminary | final | amended +
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<ObservationStatusCode>,
    /// Evaluation mechanism
    #[prost(message, optional, tag = "13")]
    pub method: ::core::option::Option<CodeableConcept>,
    /// Type of assessment
    #[prost(message, optional, tag = "14")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Who/what does assessment apply to?
    #[prost(message, optional, tag = "15")]
    pub subject: ::core::option::Option<Reference>,
    /// Where was assessment performed?
    #[prost(message, optional, tag = "16")]
    pub context: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "17")]
    pub occurrence: ::core::option::Option<risk_assessment::Occurrence>,
    /// Condition assessed
    #[prost(message, optional, tag = "18")]
    pub condition: ::core::option::Option<Reference>,
    /// Who did assessment?
    #[prost(message, optional, tag = "19")]
    pub performer: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "20")]
    pub reason: ::core::option::Option<risk_assessment::Reason>,
    /// Information used in assessment
    #[prost(message, repeated, tag = "21")]
    pub basis: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "22")]
    pub prediction: prost::alloc::vec::Vec<risk_assessment::Prediction>,
    /// How to reduce risk
    #[prost(message, optional, tag = "23")]
    pub mitigation: ::core::option::Option<String>,
    /// Comments on the risk assessment
    #[prost(message, optional, tag = "24")]
    pub comment: ::core::option::Option<String>,
}
/// Nested message and enum types in `RiskAssessment`.
pub mod risk_assessment {
    /// When was assessment made?
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Occurrence {
        #[prost(oneof = "occurrence::Occurrence", tags = "1, 2")]
        pub occurrence: ::core::option::Option<occurrence::Occurrence>,
    }
    /// Nested message and enum types in `Occurrence`.
    pub mod occurrence {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Occurrence {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
        }
    }
    /// Why the assessment was necessary?
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Reason {
        #[prost(oneof = "reason::Reason", tags = "1, 2")]
        pub reason: ::core::option::Option<reason::Reason>,
    }
    /// Nested message and enum types in `Reason`.
    pub mod reason {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Outcome predicted
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Prediction {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Possible outcome for the subject
        #[prost(message, optional, tag = "4")]
        pub outcome: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub probability: ::core::option::Option<prediction::Probability>,
        /// Likelihood of specified outcome as a qualitative value
        #[prost(message, optional, tag = "6")]
        pub qualitative_risk: ::core::option::Option<super::CodeableConcept>,
        /// Relative likelihood
        #[prost(message, optional, tag = "7")]
        pub relative_risk: ::core::option::Option<super::Decimal>,
        #[prost(message, optional, tag = "8")]
        pub when: ::core::option::Option<prediction::When>,
        /// Explanation of prediction
        #[prost(message, optional, tag = "9")]
        pub rationale: ::core::option::Option<super::String>,
    }
    /// Nested message and enum types in `Prediction`.
    pub mod prediction {
        /// Likelihood of specified outcome
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Probability {
            #[prost(oneof = "probability::Probability", tags = "1, 2")]
            pub probability: ::core::option::Option<probability::Probability>,
        }
        /// Nested message and enum types in `Probability`.
        pub mod probability {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Probability {
                #[prost(message, tag = "1")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
            }
        }
        /// Timeframe or age range
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct When {
            #[prost(oneof = "when::When", tags = "1, 2")]
            pub when: ::core::option::Option<when::When>,
        }
        /// Nested message and enum types in `When`.
        pub mod when {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum When {
                #[prost(message, tag = "1")]
                Period(super::super::super::Period),
                #[prost(message, tag = "2")]
                Range(super::super::super::Range),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Schedule, last updated
/// 2017-04-19T07:44:43.294+10:00. A container for slots of time that may be
/// available for booking appointments. See
/// <http://hl7.org/fhir/StructureDefinition/Schedule>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Schedule {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this item
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Whether this schedule is in active use
    #[prost(message, optional, tag = "10")]
    pub active: ::core::option::Option<Boolean>,
    /// A broad categorisation of the service that is to be performed during this
    /// appointment
    #[prost(message, optional, tag = "11")]
    pub service_category: ::core::option::Option<CodeableConcept>,
    /// The specific service that is to be performed during this appointment
    #[prost(message, repeated, tag = "12")]
    pub service_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// The specialty of a practitioner that would be required to perform the
    /// service requested in this appointment
    #[prost(message, repeated, tag = "13")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// The resource this Schedule resource is providing availability information
    /// for. These are expected to usually be one of HealthcareService, Location,
    /// Practitioner, PractitionerRole, Device, Patient or RelatedPerson
    #[prost(message, repeated, tag = "14")]
    pub actor: prost::alloc::vec::Vec<Reference>,
    /// The period of time that the slots that are attached to this Schedule
    /// resource cover (even if none exist). These  cover the amount of time that
    /// an organization's planning horizon; the interval for which they are
    /// currently accepting appointments. This does not define a "template" for
    /// planning outside these dates
    #[prost(message, optional, tag = "15")]
    pub planning_horizon: ::core::option::Option<Period>,
    /// Comments on the availability to describe any extended information. Such as
    /// custom constraints on the slots that may be associated
    #[prost(message, optional, tag = "16")]
    pub comment: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for SearchParameter, last updated
/// 2017-04-19T07:44:43.294+10:00. Search Parameter for a resource. See
/// <http://hl7.org/fhir/StructureDefinition/SearchParameter>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SearchParameter {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this search parameter (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Business version of the search parameter
    #[prost(message, optional, tag = "10")]
    pub version: ::core::option::Option<String>,
    /// Name for this search parameter (computer friendly)
    #[prost(message, optional, tag = "11")]
    pub name: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "13")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "14")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "15")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "16")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "17")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for search parameter (if applicable)
    #[prost(message, repeated, tag = "18")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this search parameter is defined
    #[prost(message, optional, tag = "19")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Code used in URL
    #[prost(message, optional, tag = "20")]
    pub code: ::core::option::Option<Code>,
    /// The resource type(s) this search parameter applies to
    #[prost(message, repeated, tag = "21")]
    pub base: prost::alloc::vec::Vec<ResourceTypeCode>,
    /// number | date | string | token | reference | composite | quantity | uri
    #[prost(message, optional, tag = "22")]
    pub r#type: ::core::option::Option<SearchParamTypeCode>,
    /// Original Definition for the search parameter
    #[prost(message, optional, tag = "23")]
    pub derived_from: ::core::option::Option<Uri>,
    /// Natural language description of the search parameter
    #[prost(message, optional, tag = "24")]
    pub description: ::core::option::Option<Markdown>,
    /// FHIRPath expression that extracts the values
    #[prost(message, optional, tag = "25")]
    pub expression: ::core::option::Option<String>,
    /// XPath that extracts the values
    #[prost(message, optional, tag = "26")]
    pub xpath: ::core::option::Option<String>,
    /// normal | phonetic | nearby | distance | other
    #[prost(message, optional, tag = "27")]
    pub xpath_usage: ::core::option::Option<XPathUsageTypeCode>,
    /// Types of resource (if a resource reference)
    #[prost(message, repeated, tag = "28")]
    pub target: prost::alloc::vec::Vec<ResourceTypeCode>,
    /// eq | ne | gt | lt | ge | le | sa | eb | ap
    #[prost(message, repeated, tag = "29")]
    pub comparator: prost::alloc::vec::Vec<SearchComparatorCode>,
    /// missing | exact | contains | not | text | in | not-in | below | above |
    /// type
    #[prost(message, repeated, tag = "30")]
    pub modifier: prost::alloc::vec::Vec<SearchModifierCodeCode>,
    /// Chained names supported
    #[prost(message, repeated, tag = "31")]
    pub chain: prost::alloc::vec::Vec<String>,
    #[prost(message, repeated, tag = "32")]
    pub component: prost::alloc::vec::Vec<search_parameter::Component>,
}
/// Nested message and enum types in `SearchParameter`.
pub mod search_parameter {
    /// For Composite resources to define the parts
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Component {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Defines how the part works
        #[prost(message, optional, tag = "4")]
        pub definition: ::core::option::Option<super::Reference>,
        /// Subexpression relative to main expression
        #[prost(message, optional, tag = "5")]
        pub expression: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for Sequence, last updated
/// 2017-04-19T07:44:43.294+10:00. Information about a biological sequence. See
/// <http://hl7.org/fhir/StructureDefinition/Sequence>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Sequence {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique ID for this particular sequence. This is a FHIR-defined id
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// aa | dna | rna
    #[prost(message, optional, tag = "10")]
    pub r#type: ::core::option::Option<SequenceTypeCode>,
    /// Base number of coordinate system (0 for 0-based numbering or coordinates,
    /// inclusive start, exclusive end, 1 for 1-based numbering, inclusive start,
    /// inclusive end)
    #[prost(message, optional, tag = "11")]
    pub coordinate_system: ::core::option::Option<Integer>,
    /// Who and/or what this is about
    #[prost(message, optional, tag = "12")]
    pub patient: ::core::option::Option<Reference>,
    /// Specimen used for sequencing
    #[prost(message, optional, tag = "13")]
    pub specimen: ::core::option::Option<Reference>,
    /// The method for sequencing
    #[prost(message, optional, tag = "14")]
    pub device: ::core::option::Option<Reference>,
    /// Who should be responsible for test result
    #[prost(message, optional, tag = "15")]
    pub performer: ::core::option::Option<Reference>,
    /// The number of copies of the seqeunce of interest.  (RNASeq)
    #[prost(message, optional, tag = "16")]
    pub quantity: ::core::option::Option<Quantity>,
    #[prost(message, optional, tag = "17")]
    pub reference_seq: ::core::option::Option<sequence::ReferenceSeq>,
    #[prost(message, repeated, tag = "18")]
    pub variant: prost::alloc::vec::Vec<sequence::Variant>,
    /// Sequence that was observed
    #[prost(message, optional, tag = "19")]
    pub observed_seq: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "20")]
    pub quality: prost::alloc::vec::Vec<sequence::Quality>,
    /// Average number of reads representing a given nucleotide in the
    /// reconstructed sequence
    #[prost(message, optional, tag = "21")]
    pub read_coverage: ::core::option::Option<Integer>,
    #[prost(message, repeated, tag = "22")]
    pub repository: prost::alloc::vec::Vec<sequence::Repository>,
    /// Pointer to next atomic sequence
    #[prost(message, repeated, tag = "23")]
    pub pointer: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `Sequence`.
pub mod sequence {
    /// A sequence used as reference
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct ReferenceSeq {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Chromosome containing genetic finding
        #[prost(message, optional, tag = "4")]
        pub chromosome: ::core::option::Option<super::CodeableConcept>,
        /// The Genome Build used for reference, following GRCh build versions e.g.
        /// 'GRCh 37'
        #[prost(message, optional, tag = "5")]
        pub genome_build: ::core::option::Option<super::String>,
        /// Reference identifier
        #[prost(message, optional, tag = "6")]
        pub reference_seq_id: ::core::option::Option<super::CodeableConcept>,
        /// A Pointer to another Sequence entity as reference sequence
        #[prost(message, optional, tag = "7")]
        pub reference_seq_pointer: ::core::option::Option<super::Reference>,
        /// A string to represent reference sequence
        #[prost(message, optional, tag = "8")]
        pub reference_seq_string: ::core::option::Option<super::String>,
        /// Directionality of DNA ( +1/-1)
        #[prost(message, optional, tag = "9")]
        pub strand: ::core::option::Option<super::Integer>,
        /// Start position of the window on the  reference sequence
        #[prost(message, optional, tag = "10")]
        pub window_start: ::core::option::Option<super::Integer>,
        /// End position of the window on the reference sequence
        #[prost(message, optional, tag = "11")]
        pub window_end: ::core::option::Option<super::Integer>,
    }
    /// Variant in sequence
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Variant {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Start position of the variant on the  reference sequence
        #[prost(message, optional, tag = "4")]
        pub start: ::core::option::Option<super::Integer>,
        /// End position of the variant on the reference sequence
        #[prost(message, optional, tag = "5")]
        pub end: ::core::option::Option<super::Integer>,
        /// Allele that was observed
        #[prost(message, optional, tag = "6")]
        pub observed_allele: ::core::option::Option<super::String>,
        /// Allele in the reference sequence
        #[prost(message, optional, tag = "7")]
        pub reference_allele: ::core::option::Option<super::String>,
        /// Extended CIGAR string for aligning the sequence with reference bases
        #[prost(message, optional, tag = "8")]
        pub cigar: ::core::option::Option<super::String>,
        /// Pointer to observed variant information
        #[prost(message, optional, tag = "9")]
        pub variant_pointer: ::core::option::Option<super::Reference>,
    }
    /// An set of value as quality of sequence
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Quality {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// indel | snp | unknown
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::QualityTypeCode>,
        /// Standard sequence for comparison
        #[prost(message, optional, tag = "5")]
        pub standard_sequence: ::core::option::Option<super::CodeableConcept>,
        /// Start position of the sequence
        #[prost(message, optional, tag = "6")]
        pub start: ::core::option::Option<super::Integer>,
        /// End position of the sequence
        #[prost(message, optional, tag = "7")]
        pub end: ::core::option::Option<super::Integer>,
        /// Quality score for the comparison
        #[prost(message, optional, tag = "8")]
        pub score: ::core::option::Option<super::Quantity>,
        /// Method to get quality
        #[prost(message, optional, tag = "9")]
        pub method: ::core::option::Option<super::CodeableConcept>,
        /// True positives from the perspective of the truth data
        #[prost(message, optional, tag = "10")]
        pub truth_tp: ::core::option::Option<super::Decimal>,
        /// True positives from the perspective of the query data
        #[prost(message, optional, tag = "11")]
        pub query_tp: ::core::option::Option<super::Decimal>,
        /// False negatives
        #[prost(message, optional, tag = "12")]
        pub truth_fn: ::core::option::Option<super::Decimal>,
        /// False positives
        #[prost(message, optional, tag = "13")]
        pub query_fp: ::core::option::Option<super::Decimal>,
        /// False positives where the non-REF alleles in the Truth and Query Call
        /// Sets match
        #[prost(message, optional, tag = "14")]
        pub gt_fp: ::core::option::Option<super::Decimal>,
        /// Precision of comparison
        #[prost(message, optional, tag = "15")]
        pub precision: ::core::option::Option<super::Decimal>,
        /// Recall of comparison
        #[prost(message, optional, tag = "16")]
        pub recall: ::core::option::Option<super::Decimal>,
        /// F-score
        #[prost(message, optional, tag = "17")]
        pub f_score: ::core::option::Option<super::Decimal>,
    }
    /// External repository which contains detailed report related with observedSeq
    /// in this resource
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Repository {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// directlink | openapi | login | oauth | other
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::RepositoryTypeCode>,
        /// URI of the repository
        #[prost(message, optional, tag = "5")]
        pub url: ::core::option::Option<super::Uri>,
        /// Repository's name
        #[prost(message, optional, tag = "6")]
        pub name: ::core::option::Option<super::String>,
        /// Id of the dataset that used to call for dataset in repository
        #[prost(message, optional, tag = "7")]
        pub dataset_id: ::core::option::Option<super::String>,
        /// Id of the variantset that used to call for variantset in repository
        #[prost(message, optional, tag = "8")]
        pub variantset_id: ::core::option::Option<super::String>,
        /// Id of the read
        #[prost(message, optional, tag = "9")]
        pub readset_id: ::core::option::Option<super::String>,
    }
}
/// Auto-generated from StructureDefinition for ServiceDefinition, last updated
/// 2017-04-19T07:44:43.294+10:00. A description of decision support service
/// functionality. See <http://hl7.org/fhir/StructureDefinition/ServiceDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ServiceDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this service definition (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the service definition
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the service definition
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this service definition (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this service definition (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Natural language description of the service definition
    #[prost(message, optional, tag = "18")]
    pub description: ::core::option::Option<Markdown>,
    /// Why this service definition is defined
    #[prost(message, optional, tag = "19")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Describes the clinical usage of the module
    #[prost(message, optional, tag = "20")]
    pub usage: ::core::option::Option<String>,
    /// When the service definition was approved by publisher
    #[prost(message, optional, tag = "21")]
    pub approval_date: ::core::option::Option<Date>,
    /// When the service definition was last reviewed
    #[prost(message, optional, tag = "22")]
    pub last_review_date: ::core::option::Option<Date>,
    /// When the service definition is expected to be used
    #[prost(message, optional, tag = "23")]
    pub effective_period: ::core::option::Option<Period>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "24")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for service definition (if applicable)
    #[prost(message, repeated, tag = "25")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// E.g. Education, Treatment, Assessment, etc
    #[prost(message, repeated, tag = "26")]
    pub topic: prost::alloc::vec::Vec<CodeableConcept>,
    /// A content contributor
    #[prost(message, repeated, tag = "27")]
    pub contributor: prost::alloc::vec::Vec<Contributor>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "28")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "29")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Additional documentation, citations, etc
    #[prost(message, repeated, tag = "30")]
    pub related_artifact: prost::alloc::vec::Vec<RelatedArtifact>,
    /// "when" the module should be invoked
    #[prost(message, repeated, tag = "31")]
    pub trigger: prost::alloc::vec::Vec<TriggerDefinition>,
    /// What data is used by the module
    #[prost(message, repeated, tag = "32")]
    pub data_requirement: prost::alloc::vec::Vec<DataRequirement>,
    /// Operation to invoke
    #[prost(message, optional, tag = "33")]
    pub operation_definition: ::core::option::Option<Reference>,
}
/// Auto-generated from StructureDefinition for Slot, last updated
/// 2017-04-19T07:44:43.294+10:00. A slot of time on a schedule that may be
/// available for booking appointments. See
/// <http://hl7.org/fhir/StructureDefinition/Slot>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Slot {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Ids for this item
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// A broad categorisation of the service that is to be performed during this
    /// appointment
    #[prost(message, optional, tag = "10")]
    pub service_category: ::core::option::Option<CodeableConcept>,
    /// The type of appointments that can be booked into this slot (ideally this
    /// would be an identifiable service - which is at a location, rather than the
    /// location itself). If provided then this overrides the value provided on the
    /// availability resource
    #[prost(message, repeated, tag = "11")]
    pub service_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// The specialty of a practitioner that would be required to perform the
    /// service requested in this appointment
    #[prost(message, repeated, tag = "12")]
    pub specialty: prost::alloc::vec::Vec<CodeableConcept>,
    /// The style of appointment or patient that may be booked in the slot (not
    /// service type)
    #[prost(message, optional, tag = "13")]
    pub appointment_type: ::core::option::Option<CodeableConcept>,
    /// The schedule resource that this slot defines an interval of status
    /// information
    #[prost(message, optional, tag = "14")]
    pub schedule: ::core::option::Option<Reference>,
    /// busy | free | busy-unavailable | busy-tentative | entered-in-error
    #[prost(message, optional, tag = "15")]
    pub status: ::core::option::Option<SlotStatusCode>,
    /// Date/Time that the slot is to begin
    #[prost(message, optional, tag = "16")]
    pub start: ::core::option::Option<Instant>,
    /// Date/Time that the slot is to conclude
    #[prost(message, optional, tag = "17")]
    pub end: ::core::option::Option<Instant>,
    /// This slot has already been overbooked, appointments are unlikely to be
    /// accepted for this time
    #[prost(message, optional, tag = "18")]
    pub overbooked: ::core::option::Option<Boolean>,
    /// Comments on the slot to describe any extended information. Such as custom
    /// constraints on the slot
    #[prost(message, optional, tag = "19")]
    pub comment: ::core::option::Option<String>,
}
/// Auto-generated from StructureDefinition for Specimen, last updated
/// 2017-04-19T07:44:43.294+10:00. Sample for analysis. See
/// <http://hl7.org/fhir/StructureDefinition/Specimen>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Specimen {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Identifier assigned by the lab
    #[prost(message, optional, tag = "10")]
    pub accession_identifier: ::core::option::Option<Identifier>,
    /// available | unavailable | unsatisfactory | entered-in-error
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<SpecimenStatusCode>,
    /// Kind of material that forms the specimen
    #[prost(message, optional, tag = "12")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    /// Where the specimen came from. This may be from the patient(s) or from the
    /// environment or a device
    #[prost(message, optional, tag = "13")]
    pub subject: ::core::option::Option<Reference>,
    /// The time when specimen was received for processing
    #[prost(message, optional, tag = "14")]
    pub received_time: ::core::option::Option<DateTime>,
    /// Specimen from which this specimen originated
    #[prost(message, repeated, tag = "15")]
    pub parent: prost::alloc::vec::Vec<Reference>,
    /// Why the specimen was collected
    #[prost(message, repeated, tag = "16")]
    pub request: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "17")]
    pub collection: ::core::option::Option<specimen::Collection>,
    #[prost(message, repeated, tag = "18")]
    pub processing: prost::alloc::vec::Vec<specimen::Processing>,
    #[prost(message, repeated, tag = "19")]
    pub container: prost::alloc::vec::Vec<specimen::Container>,
    /// Comments
    #[prost(message, repeated, tag = "20")]
    pub note: prost::alloc::vec::Vec<Annotation>,
}
/// Nested message and enum types in `Specimen`.
pub mod specimen {
    /// Collection details
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Collection {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Who collected the specimen
        #[prost(message, optional, tag = "4")]
        pub collector: ::core::option::Option<super::Reference>,
        #[prost(message, optional, tag = "5")]
        pub collected: ::core::option::Option<collection::Collected>,
        /// The quantity of specimen collected
        #[prost(message, optional, tag = "6")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        /// Technique used to perform collection
        #[prost(message, optional, tag = "7")]
        pub method: ::core::option::Option<super::CodeableConcept>,
        /// Anatomical collection site
        #[prost(message, optional, tag = "8")]
        pub body_site: ::core::option::Option<super::CodeableConcept>,
    }
    /// Nested message and enum types in `Collection`.
    pub mod collection {
        /// Collection time
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Collected {
            #[prost(oneof = "collected::Collected", tags = "1, 2")]
            pub collected: ::core::option::Option<collected::Collected>,
        }
        /// Nested message and enum types in `Collected`.
        pub mod collected {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Collected {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
    }
    /// Processing and processing step details
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Processing {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Textual description of procedure
        #[prost(message, optional, tag = "4")]
        pub description: ::core::option::Option<super::String>,
        /// Indicates the treatment step  applied to the specimen
        #[prost(message, optional, tag = "5")]
        pub procedure: ::core::option::Option<super::CodeableConcept>,
        /// Material used in the processing step
        #[prost(message, repeated, tag = "6")]
        pub additive: prost::alloc::vec::Vec<super::Reference>,
        #[prost(message, optional, tag = "7")]
        pub time: ::core::option::Option<processing::Time>,
    }
    /// Nested message and enum types in `Processing`.
    pub mod processing {
        /// Date and time of specimen processing
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Time {
            #[prost(oneof = "time::Time", tags = "1, 2")]
            pub time: ::core::option::Option<time::Time>,
        }
        /// Nested message and enum types in `Time`.
        pub mod time {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Time {
                #[prost(message, tag = "1")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "2")]
                Period(super::super::super::Period),
            }
        }
    }
    /// Direct container of specimen (tube/slide, etc.)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Container {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Id for the container
        #[prost(message, repeated, tag = "4")]
        pub identifier: prost::alloc::vec::Vec<super::Identifier>,
        /// Textual description of the container
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        /// Kind of container directly associated with specimen
        #[prost(message, optional, tag = "6")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        /// Container volume or size
        #[prost(message, optional, tag = "7")]
        pub capacity: ::core::option::Option<super::SimpleQuantity>,
        /// Quantity of specimen within container
        #[prost(message, optional, tag = "8")]
        pub specimen_quantity: ::core::option::Option<super::SimpleQuantity>,
        #[prost(message, optional, tag = "9")]
        pub additive: ::core::option::Option<container::Additive>,
    }
    /// Nested message and enum types in `Container`.
    pub mod container {
        /// Additive associated with container
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Additive {
            #[prost(oneof = "additive::Additive", tags = "1, 2")]
            pub additive: ::core::option::Option<additive::Additive>,
        }
        /// Nested message and enum types in `Additive`.
        pub mod additive {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Additive {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for StructureDefinition, last updated
/// 2017-04-19T07:44:43.294+10:00. Structural Definition. See
/// <http://hl7.org/fhir/StructureDefinition/StructureDefinition>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureDefinition {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this structure definition (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the structure definition
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the structure definition
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this structure definition (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this structure definition (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the structure definition
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for structure definition (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this structure definition is defined
    #[prost(message, optional, tag = "22")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "23")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Assist with indexing and finding
    #[prost(message, repeated, tag = "24")]
    pub keyword: prost::alloc::vec::Vec<Coding>,
    /// FHIR Version this StructureDefinition targets
    #[prost(message, optional, tag = "25")]
    pub fhir_version: ::core::option::Option<Id>,
    #[prost(message, repeated, tag = "26")]
    pub mapping: prost::alloc::vec::Vec<structure_definition::Mapping>,
    /// primitive-type | complex-type | resource | logical
    #[prost(message, optional, tag = "27")]
    pub kind: ::core::option::Option<StructureDefinitionKindCode>,
    /// Whether the structure is abstract
    #[prost(message, optional, tag = "28")]
    pub r#abstract: ::core::option::Option<Boolean>,
    /// resource | datatype | extension
    #[prost(message, optional, tag = "29")]
    pub context_type: ::core::option::Option<ExtensionContextCode>,
    /// Where the extension can be used in instances
    #[prost(message, repeated, tag = "30")]
    pub context: prost::alloc::vec::Vec<String>,
    /// FHIRPath invariants - when the extension can be used
    #[prost(message, repeated, tag = "31")]
    pub context_invariant: prost::alloc::vec::Vec<String>,
    /// Type defined or constrained by this structure
    #[prost(message, optional, tag = "32")]
    pub r#type: ::core::option::Option<FhirDefinedTypeExtCode>,
    /// Definition that this type is constrained/specialized from
    #[prost(message, optional, tag = "33")]
    pub base_definition: ::core::option::Option<Uri>,
    /// specialization | constraint - How relates to base definition
    #[prost(message, optional, tag = "34")]
    pub derivation: ::core::option::Option<TypeDerivationRuleCode>,
    #[prost(message, optional, tag = "35")]
    pub snapshot: ::core::option::Option<structure_definition::Snapshot>,
    #[prost(message, optional, tag = "36")]
    pub differential: ::core::option::Option<structure_definition::Differential>,
}
/// Nested message and enum types in `StructureDefinition`.
pub mod structure_definition {
    /// External specification that the content is mapped to
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Mapping {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Internal id when this mapping is used
        #[prost(message, optional, tag = "4")]
        pub identity: ::core::option::Option<super::Id>,
        /// Identifies what this mapping refers to
        #[prost(message, optional, tag = "5")]
        pub uri: ::core::option::Option<super::Uri>,
        /// Names what this mapping refers to
        #[prost(message, optional, tag = "6")]
        pub name: ::core::option::Option<super::String>,
        /// Versions, Issues, Scope limitations etc.
        #[prost(message, optional, tag = "7")]
        pub comment: ::core::option::Option<super::String>,
    }
    /// Snapshot view of the structure
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Snapshot {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Definition of elements in the resource (if no StructureDefinition)
        #[prost(message, repeated, tag = "4")]
        pub element: prost::alloc::vec::Vec<super::ElementDefinition>,
    }
    /// Differential view of the structure
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Differential {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Definition of elements in the resource (if no StructureDefinition)
        #[prost(message, repeated, tag = "4")]
        pub element: prost::alloc::vec::Vec<super::ElementDefinition>,
    }
}
/// Auto-generated from StructureDefinition for StructureMap, last updated
/// 2017-04-19T07:44:43.294+10:00. A Map of relationships between 2 structures
/// that can be used to transform data. See
/// <http://hl7.org/fhir/StructureDefinition/StructureMap>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct StructureMap {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this structure map (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the structure map
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the structure map
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this structure map (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this structure map (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the structure map
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for structure map (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this structure map is defined
    #[prost(message, optional, tag = "22")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "23")]
    pub copyright: ::core::option::Option<Markdown>,
    #[prost(message, repeated, tag = "24")]
    pub structure: prost::alloc::vec::Vec<structure_map::Structure>,
    /// Other maps used by this map (canonical URLs)
    #[prost(message, repeated, tag = "25")]
    pub import: prost::alloc::vec::Vec<Uri>,
    #[prost(message, repeated, tag = "26")]
    pub group: prost::alloc::vec::Vec<structure_map::Group>,
}
/// Nested message and enum types in `StructureMap`.
pub mod structure_map {
    /// Structure Definition used by this map
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Structure {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Canonical URL for structure definition
        #[prost(message, optional, tag = "4")]
        pub url: ::core::option::Option<super::Uri>,
        /// source | queried | target | produced
        #[prost(message, optional, tag = "5")]
        pub mode: ::core::option::Option<super::StructureMapModelModeCode>,
        /// Name for type in this map
        #[prost(message, optional, tag = "6")]
        pub alias: ::core::option::Option<super::String>,
        /// Documentation on use of structure
        #[prost(message, optional, tag = "7")]
        pub documentation: ::core::option::Option<super::String>,
    }
    /// Named sections for reader convenience
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Group {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Human-readable label
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::Id>,
        /// Another group that this group adds rules to
        #[prost(message, optional, tag = "5")]
        pub extends: ::core::option::Option<super::Id>,
        /// none | types | type-and-types
        #[prost(message, optional, tag = "6")]
        pub type_mode: ::core::option::Option<super::StructureMapGroupTypeModeCode>,
        /// Additional description/explaination for group
        #[prost(message, optional, tag = "7")]
        pub documentation: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "8")]
        pub input: prost::alloc::vec::Vec<group::Input>,
        #[prost(message, repeated, tag = "9")]
        pub rule: prost::alloc::vec::Vec<group::Rule>,
    }
    /// Nested message and enum types in `Group`.
    pub mod group {
        /// Named instance provided when invoking the map
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Input {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Name for this instance of data
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::Id>,
            /// Type for this instance of data
            #[prost(message, optional, tag = "5")]
            pub r#type: ::core::option::Option<super::super::String>,
            /// source | target
            #[prost(message, optional, tag = "6")]
            pub mode: ::core::option::Option<super::super::StructureMapInputModeCode>,
            /// Documentation for this instance of data
            #[prost(message, optional, tag = "7")]
            pub documentation: ::core::option::Option<super::super::String>,
        }
        /// Transform Rule from source to target
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Rule {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Name of the rule for internal references
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::Id>,
            #[prost(message, repeated, tag = "5")]
            pub source: prost::alloc::vec::Vec<rule::Source>,
            #[prost(message, repeated, tag = "6")]
            pub target: prost::alloc::vec::Vec<rule::Target>,
            /// Rules contained in this rule
            #[prost(message, repeated, tag = "7")]
            pub rule: prost::alloc::vec::Vec<Rule>,
            #[prost(message, repeated, tag = "8")]
            pub dependent: prost::alloc::vec::Vec<rule::Dependent>,
            /// Documentation for this instance of data
            #[prost(message, optional, tag = "9")]
            pub documentation: ::core::option::Option<super::super::String>,
        }
        /// Nested message and enum types in `Rule`.
        pub mod rule {
            /// Source inputs to the mapping
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Source {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Type or variable this rule applies to
                #[prost(message, optional, tag = "4")]
                pub context: ::core::option::Option<super::super::super::Id>,
                /// Specified minimum cardinality
                #[prost(message, optional, tag = "5")]
                pub min: ::core::option::Option<super::super::super::Integer>,
                /// Specified maximum cardinality (number or *)
                #[prost(message, optional, tag = "6")]
                pub max: ::core::option::Option<super::super::super::String>,
                /// Rule only applies if source has this type
                #[prost(message, optional, tag = "7")]
                pub r#type: ::core::option::Option<super::super::super::String>,
                #[prost(message, optional, tag = "8")]
                pub default_value: ::core::option::Option<source::DefaultValue>,
                /// Optional field for this source
                #[prost(message, optional, tag = "9")]
                pub element: ::core::option::Option<super::super::super::String>,
                /// first | not_first | last | not_last | only_one
                #[prost(message, optional, tag = "10")]
                pub list_mode:
                    ::core::option::Option<super::super::super::StructureMapSourceListModeCode>,
                /// Named context for field, if a field is specified
                #[prost(message, optional, tag = "11")]
                pub variable: ::core::option::Option<super::super::super::Id>,
                /// FHIRPath expression  - must be true or the rule does not apply
                #[prost(message, optional, tag = "12")]
                pub condition: ::core::option::Option<super::super::super::String>,
                /// FHIRPath expression  - must be true or the mapping engine throws an
                /// error instead of completing
                #[prost(message, optional, tag = "13")]
                pub check: ::core::option::Option<super::super::super::String>,
            }
            /// Nested message and enum types in `Source`.
            pub mod source {
                /// Default value if no value exists
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct DefaultValue {
                    #[prost(
                        oneof = "default_value::DefaultValue",
                        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
                    )]
                    pub default_value: ::core::option::Option<default_value::DefaultValue>,
                }
                /// Nested message and enum types in `DefaultValue`.
                pub mod default_value {
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Oneof)]
                    pub enum DefaultValue {
                        #[prost(message, tag = "1")]
                        Base64Binary(super::super::super::super::super::Base64Binary),
                        #[prost(message, tag = "2")]
                        Boolean(super::super::super::super::super::Boolean),
                        #[prost(message, tag = "3")]
                        Code(super::super::super::super::super::Code),
                        #[prost(message, tag = "4")]
                        Date(super::super::super::super::super::Date),
                        #[prost(message, tag = "5")]
                        DateTime(super::super::super::super::super::DateTime),
                        #[prost(message, tag = "6")]
                        Decimal(super::super::super::super::super::Decimal),
                        #[prost(message, tag = "7")]
                        Id(super::super::super::super::super::Id),
                        #[prost(message, tag = "8")]
                        Instant(super::super::super::super::super::Instant),
                        #[prost(message, tag = "9")]
                        Integer(super::super::super::super::super::Integer),
                        #[prost(message, tag = "10")]
                        Markdown(super::super::super::super::super::Markdown),
                        #[prost(message, tag = "11")]
                        Oid(super::super::super::super::super::Oid),
                        #[prost(message, tag = "12")]
                        PositiveInt(super::super::super::super::super::PositiveInt),
                        #[prost(message, tag = "13")]
                        StringValue(super::super::super::super::super::String),
                        #[prost(message, tag = "14")]
                        Time(super::super::super::super::super::Time),
                        #[prost(message, tag = "15")]
                        UnsignedInt(super::super::super::super::super::UnsignedInt),
                        #[prost(message, tag = "16")]
                        Uri(super::super::super::super::super::Uri),
                        #[prost(message, tag = "17")]
                        Address(super::super::super::super::super::Address),
                        #[prost(message, tag = "18")]
                        Age(super::super::super::super::super::Age),
                        #[prost(message, tag = "19")]
                        Annotation(super::super::super::super::super::Annotation),
                        #[prost(message, tag = "20")]
                        Attachment(super::super::super::super::super::Attachment),
                        #[prost(message, tag = "21")]
                        CodeableConcept(super::super::super::super::super::CodeableConcept),
                        #[prost(message, tag = "22")]
                        Coding(super::super::super::super::super::Coding),
                        #[prost(message, tag = "23")]
                        ContactPoint(super::super::super::super::super::ContactPoint),
                        #[prost(message, tag = "24")]
                        Count(super::super::super::super::super::Count),
                        #[prost(message, tag = "25")]
                        Distance(super::super::super::super::super::Distance),
                        #[prost(message, tag = "26")]
                        Duration(super::super::super::super::super::Duration),
                        #[prost(message, tag = "27")]
                        HumanName(super::super::super::super::super::HumanName),
                        #[prost(message, tag = "28")]
                        Identifier(super::super::super::super::super::Identifier),
                        #[prost(message, tag = "29")]
                        Money(super::super::super::super::super::Money),
                        #[prost(message, tag = "30")]
                        Period(super::super::super::super::super::Period),
                        #[prost(message, tag = "31")]
                        Quantity(super::super::super::super::super::Quantity),
                        #[prost(message, tag = "32")]
                        Range(super::super::super::super::super::Range),
                        #[prost(message, tag = "33")]
                        Ratio(super::super::super::super::super::Ratio),
                        #[prost(message, tag = "34")]
                        Reference(super::super::super::super::super::Reference),
                        #[prost(message, tag = "35")]
                        SampledData(super::super::super::super::super::SampledData),
                        #[prost(message, tag = "36")]
                        Signature(super::super::super::super::super::Signature),
                        #[prost(message, tag = "37")]
                        Timing(super::super::super::super::super::Timing),
                        #[prost(message, tag = "38")]
                        Meta(super::super::super::super::super::Meta),
                    }
                }
            }
            /// Content to create because of this mapping rule
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Target {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Type or variable this rule applies to
                #[prost(message, optional, tag = "4")]
                pub context: ::core::option::Option<super::super::super::Id>,
                /// type | variable
                #[prost(message, optional, tag = "5")]
                pub context_type:
                    ::core::option::Option<super::super::super::StructureMapContextTypeCode>,
                /// Field to create in the context
                #[prost(message, optional, tag = "6")]
                pub element: ::core::option::Option<super::super::super::String>,
                /// Named context for field, if desired, and a field is specified
                #[prost(message, optional, tag = "7")]
                pub variable: ::core::option::Option<super::super::super::Id>,
                /// first | share | last | collate
                #[prost(message, repeated, tag = "8")]
                pub list_mode:
                    prost::alloc::vec::Vec<super::super::super::StructureMapTargetListModeCode>,
                /// Internal rule reference for shared list items
                #[prost(message, optional, tag = "9")]
                pub list_rule_id: ::core::option::Option<super::super::super::Id>,
                /// create | copy +
                #[prost(message, optional, tag = "10")]
                pub transform:
                    ::core::option::Option<super::super::super::StructureMapTransformCode>,
                #[prost(message, repeated, tag = "11")]
                pub parameter: prost::alloc::vec::Vec<target::Parameter>,
            }
            /// Nested message and enum types in `Target`.
            pub mod target {
                /// Parameters to the transform
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct Parameter {
                    /// xml:id (or equivalent in JSON)
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional Content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    #[prost(message, optional, tag = "4")]
                    pub value: ::core::option::Option<parameter::Value>,
                }
                /// Nested message and enum types in `Parameter`.
                pub mod parameter {
                    /// Parameter value - variable or literal
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Message)]
                    pub struct Value {
                        #[prost(oneof = "value::Value", tags = "1, 2, 3, 4, 5")]
                        pub value: ::core::option::Option<value::Value>,
                    }
                    /// Nested message and enum types in `Value`.
                    pub mod value {
                        #[derive(Serialize, Deserialize)]
                        #[serde(rename_all = "camelCase")]
                        #[derive(Clone, PartialEq, prost::Oneof)]
                        pub enum Value {
                            #[prost(message, tag = "1")]
                            Id(super::super::super::super::super::super::Id),
                            #[prost(message, tag = "2")]
                            StringValue(super::super::super::super::super::super::String),
                            #[prost(message, tag = "3")]
                            Boolean(super::super::super::super::super::super::Boolean),
                            #[prost(message, tag = "4")]
                            Integer(super::super::super::super::super::super::Integer),
                            #[prost(message, tag = "5")]
                            Decimal(super::super::super::super::super::super::Decimal),
                        }
                    }
                }
            }
            /// Which other rules to apply in the context of this rule
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Dependent {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Name of a rule or group to apply
                #[prost(message, optional, tag = "4")]
                pub name: ::core::option::Option<super::super::super::Id>,
                /// Variable to pass to the rule or group
                #[prost(message, repeated, tag = "5")]
                pub variable: prost::alloc::vec::Vec<super::super::super::String>,
            }
        }
    }
}
/// Auto-generated from StructureDefinition for Subscription, last updated
/// 2017-04-19T07:44:43.294+10:00. A server push subscription criteria. See
/// <http://hl7.org/fhir/StructureDefinition/Subscription>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Subscription {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// requested | active | error | off
    #[prost(message, optional, tag = "9")]
    pub status: ::core::option::Option<SubscriptionStatusCode>,
    /// Contact details for source (e.g. troubleshooting)
    #[prost(message, repeated, tag = "10")]
    pub contact: prost::alloc::vec::Vec<ContactPoint>,
    /// When to automatically delete the subscription
    #[prost(message, optional, tag = "11")]
    pub end: ::core::option::Option<Instant>,
    /// Description of why this subscription was created
    #[prost(message, optional, tag = "12")]
    pub reason: ::core::option::Option<String>,
    /// Rule for server push criteria
    #[prost(message, optional, tag = "13")]
    pub criteria: ::core::option::Option<String>,
    /// Latest error note
    #[prost(message, optional, tag = "14")]
    pub error: ::core::option::Option<String>,
    #[prost(message, optional, tag = "15")]
    pub channel: ::core::option::Option<subscription::Channel>,
    /// A tag to add to matching resources
    #[prost(message, repeated, tag = "16")]
    pub tag: prost::alloc::vec::Vec<Coding>,
}
/// Nested message and enum types in `Subscription`.
pub mod subscription {
    /// The channel on which to report matches to the criteria
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Channel {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// rest-hook | websocket | email | sms | message
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::SubscriptionChannelTypeCode>,
        /// Where the channel points to
        #[prost(message, optional, tag = "5")]
        pub endpoint: ::core::option::Option<super::Uri>,
        /// Mimetype to send, or omit for no payload
        #[prost(message, optional, tag = "6")]
        pub payload: ::core::option::Option<super::String>,
        /// Usage depends on the channel type
        #[prost(message, repeated, tag = "7")]
        pub header: prost::alloc::vec::Vec<super::String>,
    }
}
/// Auto-generated from StructureDefinition for Substance, last updated
/// 2017-04-19T07:44:43.294+10:00. A homogeneous material with a definite
/// composition. See <http://hl7.org/fhir/StructureDefinition/Substance>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Substance {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | inactive | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FhirSubstanceStatusCode>,
    /// What class/type of substance this is
    #[prost(message, repeated, tag = "11")]
    pub category: prost::alloc::vec::Vec<CodeableConcept>,
    /// What substance this is
    #[prost(message, optional, tag = "12")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Textual description of the substance, comments
    #[prost(message, optional, tag = "13")]
    pub description: ::core::option::Option<String>,
    #[prost(message, repeated, tag = "14")]
    pub instance: prost::alloc::vec::Vec<substance::Instance>,
    #[prost(message, repeated, tag = "15")]
    pub ingredient: prost::alloc::vec::Vec<substance::Ingredient>,
}
/// Nested message and enum types in `Substance`.
pub mod substance {
    /// If this describes a specific package/container of the substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Instance {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Identifier of the package/container
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Identifier>,
        /// When no longer valid to use
        #[prost(message, optional, tag = "5")]
        pub expiry: ::core::option::Option<super::DateTime>,
        /// Amount of substance in the package
        #[prost(message, optional, tag = "6")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
    }
    /// Composition information about the substance
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Ingredient {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Optional amount (concentration)
        #[prost(message, optional, tag = "4")]
        pub quantity: ::core::option::Option<super::Ratio>,
        #[prost(message, optional, tag = "5")]
        pub substance: ::core::option::Option<ingredient::SubstanceType>,
    }
    /// Nested message and enum types in `Ingredient`.
    pub mod ingredient {
        /// A component of the substance
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SubstanceType {
            #[prost(oneof = "substance_type::Substance", tags = "1, 2")]
            pub substance: ::core::option::Option<substance_type::Substance>,
        }
        /// Nested message and enum types in `SubstanceType`.
        pub mod substance_type {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Substance {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for SupplyDelivery, last updated
/// 2017-04-19T07:44:43.294+10:00. Delivery of bulk Supplies. See
/// <http://hl7.org/fhir/StructureDefinition/SupplyDelivery>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyDelivery {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Fulfills plan, proposal or order
    #[prost(message, repeated, tag = "10")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Part of referenced event
    #[prost(message, repeated, tag = "11")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// in-progress | completed | abandoned | entered-in-error
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<SupplyDeliveryStatusCode>,
    /// Patient for whom the item is supplied
    #[prost(message, optional, tag = "13")]
    pub patient: ::core::option::Option<Reference>,
    /// Category of dispense event
    #[prost(message, optional, tag = "14")]
    pub r#type: ::core::option::Option<CodeableConcept>,
    #[prost(message, optional, tag = "15")]
    pub supplied_item: ::core::option::Option<supply_delivery::SuppliedItem>,
    #[prost(message, optional, tag = "16")]
    pub occurrence: ::core::option::Option<supply_delivery::Occurrence>,
    /// Dispenser
    #[prost(message, optional, tag = "17")]
    pub supplier: ::core::option::Option<Reference>,
    /// Where the Supply was sent
    #[prost(message, optional, tag = "18")]
    pub destination: ::core::option::Option<Reference>,
    /// Who collected the Supply
    #[prost(message, repeated, tag = "19")]
    pub receiver: prost::alloc::vec::Vec<Reference>,
}
/// Nested message and enum types in `SupplyDelivery`.
pub mod supply_delivery {
    /// The item that is delivered or supplied
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct SuppliedItem {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Amount dispensed
        #[prost(message, optional, tag = "4")]
        pub quantity: ::core::option::Option<super::SimpleQuantity>,
        #[prost(message, optional, tag = "5")]
        pub item: ::core::option::Option<supplied_item::Item>,
    }
    /// Nested message and enum types in `SuppliedItem`.
    pub mod supplied_item {
        /// Medication, Substance, or Device supplied
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Item {
            #[prost(oneof = "item::Item", tags = "1, 2")]
            pub item: ::core::option::Option<item::Item>,
        }
        /// Nested message and enum types in `Item`.
        pub mod item {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Item {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// When event occurred
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Occurrence {
        #[prost(oneof = "occurrence::Occurrence", tags = "1, 2, 3")]
        pub occurrence: ::core::option::Option<occurrence::Occurrence>,
    }
    /// Nested message and enum types in `Occurrence`.
    pub mod occurrence {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Occurrence {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
        }
    }
}
/// Auto-generated from StructureDefinition for SupplyRequest, last updated
/// 2017-04-19T07:44:43.294+10:00. Request for a medication, substance or device.
/// See <http://hl7.org/fhir/StructureDefinition/SupplyRequest>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct SupplyRequest {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Unique identifier
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// draft | active | suspended +
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<SupplyRequestStatusCode>,
    /// The kind of supply (central, non-stock, etc.)
    #[prost(message, optional, tag = "11")]
    pub category: ::core::option::Option<CodeableConcept>,
    /// routine | urgent | asap | stat
    #[prost(message, optional, tag = "12")]
    pub priority: ::core::option::Option<RequestPriorityCode>,
    #[prost(message, optional, tag = "13")]
    pub ordered_item: ::core::option::Option<supply_request::OrderedItem>,
    #[prost(message, optional, tag = "14")]
    pub occurrence: ::core::option::Option<supply_request::Occurrence>,
    /// When the request was made
    #[prost(message, optional, tag = "15")]
    pub authored_on: ::core::option::Option<DateTime>,
    #[prost(message, optional, tag = "16")]
    pub requester: ::core::option::Option<supply_request::Requester>,
    /// Who is intended to fulfill the request
    #[prost(message, repeated, tag = "17")]
    pub supplier: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "18")]
    pub reason: ::core::option::Option<supply_request::Reason>,
    /// The origin of the supply
    #[prost(message, optional, tag = "19")]
    pub deliver_from: ::core::option::Option<Reference>,
    /// The destination of the supply
    #[prost(message, optional, tag = "20")]
    pub deliver_to: ::core::option::Option<Reference>,
}
/// Nested message and enum types in `SupplyRequest`.
pub mod supply_request {
    /// The item being requested
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct OrderedItem {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The requested amount of the item indicated
        #[prost(message, optional, tag = "4")]
        pub quantity: ::core::option::Option<super::Quantity>,
        #[prost(message, optional, tag = "5")]
        pub item: ::core::option::Option<ordered_item::Item>,
    }
    /// Nested message and enum types in `OrderedItem`.
    pub mod ordered_item {
        /// Medication, Substance, or Device requested to be supplied
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Item {
            #[prost(oneof = "item::Item", tags = "1, 2")]
            pub item: ::core::option::Option<item::Item>,
        }
        /// Nested message and enum types in `Item`.
        pub mod item {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Item {
                #[prost(message, tag = "1")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "2")]
                Reference(super::super::super::Reference),
            }
        }
    }
    /// When the request should be fulfilled
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Occurrence {
        #[prost(oneof = "occurrence::Occurrence", tags = "1, 2, 3")]
        pub occurrence: ::core::option::Option<occurrence::Occurrence>,
    }
    /// Nested message and enum types in `Occurrence`.
    pub mod occurrence {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Occurrence {
            #[prost(message, tag = "1")]
            DateTime(super::super::DateTime),
            #[prost(message, tag = "2")]
            Period(super::super::Period),
            #[prost(message, tag = "3")]
            Timing(super::super::Timing),
        }
    }
    /// Who/what is requesting service
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Requester {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Individual making the request
        #[prost(message, optional, tag = "4")]
        pub agent: ::core::option::Option<super::Reference>,
        /// Organization agent is acting for
        #[prost(message, optional, tag = "5")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
    /// Why the supply item was requested
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Reason {
        #[prost(oneof = "reason::Reason", tags = "1, 2")]
        pub reason: ::core::option::Option<reason::Reason>,
    }
    /// Nested message and enum types in `Reason`.
    pub mod reason {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
}
/// Auto-generated from StructureDefinition for Task, last updated
/// 2017-04-19T07:44:43.294+10:00. A task to be performed. See
/// <http://hl7.org/fhir/StructureDefinition/Task>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Task {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Task Instance Identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    #[prost(message, optional, tag = "10")]
    pub definition: ::core::option::Option<task::Definition>,
    /// Request fulfilled by this task
    #[prost(message, repeated, tag = "11")]
    pub based_on: prost::alloc::vec::Vec<Reference>,
    /// Requisition or grouper id
    #[prost(message, optional, tag = "12")]
    pub group_identifier: ::core::option::Option<Identifier>,
    /// Composite task
    #[prost(message, repeated, tag = "13")]
    pub part_of: prost::alloc::vec::Vec<Reference>,
    /// draft | requested | received | accepted | +
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<TaskStatusCode>,
    /// Reason for current status
    #[prost(message, optional, tag = "15")]
    pub status_reason: ::core::option::Option<CodeableConcept>,
    /// E.g. "Specimen collected", "IV prepped"
    #[prost(message, optional, tag = "16")]
    pub business_status: ::core::option::Option<CodeableConcept>,
    /// proposal | plan | order +
    #[prost(message, optional, tag = "17")]
    pub intent: ::core::option::Option<RequestIntentCode>,
    /// normal | urgent | asap | stat
    #[prost(message, optional, tag = "18")]
    pub priority: ::core::option::Option<RequestPriorityCode>,
    /// Task Type
    #[prost(message, optional, tag = "19")]
    pub code: ::core::option::Option<CodeableConcept>,
    /// Human-readable explanation of task
    #[prost(message, optional, tag = "20")]
    pub description: ::core::option::Option<String>,
    /// What task is acting on
    #[prost(message, optional, tag = "21")]
    pub focus: ::core::option::Option<Reference>,
    /// Beneficiary of the Task
    #[prost(message, optional, tag = "22")]
    pub for_value: ::core::option::Option<Reference>,
    /// Healthcare event during which this task originated
    #[prost(message, optional, tag = "23")]
    pub context: ::core::option::Option<Reference>,
    /// Start and end time of execution
    #[prost(message, optional, tag = "24")]
    pub execution_period: ::core::option::Option<Period>,
    /// Task Creation Date
    #[prost(message, optional, tag = "25")]
    pub authored_on: ::core::option::Option<DateTime>,
    /// Task Last Modified Date
    #[prost(message, optional, tag = "26")]
    pub last_modified: ::core::option::Option<DateTime>,
    #[prost(message, optional, tag = "27")]
    pub requester: ::core::option::Option<task::Requester>,
    /// requester | dispatcher | scheduler | performer | monitor | manager |
    /// acquirer | reviewer
    #[prost(message, repeated, tag = "28")]
    pub performer_type: prost::alloc::vec::Vec<CodeableConcept>,
    /// Responsible individual
    #[prost(message, optional, tag = "29")]
    pub owner: ::core::option::Option<Reference>,
    /// Why task is needed
    #[prost(message, optional, tag = "30")]
    pub reason: ::core::option::Option<CodeableConcept>,
    /// Comments made about the task
    #[prost(message, repeated, tag = "31")]
    pub note: prost::alloc::vec::Vec<Annotation>,
    /// Key events in history of the Task
    #[prost(message, repeated, tag = "32")]
    pub relevant_history: prost::alloc::vec::Vec<Reference>,
    #[prost(message, optional, tag = "33")]
    pub restriction: ::core::option::Option<task::Restriction>,
    #[prost(message, repeated, tag = "34")]
    pub input: prost::alloc::vec::Vec<task::Parameter>,
    #[prost(message, repeated, tag = "35")]
    pub output: prost::alloc::vec::Vec<task::Output>,
}
/// Nested message and enum types in `Task`.
pub mod task {
    /// Formal definition of task
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Definition {
        #[prost(oneof = "definition::Definition", tags = "1, 2")]
        pub definition: ::core::option::Option<definition::Definition>,
    }
    /// Nested message and enum types in `Definition`.
    pub mod definition {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Definition {
            #[prost(message, tag = "1")]
            Uri(super::super::Uri),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Who is asking for task to be done
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Requester {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Individual asking for task
        #[prost(message, optional, tag = "4")]
        pub agent: ::core::option::Option<super::Reference>,
        /// Organization individual is acting for
        #[prost(message, optional, tag = "5")]
        pub on_behalf_of: ::core::option::Option<super::Reference>,
    }
    /// Constraints on fulfillment tasks
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Restriction {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// How many times to repeat
        #[prost(message, optional, tag = "4")]
        pub repetitions: ::core::option::Option<super::PositiveInt>,
        /// When fulfillment sought
        #[prost(message, optional, tag = "5")]
        pub period: ::core::option::Option<super::Period>,
        /// For whom is fulfillment sought?
        #[prost(message, repeated, tag = "6")]
        pub recipient: prost::alloc::vec::Vec<super::Reference>,
    }
    /// Information used to perform task
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Parameter {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Label for the input
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<parameter::Value>,
    }
    /// Nested message and enum types in `Parameter`.
    pub mod parameter {
        /// Content to use in performing the task
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Value {
            #[prost(
                oneof = "value::Value",
                tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
            )]
            pub value: ::core::option::Option<value::Value>,
        }
        /// Nested message and enum types in `Value`.
        pub mod value {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Value {
                #[prost(message, tag = "1")]
                Base64Binary(super::super::super::Base64Binary),
                #[prost(message, tag = "2")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "3")]
                Code(super::super::super::Code),
                #[prost(message, tag = "4")]
                Date(super::super::super::Date),
                #[prost(message, tag = "5")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "6")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "7")]
                Id(super::super::super::Id),
                #[prost(message, tag = "8")]
                Instant(super::super::super::Instant),
                #[prost(message, tag = "9")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "10")]
                Markdown(super::super::super::Markdown),
                #[prost(message, tag = "11")]
                Oid(super::super::super::Oid),
                #[prost(message, tag = "12")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "13")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "14")]
                Time(super::super::super::Time),
                #[prost(message, tag = "15")]
                UnsignedInt(super::super::super::UnsignedInt),
                #[prost(message, tag = "16")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "17")]
                Address(super::super::super::Address),
                #[prost(message, tag = "18")]
                Age(super::super::super::Age),
                #[prost(message, tag = "19")]
                Annotation(super::super::super::Annotation),
                #[prost(message, tag = "20")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "21")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "22")]
                Coding(super::super::super::Coding),
                #[prost(message, tag = "23")]
                ContactPoint(super::super::super::ContactPoint),
                #[prost(message, tag = "24")]
                Count(super::super::super::Count),
                #[prost(message, tag = "25")]
                Distance(super::super::super::Distance),
                #[prost(message, tag = "26")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "27")]
                HumanName(super::super::super::HumanName),
                #[prost(message, tag = "28")]
                Identifier(super::super::super::Identifier),
                #[prost(message, tag = "29")]
                Money(super::super::super::Money),
                #[prost(message, tag = "30")]
                Period(super::super::super::Period),
                #[prost(message, tag = "31")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "32")]
                Range(super::super::super::Range),
                #[prost(message, tag = "33")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "34")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "35")]
                SampledData(super::super::super::SampledData),
                #[prost(message, tag = "36")]
                Signature(super::super::super::Signature),
                #[prost(message, tag = "37")]
                Timing(super::super::super::Timing),
                #[prost(message, tag = "38")]
                Meta(super::super::super::Meta),
            }
        }
    }
    /// Information produced as part of task
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Output {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Label for output
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::CodeableConcept>,
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<output::Value>,
    }
    /// Nested message and enum types in `Output`.
    pub mod output {
        /// Result of output
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Value {
            #[prost(
                oneof = "value::Value",
                tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38"
            )]
            pub value: ::core::option::Option<value::Value>,
        }
        /// Nested message and enum types in `Value`.
        pub mod value {
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Oneof)]
            pub enum Value {
                #[prost(message, tag = "1")]
                Base64Binary(super::super::super::Base64Binary),
                #[prost(message, tag = "2")]
                Boolean(super::super::super::Boolean),
                #[prost(message, tag = "3")]
                Code(super::super::super::Code),
                #[prost(message, tag = "4")]
                Date(super::super::super::Date),
                #[prost(message, tag = "5")]
                DateTime(super::super::super::DateTime),
                #[prost(message, tag = "6")]
                Decimal(super::super::super::Decimal),
                #[prost(message, tag = "7")]
                Id(super::super::super::Id),
                #[prost(message, tag = "8")]
                Instant(super::super::super::Instant),
                #[prost(message, tag = "9")]
                Integer(super::super::super::Integer),
                #[prost(message, tag = "10")]
                Markdown(super::super::super::Markdown),
                #[prost(message, tag = "11")]
                Oid(super::super::super::Oid),
                #[prost(message, tag = "12")]
                PositiveInt(super::super::super::PositiveInt),
                #[prost(message, tag = "13")]
                StringValue(super::super::super::String),
                #[prost(message, tag = "14")]
                Time(super::super::super::Time),
                #[prost(message, tag = "15")]
                UnsignedInt(super::super::super::UnsignedInt),
                #[prost(message, tag = "16")]
                Uri(super::super::super::Uri),
                #[prost(message, tag = "17")]
                Address(super::super::super::Address),
                #[prost(message, tag = "18")]
                Age(super::super::super::Age),
                #[prost(message, tag = "19")]
                Annotation(super::super::super::Annotation),
                #[prost(message, tag = "20")]
                Attachment(super::super::super::Attachment),
                #[prost(message, tag = "21")]
                CodeableConcept(super::super::super::CodeableConcept),
                #[prost(message, tag = "22")]
                Coding(super::super::super::Coding),
                #[prost(message, tag = "23")]
                ContactPoint(super::super::super::ContactPoint),
                #[prost(message, tag = "24")]
                Count(super::super::super::Count),
                #[prost(message, tag = "25")]
                Distance(super::super::super::Distance),
                #[prost(message, tag = "26")]
                Duration(super::super::super::Duration),
                #[prost(message, tag = "27")]
                HumanName(super::super::super::HumanName),
                #[prost(message, tag = "28")]
                Identifier(super::super::super::Identifier),
                #[prost(message, tag = "29")]
                Money(super::super::super::Money),
                #[prost(message, tag = "30")]
                Period(super::super::super::Period),
                #[prost(message, tag = "31")]
                Quantity(super::super::super::Quantity),
                #[prost(message, tag = "32")]
                Range(super::super::super::Range),
                #[prost(message, tag = "33")]
                Ratio(super::super::super::Ratio),
                #[prost(message, tag = "34")]
                Reference(super::super::super::Reference),
                #[prost(message, tag = "35")]
                SampledData(super::super::super::SampledData),
                #[prost(message, tag = "36")]
                Signature(super::super::super::Signature),
                #[prost(message, tag = "37")]
                Timing(super::super::super::Timing),
                #[prost(message, tag = "38")]
                Meta(super::super::super::Meta),
            }
        }
    }
}
/// Auto-generated from StructureDefinition for TestReport, last updated
/// 2017-04-19T07:44:43.294+10:00. Describes the results of a TestScript
/// execution. See <http://hl7.org/fhir/StructureDefinition/TestReport>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestReport {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// External identifier
    #[prost(message, optional, tag = "9")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Informal name of the executed TestScript
    #[prost(message, optional, tag = "10")]
    pub name: ::core::option::Option<String>,
    /// completed | in-progress | waiting | stopped | entered-in-error
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<TestReportStatusCode>,
    /// Reference to the  version-specific TestScript that was executed to produce
    /// this TestReport
    #[prost(message, optional, tag = "12")]
    pub test_script: ::core::option::Option<Reference>,
    /// pass | fail | pending
    #[prost(message, optional, tag = "13")]
    pub result: ::core::option::Option<TestReportResultCode>,
    /// The final score (percentage of tests passed) resulting from the execution
    /// of the TestScript
    #[prost(message, optional, tag = "14")]
    pub score: ::core::option::Option<Decimal>,
    /// Name of the tester producing this report (Organization or individual)
    #[prost(message, optional, tag = "15")]
    pub tester: ::core::option::Option<String>,
    /// When the TestScript was executed and this TestReport was generated
    #[prost(message, optional, tag = "16")]
    pub issued: ::core::option::Option<DateTime>,
    #[prost(message, repeated, tag = "17")]
    pub participant: prost::alloc::vec::Vec<test_report::Participant>,
    #[prost(message, optional, tag = "18")]
    pub setup: ::core::option::Option<test_report::Setup>,
    #[prost(message, repeated, tag = "19")]
    pub test: prost::alloc::vec::Vec<test_report::Test>,
    #[prost(message, optional, tag = "20")]
    pub teardown: ::core::option::Option<test_report::Teardown>,
}
/// Nested message and enum types in `TestReport`.
pub mod test_report {
    /// A participant in the test execution, either the execution engine, a client,
    /// or a server
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Participant {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// test-engine | client | server
        #[prost(message, optional, tag = "4")]
        pub r#type: ::core::option::Option<super::TestReportParticipantTypeCode>,
        /// The uri of the participant. An absolute URL is preferred
        #[prost(message, optional, tag = "5")]
        pub uri: ::core::option::Option<super::Uri>,
        /// The display name of the participant
        #[prost(message, optional, tag = "6")]
        pub display: ::core::option::Option<super::String>,
    }
    /// The results of the series of required setup operations before the tests
    /// were executed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Setup {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub action: prost::alloc::vec::Vec<setup::SetupAction>,
    }
    /// Nested message and enum types in `Setup`.
    pub mod setup {
        /// A setup operation or assert that was executed
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SetupAction {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<setup_action::Operation>,
            #[prost(message, optional, tag = "5")]
            pub assert_value: ::core::option::Option<setup_action::Assert>,
        }
        /// Nested message and enum types in `SetupAction`.
        pub mod setup_action {
            /// The operation to perform
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Operation {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// pass | skip | fail | warning | error
                #[prost(message, optional, tag = "4")]
                pub result: ::core::option::Option<super::super::super::TestReportActionResultCode>,
                /// A message associated with the result
                #[prost(message, optional, tag = "5")]
                pub message: ::core::option::Option<super::super::super::Markdown>,
                /// A link to further details on the result
                #[prost(message, optional, tag = "6")]
                pub detail: ::core::option::Option<super::super::super::Uri>,
            }
            /// The assertion to perform
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Assert {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// pass | skip | fail | warning | error
                #[prost(message, optional, tag = "4")]
                pub result: ::core::option::Option<super::super::super::TestReportActionResultCode>,
                /// A message associated with the result
                #[prost(message, optional, tag = "5")]
                pub message: ::core::option::Option<super::super::super::Markdown>,
                /// A link to further details on the result
                #[prost(message, optional, tag = "6")]
                pub detail: ::core::option::Option<super::super::super::String>,
            }
        }
    }
    /// A test executed from the test script
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Test {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Tracking/logging name of this test
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Tracking/reporting short description of the test
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "6")]
        pub action: prost::alloc::vec::Vec<test::TestAction>,
    }
    /// Nested message and enum types in `Test`.
    pub mod test {
        /// A test operation or assert that was performed
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TestAction {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The operation performed
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<super::setup::setup_action::Operation>,
            /// The assertion performed
            #[prost(message, optional, tag = "5")]
            pub assert_value: ::core::option::Option<super::setup::setup_action::Assert>,
        }
    }
    /// The results of running the series of required clean up steps
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Teardown {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub action: prost::alloc::vec::Vec<teardown::TeardownAction>,
    }
    /// Nested message and enum types in `Teardown`.
    pub mod teardown {
        /// One or more teardown operations performed
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TeardownAction {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The teardown operation performed
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<super::setup::setup_action::Operation>,
        }
    }
}
/// Auto-generated from StructureDefinition for TestScript, last updated
/// 2017-04-19T07:44:43.294+10:00. Describes a set of tests. See
/// <http://hl7.org/fhir/StructureDefinition/TestScript>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct TestScript {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this test script (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the test script
    #[prost(message, optional, tag = "10")]
    pub identifier: ::core::option::Option<Identifier>,
    /// Business version of the test script
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this test script (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this test script (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the test script
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for test script (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Why this test script is defined
    #[prost(message, optional, tag = "22")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "23")]
    pub copyright: ::core::option::Option<Markdown>,
    #[prost(message, repeated, tag = "24")]
    pub origin: prost::alloc::vec::Vec<test_script::Origin>,
    #[prost(message, repeated, tag = "25")]
    pub destination: prost::alloc::vec::Vec<test_script::Destination>,
    #[prost(message, optional, tag = "26")]
    pub metadata: ::core::option::Option<test_script::Metadata>,
    #[prost(message, repeated, tag = "27")]
    pub fixture: prost::alloc::vec::Vec<test_script::Fixture>,
    /// Reference of the validation profile
    #[prost(message, repeated, tag = "28")]
    pub profile: prost::alloc::vec::Vec<Reference>,
    #[prost(message, repeated, tag = "29")]
    pub variable: prost::alloc::vec::Vec<test_script::Variable>,
    #[prost(message, repeated, tag = "30")]
    pub rule: prost::alloc::vec::Vec<test_script::Rule>,
    #[prost(message, repeated, tag = "31")]
    pub ruleset: prost::alloc::vec::Vec<test_script::Ruleset>,
    #[prost(message, optional, tag = "32")]
    pub setup: ::core::option::Option<test_script::Setup>,
    #[prost(message, repeated, tag = "33")]
    pub test: prost::alloc::vec::Vec<test_script::Test>,
    #[prost(message, optional, tag = "34")]
    pub teardown: ::core::option::Option<test_script::Teardown>,
}
/// Nested message and enum types in `TestScript`.
pub mod test_script {
    /// An abstract server representing a client or sender in a message exchange
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Origin {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The index of the abstract origin server starting at 1
        #[prost(message, optional, tag = "4")]
        pub index: ::core::option::Option<super::Integer>,
        /// FHIR-Client | FHIR-SDC-FormFiller
        #[prost(message, optional, tag = "5")]
        pub profile: ::core::option::Option<super::Coding>,
    }
    /// An abstract server representing a destination or receiver in a message
    /// exchange
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Destination {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// The index of the abstract destination server starting at 1
        #[prost(message, optional, tag = "4")]
        pub index: ::core::option::Option<super::Integer>,
        /// FHIR-Server | FHIR-SDC-FormManager | FHIR-SDC-FormReceiver |
        /// FHIR-SDC-FormProcessor
        #[prost(message, optional, tag = "5")]
        pub profile: ::core::option::Option<super::Coding>,
    }
    /// Required capability that is assumed to function correctly on the FHIR
    /// server being tested
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Metadata {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub link: prost::alloc::vec::Vec<metadata::Link>,
        #[prost(message, repeated, tag = "5")]
        pub capability: prost::alloc::vec::Vec<metadata::Capability>,
    }
    /// Nested message and enum types in `Metadata`.
    pub mod metadata {
        /// Links to the FHIR specification
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Link {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// URL to the specification
            #[prost(message, optional, tag = "4")]
            pub url: ::core::option::Option<super::super::Uri>,
            /// Short description
            #[prost(message, optional, tag = "5")]
            pub description: ::core::option::Option<super::super::String>,
        }
        /// Capabilities  that are assumed to function correctly on the FHIR server
        /// being tested
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Capability {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Are the capabilities required?
            #[prost(message, optional, tag = "4")]
            pub required: ::core::option::Option<super::super::Boolean>,
            /// Are the capabilities validated?
            #[prost(message, optional, tag = "5")]
            pub validated: ::core::option::Option<super::super::Boolean>,
            /// The expected capabilities of the server
            #[prost(message, optional, tag = "6")]
            pub description: ::core::option::Option<super::super::String>,
            /// Which origin server these requirements apply to
            #[prost(message, repeated, tag = "7")]
            pub origin: prost::alloc::vec::Vec<super::super::Integer>,
            /// Which server these requirements apply to
            #[prost(message, optional, tag = "8")]
            pub destination: ::core::option::Option<super::super::Integer>,
            /// Links to the FHIR specification
            #[prost(message, repeated, tag = "9")]
            pub link: prost::alloc::vec::Vec<super::super::Uri>,
            /// Required Capability Statement
            #[prost(message, optional, tag = "10")]
            pub capabilities: ::core::option::Option<super::super::Reference>,
        }
    }
    /// Fixture in the test script - by reference (uri)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Fixture {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Whether or not to implicitly create the fixture during setup
        #[prost(message, optional, tag = "4")]
        pub autocreate: ::core::option::Option<super::Boolean>,
        /// Whether or not to implicitly delete the fixture during teardown
        #[prost(message, optional, tag = "5")]
        pub autodelete: ::core::option::Option<super::Boolean>,
        /// Reference of the resource
        #[prost(message, optional, tag = "6")]
        pub resource: ::core::option::Option<super::Reference>,
    }
    /// Placeholder for evaluated elements
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Variable {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Descriptive name for this variable
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Default, hard-coded, or user-defined value for this variable
        #[prost(message, optional, tag = "5")]
        pub default_value: ::core::option::Option<super::String>,
        /// Natural language description of the variable
        #[prost(message, optional, tag = "6")]
        pub description: ::core::option::Option<super::String>,
        /// The fluentpath expression against the fixture body
        #[prost(message, optional, tag = "7")]
        pub expression: ::core::option::Option<super::String>,
        /// HTTP header field name for source
        #[prost(message, optional, tag = "8")]
        pub header_field: ::core::option::Option<super::String>,
        /// Hint help text for default value to enter
        #[prost(message, optional, tag = "9")]
        pub hint: ::core::option::Option<super::String>,
        /// XPath or JSONPath against the fixture body
        #[prost(message, optional, tag = "10")]
        pub path: ::core::option::Option<super::String>,
        /// Fixture Id of source expression or headerField within this variable
        #[prost(message, optional, tag = "11")]
        pub source_id: ::core::option::Option<super::Id>,
    }
    /// Assert rule used within the test script
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Rule {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Assert rule resource reference
        #[prost(message, optional, tag = "4")]
        pub resource: ::core::option::Option<super::Reference>,
        #[prost(message, repeated, tag = "5")]
        pub param: prost::alloc::vec::Vec<rule::RuleParam>,
    }
    /// Nested message and enum types in `Rule`.
    pub mod rule {
        /// Rule parameter template
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RuleParam {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Parameter name matching external assert rule parameter
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::String>,
            /// Parameter value defined either explicitly or dynamically
            #[prost(message, optional, tag = "5")]
            pub value: ::core::option::Option<super::super::String>,
        }
    }
    /// Assert ruleset used within the test script
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Ruleset {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Assert ruleset resource reference
        #[prost(message, optional, tag = "4")]
        pub resource: ::core::option::Option<super::Reference>,
        #[prost(message, repeated, tag = "5")]
        pub rule: prost::alloc::vec::Vec<ruleset::RulesetRule>,
    }
    /// Nested message and enum types in `Ruleset`.
    pub mod ruleset {
        /// The referenced rule within the ruleset
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct RulesetRule {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Id of referenced rule within the ruleset
            #[prost(message, optional, tag = "4")]
            pub rule_id: ::core::option::Option<super::super::Id>,
            #[prost(message, repeated, tag = "5")]
            pub param: prost::alloc::vec::Vec<ruleset_rule::RulesetRuleParam>,
        }
        /// Nested message and enum types in `RulesetRule`.
        pub mod ruleset_rule {
            /// Ruleset rule parameter template
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct RulesetRuleParam {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Parameter name matching external assert ruleset rule parameter
                #[prost(message, optional, tag = "4")]
                pub name: ::core::option::Option<super::super::super::String>,
                /// Parameter value defined either explicitly or dynamically
                #[prost(message, optional, tag = "5")]
                pub value: ::core::option::Option<super::super::super::String>,
            }
        }
    }
    /// A series of required setup operations before tests are executed
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Setup {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub action: prost::alloc::vec::Vec<setup::SetupAction>,
    }
    /// Nested message and enum types in `Setup`.
    pub mod setup {
        /// A setup operation or assert to perform
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct SetupAction {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<setup_action::Operation>,
            #[prost(message, optional, tag = "5")]
            pub assert_value: ::core::option::Option<setup_action::Assert>,
        }
        /// Nested message and enum types in `SetupAction`.
        pub mod setup_action {
            /// The setup operation to perform
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Operation {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// The operation code type that will be executed
                #[prost(message, optional, tag = "4")]
                pub r#type: ::core::option::Option<super::super::super::Coding>,
                /// Resource type
                #[prost(message, optional, tag = "5")]
                pub resource: ::core::option::Option<super::super::super::FhirDefinedTypeCode>,
                /// Tracking/logging operation label
                #[prost(message, optional, tag = "6")]
                pub label: ::core::option::Option<super::super::super::String>,
                /// Tracking/reporting operation description
                #[prost(message, optional, tag = "7")]
                pub description: ::core::option::Option<super::super::super::String>,
                /// xml | json | ttl | none
                #[prost(message, optional, tag = "8")]
                pub accept: ::core::option::Option<super::super::super::ContentTypeCode>,
                /// xml | json | ttl | none
                #[prost(message, optional, tag = "9")]
                pub content_type: ::core::option::Option<super::super::super::ContentTypeCode>,
                /// Server responding to the request
                #[prost(message, optional, tag = "10")]
                pub destination: ::core::option::Option<super::super::super::Integer>,
                /// Whether or not to send the request url in encoded format
                #[prost(message, optional, tag = "11")]
                pub encode_request_url: ::core::option::Option<super::super::super::Boolean>,
                /// Server initiating the request
                #[prost(message, optional, tag = "12")]
                pub origin: ::core::option::Option<super::super::super::Integer>,
                /// Explicitly defined path parameters
                #[prost(message, optional, tag = "13")]
                pub params: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "14")]
                pub request_header: prost::alloc::vec::Vec<operation::RequestHeader>,
                /// Fixture Id of mapped request
                #[prost(message, optional, tag = "15")]
                pub request_id: ::core::option::Option<super::super::super::Id>,
                /// Fixture Id of mapped response
                #[prost(message, optional, tag = "16")]
                pub response_id: ::core::option::Option<super::super::super::Id>,
                /// Fixture Id of body for PUT and POST requests
                #[prost(message, optional, tag = "17")]
                pub source_id: ::core::option::Option<super::super::super::Id>,
                /// Id of fixture used for extracting the \[id\],  \[type\], and \[vid\] for
                /// GET requests
                #[prost(message, optional, tag = "18")]
                pub target_id: ::core::option::Option<super::super::super::Id>,
                /// Request URL
                #[prost(message, optional, tag = "19")]
                pub url: ::core::option::Option<super::super::super::String>,
            }
            /// Nested message and enum types in `Operation`.
            pub mod operation {
                /// Each operation can have one or more header elements
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct RequestHeader {
                    /// xml:id (or equivalent in JSON)
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional Content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// HTTP header field name
                    #[prost(message, optional, tag = "4")]
                    pub field: ::core::option::Option<super::super::super::super::String>,
                    /// HTTP headerfield value
                    #[prost(message, optional, tag = "5")]
                    pub value: ::core::option::Option<super::super::super::super::String>,
                }
            }
            /// The assertion to perform
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Assert {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Tracking/logging assertion label
                #[prost(message, optional, tag = "4")]
                pub label: ::core::option::Option<super::super::super::String>,
                /// Tracking/reporting assertion description
                #[prost(message, optional, tag = "5")]
                pub description: ::core::option::Option<super::super::super::String>,
                /// response | request
                #[prost(message, optional, tag = "6")]
                pub direction:
                    ::core::option::Option<super::super::super::AssertionDirectionTypeCode>,
                /// Id of the source fixture to be evaluated
                #[prost(message, optional, tag = "7")]
                pub compare_to_source_id: ::core::option::Option<super::super::super::String>,
                /// The fluentpath expression to evaluate against the source fixture
                #[prost(message, optional, tag = "8")]
                pub compare_to_source_expression:
                    ::core::option::Option<super::super::super::String>,
                /// XPath or JSONPath expression to evaluate against the source fixture
                #[prost(message, optional, tag = "9")]
                pub compare_to_source_path: ::core::option::Option<super::super::super::String>,
                /// xml | json | ttl | none
                #[prost(message, optional, tag = "10")]
                pub content_type: ::core::option::Option<super::super::super::ContentTypeCode>,
                /// The fluentpath expression to be evaluated
                #[prost(message, optional, tag = "11")]
                pub expression: ::core::option::Option<super::super::super::String>,
                /// HTTP header field name
                #[prost(message, optional, tag = "12")]
                pub header_field: ::core::option::Option<super::super::super::String>,
                /// Fixture Id of minimum content resource
                #[prost(message, optional, tag = "13")]
                pub minimum_id: ::core::option::Option<super::super::super::String>,
                /// Perform validation on navigation links?
                #[prost(message, optional, tag = "14")]
                pub navigation_links: ::core::option::Option<super::super::super::Boolean>,
                /// equals | notEquals | in | notIn | greaterThan | lessThan | empty |
                /// notEmpty | contains | notContains | eval
                #[prost(message, optional, tag = "15")]
                pub operator:
                    ::core::option::Option<super::super::super::AssertionOperatorTypeCode>,
                /// XPath or JSONPath expression
                #[prost(message, optional, tag = "16")]
                pub path: ::core::option::Option<super::super::super::String>,
                /// delete | get | options | patch | post | put
                #[prost(message, optional, tag = "17")]
                pub request_method:
                    ::core::option::Option<super::super::super::TestScriptRequestMethodCodeCode>,
                /// Request URL comparison value
                #[prost(message, optional, tag = "18")]
                pub request_url: ::core::option::Option<super::super::super::String>,
                /// Resource type
                #[prost(message, optional, tag = "19")]
                pub resource: ::core::option::Option<super::super::super::FhirDefinedTypeCode>,
                /// okay | created | noContent | notModified | bad | forbidden | notFound
                /// | methodNotAllowed | conflict | gone | preconditionFailed |
                /// unprocessable
                #[prost(message, optional, tag = "20")]
                pub response:
                    ::core::option::Option<super::super::super::AssertionResponseTypesCode>,
                /// HTTP response code to test
                #[prost(message, optional, tag = "21")]
                pub response_code: ::core::option::Option<super::super::super::String>,
                #[prost(message, optional, tag = "22")]
                pub rule: ::core::option::Option<assert::ActionAssertRule>,
                #[prost(message, optional, tag = "23")]
                pub ruleset: ::core::option::Option<assert::ActionAssertRuleset>,
                /// Fixture Id of source expression or headerField
                #[prost(message, optional, tag = "24")]
                pub source_id: ::core::option::Option<super::super::super::Id>,
                /// Profile Id of validation profile reference
                #[prost(message, optional, tag = "25")]
                pub validate_profile_id: ::core::option::Option<super::super::super::Id>,
                /// The value to compare to
                #[prost(message, optional, tag = "26")]
                pub value: ::core::option::Option<super::super::super::String>,
                /// Will this assert produce a warning only on error?
                #[prost(message, optional, tag = "27")]
                pub warning_only: ::core::option::Option<super::super::super::Boolean>,
            }
            /// Nested message and enum types in `Assert`.
            pub mod assert {
                /// The reference to a TestScript.rule
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ActionAssertRule {
                    /// xml:id (or equivalent in JSON)
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional Content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Id of the TestScript.rule
                    #[prost(message, optional, tag = "4")]
                    pub rule_id: ::core::option::Option<super::super::super::super::Id>,
                    #[prost(message, repeated, tag = "5")]
                    pub param: prost::alloc::vec::Vec<action_assert_rule::ActionAssertRuleParam>,
                }
                /// Nested message and enum types in `ActionAssertRule`.
                pub mod action_assert_rule {
                    /// Rule parameter template
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Message)]
                    pub struct ActionAssertRuleParam {
                        /// xml:id (or equivalent in JSON)
                        #[prost(message, optional, tag = "1")]
                        pub id: ::core::option::Option<super::super::super::super::super::String>,
                        /// Additional Content defined by implementations
                        #[prost(message, repeated, tag = "2")]
                        pub extension:
                            prost::alloc::vec::Vec<super::super::super::super::super::Extension>,
                        /// Extensions that cannot be ignored
                        #[prost(message, repeated, tag = "3")]
                        pub modifier_extension:
                            prost::alloc::vec::Vec<super::super::super::super::super::Extension>,
                        /// Parameter name matching external assert rule parameter
                        #[prost(message, optional, tag = "4")]
                        pub name: ::core::option::Option<super::super::super::super::super::String>,
                        /// Parameter value defined either explicitly or dynamically
                        #[prost(message, optional, tag = "5")]
                        pub value:
                            ::core::option::Option<super::super::super::super::super::String>,
                    }
                }
                /// The reference to a TestScript.ruleset
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct ActionAssertRuleset {
                    /// xml:id (or equivalent in JSON)
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional Content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Id of the TestScript.ruleset
                    #[prost(message, optional, tag = "4")]
                    pub ruleset_id: ::core::option::Option<super::super::super::super::Id>,
                    #[prost(message, repeated, tag = "5")]
                    pub rule:
                        prost::alloc::vec::Vec<action_assert_ruleset::ActionAssertRulesetRule>,
                }
                /// Nested message and enum types in `ActionAssertRuleset`.
                pub mod action_assert_ruleset {
                    /// The referenced rule within the ruleset
                    #[derive(Serialize, Deserialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, prost::Message)]
                    pub struct ActionAssertRulesetRule {
                        /// xml:id (or equivalent in JSON)
                        #[prost(message, optional, tag = "1")]
                        pub id: ::core::option::Option<super::super::super::super::super::String>,
                        /// Additional Content defined by implementations
                        #[prost(message, repeated, tag = "2")]
                        pub extension:
                            prost::alloc::vec::Vec<super::super::super::super::super::Extension>,
                        /// Extensions that cannot be ignored
                        #[prost(message, repeated, tag = "3")]
                        pub modifier_extension:
                            prost::alloc::vec::Vec<super::super::super::super::super::Extension>,
                        /// Id of referenced rule within the ruleset
                        #[prost(message, optional, tag = "4")]
                        pub rule_id: ::core::option::Option<super::super::super::super::super::Id>,
                        #[prost(message, repeated, tag = "5")]
                        pub param: prost::alloc::vec::Vec<action_assert_ruleset_rule::Param>,
                    }
                    /// Nested message and enum types in `ActionAssertRulesetRule`.
                    pub mod action_assert_ruleset_rule {
                        /// Rule parameter template
                        #[derive(Serialize, Deserialize)]
                        #[serde(rename_all = "camelCase")]
                        #[derive(Clone, PartialEq, prost::Message)]
                        pub struct Param {
                            /// xml:id (or equivalent in JSON)
                            #[prost(message, optional, tag = "1")]
                            pub id: ::core::option::Option<
                                super::super::super::super::super::super::String,
                            >,
                            /// Additional Content defined by implementations
                            #[prost(message, repeated, tag = "2")]
                            pub extension: prost::alloc::vec::Vec<
                                super::super::super::super::super::super::Extension,
                            >,
                            /// Extensions that cannot be ignored
                            #[prost(message, repeated, tag = "3")]
                            pub modifier_extension: prost::alloc::vec::Vec<
                                super::super::super::super::super::super::Extension,
                            >,
                            /// Parameter name matching external assert ruleset rule parameter
                            #[prost(message, optional, tag = "4")]
                            pub name: ::core::option::Option<
                                super::super::super::super::super::super::String,
                            >,
                            /// Parameter value defined either explicitly or dynamically
                            #[prost(message, optional, tag = "5")]
                            pub value: ::core::option::Option<
                                super::super::super::super::super::super::String,
                            >,
                        }
                    }
                }
            }
        }
    }
    /// A test in this script
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Test {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Tracking/logging name of this test
        #[prost(message, optional, tag = "4")]
        pub name: ::core::option::Option<super::String>,
        /// Tracking/reporting short description of the test
        #[prost(message, optional, tag = "5")]
        pub description: ::core::option::Option<super::String>,
        #[prost(message, repeated, tag = "6")]
        pub action: prost::alloc::vec::Vec<test::TestAction>,
    }
    /// Nested message and enum types in `Test`.
    pub mod test {
        /// A test operation or assert to perform
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TestAction {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The setup operation to perform
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<super::setup::setup_action::Operation>,
            /// The setup assertion to perform
            #[prost(message, optional, tag = "5")]
            pub assert_value: ::core::option::Option<super::setup::setup_action::Assert>,
        }
    }
    /// A series of required clean up steps
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Teardown {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        #[prost(message, repeated, tag = "4")]
        pub action: prost::alloc::vec::Vec<teardown::TeardownAction>,
    }
    /// Nested message and enum types in `Teardown`.
    pub mod teardown {
        /// One or more teardown operations to perform
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct TeardownAction {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The teardown operation to perform
            #[prost(message, optional, tag = "4")]
            pub operation: ::core::option::Option<super::setup::setup_action::Operation>,
        }
    }
}
/// Auto-generated from StructureDefinition for ValueSet, last updated
/// 2017-04-19T07:44:43.294+10:00. A set of codes drawn from one or more code
/// systems. See <http://hl7.org/fhir/StructureDefinition/ValueSet>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ValueSet {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Logical URI to reference this value set (globally unique)
    #[prost(message, optional, tag = "9")]
    pub url: ::core::option::Option<Uri>,
    /// Additional identifier for the value set
    #[prost(message, repeated, tag = "10")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// Business version of the value set
    #[prost(message, optional, tag = "11")]
    pub version: ::core::option::Option<String>,
    /// Name for this value set (computer friendly)
    #[prost(message, optional, tag = "12")]
    pub name: ::core::option::Option<String>,
    /// Name for this value set (human friendly)
    #[prost(message, optional, tag = "13")]
    pub title: ::core::option::Option<String>,
    /// draft | active | retired | unknown
    #[prost(message, optional, tag = "14")]
    pub status: ::core::option::Option<PublicationStatusCode>,
    /// For testing purposes, not real usage
    #[prost(message, optional, tag = "15")]
    pub experimental: ::core::option::Option<Boolean>,
    /// Date this was last changed
    #[prost(message, optional, tag = "16")]
    pub date: ::core::option::Option<DateTime>,
    /// Name of the publisher (organization or individual)
    #[prost(message, optional, tag = "17")]
    pub publisher: ::core::option::Option<String>,
    /// Contact details for the publisher
    #[prost(message, repeated, tag = "18")]
    pub contact: prost::alloc::vec::Vec<ContactDetail>,
    /// Natural language description of the value set
    #[prost(message, optional, tag = "19")]
    pub description: ::core::option::Option<Markdown>,
    /// Context the content is intended to support
    #[prost(message, repeated, tag = "20")]
    pub use_context: prost::alloc::vec::Vec<UsageContext>,
    /// Intended jurisdiction for value set (if applicable)
    #[prost(message, repeated, tag = "21")]
    pub jurisdiction: prost::alloc::vec::Vec<CodeableConcept>,
    /// Indicates whether or not any change to the content logical definition may
    /// occur
    #[prost(message, optional, tag = "22")]
    pub immutable: ::core::option::Option<Boolean>,
    /// Why this value set is defined
    #[prost(message, optional, tag = "23")]
    pub purpose: ::core::option::Option<Markdown>,
    /// Use and/or publishing restrictions
    #[prost(message, optional, tag = "24")]
    pub copyright: ::core::option::Option<Markdown>,
    /// Whether this is intended to be used with an extensible binding
    #[prost(message, optional, tag = "25")]
    pub extensible: ::core::option::Option<Boolean>,
    #[prost(message, optional, tag = "26")]
    pub compose: ::core::option::Option<value_set::Compose>,
    #[prost(message, optional, tag = "27")]
    pub expansion: ::core::option::Option<value_set::Expansion>,
}
/// Nested message and enum types in `ValueSet`.
pub mod value_set {
    /// Definition of the content of the value set (CLD)
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Compose {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Fixed date for version-less references (transitive)
        #[prost(message, optional, tag = "4")]
        pub locked_date: ::core::option::Option<super::Date>,
        /// Whether inactive codes are in the value set
        #[prost(message, optional, tag = "5")]
        pub inactive: ::core::option::Option<super::Boolean>,
        #[prost(message, repeated, tag = "6")]
        pub include: prost::alloc::vec::Vec<compose::ConceptSet>,
        /// Explicitly exclude codes from a code system or other value sets
        #[prost(message, repeated, tag = "7")]
        pub exclude: prost::alloc::vec::Vec<compose::ConceptSet>,
    }
    /// Nested message and enum types in `Compose`.
    pub mod compose {
        /// Include one or more codes from a code system or other value set(s)
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct ConceptSet {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// The system the codes come from
            #[prost(message, optional, tag = "4")]
            pub system: ::core::option::Option<super::super::Uri>,
            /// Specific version of the code system referred to
            #[prost(message, optional, tag = "5")]
            pub version: ::core::option::Option<super::super::String>,
            #[prost(message, repeated, tag = "6")]
            pub concept: prost::alloc::vec::Vec<concept_set::ConceptReference>,
            #[prost(message, repeated, tag = "7")]
            pub filter: prost::alloc::vec::Vec<concept_set::Filter>,
            /// Select only contents included in this value set
            #[prost(message, repeated, tag = "8")]
            pub value_set: prost::alloc::vec::Vec<super::super::Uri>,
        }
        /// Nested message and enum types in `ConceptSet`.
        pub mod concept_set {
            /// A concept defined in the system
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct ConceptReference {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Code or expression from system
                #[prost(message, optional, tag = "4")]
                pub code: ::core::option::Option<super::super::super::Code>,
                /// Text to display for this code for this value set in this valueset
                #[prost(message, optional, tag = "5")]
                pub display: ::core::option::Option<super::super::super::String>,
                #[prost(message, repeated, tag = "6")]
                pub designation: prost::alloc::vec::Vec<concept_reference::Designation>,
            }
            /// Nested message and enum types in `ConceptReference`.
            pub mod concept_reference {
                /// Additional representations for this concept
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Message)]
                pub struct Designation {
                    /// xml:id (or equivalent in JSON)
                    #[prost(message, optional, tag = "1")]
                    pub id: ::core::option::Option<super::super::super::super::String>,
                    /// Additional Content defined by implementations
                    #[prost(message, repeated, tag = "2")]
                    pub extension: prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Extensions that cannot be ignored
                    #[prost(message, repeated, tag = "3")]
                    pub modifier_extension:
                        prost::alloc::vec::Vec<super::super::super::super::Extension>,
                    /// Human language of the designation
                    #[prost(message, optional, tag = "4")]
                    pub language: ::core::option::Option<super::super::super::super::LanguageCode>,
                    /// Details how this designation would be used
                    #[prost(message, optional, tag = "5")]
                    pub r#use: ::core::option::Option<super::super::super::super::Coding>,
                    /// The text value for this designation
                    #[prost(message, optional, tag = "6")]
                    pub value: ::core::option::Option<super::super::super::super::String>,
                }
            }
            /// Select codes/concepts by their properties (including relationships)
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Filter {
                /// xml:id (or equivalent in JSON)
                #[prost(message, optional, tag = "1")]
                pub id: ::core::option::Option<super::super::super::String>,
                /// Additional Content defined by implementations
                #[prost(message, repeated, tag = "2")]
                pub extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// Extensions that cannot be ignored
                #[prost(message, repeated, tag = "3")]
                pub modifier_extension: prost::alloc::vec::Vec<super::super::super::Extension>,
                /// A property defined by the code system
                #[prost(message, optional, tag = "4")]
                pub property: ::core::option::Option<super::super::super::Code>,
                /// = | is-a | descendent-of | is-not-a | regex | in | not-in |
                /// generalizes | exists
                #[prost(message, optional, tag = "5")]
                pub op: ::core::option::Option<super::super::super::FilterOperatorCode>,
                /// Code from the system, or regex criteria, or boolean value for exists
                #[prost(message, optional, tag = "6")]
                pub value: ::core::option::Option<super::super::super::Code>,
            }
        }
    }
    /// Used when the value set is "expanded"
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Expansion {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Uniquely identifies this expansion
        #[prost(message, optional, tag = "4")]
        pub identifier: ::core::option::Option<super::Uri>,
        /// Time ValueSet expansion happened
        #[prost(message, optional, tag = "5")]
        pub timestamp: ::core::option::Option<super::DateTime>,
        /// Total number of codes in the expansion
        #[prost(message, optional, tag = "6")]
        pub total: ::core::option::Option<super::Integer>,
        /// Offset at which this resource starts
        #[prost(message, optional, tag = "7")]
        pub offset: ::core::option::Option<super::Integer>,
        #[prost(message, repeated, tag = "8")]
        pub parameter: prost::alloc::vec::Vec<expansion::Parameter>,
        #[prost(message, repeated, tag = "9")]
        pub contains: prost::alloc::vec::Vec<expansion::Contains>,
    }
    /// Nested message and enum types in `Expansion`.
    pub mod expansion {
        /// Parameter that controlled the expansion process
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Parameter {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Name as assigned by the server
            #[prost(message, optional, tag = "4")]
            pub name: ::core::option::Option<super::super::String>,
            #[prost(message, optional, tag = "5")]
            pub value: ::core::option::Option<parameter::Value>,
        }
        /// Nested message and enum types in `Parameter`.
        pub mod parameter {
            /// Value of the named parameter
            #[derive(Serialize, Deserialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, prost::Message)]
            pub struct Value {
                #[prost(oneof = "value::Value", tags = "1, 2, 3, 4, 5, 6")]
                pub value: ::core::option::Option<value::Value>,
            }
            /// Nested message and enum types in `Value`.
            pub mod value {
                #[derive(Serialize, Deserialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, prost::Oneof)]
                pub enum Value {
                    #[prost(message, tag = "1")]
                    StringValue(super::super::super::super::String),
                    #[prost(message, tag = "2")]
                    Boolean(super::super::super::super::Boolean),
                    #[prost(message, tag = "3")]
                    Integer(super::super::super::super::Integer),
                    #[prost(message, tag = "4")]
                    Decimal(super::super::super::super::Decimal),
                    #[prost(message, tag = "5")]
                    Uri(super::super::super::super::Uri),
                    #[prost(message, tag = "6")]
                    Code(super::super::super::super::Code),
                }
            }
        }
        /// Codes in the value set
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Message)]
        pub struct Contains {
            /// xml:id (or equivalent in JSON)
            #[prost(message, optional, tag = "1")]
            pub id: ::core::option::Option<super::super::String>,
            /// Additional Content defined by implementations
            #[prost(message, repeated, tag = "2")]
            pub extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// Extensions that cannot be ignored
            #[prost(message, repeated, tag = "3")]
            pub modifier_extension: prost::alloc::vec::Vec<super::super::Extension>,
            /// System value for the code
            #[prost(message, optional, tag = "4")]
            pub system: ::core::option::Option<super::super::Uri>,
            /// If user cannot select this entry
            #[prost(message, optional, tag = "5")]
            pub r#abstract: ::core::option::Option<super::super::Boolean>,
            /// If concept is inactive in the code system
            #[prost(message, optional, tag = "6")]
            pub inactive: ::core::option::Option<super::super::Boolean>,
            /// Version in which this code/display is defined
            #[prost(message, optional, tag = "7")]
            pub version: ::core::option::Option<super::super::String>,
            /// Code - if blank, this is not a selectable code
            #[prost(message, optional, tag = "8")]
            pub code: ::core::option::Option<super::super::Code>,
            /// User display for the concept
            #[prost(message, optional, tag = "9")]
            pub display: ::core::option::Option<super::super::String>,
            /// Additional representations for this item
            #[prost(message, repeated, tag = "10")]
            pub designation:
                prost::alloc::vec::Vec<super::compose::concept_set::concept_reference::Designation>,
            /// Codes contained under this entry
            #[prost(message, repeated, tag = "11")]
            pub contains: prost::alloc::vec::Vec<Contains>,
        }
    }
}
/// Auto-generated from StructureDefinition for VisionPrescription, last updated
/// 2017-04-19T07:44:43.294+10:00. Prescription for vision correction products
/// for a patient. See <http://hl7.org/fhir/StructureDefinition/VisionPrescription>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct VisionPrescription {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
    /// Business identifier
    #[prost(message, repeated, tag = "9")]
    pub identifier: prost::alloc::vec::Vec<Identifier>,
    /// active | cancelled | draft | entered-in-error
    #[prost(message, optional, tag = "10")]
    pub status: ::core::option::Option<FinancialResourceStatusCode>,
    /// Who prescription is for
    #[prost(message, optional, tag = "11")]
    pub patient: ::core::option::Option<Reference>,
    /// Created during encounter / admission / stay
    #[prost(message, optional, tag = "12")]
    pub encounter: ::core::option::Option<Reference>,
    /// When prescription was authorized
    #[prost(message, optional, tag = "13")]
    pub date_written: ::core::option::Option<DateTime>,
    /// Who authorizes the vision product
    #[prost(message, optional, tag = "14")]
    pub prescriber: ::core::option::Option<Reference>,
    #[prost(message, optional, tag = "15")]
    pub reason: ::core::option::Option<vision_prescription::Reason>,
    #[prost(message, repeated, tag = "16")]
    pub dispense: prost::alloc::vec::Vec<vision_prescription::Dispense>,
}
/// Nested message and enum types in `VisionPrescription`.
pub mod vision_prescription {
    /// Reason or indication for writing the prescription
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Reason {
        #[prost(oneof = "reason::Reason", tags = "1, 2")]
        pub reason: ::core::option::Option<reason::Reason>,
    }
    /// Nested message and enum types in `Reason`.
    pub mod reason {
        #[derive(Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, prost::Oneof)]
        pub enum Reason {
            #[prost(message, tag = "1")]
            CodeableConcept(super::super::CodeableConcept),
            #[prost(message, tag = "2")]
            Reference(super::super::Reference),
        }
    }
    /// Vision supply authorization
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Message)]
    pub struct Dispense {
        /// xml:id (or equivalent in JSON)
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::String>,
        /// Additional Content defined by implementations
        #[prost(message, repeated, tag = "2")]
        pub extension: prost::alloc::vec::Vec<super::Extension>,
        /// Extensions that cannot be ignored
        #[prost(message, repeated, tag = "3")]
        pub modifier_extension: prost::alloc::vec::Vec<super::Extension>,
        /// Product to be supplied
        #[prost(message, optional, tag = "4")]
        pub product: ::core::option::Option<super::CodeableConcept>,
        /// right | left
        #[prost(message, optional, tag = "5")]
        pub eye: ::core::option::Option<super::VisionEyesCode>,
        /// Lens sphere
        #[prost(message, optional, tag = "6")]
        pub sphere: ::core::option::Option<super::Decimal>,
        /// Lens cylinder
        #[prost(message, optional, tag = "7")]
        pub cylinder: ::core::option::Option<super::Decimal>,
        /// Lens axis
        #[prost(message, optional, tag = "8")]
        pub axis: ::core::option::Option<super::Integer>,
        /// Lens prism
        #[prost(message, optional, tag = "9")]
        pub prism: ::core::option::Option<super::Decimal>,
        /// up | down | in | out
        #[prost(message, optional, tag = "10")]
        pub base: ::core::option::Option<super::VisionBaseCode>,
        /// Lens add
        #[prost(message, optional, tag = "11")]
        pub add: ::core::option::Option<super::Decimal>,
        /// Contact lens power
        #[prost(message, optional, tag = "12")]
        pub power: ::core::option::Option<super::Decimal>,
        /// Contact lens back curvature
        #[prost(message, optional, tag = "13")]
        pub back_curve: ::core::option::Option<super::Decimal>,
        /// Contact lens diameter
        #[prost(message, optional, tag = "14")]
        pub diameter: ::core::option::Option<super::Decimal>,
        /// Lens wear duration
        #[prost(message, optional, tag = "15")]
        pub duration: ::core::option::Option<super::SimpleQuantity>,
        /// Color required
        #[prost(message, optional, tag = "16")]
        pub color: ::core::option::Option<super::String>,
        /// Brand required
        #[prost(message, optional, tag = "17")]
        pub brand: ::core::option::Option<super::String>,
        /// Notes for coatings
        #[prost(message, repeated, tag = "18")]
        pub note: prost::alloc::vec::Vec<super::Annotation>,
    }
}
/// Auto-generated from StructureDefinition for Resource, last updated
/// 2017-04-19T07:44:43.294+10:00. Base Resource. See
/// <http://hl7.org/fhir/StructureDefinition/Resource>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct Resource {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
}
/// Auto-generated from StructureDefinition for DomainResource, last updated
/// 2017-04-19T07:44:43.294+10:00. A resource with narrative, extensions, and
/// contained resources. See
/// <http://hl7.org/fhir/StructureDefinition/DomainResource>
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct DomainResource {
    /// Logical id of this artifact
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    /// Metadata about the resource
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<Meta>,
    /// A set of rules under which this content was created
    #[prost(message, optional, tag = "3")]
    pub implicit_rules: ::core::option::Option<Uri>,
    /// Language of the resource content
    #[prost(message, optional, tag = "4")]
    pub language: ::core::option::Option<LanguageCode>,
    /// Text summary of the resource, for human interpretation
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Narrative>,
    /// Contained, inline Resources
    #[prost(message, repeated, tag = "6")]
    pub contained: prost::alloc::vec::Vec<ContainedResource>,
    /// Additional Content defined by implementations
    #[prost(message, repeated, tag = "7")]
    pub extension: prost::alloc::vec::Vec<Extension>,
    /// Extensions that cannot be ignored
    #[prost(message, repeated, tag = "8")]
    pub modifier_extension: prost::alloc::vec::Vec<Extension>,
}
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, prost::Message)]
pub struct ContainedResource {
    #[prost(
        oneof = "contained_resource::OneofResource",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117"
    )]
    pub oneof_resource: ::core::option::Option<contained_resource::OneofResource>,
}
/// Nested message and enum types in `ContainedResource`.
pub mod contained_resource {
    #[derive(Serialize, Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, prost::Oneof)]
    pub enum OneofResource {
        #[prost(message, tag = "1")]
        Account(super::Account),
        #[prost(message, tag = "2")]
        ActivityDefinition(super::ActivityDefinition),
        #[prost(message, tag = "3")]
        AdverseEvent(super::AdverseEvent),
        #[prost(message, tag = "4")]
        AllergyIntolerance(super::AllergyIntolerance),
        #[prost(message, tag = "5")]
        Appointment(super::Appointment),
        #[prost(message, tag = "6")]
        AppointmentResponse(super::AppointmentResponse),
        #[prost(message, tag = "7")]
        AuditEvent(super::AuditEvent),
        #[prost(message, tag = "8")]
        Basic(super::Basic),
        #[prost(message, tag = "9")]
        Binary(super::Binary),
        #[prost(message, tag = "10")]
        BodySite(super::BodySite),
        #[prost(message, tag = "11")]
        Bundle(super::Bundle),
        #[prost(message, tag = "12")]
        CapabilityStatement(super::CapabilityStatement),
        #[prost(message, tag = "13")]
        CarePlan(super::CarePlan),
        #[prost(message, tag = "14")]
        CareTeam(super::CareTeam),
        #[prost(message, tag = "15")]
        ChargeItem(super::ChargeItem),
        #[prost(message, tag = "16")]
        Claim(super::Claim),
        #[prost(message, tag = "17")]
        ClaimResponse(super::ClaimResponse),
        #[prost(message, tag = "18")]
        ClinicalImpression(super::ClinicalImpression),
        #[prost(message, tag = "19")]
        CodeSystem(super::CodeSystem),
        #[prost(message, tag = "20")]
        Communication(super::Communication),
        #[prost(message, tag = "21")]
        CommunicationRequest(super::CommunicationRequest),
        #[prost(message, tag = "22")]
        CompartmentDefinition(super::CompartmentDefinition),
        #[prost(message, tag = "23")]
        Composition(super::Composition),
        #[prost(message, tag = "24")]
        ConceptMap(super::ConceptMap),
        #[prost(message, tag = "25")]
        Condition(super::Condition),
        #[prost(message, tag = "26")]
        Consent(super::Consent),
        #[prost(message, tag = "27")]
        Contract(super::Contract),
        #[prost(message, tag = "28")]
        Coverage(super::Coverage),
        #[prost(message, tag = "29")]
        DataElement(super::DataElement),
        #[prost(message, tag = "30")]
        DetectedIssue(super::DetectedIssue),
        #[prost(message, tag = "31")]
        Device(super::Device),
        #[prost(message, tag = "32")]
        DeviceComponent(super::DeviceComponent),
        #[prost(message, tag = "33")]
        DeviceMetric(super::DeviceMetric),
        #[prost(message, tag = "34")]
        DeviceRequest(super::DeviceRequest),
        #[prost(message, tag = "35")]
        DeviceUseStatement(super::DeviceUseStatement),
        #[prost(message, tag = "36")]
        DiagnosticReport(super::DiagnosticReport),
        #[prost(message, tag = "37")]
        DocumentManifest(super::DocumentManifest),
        #[prost(message, tag = "38")]
        DocumentReference(super::DocumentReference),
        #[prost(message, tag = "39")]
        EligibilityRequest(super::EligibilityRequest),
        #[prost(message, tag = "40")]
        EligibilityResponse(super::EligibilityResponse),
        #[prost(message, tag = "41")]
        Encounter(super::Encounter),
        #[prost(message, tag = "42")]
        Endpoint(super::Endpoint),
        #[prost(message, tag = "43")]
        EnrollmentRequest(super::EnrollmentRequest),
        #[prost(message, tag = "44")]
        EnrollmentResponse(super::EnrollmentResponse),
        #[prost(message, tag = "45")]
        EpisodeOfCare(super::EpisodeOfCare),
        #[prost(message, tag = "46")]
        ExpansionProfile(super::ExpansionProfile),
        #[prost(message, tag = "47")]
        ExplanationOfBenefit(super::ExplanationOfBenefit),
        #[prost(message, tag = "48")]
        FamilyMemberHistory(super::FamilyMemberHistory),
        #[prost(message, tag = "49")]
        Flag(super::Flag),
        #[prost(message, tag = "50")]
        Goal(super::Goal),
        #[prost(message, tag = "51")]
        GraphDefinition(super::GraphDefinition),
        #[prost(message, tag = "52")]
        Group(super::Group),
        #[prost(message, tag = "53")]
        GuidanceResponse(super::GuidanceResponse),
        #[prost(message, tag = "54")]
        HealthcareService(super::HealthcareService),
        #[prost(message, tag = "55")]
        ImagingManifest(super::ImagingManifest),
        #[prost(message, tag = "56")]
        ImagingStudy(super::ImagingStudy),
        #[prost(message, tag = "57")]
        Immunization(super::Immunization),
        #[prost(message, tag = "58")]
        ImmunizationRecommendation(super::ImmunizationRecommendation),
        #[prost(message, tag = "59")]
        ImplementationGuide(super::ImplementationGuide),
        #[prost(message, tag = "60")]
        Library(super::Library),
        #[prost(message, tag = "61")]
        Linkage(super::Linkage),
        #[prost(message, tag = "62")]
        List(super::List),
        #[prost(message, tag = "63")]
        Location(super::Location),
        #[prost(message, tag = "64")]
        Measure(super::Measure),
        #[prost(message, tag = "65")]
        MeasureReport(super::MeasureReport),
        #[prost(message, tag = "66")]
        Media(super::Media),
        #[prost(message, tag = "67")]
        Medication(super::Medication),
        #[prost(message, tag = "68")]
        MedicationAdministration(super::MedicationAdministration),
        #[prost(message, tag = "69")]
        MedicationDispense(super::MedicationDispense),
        #[prost(message, tag = "70")]
        MedicationRequest(super::MedicationRequest),
        #[prost(message, tag = "71")]
        MedicationStatement(super::MedicationStatement),
        #[prost(message, tag = "72")]
        MessageDefinition(super::MessageDefinition),
        #[prost(message, tag = "73")]
        MessageHeader(super::MessageHeader),
        #[prost(message, tag = "74")]
        NamingSystem(super::NamingSystem),
        #[prost(message, tag = "75")]
        NutritionOrder(super::NutritionOrder),
        #[prost(message, tag = "76")]
        Observation(super::Observation),
        #[prost(message, tag = "77")]
        OperationDefinition(super::OperationDefinition),
        #[prost(message, tag = "78")]
        OperationOutcome(super::OperationOutcome),
        #[prost(message, tag = "79")]
        Organization(super::Organization),
        #[prost(message, tag = "80")]
        Parameters(super::Parameters),
        #[prost(message, tag = "81")]
        Patient(super::Patient),
        #[prost(message, tag = "82")]
        PaymentNotice(super::PaymentNotice),
        #[prost(message, tag = "83")]
        PaymentReconciliation(super::PaymentReconciliation),
        #[prost(message, tag = "84")]
        Person(super::Person),
        #[prost(message, tag = "85")]
        PlanDefinition(super::PlanDefinition),
        #[prost(message, tag = "86")]
        Practitioner(super::Practitioner),
        #[prost(message, tag = "87")]
        PractitionerRole(super::PractitionerRole),
        #[prost(message, tag = "88")]
        Procedure(super::Procedure),
        #[prost(message, tag = "89")]
        ProcedureRequest(super::ProcedureRequest),
        #[prost(message, tag = "90")]
        ProcessRequest(super::ProcessRequest),
        #[prost(message, tag = "91")]
        ProcessResponse(super::ProcessResponse),
        #[prost(message, tag = "92")]
        Provenance(super::Provenance),
        #[prost(message, tag = "93")]
        Questionnaire(super::Questionnaire),
        #[prost(message, tag = "94")]
        QuestionnaireResponse(super::QuestionnaireResponse),
        #[prost(message, tag = "95")]
        ReferralRequest(super::ReferralRequest),
        #[prost(message, tag = "96")]
        RelatedPerson(super::RelatedPerson),
        #[prost(message, tag = "97")]
        RequestGroup(super::RequestGroup),
        #[prost(message, tag = "98")]
        ResearchStudy(super::ResearchStudy),
        #[prost(message, tag = "99")]
        ResearchSubject(super::ResearchSubject),
        #[prost(message, tag = "100")]
        RiskAssessment(super::RiskAssessment),
        #[prost(message, tag = "101")]
        Schedule(super::Schedule),
        #[prost(message, tag = "102")]
        SearchParameter(super::SearchParameter),
        #[prost(message, tag = "103")]
        Sequence(super::Sequence),
        #[prost(message, tag = "104")]
        ServiceDefinition(super::ServiceDefinition),
        #[prost(message, tag = "105")]
        Slot(super::Slot),
        #[prost(message, tag = "106")]
        Specimen(super::Specimen),
        #[prost(message, tag = "107")]
        StructureDefinition(super::StructureDefinition),
        #[prost(message, tag = "108")]
        StructureMap(super::StructureMap),
        #[prost(message, tag = "109")]
        Subscription(super::Subscription),
        #[prost(message, tag = "110")]
        Substance(super::Substance),
        #[prost(message, tag = "111")]
        SupplyDelivery(super::SupplyDelivery),
        #[prost(message, tag = "112")]
        SupplyRequest(super::SupplyRequest),
        #[prost(message, tag = "113")]
        Task(super::Task),
        #[prost(message, tag = "114")]
        TestReport(super::TestReport),
        #[prost(message, tag = "115")]
        TestScript(super::TestScript),
        #[prost(message, tag = "116")]
        ValueSet(super::ValueSet),
        #[prost(message, tag = "117")]
        VisionPrescription(super::VisionPrescription),
    }
}
